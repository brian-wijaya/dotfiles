vocabulary:
  sensor-daemon: C++ process hosting sensor/ and executive/ modules
  kinetic-jar: Java 25 JVM process hosting kinetic MCP gateway
  fail-stop: both processes restart together on any crash
  consistency-sweep: startup validation of cross-store invariants

metadata:
  feature: system
  component: operational-lifecycle
  tags: [system, lifecycle, crash-recovery, startup]

stories:
  - name: process-crash-recovery
    description: When either process crashes, systemd restarts both within bounded time
    tags: [critical, smoke]
    estimated_duration_ms: 35000
    preconditions:
      - sensor running as systemd user service
      - kinetic running as systemd user service
      - services configured with Restart=always
    steps:
      - bash: "systemctl --user is-active sensor && echo 'active'"
      # TODO(kinetic): uncomment when kinetic.service exists
      # - bash: "systemctl --user is-active kinetic && echo 'active'"
      - bash: "kill -9 $(pidof sensor) 2>/dev/null; sleep 5; systemctl --user is-active sensor && echo 'recovered'"
      # TODO(kinetic): test kinetic crash recovery
      # - bash: "kill -9 $(pgrep -f kinetic.jar) 2>/dev/null; sleep 5; systemctl --user is-active kinetic && echo 'recovered'"
    verify:
      - Equals: "recovered"

  - name: cold-boot-initialization
    description: System becomes operational within 30s of user session start
    tags: [smoke]
    estimated_duration_ms: 30000
    preconditions:
      - systemd user session starts
    steps:
      - bash: "systemctl --user start sensor && sleep 2 && systemctl --user is-active sensor"
      # TODO(kinetic): uncomment when kinetic.service exists
      # - bash: "systemctl --user start kinetic && sleep 5 && systemctl --user is-active kinetic"
      # TODO(kinetic): verify MCP tools/list responds
      # - bash: "kinetic-mcp tools/list | jq '.tools | length'"
    verify:
      - Equals: "active"
      # TODO(kinetic): verify tool count
      # - Equals: "35"

  - name: ring-buffer-overflow-handling
    description: When ring buffer fills, data spills to disk without loss
    tags: [stress]
    estimated_duration_ms: 10000
    preconditions:
      - sensor running
      - ring buffer configured for 60s window
    steps:
      # Generate rapid events to fill ring buffer
      - bash: "for i in $(seq 1 10000); do xdotool key a; done"
      - bash: "sleep 2"
      # TODO(sensor): verify spill files created and consumed
      # - bash: "ls /tmp/sensor-spill/ 2>/dev/null | wc -l"
      - bash: "sensor get_stats | jq -r '.events_dropped // 0'"
    verify:
      - Equals: "0"

enforced_constraints:
  - name: startup-time-budget
    value: 30s
    rationale: Balances responsiveness with proper initialization; allows JVM warmup, model loading, index validation

  - name: ring-buffer-window
    value: 60s
    size: ~2GB
    rationale: Sufficient for anomaly detection baseline and commentary context; <2% of 128GB RAM

  - name: restart-mechanism
    value: systemd user services
    rationale: Standard, battle-tested, handles crash loops, integrates with journal, no custom supervision code

opinionated_constraints:
  - name: fail-stop-coupling
    description: Both processes restart together on any crash
    rationale: Simplifies reasoning about cross-process state; consistency sweep on restart heals any divergence

  - name: non-blocking-consistency-sweep
    description: Startup sweep runs in background, does not block MCP readiness
    rationale: Accepts brief window of potentially stale data to meet 30s startup budget
