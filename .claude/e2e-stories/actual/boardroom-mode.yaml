vocabulary:
  boardroom_mode: "A real-time collaborative presentation mode where the agent uses a visual board (served via gateway HTTP) as its primary communication channel. Chat becomes compressed; the board becomes the canvas. Activated by /boardroom-mode on, deactivated by /boardroom-mode off."
  board_server: "Gateway-native HTTP endpoint serving board.html at /board and accepting WebSocket connections at /board/ws. Runs on the same Jetty instance as MCP (127.0.0.1:8372). No external servers, no Chrome extension, no file-based refresh."
  board_card: "A discrete unit of visual content pushed to the board via WebSocket. Has a type (proposal, education, result, decision, reference), title, and structured data fields. Board renders cards client-side from templates — no HTML is sent over the wire. Gateway tool ACT_board_card sends structured JSON; POST /board/card accepts JSON from sub-agents."
  card_type: "Visual grammar category for a board card. Each type has an accent color: proposal (blue), education (green), result (purple), decision (orange), reference (gray). Type determines the card's visual border/header treatment. Card templates are client-side JS in board.html."
  director: "The orchestrating agent (Opus) in boardroom mode. NEVER writes HTML or content — sends structured card specs via ACT_board_card (~30-50 tokens per action). NEVER makes mechanical tool calls (arrange windows, screenshot, inject cards) — uses compound gateway tools that encapsulate multi-step choreography. Dispatches haiku agents for complex visualizations."
  presenter_agent: "A haiku-model sub-agent spawned by the director to produce complex visual content (SVG diagrams, architecture visualizations, code analysis). Receives screenshot context and POSTs structured card data directly to POST /board/card when ready. Fire-and-forget — director does not wait. ~5-15s latency."
  compound_tool: "A gateway tool that encapsulates a multi-step choreography in a single call. ACT_boardroom_activate does screenshot+arrange+open+push in <200ms. ACT_board_card pushes structured data to all WebSocket clients in <100ms. Each compound tool costs the director exactly one tool call (~30-50 tokens)."
  activation_sequence: "Single tool call: ACT_boardroom_activate. Gateway internally does: screenshot capture -> i3 window arrangement -> open board in Chrome -> WebSocket connect -> push activation card. All <200ms. Director says 'Board is up.' in chat. One tool call, two words."
  board_archive: "HTML snapshot of a completed board session, saved to ~/vault/org/btw/boards/{timestamp}.html on /boardroom-mode off. Indexed by vault watcher for future retrieval. Self-contained HTML with inline styles."
  layout_ownership: "The director's control over the right 2/3 of the screen during boardroom mode. Managed via compound tools that handle i3 commands internally. Director never calls ACT_arrange_windows directly."
  screen_awareness: "Screenshot captured by ACT_boardroom_activate at activation time. Returned as a path in the tool result so director can pass it to haiku agents. Director does not call SENSE_capture_screen_region directly."
  layer_cake: "The four-layer architecture: Director (Opus, decisions, ~30-50 tokens/action) -> Gateway (compound tools, <200ms) -> Board (WebSocket rendering, client-side templates) -> Haiku agents (complex content, fire-and-forget via POST /board/card)."

metadata:
  feature: actual
  component: boardroom-mode
  date: "2026-02-18"
  revision: "v2 — updated for compound-tool + structured-data architecture"

stories:
  # === Activation ===

  - name: activation-single-tool-call
    description: >
      /boardroom-mode on triggers exactly ONE tool call: ACT_boardroom_activate.
      The gateway compound tool internally performs: screenshot capture, i3 arrange
      (chat 1/3, board 2/3), open board in Chrome, push activation card via WebSocket.
      Total latency <200ms gateway-side. Director says 'Board is up.' in chat.
      Director context cost: one tool call (~30 tokens) + two words (~5 tokens).
    preconditions:
      - "Gateway is running on 127.0.0.1:8372 with board server enabled"
      - "User's display (:0) is accessible"
      - "Chrome or Chromium is available for board display"
      - "i3 window manager is running on user's display"
    steps:
      - "User types /boardroom-mode on and presses Enter"
      - "Director calls ACT_boardroom_activate (single tool call, no other tool calls)"
      - "Gateway internally: captures screenshot via SENSE_capture_screen_region"
      - "Gateway internally: sends i3 arrange command (chat left 1/3, board right 2/3)"
      - "Gateway internally: opens http://127.0.0.1:8372/board in Chrome"
      - "Gateway internally: waits for WebSocket connection from board.html"
      - "Gateway internally: pushes activation card {type: 'proposal', title: 'Session Started', data: {timestamp, screenshot_summary}}"
      - "Gateway returns result including screenshot_path for agent context"
      - "Director outputs 'Board is up.' in chat (compressed confirmation)"
    verify:
      - "Director made exactly ONE tool call (ACT_boardroom_activate)"
      - "Director did NOT call ACT_arrange_windows, SENSE_capture_screen_region, or any browser tool"
      - "Total elapsed time from tool call to result is < 200ms (gateway-side)"
      - "Total elapsed time from Enter to 'Board is up.' in chat is < 2 seconds (including model latency)"
      - "i3 layout shows chat in left 33% and board in right 67%"
      - "Board page is loaded and WebSocket status shows 'connected'"
      - "Activation card is visible on the board with correct timestamp"
      - "Screenshot file exists and path is included in tool result"
      - "Chat output is exactly 'Board is up.' — no prose, no explanation"

  - name: screenshot-returned-for-agent-dispatch
    description: >
      ACT_boardroom_activate returns the screenshot path in its result so the director
      can pass it to haiku agents without making an additional SENSE_capture_screen_region call.
      This keeps the director at zero extra tool calls for visual context.
    preconditions:
      - "Gateway is running with display tools available"
      - "User's display (:0) has windows in some arrangement"
    steps:
      - "User triggers /boardroom-mode on"
      - "Director calls ACT_boardroom_activate"
      - "Gateway captures screenshot BEFORE any layout changes (captures current state)"
      - "Gateway stores screenshot at a known path (e.g. /tmp/boardroom-activation.png)"
      - "Gateway returns JSON result including screenshot_path field"
      - "Director can later pass this path to haiku agents for visual context"
    verify:
      - "Screenshot file exists at the returned path"
      - "Screenshot was captured BEFORE any i3 arrange commands were issued"
      - "Screenshot dimensions match user's display resolution"
      - "Director did NOT call SENSE_capture_screen_region — screenshot was internal to compound tool"
      - "Tool result contains screenshot_path as a parseable field"

  - name: layout-arrangement-internal
    description: >
      Window arrangement is handled internally by ACT_boardroom_activate.
      The director never calls ACT_arrange_windows directly during activation.
      Chat occupies left 1/3, board occupies right 2/3. Verified via i3 tree.
    preconditions:
      - "i3 is running on user's display"
      - "Chat window (Claude Code terminal) is identifiable in i3 tree"
    steps:
      - "ACT_boardroom_activate internally issues i3 command to arrange chat to left 1/3"
      - "Compound tool internally places board browser in right 2/3"
      - "i3 commands execute (millisecond-level latency)"
      - "Board browser window opens or is moved to the right container"
    verify:
      - "SENSE_read_window_layout shows two containers in horizontal split"
      - "Left container (chat) occupies approximately 33% of screen width"
      - "Right container (board) occupies approximately 67% of screen width"
      - "Both containers are on the same workspace"
      - "Layout change completed in < 100ms (i3 is instantaneous)"
      - "Director made zero ACT_arrange_windows calls"

  # === Board Server ===

  - name: board-server-health
    description: >
      The board server runs on gateway's existing Jetty instance. board.html is served at /board,
      WebSocket endpoint at /board/ws, card POST API at /board/card. No separate process.
    preconditions:
      - "Gateway is running on 127.0.0.1:8372"
    steps:
      - "HTTP GET http://127.0.0.1:8372/board returns board.html"
      - "board.html contains JavaScript that connects to ws://127.0.0.1:8372/board/ws"
      - "board.html contains client-side card templates for all five card types"
      - "WebSocket connection establishes successfully (onopen fires)"
      - "POST http://127.0.0.1:8372/board/card with JSON body {type, title, data} returns 200"
      - "Posted card data is pushed to all connected WebSocket clients as JSON"
      - "Board JS receives JSON, selects card template by type, renders card in DOM"
    verify:
      - "GET /board returns 200 with Content-Type text/html"
      - "board.html contains WebSocket connection code targeting /board/ws"
      - "board.html contains card template functions for: proposal, education, result, decision, reference"
      - "WebSocket handshake succeeds (101 Switching Protocols)"
      - "POST /board/card returns 200 (or 204) on success"
      - "POST /board/card with malformed JSON returns 400"
      - "No HTML is transmitted over WebSocket — only structured JSON card data"
      - "No external processes started (no python, no node, no separate server)"
      - "Board runs on same port as MCP endpoint (8372)"

  - name: card-push-latency
    description: >
      Cards must appear on the board within 100ms of being pushed. The pipeline is:
      ACT_board_card or POST /board/card -> JSON parse -> WebSocket push -> board JS
      receives JSON -> template selection -> DOM render. <100ms end-to-end.
    preconditions:
      - "Board is open in browser and WebSocket is connected"
    steps:
      - "Record timestamp T0 immediately before ACT_board_card call (or POST /board/card)"
      - "Gateway receives structured card data, serializes to JSON, pushes via WebSocket"
      - "Board JS receives WebSocket message, parses JSON, selects template by card type"
      - "Template function creates DOM elements from structured data fields"
      - "Card is visible in viewport (scrolled into view if needed)"
      - "Record timestamp T1 when card's mutation fires in DOM"
    verify:
      - "T1 - T0 < 100ms under normal conditions"
      - "Card is rendered from structured data via client-side template (no raw HTML in WebSocket payload)"
      - "Card appears at the bottom of the board (newest last)"
      - "Board auto-scrolls to show the new card"
      - "Multiple rapid pushes (burst of 5 cards in 50ms) all render in order"
      - "Card visual matches its type template (correct accent color, structure)"

  - name: board-reconnection
    description: >
      If the WebSocket connection drops (network blip, gateway restart), the board
      auto-reconnects without user intervention. Reconnection is visible but not disruptive.
    preconditions:
      - "Board is open and WebSocket was previously connected"
      - "board.html has reconnection logic"
    steps:
      - "WebSocket connection drops (server closes, network interruption)"
      - "board.html's onclose handler fires"
      - "Reconnection loop starts with exponential backoff (1s, 2s, 4s, max 30s)"
      - "board.html shows connection status indicator (e.g. 'Reconnecting...')"
      - "Gateway comes back / network restores"
      - "WebSocket reconnects successfully"
      - "Status indicator returns to 'Connected'"
    verify:
      - "Reconnection attempts are automatic (no user action required)"
      - "Reconnection uses exponential backoff (not aggressive spin)"
      - "Connection status is visible on the board (user knows when disconnected)"
      - "Cards posted during disconnection are not lost if gateway buffers them"
      - "No duplicate cards after reconnection"
      - "Existing cards on the board are preserved across reconnection (no page reload needed)"

  # === Card Generation — Structured Data ===

  - name: director-structured-card
    description: >
      Director sends structured card data via ACT_board_card, NEVER HTML.
      The tool accepts {type, title, items/data} and the board renders it
      client-side via card templates. Director context cost: ~30-50 tokens per card.
    preconditions:
      - "Boardroom mode is active"
      - "Board is connected via WebSocket"
    steps:
      - "User sends a message requiring a response (e.g. 'What's the plan?')"
      - "Director calls ACT_board_card with structured data:"
      - "  {type: 'proposal', title: 'Implementation Plan', items: ['Stage 1: Foundation', 'Stage 2: Tools', 'Stage 3: Polish']}"
      - "Gateway pushes JSON to board via WebSocket"
      - "Board JS selects 'proposal' card template, renders list items as styled <li> elements"
      - "Director outputs 'On the board.' in chat"
    verify:
      - "Director sent structured data (JSON fields), NOT HTML strings"
      - "ACT_board_card call was ~30-50 tokens of director context"
      - "Card appears on board within 100ms of tool call"
      - "Card rendered by client-side template matches proposal visual grammar (blue accent)"
      - "Chat output is compressed ('On the board.' — 3 words)"
      - "No agent was spawned for this simple card"
      - "Director made exactly ONE tool call for this card"

  - name: haiku-agent-fire-and-forget
    description: >
      For complex content (SVG diagrams, architecture visualizations, code analysis),
      the director dispatches a haiku model agent. The agent POSTs structured card data
      directly to POST /board/card when ready. Director does NOT block — fire-and-forget.
      Agent latency is ~5-15 seconds. Director continues processing immediately.
    preconditions:
      - "Boardroom mode is active"
      - "Board is connected via WebSocket"
      - "Haiku model is available for agent dispatch"
    steps:
      - "User requests something requiring complex visualization (e.g. 'Show me the dependency graph')"
      - "Director dispatches haiku agent via Task tool with:"
      - "  - Task description and user intent"
      - "  - Screenshot path from ACT_boardroom_activate result"
      - "  - Gateway board API URL: POST http://127.0.0.1:8372/board/card"
      - "  - Card type and title guidance"
      - "Director immediately outputs in chat: 'Dependency graph coming to the board.'"
      - "Director continues processing other messages (not blocked)"
      - "Haiku agent analyzes codebase, generates SVG/structured content"
      - "Haiku agent POSTs card: {type: 'result', title: 'Dependency Graph', data: {svg: '...', caption: '...'}}"
      - "Board renders card via result template (5-15 seconds after dispatch)"
    verify:
      - "Director's chat response is immediate (< 2s) despite complex visualization pending"
      - "Director did NOT block/wait for agent completion"
      - "Director's context cost for dispatch was minimal (~50-100 tokens: task description + tool call)"
      - "Haiku agent has access to screenshot path for visual context"
      - "Haiku agent POSTs directly to http://127.0.0.1:8372/board/card (not back to director)"
      - "Card appears on board when agent completes (~5-15s after dispatch)"
      - "Director can respond to other user messages while agent works"
      - "If agent fails, no card appears — no error propagates to director context"
      - "Agent used haiku model (cheap, fast), not opus (expensive, frontier)"

  - name: screen-awareness-for-agents
    description: >
      Haiku agents receive the screenshot path captured by ACT_boardroom_activate so they
      understand the user's visual state. Director passes the path from the activation
      result — no additional screenshot tool calls needed.
    preconditions:
      - "Boardroom mode is active"
      - "ACT_boardroom_activate returned a screenshot_path"
      - "Director is dispatching a haiku agent"
    steps:
      - "Director includes screenshot_path (from activation result) in agent's task prompt"
      - "Haiku agent reads the screenshot (multimodal input)"
      - "Agent uses visual context to inform its visualization"
      - "Agent generates card content that complements what's on screen"
    verify:
      - "Agent's task description includes screenshot file path from activation result"
      - "Director did NOT call SENSE_capture_screen_region to get the screenshot"
      - "Agent can read the screenshot file (path is accessible)"
      - "Agent's output demonstrates awareness of screen state"

  # === Card Types ===

  - name: card-type-visual-grammar
    description: >
      Each card type has a distinct visual accent color, structural purpose, and client-side
      template. The board renders all cards from structured JSON data — no HTML over the wire.
      Visual grammar is consistent so users recognize card roles at a glance.
    preconditions:
      - "Board is open and rendering cards"
    steps:
      - "Push card with type='proposal' — blue accent, renders items as list"
      - "Push card with type='education' — green accent, renders data as explanation blocks"
      - "Push card with type='result' — purple accent, renders data with optional SVG/code"
      - "Push card with type='decision' — orange accent, renders options with trade-offs"
      - "Push card with type='reference' — gray accent, renders raw material (file contents, links)"
    verify:
      - "Proposal card has blue accent — indicates 'what I plan to do, shown BEFORE action'"
      - "Education card has green accent — indicates 'context you need'"
      - "Result card has purple accent — indicates 'what happened, AFTER action'"
      - "Decision card has orange accent — indicates 'I need your input, options with trade-offs'"
      - "Reference card has gray accent — indicates 'raw material to see'"
      - "Each card type rendered entirely client-side from JSON data via its template function"
      - "Unknown type defaults gracefully (no crash, renders as plain card with data dump)"
      - "Card title is always visible in the header area"
      - "Card body renders structured data fields below the title"
      - "All text meets minimum 14px font size requirement"

  # === Director Voice & Context Budget ===

  - name: director-compressed-chat
    description: >
      In boardroom mode, chat output is radically compressed. The board is the primary
      communication channel. Chat contains only: decisions, file paths, 'On the board.',
      acknowledgments. No explanations, prose, or status updates in chat.
    preconditions:
      - "Boardroom mode is active"
    steps:
      - "User asks a question that requires explanation"
      - "Director sends structured card data via ACT_board_card (education type)"
      - "Director outputs only 'On the board.' in chat"
      - "User asks about a file change"
      - "Director outputs file path and 'Result on the board.' in chat"
      - "Director sends result card via ACT_board_card with structured data"
    verify:
      - "Chat messages during boardroom mode average < 10 words"
      - "No chat message contains multi-sentence explanations"
      - "All detailed content goes to board cards"
      - "'On the board.' is the standard redirect phrase"
      - "File paths are given in chat (user needs them for copy-paste)"
      - "Acknowledgments are single words or short phrases"
      - "Status updates go to board cards, not chat"

  - name: director-context-budget
    description: >
      The director spends ~30-50 tokens per board action. One tool call per action.
      Two words in chat. Everything else happens outside frontier context: gateway
      handles choreography, board handles rendering, haiku agents handle complex content.
      Director NEVER writes HTML, NEVER calls mechanical tools.
    preconditions:
      - "Boardroom mode is active"
    steps:
      - "Simple card: director calls ACT_board_card({type, title, items}) — ~30-50 tokens"
      - "Complex card: director dispatches haiku agent via Task tool — ~50-100 tokens"
      - "Chat output: 'On the board.' — ~5 tokens"
      - "Total per-action: ~35-55 tokens (simple) or ~55-105 tokens (complex dispatch)"
      - "Director NEVER generates HTML strings"
      - "Director NEVER calls ACT_arrange_windows, SENSE_capture_screen_region, or browser tools"
      - "Director NEVER calls Chrome javascript_tool, navigate, or read_page"
    verify:
      - "No director tool call contains HTML markup"
      - "No director turn during boardroom mode exceeds ~200 tokens total output"
      - "Director makes at most 1-2 tool calls per user message"
      - "ACT_board_card arguments are structured data (type, title, items/data), never HTML body"
      - "Zero calls to mechanical/layout tools — all handled by compound tools or activation"
      - "Zero calls to browser tools (javascript_tool, navigate, read_page, computer)"
      - "Zero calls to SENSE_capture_screen_region during normal operation (only in compound tools)"

  # === Compound Gateway Tools ===

  - name: compound-tool-activate
    description: >
      ACT_boardroom_activate encapsulates the entire activation sequence in one gateway
      tool call. Internally: screenshot -> i3 arrange -> Chrome open -> WebSocket wait ->
      activation card push. All steps run sequentially inside the gateway JVM. <200ms total.
    preconditions:
      - "Gateway is running with display tools, i3, and Chrome available"
    steps:
      - "Director calls ACT_boardroom_activate with optional display_id"
      - "Gateway captures screenshot (SENSE_capture_screen_region internal)"
      - "Gateway arranges i3 layout: chat left 1/3, board right 2/3"
      - "Gateway opens Chrome to http://127.0.0.1:8372/board"
      - "Gateway waits for WebSocket connection from board.html (with timeout)"
      - "Gateway pushes activation card via WebSocket: {type: 'proposal', title: 'Session Started'}"
      - "Gateway returns {screenshot_path, layout_confirmed, websocket_connected}"
    verify:
      - "Single tool registration: ACT_boardroom_activate in ToolRegistry"
      - "All five internal steps complete in <200ms"
      - "Result includes screenshot_path for downstream agent dispatch"
      - "Result includes connection status confirmation"
      - "If any step fails, error is returned with detail on which step failed"
      - "Chrome reuses existing window if board is already open (idempotent)"

  - name: compound-tool-card
    description: >
      ACT_board_card accepts structured card data and pushes it to all connected
      WebSocket clients. The director sends {type, title, items} or {type, title, data}.
      The board's client-side JS renders the card from templates. <100ms.
    preconditions:
      - "Board is connected via WebSocket"
    steps:
      - "Director calls ACT_board_card with {type: 'proposal', title: 'Plan', items: [...]}"
      - "Gateway serializes to JSON: {type, title, data, timestamp}"
      - "Gateway pushes JSON to all connected WebSocket clients"
      - "Board JS receives message, parses JSON, selects template by type"
      - "Template renders card DOM elements from structured data"
      - "Gateway returns success confirmation"
    verify:
      - "Tool accepts structured data fields, NOT an HTML body parameter"
      - "WebSocket payload is JSON with {type, title, data, timestamp}"
      - "No HTML is present in the WebSocket payload"
      - "Card renders correctly from template on the board"
      - "Tool returns in <100ms"
      - "Multiple concurrent clients all receive the push"

  # === Session Lifecycle ===

  - name: session-archiving
    description: >
      /boardroom-mode off triggers ACT_boardroom_deactivate. Gateway archives the current
      board to ~/vault/org/btw/boards/{timestamp}.html, resets the board, restores layout.
    preconditions:
      - "Boardroom mode is active with cards on the board"
      - "~/vault/org/btw/boards/ directory exists (or will be created)"
    steps:
      - "User types /boardroom-mode off"
      - "Director calls ACT_boardroom_deactivate (single tool call)"
      - "Gateway captures final board state: requests full HTML from board via WebSocket or HTTP"
      - "Gateway saves self-contained HTML to ~/vault/org/btw/boards/{ISO-timestamp}.html"
      - "Gateway resets board (clears cards, ready for next session)"
      - "Gateway restores i3 layout (or leaves as-is if user prefers)"
      - "Director outputs 'Board archived. Back to normal.' in chat"
    verify:
      - "Director made exactly ONE tool call (ACT_boardroom_deactivate)"
      - "Archive file exists at ~/vault/org/btw/boards/{timestamp}.html"
      - "Archive contains all cards from the session in order"
      - "Archive is self-contained HTML (inline styles, no external deps)"
      - "Timestamp format is ISO 8601 (e.g. 2026-02-18T14-30-00)"
      - "Board is cleared after archiving (empty state for next session)"
      - "Chat returns to normal verbose mode after deactivation"
      - "Old archives are preserved (not overwritten)"
      - "Vault watcher will eventually index the archive for retrieval"

  # === Dynamic Layout ===

  - name: dynamic-layout-reshape
    description: >
      The director can dynamically reshape the right 2/3 of the screen during a session
      via ACT_board_card with a special 'layout' command, or through a dedicated
      ACT_boardroom_layout tool if needed. Layout changes are instant via i3 commands
      executed inside the gateway — director never calls ACT_arrange_windows directly.
    preconditions:
      - "Boardroom mode is active with chat 1/3 + board 2/3 layout"
      - "i3 is running on user's display"
    steps:
      - "Director decides to show code alongside the board"
      - "Director calls a layout tool or sends layout directive via ACT_board_card"
      - "Gateway internally issues i3 commands to reshape right 2/3"
      - "Layout change executes in milliseconds"
    verify:
      - "SENSE_read_window_layout confirms new arrangement matches intent"
      - "Chat container (left 1/3) is undisturbed by right-side layout changes"
      - "Layout changes execute in < 100ms (i3 is instantaneous)"
      - "Board remains connected (WebSocket survives window resize/move)"
      - "Board content re-renders correctly at new dimensions"
      - "Director made zero ACT_arrange_windows calls"
      - "Multiple layout changes per session are supported"

  # === Board Card API (for sub-agents) ===

  - name: board-card-post-api
    description: >
      POST /board/card is the shared bus for any process to push cards to the board.
      Haiku agents, scripts, curl — anything that can make an HTTP POST can push a card.
      This decouples card production from the director entirely.
    preconditions:
      - "Gateway is running and board WebSocket has at least one connected client"
    steps:
      - "External process (haiku agent, script, curl) sends POST to http://127.0.0.1:8372/board/card"
      - "Request body: {type: 'result', title: 'Analysis', data: {content: '...', svg: '...'}}"
      - "Gateway parses JSON, validates required fields (type, title)"
      - "Gateway pushes card data to all connected WebSocket clients"
      - "Board renders card via appropriate template"
    verify:
      - "POST /board/card returns 200/204 on success"
      - "POST with missing 'type' returns 400"
      - "POST with missing 'title' returns 400"
      - "POST with malformed JSON returns 400"
      - "Card appears on board within 100ms of POST"
      - "No authentication required (localhost only, same as MCP)"
      - "Multiple POSTs from different agents render in order received"
      - "Board handles concurrent POSTs without data corruption"

enforced_constraints:
  - name: director-never-writes-html
    description: >
      The director NEVER generates HTML strings. Writing HTML burns frontier context
      identically to writing prose. Director sends structured data (JSON-like card specs):
      {type, title, items} or {type, title, data}. The board renders client-side via templates.
    rationale: >
      Every character of HTML the director writes is a frontier token spent on rendering
      instead of thinking. A 500-character HTML card costs ~150 tokens. A structured
      {type, title, items: [3 strings]} costs ~30 tokens. 5x savings per card. Over a
      session with 20 cards, that's ~2400 tokens saved — enough for 3-4 additional
      reasoning steps.

  - name: director-never-makes-mechanical-tool-calls
    description: >
      The director NEVER calls mechanical/choreography tools directly. No ACT_arrange_windows,
      no SENSE_capture_screen_region, no browser tools (javascript_tool, navigate, read_page,
      computer). Every tool call burns frontier tokens. All choreography is handled by
      compound gateway tools: ACT_boardroom_activate, ACT_board_card, ACT_boardroom_deactivate.
    rationale: >
      Each tool call costs ~30-50 tokens (call) + ~50-200 tokens (result parsing).
      A 5-step activation sequence done manually costs ~500 tokens. The compound tool
      ACT_boardroom_activate costs ~80 tokens total (one call + one result).
      The savings compound: over 10 board actions, 2000+ tokens saved.

  - name: director-context-budget-30-50-tokens
    description: >
      The director spends ~30-50 tokens per board action. One tool call per action.
      Two words in chat. Everything else happens outside frontier context.
      Budget breakdown: ACT_board_card call ~30-50 tokens, chat output ~5 tokens,
      result parsing ~20 tokens. Total per action: ~55-75 tokens.
    rationale: >
      Opus context is the scarcest resource in the system. A boardroom session might
      have 30-50 board actions. At ~60 tokens/action, that's 1800-3000 tokens on board
      management — leaving >90% of context for actual reasoning and user interaction.
      At the old rate (~500 tokens/action with manual HTML + tool calls), 30 actions
      would consume 15000 tokens — a catastrophic context burn.

  - name: activation-under-200ms-gateway
    description: >
      ACT_boardroom_activate MUST complete all internal steps in under 200ms (gateway-side).
      Total user-visible time (including model latency) MUST be under 2 seconds.
    rationale: >
      The first boardroom mode run took 5 minutes with nothing on screen. The compound
      tool eliminates model round-trips. 200ms is achievable because all steps are local:
      screenshot (~50ms), i3 arrange (~10ms), Chrome open (~100ms), WebSocket push (~5ms).

  - name: card-push-under-100ms
    description: >
      ACT_board_card (or POST /board/card) to DOM render MUST complete in under 100ms.
      Pipeline: tool call -> gateway JSON serialize -> WebSocket push -> board JS parse ->
      template render -> DOM visible.
    rationale: >
      100ms is the threshold for "instant" in human perception. Cards must feel like they
      appear the moment they're sent. Client-side template rendering is faster than
      parsing and inserting raw HTML — the board already has the templates loaded.

  - name: no-external-server-dependency
    description: >
      The board MUST be served from gateway's Jetty instance. No python http.server,
      no node, no Chrome extension, no file editing + F5 refresh cycle.
    rationale: >
      External server dependencies add startup time, failure modes, and configuration
      complexity. The gateway already has Jetty running for MCP HTTP. Serving static HTML
      and handling WebSocket from the same process eliminates an entire class of failures.

  - name: websocket-not-polling
    description: >
      Card delivery MUST use WebSocket push, not HTTP polling. The browser receives
      cards the instant they're posted, with no polling interval delay.
    rationale: >
      Polling adds latency equal to half the polling interval on average. Even 1-second
      polling would make cards feel sluggish. WebSocket push delivers cards in single-digit
      milliseconds, which is essential for the <100ms push target.

  - name: director-does-not-block-on-agents
    description: >
      When the director dispatches a haiku agent for complex content, the director
      MUST NOT block waiting for the agent to complete. Chat remains responsive.
      The agent POSTs its card independently when ready. Fire-and-forget.
    rationale: >
      Blocking on agent work recreates the original problem (5 minutes of silence).
      The director's job is orchestration: dispatch the agent, acknowledge in chat,
      move on. The agent's card appears asynchronously (~5-15s). This keeps the user
      engaged with sub-second chat responses even when heavy computation is in flight.

  - name: haiku-agents-not-opus
    description: >
      Complex card content MUST be generated by haiku-model agents, never by the director
      (Opus). The director dispatches; haiku produces. SVG, code analysis, architecture
      diagrams — all haiku work.
    rationale: >
      Haiku is ~20x cheaper than Opus per token and fast enough for card content.
      The director's Opus context is for decisions and orchestration. Using Opus to
      generate SVG diagrams is like using a CEO to write HTML — wrong level of abstraction.

  - name: compressed-chat-in-boardroom
    description: >
      During boardroom mode, ALL chat output MUST be compressed to decisions, file paths,
      'On the board.', and short acknowledgments. No multi-sentence explanations, no prose,
      no status updates in chat.
    rationale: >
      The board is the communication channel. Chat becomes a control channel. If the
      director dumps explanations in both places, the user has to read two streams.
      Compressing chat to near-zero forces all substantive content onto the board where
      it has visual structure, type-coding, and persistence.

  - name: window-arrangement-internal-only
    description: >
      Window arrangement in boardroom mode MUST happen inside compound tools only.
      The director MUST NOT call ACT_arrange_windows directly. Layout changes are either
      part of ACT_boardroom_activate or a dedicated compound layout tool.
    rationale: >
      Every ACT_arrange_windows call burns ~50 tokens of director context for an operation
      that has zero decision value — the layout is predetermined. Compound tools handle
      it for free (internal to gateway, no frontier tokens consumed).

opinionated_constraints:
  - name: card-type-color-grammar
    description: >
      Card types use these specific accent colors: proposal=blue, education=green,
      result=purple, decision=orange, reference=gray. Colors are not configurable
      per-session; they form a consistent visual language.
    rationale: >
      Consistent color coding lets users glance at a card and know its purpose without
      reading the header. Blue=future (proposal), green=learning (education),
      purple=past (result), orange=attention (decision), gray=neutral (reference).
      Changing colors per-session would destroy the learned associations.

  - name: client-side-card-templates
    description: >
      Card rendering MUST be client-side. board.html contains a template function per
      card type. Templates accept structured JSON data and produce DOM elements.
      No server-side HTML generation, no HTML over WebSocket.
    rationale: >
      Client-side templates mean the WebSocket payload is tiny (structured data, ~100-300
      bytes per card). Server-side HTML generation would require the gateway to maintain
      templates, produce HTML strings, and transmit large payloads. Client-side rendering
      is faster, lighter, and keeps the gateway focused on data routing.

  - name: board-archive-self-contained
    description: >
      Archived board HTML files MUST be self-contained: inline CSS, no external
      stylesheet links, no JavaScript dependencies. The archive is a static snapshot.
    rationale: >
      Archives may be viewed months later when the gateway isn't running. External
      dependencies would break rendering. Self-contained HTML ensures the archive
      is always viewable in any browser, even offline.

  - name: newest-card-at-bottom
    description: >
      New cards appear at the bottom of the board, and the board auto-scrolls to show them.
      The board reads top-to-bottom chronologically, like a chat log.
    rationale: >
      Bottom-append with auto-scroll matches the mental model of a timeline. Users
      expect the latest content at the bottom (same as chat). Top-append would require
      the user to scroll up to see new cards, which breaks flow.

  - name: activation-card-required
    description: >
      The activation sequence MUST produce a visible card on the board. An empty board
      after activation feels broken, even if the system is ready.
    rationale: >
      The activation card serves as proof-of-life for the entire pipeline: gateway
      served the page, WebSocket connected, card pushed, template rendered. If the
      activation card appears, the user knows every component is working.

  - name: archive-path-convention
    description: >
      Board archives are stored at ~/vault/org/btw/boards/{ISO-timestamp}.html.
      The path is fixed, not configurable. The vault watcher indexes this directory.
    rationale: >
      A fixed path means archives are always findable. The vault/org/btw/ prefix
      follows the existing vault organization for "by the way" ephemeral content.
      ISO timestamps sort lexicographically, making ls output chronological.

  - name: presenter-agent-posts-directly
    description: >
      Haiku agents POST their cards directly to http://127.0.0.1:8372/board/card,
      not back to the director for relay. This eliminates the director as a bottleneck
      and avoids consuming director context with agent output.
    rationale: >
      If agents returned card content to the director for posting, the director would
      need to parse and forward large payloads, burning frontier tokens. Direct POST
      means the agent's card hits the board as soon as it's ready, with no intermediary.
      The gateway's POST endpoint is the shared bus.

  - name: board-html-minimal
    description: >
      board.html should be minimal: a WebSocket client, a card container, card template
      functions (one per type), auto-scroll logic, reconnection logic, connection status
      indicator. No framework, no build step, no npm. Plain HTML + CSS + vanilla JS.
    rationale: >
      The board is a rendering engine, not an application. Minimal HTML loads instantly,
      has zero build dependencies, and is trivially debuggable. A framework would add
      load time, bundle size, and failure modes for zero benefit — the board just
      renders structured data through templates pushed over a WebSocket.

  - name: layer-cake-architecture
    description: >
      The system has exactly four layers:
      1. Director (Opus) — decisions, orchestration, ~30-50 tokens/action
      2. Gateway (compound tools) — choreography, <200ms per compound action
      3. Board (WebSocket + client-side templates) — rendering, <100ms per card
      4. Haiku agents (fire-and-forget) — complex content, ~5-15s, POST to /board/card
      No layer may skip levels. Director talks to Gateway. Gateway talks to Board.
      Haiku agents talk to Gateway (POST /board/card). Director never talks to Board directly.
    rationale: >
      Strict layering keeps each component focused and prevents context bleed.
      The director doesn't know about WebSocket, HTML, or i3. The board doesn't know
      about the director or agents. The gateway is the universal intermediary.
      Breaking layering (director writes HTML, director calls i3) collapses the
      cost model and recreates the 5-minute-of-silence failure mode.
