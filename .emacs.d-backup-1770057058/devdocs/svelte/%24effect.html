<header> <h1>$effect</h1></header> <aside class="on-this-page svelte-wtnkd6"><label class="svelte-wtnkd6"> <h3 class="svelte-wtnkd6">On this page</h3></label> <nav class="svelte-wtnkd6"><ul class="svelte-wtnkd6">
<li class="svelte-wtnkd6"><a href="$effect" class="svelte-wtnkd6 active">$effect</a></li> <li class="svelte-wtnkd6"><a href="#$effect.pre" class="svelte-wtnkd6">$effect.pre</a></li>
<li class="svelte-wtnkd6"><a href="#$effect.tracking" class="svelte-wtnkd6">$effect.tracking</a></li>
<li class="svelte-wtnkd6"><a href="#$effect.pending" class="svelte-wtnkd6">$effect.pending</a></li>
<li class="svelte-wtnkd6"><a href="#$effect.root" class="svelte-wtnkd6">$effect.root</a></li>
<li class="svelte-wtnkd6"><a href="#When-not-to-use-$effect" class="svelte-wtnkd6">When not to use $effect</a></li>
</ul></nav></aside> <div class="text content"><div class="text svelte-zb31s9">
<p>Effects are functions that run when state updates, and can be used for things like calling third-party libraries, drawing on <code>&lt;canvas&gt;</code> elements, or making network requests. They only run in the browser, not during server-side rendering.</p> <p>Generally speaking, you should <em>not</em> update state inside effects, as it will make code more convoluted and will often lead to never-ending update cycles. If you find yourself doing so, see <a href="#When-not-to-use-$effect">when not to use <code>$effect</code></a> to learn about alternative approaches.</p> <p>You can create an effect with the <code>$effect</code> rune (<a href="https://svelte.dev/playground/untitled#H4sIAAAAAAAAE31S246bMBD9lZF3pSRSAqTVvrCAVPUP2sdSKY4ZwJJjkD0hSVH-vbINuWxXfQH5zMyZc2ZmZLVUaFn6a2R06ZGlHmBrpvnBvb71fWQHVOSwPbf4GS46TajJspRlVhjZU1HqkhQSWPkHIYdXS5xw-Zas3ueI6FRn7qHFS11_xSRZhIxbFtcDtw7SJb1iXaOg5XIFeQGjzyPRaevYNOGZIJ8qogbpe8CWiy_VzEpTXiQUcvPDkSVrSNZz1UlW1N5eLcqmpdXUvaQ4BmqlhZNUCgxuzFHDqUWNAxrYeUM76AzsnOsdiJbrBp_71lKpn3RRbii-4P3f-IMsRxS-wcDV_bL4PmSdBa2wl7pKnbp8DMgVvJm8ZNskKRkEM_OzyOKQFkgqOYBQ3Nq89Ns0nbIl81vMFN-jKoLMTOr-SOBOJS-Z8f5Y6D1wdcR8dFqvEBdetK-PHwj-z-cH8oHPY54wRJ8Ys7iSQ3Bg3VA9azQbmC9k35kKzYa6PoVtfwbbKVnBixBiGn7Pq0rqJoUtHiCZwAM3jdTPWCVtr_glhVrhecIa3vuksJ_b7TqFs4DPyriSjd5IwoNNQaAmNI-ESfR2p8zimzvN1swdCkvJHPH6-_oX8o1SgcIDAAA=">demo</a>):</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	let size = $state(50);
	let color = $state('#ff3e00');

	let canvas;

	$effect(() =&gt; {
		const context = canvas.getContext('2d');
		context.clearRect(0, 0, canvas.width, canvas.height);

		// this will re-run whenever `color` or `size` change
		context.fillStyle = color;
		context.fillRect(0, 0, size, size);
	});
&lt;/script&gt;

&lt;canvas bind:this={canvas} width="100" height="100"&gt;&lt;/canvas&gt;</pre>
</div>
<p>When Svelte runs an effect function, it tracks which pieces of state (and derived state) are accessed (unless accessed inside <a href="svelte#untrack"><code>untrack</code></a>), and re-runs the function when that state later changes.</p> <blockquote class="note">
<p> If you’re having difficulty understanding why your <code>$effect</code> is rerunning or is not running see <a href="#Understanding-dependencies">understanding dependencies</a>. Effects are triggered differently than the <code>$:</code> blocks you may be used to if coming from Svelte 4.</p> </blockquote>
<h3 id="Understanding-lifecycle">
<span>Understanding lifecycle</span>
</h3>
<p>Your effects run after the component has been mounted to the DOM, and in a <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide">microtask</a> after state changes. Re-runs are batched (i.e. changing <code>color</code> and <code>size</code> in the same moment won’t cause two separate runs), and happen after any DOM updates have been applied.</p> <p>You can use <code>$effect</code> anywhere, not just at the top level of a component, as long as it is called while a parent effect is running.</p> <blockquote class="note">
<p> Svelte uses effects internally to represent logic and expressions in your template — this is how <code>&lt;h1&gt;hello {name}!&lt;/h1&gt;</code> updates when <code>name</code> changes.</p> </blockquote>
<p>An effect can return a <em>teardown function</em> which will run immediately before the effect re-runs (<a href="https://svelte.dev/playground/untitled#H4sIAAAAAAAAE42SQVODMBCF_8pOxkPRKq3HCsx49K4n64xpskjGkDDJ0tph-O8uINo6HjxB3u7HvrehE07WKDbiyZEhi1osRWksRrF57gQdm6E2CKx_dd43zU3co6VB28mIf-nKO0JH_BmRRRVMQ8XWbXkAgfKtI8jhIpIkXKySu7lSG2tNRGZ1_GlYr1ZTD3ddYFmiosUigbyAbpC2lKbwWJkIB8ZhhxBQBWRSw6FCh3sM8GrYTthL-wqqku4N44TyqEgwF3lmRHr4Op0PGXoH31c5rO8mqV-eOZ49bikgtcHBL55tmhIkEMqg_cFB2TpFxjtg703we6NRL8HQFCS07oSUCZi6Rm04lz1yytIHBKoQpo1w6Gsm4gmyS8b8Y5PydeMdX8gwS2Ok4I-ov5NZtvQde95GMsccn_1wzNKfu3RZtS66cSl9lvL7qO1aIk7knbJGvefdtIOzi73M4bYvovUHDFk6AcX_0HRESxnpBOW_jfCDxIZCi_1L_wm4xGQ60wIAAA==">demo</a>).</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	let count = $state(0);
	let milliseconds = $state(1000);

	$effect(() =&gt; {
		// This will be recreated whenever `milliseconds` changes
		const interval = setInterval(() =&gt; {
			count += 1;
		}, milliseconds);

		return () =&gt; {
			// if a teardown function is provided, it will run
			// a) immediately before the effect re-runs
			// b) when the component is destroyed
			clearInterval(interval);
		};
	});
&lt;/script&gt;

&lt;h1&gt;{count}&lt;/h1&gt;

&lt;button onclick={() =&gt; (milliseconds *= 2)}&gt;slower&lt;/button&gt;
&lt;button onclick={() =&gt; (milliseconds /= 2)}&gt;faster&lt;/button&gt;</pre>
</div>
<p>Teardown functions also run when the effect is destroyed, which happens when its parent is destroyed (for example, a component is unmounted) or the parent effect re-runs.</p> <h3 id="Understanding-dependencies">
<span>Understanding dependencies</span>
</h3>
<p><code>$effect</code> automatically picks up any reactive values (<code>$state</code>, <code>$derived</code>, <code>$props</code>) that are <em>synchronously</em> read inside its function body (including indirectly, via function calls) and registers them as dependencies. When those dependencies change, the <code>$effect</code> schedules a re-run.</p> <p>If <code>$state</code> and <code>$derived</code> are used directly inside the <code>$effect</code> (for example, during creation of a <a href="$state#Classes">reactive class</a>), those values will <em>not</em> be treated as dependencies.</p> <p>Values that are read <em>asynchronously</em> — after an <code>await</code> or inside a <code>setTimeout</code>, for example — will not be tracked. Here, the canvas will be repainted when <code>color</code> changes, but not when <code>size</code> changes (<a href="https://svelte.dev/playground/untitled#H4sIAAAAAAAAE31T246bMBD9lZF3pWSlBEirfaEQqdo_2PatVIpjBrDkGGQPJGnEv1e2IZfVal-wfHzmzJyZ4cIqqdCy9M-F0blDlnqArZjmB3f72XWRHVCRw_bc4me4aDWhJstSlllhZEfbQhekkMDKfwg5PFvihMvX5OXH_CJa1Zrb0-Kpqr5jkiwC48rieuDWQbqgZ6wqFLRcvkC-hYvnkWi1dWqa8ESQTxFRjfQWsOXiWzmr0sSLhEJu3p1YsoJkNUcdZUnN9dagrBu6FVRQHAM10sJRKgUG16bXcGxQ44AGdt7SDkTDdY02iqLHnJVU6hedlWuIp94JW6Tf8oBt_8GdTxlF0b4n0C35ZLBzXb3mmYn3ae6cOW74zj0YVzDNYXRHFt9mprNgHfZSl6mzml8CMoLvTV6wTZIUDEJv5us2iwMtiJRyAKG4tXnhl8O0yhbML0Wm-B7VNlSSSd31BG7z8oIZZ6dgIffAVY_5xdU9Qrz1Bnx8fCfwtZ7v8Qc9j3nB8PqgmMWlHIID6-bkVaPZwDySfWtKNGtquxQ23Qlsq2QJT0KIqb8dL0up6xQ2eIBkAg_c1FI_YqW0neLnFCqFpwmreedJYT7XX8FVOBfwWRhXstZrSXiwKQjUhOZeMIleb5JZfHWn2Yq5pWEpmR7Hv-N_wEqT8hEEAAA=">demo</a>):</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">$effect(() =&gt; {
	const context = canvas.getContext('2d');
	context.clearRect(0, 0, canvas.width, canvas.height);

	// this will re-run whenever `color` changes...
	context.fillStyle = color;

	setTimeout(() =&gt; {
		// ...but not when `size` changes
		context.fillRect(0, 0, size, size);
	}, 0);
});</pre>
</div>
<p>An effect only reruns when the object it reads changes, not when a property inside it changes. (If you want to observe changes <em>inside</em> an object at dev time, you can use <a href="$inspect"><code>$inspect</code></a>.)</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	let state = $state({ value: 0 });
	let derived = $derived({ value: state.value * 2 });

	// this will run once, because `state` is never reassigned (only mutated)
	$effect(() =&gt; {
		state;
	});

	// this will run whenever `state.value` changes...
	$effect(() =&gt; {
		state.value;
	});

	// ...and so will this, because `derived` is a new object each time
	$effect(() =&gt; {
		derived;
	});
&lt;/script&gt;

&lt;button onclick={() =&gt; (state.value += 1)}&gt;
	{state.value}
&lt;/button&gt;

&lt;p&gt;{state.value} doubled is {derived.value}&lt;/p&gt;</pre>
</div>
<p>An effect only depends on the values that it read the last time it ran. This has interesting implications for effects that have conditional code.</p> <p>For instance, if <code>condition</code> is <code>true</code> in the code snippet below, the code inside the <code>if</code> block will run and <code>color</code> will be evaluated. This means that changes to either <code>condition</code> or <code>color</code> <a href="https://svelte.dev/playground/untitled#H4sIAAAAAAAAE21RQW6DMBD8ytaNBJHaJFLViwNIVZ8RcnBgXVk1xsILTYT4e20TQg89IOPZ2fHM7siMaJBx9tmaWpFqjQNlAKXEihx7YVJpdIyfRkY3G4gB8Pi97cPanRtQU8AuwuF_eNUaQuPlOMtc1SlLRWlKUo1tOwJflUikQHZtA0klzCDc64Imx0ANn8bInV1CDhtHgjClrsftcSXotluLybOUb3g4JJHhOZs5WZpuIS9gjNqkJKQP5e2ClrR4SMdZ13E4xZ8zTPOTJU2A2uE_PQ9COCI926_hTVarIU4hu_REPlBrKq2q73ycrf1N-vS4TMUsulaVg3EtR8H9rFgsg8uUsT1B2F9eshigZHBRpuaD0D3mY8Qm2BfB5N2YyRzdNEYVDy0Ja-WsFjcOUuP1HvFLWA6H3XuHTUSmmDV2--0TXonxsKbp7G9C6R__NONS-MFNvxj_d6mBAgAA">will cause the effect to re-run</a>.</p> <p>Conversely, if <code>condition</code> is <code>false</code>, <code>color</code> will not be evaluated, and the effect will <em>only</em> re-run again when <code>condition</code> changes.</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">import confetti from 'canvas-confetti';

let condition = $state(true);
let color = $state('#ff3e00');

$effect(() =&gt; {
	if (condition) {
		confetti({ colors: [color] });
	} else {
		confetti();
	}
});</pre>
</div>
<h2 id="$effect.pre">
<span>$effect.pre</span>
</h2>
<p>In rare cases, you may need to run code <em>before</em> the DOM updates. For this we can use the <code>$effect.pre</code> rune:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	import { tick } from 'svelte';

	let div = $state();
	let messages = $state([]);

	// ...

	$effect.pre(() =&gt; {
		if (!div) return; // not yet mounted

		// reference `messages` array length so that this code re-runs whenever it changes
		messages.length;

		// autoscroll when new messages are added
		if (div.offsetHeight + div.scrollTop &gt; div.scrollHeight - 20) {
			tick().then(() =&gt; {
				div.scrollTo(0, div.scrollHeight);
			});
		}
	});
&lt;/script&gt;

&lt;div bind:this={div}&gt;
	{#each messages as message}
		&lt;p&gt;{message}&lt;/p&gt;
	{/each}
&lt;/div&gt;</pre>
</div>
<p>Apart from the timing, <code>$effect.pre</code> works exactly like <code>$effect</code>.</p> <h2 id="$effect.tracking">
<span>$effect.tracking</span>
</h2>
<p>The <code>$effect.tracking</code> rune is an advanced feature that tells you whether or not the code is running inside a tracking context, such as an effect or inside your template (<a href="https://svelte.dev/playground/untitled#H4sIAAAAAAAACn3PwYrCMBDG8VeZDYIt2PYeY8Dn2HrIhqkU08nQjItS-u6buAt7UDzmz8ePyaKGMWBS-nNRcmdU-hHUTpGbyuvI3KZvDFLal0v4qvtIgiSZUSb5eWSxPfWSc4oB2xDP1XYk8HHiSHkICeXKeruDDQ4Demlldv4y0rmq6z10HQwuJMxGVv4mVVXDwcJS0jP9u3knynwtoKz1vifT_Z9Jhm0WBCcOTlDD8kyspmML5qNpHg40jc3fFryJ0iWsp_UHgz3180oBAAA=">demo</a>):</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	console.log('in component setup:', $effect.tracking()); // false

	$effect(() =&gt; {
		console.log('in effect:', $effect.tracking()); // true
	});
&lt;/script&gt;

&lt;p&gt;in template: {$effect.tracking()}&lt;/p&gt; &lt;!-- true --&gt;</pre>
</div>
<p>It is used to implement abstractions like <a href="svelte-reactivity#createSubscriber"><code>createSubscriber</code></a>, which will create listeners to update reactive values but <em>only</em> if those values are being tracked (rather than, for example, read inside an event handler).</p> <h2 id="$effect.pending">
<span>$effect.pending</span>
</h2>
<p>When using <a href="await-expressions"><code>await</code></a> in components, the <code>$effect.pending()</code> rune tells you how many promises are pending in the current <a href="svelte-boundary">boundary</a>, not including child boundaries (<a href="https://svelte.dev/playground/untitled#H4sIAAAAAAAAE3WRMU_DMBCF_8rJdHDUqilILGkaiY2RgY0yOPYZWbiOFV8IleX_jpMUEAIWS_7u-d27c2ROnJBV7B6t7WDsequAozKEqmAbpo3FwKqnyOjsJ90EMr-8uvN-G97Q0sRaEfAvLjtH6CjbsDrI3nhqju5IFgkEHGAVSBDy62L_SdtvejPTzEU4Owl6cJJM50AoxcUG2gLiVM31URgChyM89N3JBORcF3BoICA9mhN2A3G9gdvdrij2UJYgejLaSCMsKLTivNj0SEOf7WEN7ZwnHV1dfqd2dTsQ5QCdk9bI10PkcxexXqcmH3W51Jt_le2kbH8os9Y3UaTcNLYpDx-Xab6GTHXpZ128MhpWqDVK2np0yrgXXqQpaLa4APDLBkIF8bd2sYql0Sn_DeE7sYr6AdNzvgljR-MUq7SwAdMHeUtgHR4CAAA=">demo</a>):</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;button onclick={() =&gt; a++}&gt;a++&lt;/button&gt;
&lt;button onclick={() =&gt; b++}&gt;b++&lt;/button&gt;

&lt;p&gt;{a} + {b} = {await add(a, b)}&lt;/p&gt;

{#if $effect.pending()}
	&lt;p&gt;pending promises: {$effect.pending()}&lt;/p&gt;
{/if}</pre>
</div>
<h2 id="$effect.root">
<span>$effect.root</span>
</h2>
<p>The <code>$effect.root</code> rune is an advanced feature that creates a non-tracked scope that doesn’t auto-cleanup. This is useful for nested effects that you want to manually control. This rune also allows for the creation of effects outside of the component initialisation phase.</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">const destroy = $effect.root(() =&gt; {
	$effect(() =&gt; {
		// setup
	});

	return () =&gt; {
		// cleanup
	};
});

// later...
destroy();</pre>
</div>
<h2 id="When-not-to-use-$effect">
<span>When not to use $effect</span>
</h2>
<p>In general, <code>$effect</code> is best considered something of an escape hatch — useful for things like analytics and direct DOM manipulation — rather than a tool you should use frequently. In particular, avoid using it to synchronise state. Instead of this...</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	let count = $state(0);
	let doubled = $state();

	// don't do this!
	$effect(() =&gt; {
		doubled = count * 2;
	});
&lt;/script&gt;</pre>
</div>
<p>...do this:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	let count = $state(0);
	let doubled = $derived(count * 2);
&lt;/script&gt;</pre>
</div>
<blockquote class="note">
<p> For things that are more complicated than a simple expression like <code>count * 2</code>, you can also use <code>$derived.by</code>.</p> </blockquote>
<p>If you’re using an effect because you want to be able to reassign the derived value (to build an optimistic UI, for example) note that <a href="$derived#Overriding-derived-values">deriveds can be directly overridden</a> as of Svelte 5.25.</p> <p>You might be tempted to do something convoluted with effects to link one value to another. The following example shows two inputs for “money spent” and “money left” that are connected to each other. If you update one, the other should update accordingly. Don’t use effects for this (<a href="https://svelte.dev/playground/untitled#H4sIAAAAAAAAE5WRTWrDMBCFryKGLBJoY3fRjWIHeoiu6i6UZBwEY0VE49TB-O6VxrFTSih0qe_Ne_OjHpxpEDS8O7ZMeIAnqC1hAP3RA1990hKI_Fb55v06XJA4sZ0J-IjvT47RcYyBIuzP1vO2chVHHFjxiQ2pUr3k-SZRQlbBx_LIFoEN4zJfzQph_UMQr4hRXmBd456Xy5Uqt6pPKHmkfmzyPAZL2PCnbRpg8qWYu63I7lu4gswOSRYqrPNt3CgeqqzgbNwRK1A76w76YqjFspfcQTWmK3vJHlQm1puSTVSeqdOc_r9GaeCHfUSY26TXry6Br4RSK3C6yMEGT-aqVU3YbUZ2NF6rfP2KzXgbuYzY46czdgyazy0On_FlLH3F-UDXhgIO35UGlA1rAgAA">demo</a>):</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	const total = 100;
	let spent = $state(0);
	let left = $state(total);

	$effect(() =&gt; {
		left = total - spent;
	});

	$effect(() =&gt; {
		spent = total - left;
	});
&lt;/script&gt;

&lt;label&gt;
	&lt;input type="range" bind:value={spent} max={total} /&gt;
	{spent}/{total} spent
&lt;/label&gt;

&lt;label&gt;
	&lt;input type="range" bind:value={left} max={total} /&gt;
	{left}/{total} left
&lt;/label&gt;</pre>
</div>
<p>Instead, use <code>oninput</code> callbacks or — better still — <a href="bind#Function-bindings">function bindings</a> where possible (<a href="https://svelte.dev/playground/untitled#H4sIAAAAAAAAE5VRvW7CMBB-FcvqECQK6dDFJEgsnfoGTQdDLsjSxVjxhYKivHvPBwFUsXS8774_nwftbQva6I_e78gdvNo6Xzu_j3quG4cQtfkaNJ1DIiWA8atkE8IiHgEpYVsb4Rm-O3gCT2yji7jrXKB15StiOJKiA1lUpXrL81VCEUjFwHTGXiJZgiyf3TYIjSxq6NwR6uyifr0ohMbEZnpHH2rWf7ImS8KZGtK6osl_UqelRIyVL5b3ir5AuwWUtoXzoee6fIWy0p31e6i0XMocLfZQDuI6qtaeykGcR7UU6XWznFAZU9LN_X9B2UyVayk9f3ji0-REugen6U9upDOCcAWcLlS7GNCejWoQTqsLtrfBqHzxDu3DrUTOf0xwIm2o62H85sk6_OHG2jQWI4y_3byXXGMCAAA=">demo</a>):</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	const total = 100;
	let spent = $state(0);
	let left = $derived(total - spent);

	function updateLeft(left) {
		spent = total - left;
	}
&lt;/script&gt;

&lt;label&gt;
	&lt;input type="range" bind:value={spent} max={total} /&gt;
	{spent}/{total} spent
&lt;/label&gt;

&lt;label&gt;
	&lt;input type="range" bind:value={() =&gt; left, updateLeft} max={total} /&gt;
	{left}/{total} left
&lt;/label&gt;</pre>
</div>
<p>If you absolutely have to update <code>$state</code> within an effect and run into an infinite loop because you read and write to the same <code>$state</code>, use <a href="svelte#untrack">untrack</a>.</p> </div></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016–2025 Rich Harris and contributors<br>Licensed under the MIT License.<br>
    <a href="https://svelte.dev/docs/svelte/$effect" class="_attribution-link">https://svelte.dev/docs/svelte/$effect</a>
  </p>
</div>
