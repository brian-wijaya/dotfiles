<header> <h1>await</h1></header> <aside class="on-this-page svelte-wtnkd6"><label class="svelte-wtnkd6"> <h3 class="svelte-wtnkd6">On this page</h3></label> <nav class="svelte-wtnkd6"><ul class="svelte-wtnkd6">
<li class="svelte-wtnkd6"><a href="await-expressions" class="svelte-wtnkd6 active">await</a></li> <li class="svelte-wtnkd6"><a href="#Boundaries" class="svelte-wtnkd6">Boundaries</a></li>
<li class="svelte-wtnkd6"><a href="#Synchronized-updates" class="svelte-wtnkd6">Synchronized updates</a></li>
<li class="svelte-wtnkd6"><a href="#Concurrency" class="svelte-wtnkd6">Concurrency</a></li>
<li class="svelte-wtnkd6"><a href="#Indicating-loading-states" class="svelte-wtnkd6">Indicating loading states</a></li>
<li class="svelte-wtnkd6"><a href="#Error-handling" class="svelte-wtnkd6">Error handling</a></li>
<li class="svelte-wtnkd6"><a href="#Caveats" class="svelte-wtnkd6">Caveats</a></li>
<li class="svelte-wtnkd6"><a href="#Breaking-changes" class="svelte-wtnkd6">Breaking changes</a></li>
</ul></nav></aside> <div class="text content"><div class="text svelte-zb31s9">
<p>As of Svelte 5.36, you can use the <code>await</code> keyword inside your components in three places where it was previously unavailable:</p> <ul> <li>at the top level of your component’s <code>&lt;script&gt;</code>
</li> <li>inside <code>$derived(...)</code> declarations</li> <li>inside your markup</li> </ul> <p>This feature is currently experimental, and you must opt in by adding the <code>experimental.async</code> option wherever you <a href="https://svelte.dev/docs/kit/configuration">configure</a> Svelte, usually <code>svelte.config.js</code>:</p> <div class="code-block">
<div class="controls">
<span class="filename" data-ext=".js">svelte.config</span>
</div>
<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">export default {
	compilerOptions: {
		experimental: {
			async: true
		}
	}
};</pre>
</div>
<p>The experimental flag will be removed in Svelte 6.</p> <h2 id="Boundaries">
<span>Boundaries</span>
</h2>
<p>Currently, you can only use <code>await</code> inside a <a href="svelte-boundary"><code>&lt;svelte:boundary&gt;</code></a> with a <code>pending</code> snippet:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;svelte:boundary&gt;
	&lt;MyApp /&gt;

	{#snippet pending()}
		&lt;p&gt;loading...&lt;/p&gt;
	{/snippet}
&lt;/svelte:boundary&gt;</pre>
</div>
<p>This restriction will be lifted once Svelte supports asynchronous server-side rendering (see <a href="#Caveats">caveats</a>).</p> <blockquote class="note">
<p> In the <a href="https://svelte.dev/playground">playground</a>, your app is rendered inside a boundary with an empty pending snippet, so that you can use <code>await</code> without having to create one.</p> </blockquote>
<h2 id="Synchronized-updates">
<span>Synchronized updates</span>
</h2>
<p>When an <code>await</code> expression depends on a particular piece of state, changes to that state will not be reflected in the UI until the asynchronous work has completed, so that the UI is not left in an inconsistent state. In other words, in an example like <a href="https://svelte.dev/playground/untitled#H4sIAAAAAAAAE42QsWrDQBBEf2VZUkhYRE4gjSwJ0qVMkS6XYk9awcFpJe5Wdoy4fw-ycdykSPt2dpiZFYVGxgrf2PsJTlPwPWTcO-U-xwIH5zli9bminudNtwEsbl-v8_wYj-x1Y5Yi_8W7SZRFI1ZYxy64WVsjRj0rEDTwEJWUs6f8cKP2Tp8vVIxSPEsHwyKdukmA-j6jAmwO63Y1SidyCsIneA_T6CJn2ZBD00Jk_XAjT4tmQwEv-32eH6AsgYK6wXWOPPTs6Xy1CaxLECDYgb3kSUbq8p5aaifzorCt0RiUZbQcDIJ10ldH8gs3K6X2Xzqbro5zu1KCHaw2QQPrtclvwVSXc2sEC1T-Vqw0LJy-ClRy_uSkx2ogHzn9ADZ1CubKAQAA">this</a>...</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	let a = $state(1);
	let b = $state(2);

	async function add(a, b) {
		await new Promise((f) =&gt; setTimeout(f, 500)); // artificial delay
		return a + b;
	}
&lt;/script&gt;

&lt;input type="number" bind:value={a}&gt;
&lt;input type="number" bind:value={b}&gt;

&lt;p&gt;{a} + {b} = {await add(a, b)}&lt;/p&gt;</pre>
</div>
<p>...if you increment <code>a</code>, the contents of the <code>&lt;p&gt;</code> will <em>not</em> immediately update to read this —</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;p&gt;2 + 2 = 3&lt;/p&gt;</pre>
</div>
<p>— instead, the text will update to <code>2 + 2 = 4</code> when <code>add(a, b)</code> resolves.</p> <p>Updates can overlap — a fast update will be reflected in the UI while an earlier slow update is still ongoing.</p> <h2 id="Concurrency">
<span>Concurrency</span>
</h2>
<p>Svelte will do as much asynchronous work as it can in parallel. For example if you have two <code>await</code> expressions in your markup...</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;p&gt;{await one()}&lt;/p&gt;
&lt;p&gt;{await two()}&lt;/p&gt;</pre>
</div>
<p>...both functions will run at the same time, as they are independent expressions, even though they are <em>visually</em> sequential.</p> <p>This does not apply to sequential <code>await</code> expressions inside your <code>&lt;script&gt;</code> or inside async functions — these run like any other asynchronous JavaScript. An exception is that independent <code>$derived</code> expressions will update independently, even though they will run sequentially when they are first created:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">// these will run sequentially the first time,
// but will update independently
let a = $derived(await one());
let b = $derived(await two());</pre>
</div>
<blockquote class="note">
<p> If you write code like this, expect Svelte to give you an <a href="runtime-warnings#Client-warnings-await_waterfall"><code>await_waterfall</code></a> warning</p> </blockquote>
<h2 id="Indicating-loading-states">
<span>Indicating loading states</span>
</h2>
<p>In addition to the nearest boundary’s <a href="svelte-boundary#Properties-pending"><code>pending</code></a> snippet, you can indicate that asynchronous work is ongoing with <a href="$effect#$effect.pending"><code>$effect.pending()</code></a>.</p> <p>You can also use <a href="svelte#settled"><code>settled()</code></a> to get a promise that resolves when the current update is complete:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">import { tick, settled } from 'svelte';

async function onclick() {
	updating = true;

	// without this, the change to `updating` will be
	// grouped with the other changes, meaning it
	// won't be reflected in the UI
	await tick();

	color = 'octarine';
	answer = 42;

	await settled();

	// any updates affected by `color` or `answer`
	// have now been applied
	updating = false;
}</pre>
</div>
<h2 id="Error-handling">
<span>Error handling</span>
</h2>
<p>Errors in <code>await</code> expressions will bubble to the nearest <a href="svelte-boundary">error boundary</a>.</p> <h2 id="Caveats">
<span>Caveats</span>
</h2>
<p>As an experimental feature, the details of how <code>await</code> is handled (and related APIs like <code>$effect.pending()</code>) are subject to breaking changes outside of a semver major release, though we intend to keep such changes to a bare minimum.</p> <p>Currently, server-side rendering is synchronous. If a <code>&lt;svelte:boundary&gt;</code> with a <code>pending</code> snippet is encountered during SSR, only the <code>pending</code> snippet will be rendered.</p> <h2 id="Breaking-changes">
<span>Breaking changes</span>
</h2>
<p>Effects run in a slightly different order when the <code>experimental.async</code> option is <code>true</code>. Specifically, <em>block</em> effects like <code>{#if ...}</code> and <code>{#each ...}</code> now run before an <code>$effect.pre</code> or <code>beforeUpdate</code> in the same component, which means that in <a href="https://svelte.dev/playground/untitled?#H4sIAAAAAAAAE22R3VLDIBCFX2WLvUhnTHsf0zre-Q7WmfwtFV2BgU1rJ5N3F0jaOuoVcPbw7VkYhK4_URTiGYkMnIyjDjLsFGO3EvdCKkIvipdB8NlGXxSCPt96snbtj0gctab2-J_eGs2oOWBE6VunLO_2es-EDKZ5x5ZhC0vPNWM2gHXGouNzAex6hHH1cPHil_Lsb95YT9VQX6KUAbS2DrNsBdsdDFHe8_XSYjH1SrhELTe3MLpsemajweiWVPuxHSbKNd-8eQTdE0EBf4OOaSg2hwNhhE_ABB_ulJzjj9FULvIcqgm5vnAqUB7wWFMfhuugQWkcAr8hVD-mq8D12kOep24J_IszToOXdveGDsuNnZwbJUNlXsKnhJdhUcTo42s41YpOSneikDV5HL8BktM6yRcCAAA=">very rare situations</a> it is possible to update a block that should no longer exist, but only if you update state inside an effect, <a href="$effect#When-not-to-use-$effect">which you should avoid</a>.</p> </div></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016–2025 Rich Harris and contributors<br>Licensed under the MIT License.<br>
    <a href="https://svelte.dev/docs/svelte/await-expressions" class="_attribution-link">https://svelte.dev/docs/svelte/await-expressions</a>
  </p>
</div>
