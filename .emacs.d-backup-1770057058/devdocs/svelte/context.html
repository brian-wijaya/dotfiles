<header> <h1>Context</h1></header> <aside class="on-this-page svelte-wtnkd6"><label class="svelte-wtnkd6"> <h3 class="svelte-wtnkd6">On this page</h3></label> <nav class="svelte-wtnkd6"><ul class="svelte-wtnkd6">
<li class="svelte-wtnkd6"><a href="context" class="svelte-wtnkd6 active">Context</a></li> <li class="svelte-wtnkd6"><a href="#Using-context-with-state" class="svelte-wtnkd6">Using context with state</a></li>
<li class="svelte-wtnkd6"><a href="#Type-safe-context" class="svelte-wtnkd6">Type-safe context</a></li>
<li class="svelte-wtnkd6"><a href="#Replacing-global-state" class="svelte-wtnkd6">Replacing global state</a></li>
</ul></nav></aside> <div class="text content"><div class="text svelte-zb31s9">
<p>Context allows components to access values owned by parent components without passing them down as props (potentially through many layers of intermediate components, known as ‘prop-drilling’). The parent component sets context with <code>setContext(key, value)</code>...</p> <div class="code-block">
<div class="controls">
<span class="filename" data-ext=".svelte">Parent</span><input class="ts-toggle raised" checked title="Toggle language" type="checkbox" aria-label="Toggle JS/TS">
</div>
<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	import { setContext } from 'svelte';

	setContext('my-context', 'hello from Parent.svelte');
&lt;/script&gt;</pre>
<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script lang="ts"&gt;
	import { setContext } from 'svelte';

	setContext('my-context', 'hello from Parent.svelte');
&lt;/script&gt;</pre>
</div>
<p>...and the child retrieves it with <code>getContext</code>:</p> <div class="code-block">
<div class="controls">
<span class="filename" data-ext=".svelte">Child</span><input class="ts-toggle raised" checked title="Toggle language" type="checkbox" aria-label="Toggle JS/TS">
</div>
<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	import { getContext } from 'svelte';

	const message = getContext('my-context');
&lt;/script&gt;

&lt;h1&gt;{message}, inside Child.svelte&lt;/h1&gt;</pre>
<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script lang="ts"&gt;
	import { getContext } from 'svelte';

	const message = getContext('my-context');
&lt;/script&gt;

&lt;h1&gt;{message}, inside Child.svelte&lt;/h1&gt;</pre>
</div>
<p>This is particularly useful when <code>Parent.svelte</code> is not directly aware of <code>Child.svelte</code>, but instead renders it as part of a <code>children</code> <a href="snippet">snippet</a> (<a href="https://svelte.dev/playground/untitled#H4sIAAAAAAAAE42Q3W6DMAyFX8WyJgESK-oto6hTX2D3YxcM3IIUQpR40yqUd58CrCXsp7tL7HNsf2dAWXaEKR56yfTBGOOxFWQwfR6Qz8q1XAHjL-GjUhvzToJd7bU09FO9ctMkG0wxM5VuFeeFLLjtVK8ZnkpNkuGo-w6CTTJ9Z3PwsBAemlbUF934W8iy5DpaZtOUcU02-ZLcaS51jHEkTFm_kY1_wfOO8QnXrb8hBzDEc6pgZ4gFoyz4KgiD7nxfTe8ghqAhIfrJ46cTzVZBbkPlODVJsLCDO6V7ZcJoncyw1yRr0hd1GNn_ZbEM3I9i1bmVxOlWElUvDUNHxpQngt3C4CXzjS1rtvkw22wMrTRtTbC8Lkuabe7jvthPPe3DofYCAAA=">demo</a>):</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;Parent&gt;
	&lt;Child /&gt;
&lt;/Parent&gt;</pre>
</div>
<p>The key (<code>'my-context'</code>, in the example above) and the context itself can be any JavaScript value.</p> <p>In addition to <a href="svelte#setContext"><code>setContext</code></a> and <a href="svelte#getContext"><code>getContext</code></a>, Svelte exposes <a href="svelte#hasContext"><code>hasContext</code></a> and <a href="svelte#getAllContexts"><code>getAllContexts</code></a> functions.</p> <h2 id="Using-context-with-state">
<span>Using context with state</span>
</h2>
<p>You can store reactive state in context (<a href="https://svelte.dev/playground/untitled#H4sIAAAAAAAAE41R0W6DMAz8FSuaBNUQdK8MkKZ-wh7HHihzu6hgosRMm1D-fUpSVNq12x4iEvvOx_kmQU2PIhfP3DCCJGgHYvxkkYid7NCI_GUS_KUcxhVEMjOelErNB3bsatvG4LW6n0ZsRC4K02qpuKqpZtmrQTNMYJA3QRAs7PTQQxS40eMCt3mX3duxnWb-lS5h7nTI0A4jMWoo4c44P_Hku-zrOazdy64chWo-ScfRkRgl8wgHKrLTH1OxHZkHgoHaTraHcopXUFYzPPVfuC_hwQaD1GrskdiNCdQwJljJqlvXfyqVsA5CGg0uRUQifHw56xFtciO75QrP07vo_JXf_tf8yK2ezDKY_ZWt_1y2qqYzv7bI1IW1V_sN19m-07wCAAA=">demo</a>)...</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	import { setContext } from 'svelte';
	import Child from './Child.svelte';

	let counter = $state({
		count: 0
	});

	setContext('counter', counter);
&lt;/script&gt;

&lt;button onclick={() =&gt; counter.count += 1}&gt;
	increment
&lt;/button&gt;

&lt;Child /&gt;
&lt;Child /&gt;
&lt;Child /&gt;</pre>
</div>
<p>...though note that if you <em>reassign</em> <code>counter</code> instead of updating it, you will ‘break the link’ — in other words instead of this...</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;button onclick={() =&gt; counter = { count: 0 }}&gt;
	reset
&lt;/button&gt;</pre>
</div>
<p>...you must do this:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;button onclick={() =&gt; counter.count = 0}&gt;
	reset
&lt;/button&gt;</pre>
</div>
<p>Svelte will warn you if you get it wrong.</p> <h2 id="Type-safe-context">
<span>Type-safe context</span>
</h2>
<p>A useful pattern is to wrap the calls to <code>setContext</code> and <code>getContext</code> inside helper functions that let you preserve type safety:</p> <div class="code-block">
<div class="controls">
<span class="filename" data-ext=".js">context</span><input class="ts-toggle raised" checked title="Toggle language" type="checkbox" aria-label="Toggle JS/TS">
</div>
<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">import { getContext, setContext } from 'svelte';

const key = {};

/** @param {User} user */
export function setUserContext(user) {
	setContext(key, user);
}

export function getUserContext() {
	return /** @type {User} */ (getContext(key));
}</pre>
<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">import { getContext, setContext } from 'svelte';

const key = {};

export function setUserContext(user: User) {
	setContext(key, user);
}

export function getUserContext() {
	return getContext(key) as User;
}</pre>
</div>
<h2 id="Replacing-global-state">
<span>Replacing global state</span>
</h2>
<p>When you have state shared by many different components, you might be tempted to put it in its own module and just import it wherever it’s needed:</p> <div class="code-block">
<div class="controls">
<span class="filename" data-ext=".js">state.svelte</span>
</div>
<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">export const myGlobalState = $state({
	user: {
		// ...
	}
	// ...
});</pre>
</div>
<p>In many cases this is perfectly fine, but there is a risk: if you mutate the state during server-side rendering (which is discouraged, but entirely possible!)...</p> <div class="code-block">
<div class="controls">
<span class="filename" data-ext=".svelte -">App</span><input class="ts-toggle raised" checked title="Toggle language" type="checkbox" aria-label="Toggle JS/TS">
</div>
<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	import { myGlobalState } from './state.svelte.js';

	let { data } = $props();

	if (data.user) {
		myGlobalState.user = data.user;
	}
&lt;/script&gt;</pre>
<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script lang="ts"&gt;
	import { myGlobalState } from './state.svelte.js';

	let { data } = $props();

	if (data.user) {
		myGlobalState.user = data.user;
	}
&lt;/script&gt;</pre>
</div>
<p>...then the data may be accessible by the <em>next</em> user. Context solves this problem because it is not shared between requests.</p> </div></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016–2025 Rich Harris and contributors<br>Licensed under the MIT License.<br>
    <a href="https://svelte.dev/docs/svelte/context" class="_attribution-link">https://svelte.dev/docs/svelte/context</a>
  </p>
</div>
