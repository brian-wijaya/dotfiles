<header> <h1>Runtime errors</h1></header> <aside class="on-this-page svelte-wtnkd6"><label class="svelte-wtnkd6"> <h3 class="svelte-wtnkd6">On this page</h3></label> <nav class="svelte-wtnkd6"><ul class="svelte-wtnkd6">
<li class="svelte-wtnkd6"><a href="runtime-errors" class="svelte-wtnkd6 active">Runtime errors</a></li> <li class="svelte-wtnkd6"><a href="#Client-errors" class="svelte-wtnkd6">Client errors</a></li>
<li class="svelte-wtnkd6"><a href="#Server-errors" class="svelte-wtnkd6">Server errors</a></li>
<li class="svelte-wtnkd6"><a href="#Shared-errors" class="svelte-wtnkd6">Shared errors</a></li>
</ul></nav></aside> <div class="text content"><div class="text svelte-zb31s9">
<h2 id="Client-errors">
<span>Client errors</span>
</h2> <h3 id="Client-errors-async_derived_orphan">
<span>async_derived_orphan</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Cannot create a `$derived(...)` with an `await` expression outside of an effect tree</pre></div>
<p>In Svelte there are two types of reaction — <a href="$derived"><code>$derived</code></a> and <a href="$effect"><code>$effect</code></a>. Deriveds can be created anywhere, because they run <em>lazily</em> and can be <a href="https://developer.mozilla.org/en-US/docs/Glossary/Garbage_collection">garbage collected</a> if nothing references them. Effects, by contrast, keep running eagerly whenever their dependencies change, until they are destroyed.</p> <p>Because of this, effects can only be created inside other effects (or <a href="$effect#$effect.root">effect roots</a>, such as the one that is created when you first mount a component) so that Svelte knows when to destroy them.</p> <p>Some sleight of hand occurs when a derived contains an <code>await</code> expression: Since waiting until we read <code>{await getPromise()}</code> to call <code>getPromise</code> would be too late, we use an effect to instead call it proactively, notifying Svelte when the value is available. But since we’re using an effect, we can only create asynchronous deriveds inside another effect.</p> <h3 id="Client-errors-bind_invalid_checkbox_value">
<span>bind_invalid_checkbox_value</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Using `bind:value` together with a checkbox input is not allowed. Use `bind:checked` instead</pre></div>
<h3 id="Client-errors-bind_invalid_export">
<span>bind_invalid_export</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Component %component% has an export named `%key%` that a consumer component is trying to access using `bind:%key%`, which is disallowed. Instead, use `bind:this` (e.g. `&lt;%name% bind:this={component} /&gt;`) and then access the property on the bound component instance (e.g. `component.%key%`)</pre></div>
<h3 id="Client-errors-bind_not_bindable">
<span>bind_not_bindable</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">A component is attempting to bind to a non-bindable property `%key%` belonging to %component% (i.e. `&lt;%name% bind:%key%={...}&gt;`). To mark a property as bindable: `let { %key% = $bindable() } = $props()`</pre></div>
<h3 id="Client-errors-component_api_changed">
<span>component_api_changed</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Calling `%method%` on a component instance (of %component%) is no longer valid in Svelte 5</pre></div>
<p>See the <a href="v5-migration-guide#Components-are-no-longer-classes">migration guide</a> for more information.</p> <h3 id="Client-errors-component_api_invalid_new">
<span>component_api_invalid_new</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Attempted to instantiate %component% with `new %name%`, which is no longer valid in Svelte 5. If this component is not under your control, set the `compatibility.componentApi` compiler option to `4` to keep it working.</pre></div>
<p>See the <a href="v5-migration-guide#Components-are-no-longer-classes">migration guide</a> for more information.</p> <h3 id="Client-errors-derived_references_self">
<span>derived_references_self</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">A derived value cannot reference itself recursively</pre></div>
<h3 id="Client-errors-each_key_duplicate">
<span>each_key_duplicate</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Keyed each block has duplicate key at indexes %a% and %b%</pre></div>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Keyed each block has duplicate key `%value%` at indexes %a% and %b%</pre></div>
<h3 id="Client-errors-effect_in_teardown">
<span>effect_in_teardown</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">`%rune%` cannot be used inside an effect cleanup function</pre></div>
<h3 id="Client-errors-effect_in_unowned_derived">
<span>effect_in_unowned_derived</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Effect cannot be created inside a `$derived` value that was not itself created inside an effect</pre></div>
<h3 id="Client-errors-effect_orphan">
<span>effect_orphan</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">`%rune%` can only be used inside an effect (e.g. during component initialisation)</pre></div>
<h3 id="Client-errors-effect_pending_outside_reaction">
<span>effect_pending_outside_reaction</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">`$effect.pending()` can only be called inside an effect or derived</pre></div>
<h3 id="Client-errors-effect_update_depth_exceeded">
<span>effect_update_depth_exceeded</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Maximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state</pre></div>
<p>If an effect updates some state that it also depends on, it will re-run, potentially in a loop:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">let count = $state(0);

$effect(() =&gt; {
	// this both reads and writes `count`,
	// so will run in an infinite loop
	count += 1;
});</pre>
</div>
<p>(Svelte intervenes before this can crash your browser tab.)</p> <p>The same applies to array mutations, since these both read and write to the array:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">let array = $state(['hello']);

$effect(() =&gt; {
	array.push('goodbye');
});</pre>
</div>
<p>Note that it’s fine for an effect to re-run itself as long as it ‘settles’:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">$effect(() =&gt; {
	// this is okay, because sorting an already-sorted array
	// won't result in a mutation
	array.sort();
});</pre>
</div>
<p>Often when encountering this issue, the value in question shouldn’t be state (for example, if you are pushing to a <code>logs</code> array in an effect, make <code>logs</code> a normal array rather than <code>$state([])</code>). In the rare cases where you really <em>do</em> need to write to state in an effect — <a href="$effect#When-not-to-use-$effect">which you should avoid</a> — you can read the state with <a href="svelte#untrack">untrack</a> to avoid adding it as a dependency.</p> <h3 id="Client-errors-flush_sync_in_effect">
<span>flush_sync_in_effect</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Cannot use `flushSync` inside an effect</pre></div>
<p>The <code>flushSync()</code> function can be used to flush any pending effects synchronously. It cannot be used if effects are currently being flushed — in other words, you can call it after a state change but <em>not</em> inside an effect.</p> <p>This restriction only applies when using the <code>experimental.async</code> option, which will be active by default in Svelte 6.</p> <h3 id="Client-errors-get_abort_signal_outside_reaction">
<span>get_abort_signal_outside_reaction</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">`getAbortSignal()` can only be called inside an effect or derived</pre></div>
<h3 id="Client-errors-hydration_failed">
<span>hydration_failed</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Failed to hydrate the application</pre></div>
<h3 id="Client-errors-invalid_snippet">
<span>invalid_snippet</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Could not `{@render}` snippet due to the expression being `null` or `undefined`. Consider using optional chaining `{@render snippet?.()}`</pre></div>
<h3 id="Client-errors-lifecycle_legacy_only">
<span>lifecycle_legacy_only</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">`%name%(...)` cannot be used in runes mode</pre></div>
<h3 id="Client-errors-props_invalid_value">
<span>props_invalid_value</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value</pre></div>
<h3 id="Client-errors-props_rest_readonly">
<span>props_rest_readonly</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Rest element properties of `$props()` such as `%property%` are readonly</pre></div>
<h3 id="Client-errors-rune_outside_svelte">
<span>rune_outside_svelte</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">The `%rune%` rune is only available inside `.svelte` and `.svelte.js/ts` files</pre></div>
<h3 id="Client-errors-set_context_after_init">
<span>set_context_after_init</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">`setContext` must be called when a component first initializes, not in a subsequent effect or after an `await` expression</pre></div>
<p>This restriction only applies when using the <code>experimental.async</code> option, which will be active by default in Svelte 6.</p> <h3 id="Client-errors-state_descriptors_fixed">
<span>state_descriptors_fixed</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.</pre></div>
<h3 id="Client-errors-state_prototype_fixed">
<span>state_prototype_fixed</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Cannot set prototype of `$state` object</pre></div>
<h3 id="Client-errors-state_unsafe_mutation">
<span>state_unsafe_mutation</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Updating state inside `$derived(...)`, `$inspect(...)` or a template expression is forbidden. If the value should not be reactive, declare it without `$state`</pre></div>
<p>This error occurs when state is updated while evaluating a <code>$derived</code>. You might encounter it while trying to ‘derive’ two pieces of state in one go:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	let count = $state(0);

	let even = $state(true);

	let odd = $derived.by(() =&gt; {
		even = count % 2 === 0;
		return !even;
	});
&lt;/script&gt;

&lt;button onclick={() =&gt; count++}&gt;{count}&lt;/button&gt;

&lt;p&gt;{count} is even: {even}&lt;/p&gt;
&lt;p&gt;{count} is odd: {odd}&lt;/p&gt;</pre>
</div>
<p>This is forbidden because it introduces instability: if <code>&lt;p&gt;{count} is even: {even}&lt;/p&gt;</code> is updated before <code>odd</code> is recalculated, <code>even</code> will be stale. In most cases the solution is to make everything derived:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">let even = $derived(count % 2 === 0);
let odd = $derived(!even);</pre>
</div>
<p>If side-effects are unavoidable, use <a href="$effect"><code>$effect</code></a> instead.</p> <h3 id="Client-errors-svelte_boundary_reset_onerror">
<span>svelte_boundary_reset_onerror</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">A `&lt;svelte:boundary&gt;` `reset` function cannot be called while an error is still being handled</pre></div>
<p>If a <a href="svelte-boundary"><code>&lt;svelte:boundary&gt;</code></a> has an <code>onerror</code> function, it must not call the provided <code>reset</code> function synchronously since the boundary is still in a broken state. Typically, <code>reset()</code> is called later, once the error has been resolved.</p> <p>If it’s possible to resolve the error inside the <code>onerror</code> callback, you must at least wait for the boundary to settle before calling <code>reset()</code>, for example using <a href="lifecycle-hooks#tick"><code>tick</code></a>:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;svelte:boundary onerror={async (error, reset) =&gt; {
	fixTheError();
	await tick();
	reset();
}}&gt;

&lt;/svelte:boundary&gt;</pre>
</div>
<h2 id="Server-errors">
<span>Server errors</span>
</h2> <h3 id="Server-errors-lifecycle_function_unavailable">
<span>lifecycle_function_unavailable</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">`%name%(...)` is not available on the server</pre></div>
<p>Certain methods such as <code>mount</code> cannot be invoked while running in a server context. Avoid calling them eagerly, i.e. not during render.</p> <h2 id="Shared-errors">
<span>Shared errors</span>
</h2> <h3 id="Shared-errors-await_outside_boundary">
<span>await_outside_boundary</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Cannot await outside a `&lt;svelte:boundary&gt;` with a `pending` snippet</pre></div>
<p>The <code>await</code> keyword can only appear in a <code>$derived(...)</code> or template expression, or at the top level of a component’s <code>&lt;script&gt;</code> block, if it is inside a <a href="svelte-boundary"><code>&lt;svelte:boundary&gt;</code></a> that has a <code>pending</code> snippet:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;svelte:boundary&gt;
	&lt;p&gt;{await getData()}&lt;/p&gt;

	{#snippet pending()}
		&lt;p&gt;loading...&lt;/p&gt;
	{/snippet}
&lt;/svelte:boundary&gt;</pre>
</div>
<p>This restriction may be lifted in a future version of Svelte.</p> <h3 id="Shared-errors-invalid_default_snippet">
<span>invalid_default_snippet</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Cannot use `{@render children(...)}` if the parent component uses `let:` directives. Consider using a named snippet instead</pre></div>
<p>This error would be thrown in a setup like this:</p> <div class="code-block">
<div class="controls">
<span class="filename" data-ext=".svelte">Parent</span>
</div>
<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;List {items} let:entry&gt;
	&lt;span&gt;{entry}&lt;/span&gt;
&lt;/List&gt;</pre>
</div>
<div class="code-block">
<div class="controls">
<span class="filename" data-ext=".svelte">List</span><input class="ts-toggle raised" checked title="Toggle language" type="checkbox" aria-label="Toggle JS/TS">
</div>
<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	let { items, children } = $props();
&lt;/script&gt;

&lt;ul&gt;
	{#each items as item}
		&lt;li&gt;{@render children(item)}&lt;/li&gt;
	{/each}
&lt;/ul&gt;</pre>
<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script lang="ts"&gt;
	let { items, children } = $props();
&lt;/script&gt;

&lt;ul&gt;
	{#each items as item}
		&lt;li&gt;{@render children(item)}&lt;/li&gt;
	{/each}
&lt;/ul&gt;</pre>
</div>
<p>Here, <code>List.svelte</code> is using <code>{@render children(item)</code> which means it expects <code>Parent.svelte</code> to use snippets. Instead, <code>Parent.svelte</code> uses the deprecated <code>let:</code> directive. This combination of APIs is incompatible, hence the error.</p> <h3 id="Shared-errors-invalid_snippet_arguments">
<span>invalid_snippet_arguments</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">A snippet function was passed invalid arguments. Snippets should only be instantiated via `{@render ...}`</pre></div>
<h3 id="Shared-errors-lifecycle_outside_component">
<span>lifecycle_outside_component</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">`%name%(...)` can only be used during component initialisation</pre></div>
<p>Certain lifecycle methods can only be used during component initialisation. To fix this, make sure you’re invoking the method inside the <em>top level of the instance script</em> of your component.</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	import { onMount } from 'svelte';

	function handleClick() {
		// This is wrong
		onMount(() =&gt; {})
	}

	// This is correct
	onMount(() =&gt; {})
&lt;/script&gt;

&lt;button onclick={handleClick}&gt;click me&lt;/button&gt;</pre>
</div>
<h3 id="Shared-errors-snippet_without_render_tag">
<span>snippet_without_render_tag</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Attempted to render a snippet without a `{@render}` block. This would cause the snippet code to be stringified instead of its content being rendered to the DOM. To fix this, change `{snippet}` to `{@render snippet()}`.</pre></div>
<p>A component throwing this error will look something like this (<code>children</code> is not being rendered):</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	let { children } = $props();
&lt;/script&gt;

{children}</pre>
</div>
<p>...or like this (a parent component is passing a snippet where a non-snippet value is expected):</p> <div class="code-block">
<div class="controls">
<span class="filename" data-ext=".svelte">Parent</span>
</div>
<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;ChildComponent&gt;
  {#snippet label()}
	&lt;span&gt;Hi!&lt;/span&gt;
  {/snippet}
&lt;/ChildComponent&gt;</pre>
</div>
<div class="code-block">
<div class="controls">
<span class="filename" data-ext=".svelte">Child</span><input class="ts-toggle raised" checked title="Toggle language" type="checkbox" aria-label="Toggle JS/TS">
</div>
<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
  let { label } = $props();
&lt;/script&gt;

&lt;!-- This component doesn't expect a snippet, but the parent provided one --&gt;
&lt;p&gt;{label}&lt;/p&gt;</pre>
<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script lang="ts"&gt;
  let { label } = $props();
&lt;/script&gt;

&lt;!-- This component doesn't expect a snippet, but the parent provided one --&gt;
&lt;p&gt;{label}&lt;/p&gt;</pre>
</div>
<h3 id="Shared-errors-store_invalid_shape">
<span>store_invalid_shape</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">`%name%` is not a store with a `subscribe` method</pre></div>
<h3 id="Shared-errors-svelte_element_invalid_this_value">
<span>svelte_element_invalid_this_value</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">The `this` prop on `&lt;svelte:element&gt;` must be a string, if defined</pre></div>
</div></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016–2025 Rich Harris and contributors<br>Licensed under the MIT License.<br>
    <a href="https://svelte.dev/docs/svelte/runtime-errors" class="_attribution-link">https://svelte.dev/docs/svelte/runtime-errors</a>
  </p>
</div>
