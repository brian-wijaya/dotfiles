<header> <h1>$state</h1></header> <aside class="on-this-page svelte-wtnkd6"><label class="svelte-wtnkd6"> <h3 class="svelte-wtnkd6">On this page</h3></label> <nav class="svelte-wtnkd6"><ul class="svelte-wtnkd6">
<li class="svelte-wtnkd6"><a href="$state" class="svelte-wtnkd6 active">$state</a></li> <li class="svelte-wtnkd6"><a href="#$state.raw" class="svelte-wtnkd6">$state.raw</a></li>
<li class="svelte-wtnkd6"><a href="#$state.snapshot" class="svelte-wtnkd6">$state.snapshot</a></li>
<li class="svelte-wtnkd6"><a href="#Passing-state-into-functions" class="svelte-wtnkd6">Passing state into functions</a></li>
<li class="svelte-wtnkd6"><a href="#Passing-state-across-modules" class="svelte-wtnkd6">Passing state across modules</a></li>
</ul></nav></aside> <div class="text content"><div class="text svelte-zb31s9">
<p>The <code>$state</code> rune allows you to create <em>reactive state</em>, which means that your UI <em>reacts</em> when it changes.</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	let count = $state(0);
&lt;/script&gt;

&lt;button onclick={() =&gt; count++}&gt;
	clicks: {count}
&lt;/button&gt;</pre>
</div>
<p>Unlike other frameworks you may have encountered, there is no API for interacting with state — <code>count</code> is just a number, rather than an object or a function, and you can update it like you would update any other variable.</p> <h3 id="Deep-state">
<span>Deep state</span>
</h3>
<p>If <code>$state</code> is used with an array or a simple object, the result is a deeply reactive <em>state proxy</em>. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxies</a> allow Svelte to run code when you read or write properties, including via methods like <code>array.push(...)</code>, triggering granular updates.</p> <p>State is proxified recursively until Svelte finds something other than an array or simple object (like a class or an object created with <code>Object.create</code>). In a case like this...</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">let todos = $state([
	{
		done: false,
		text: 'add more todos'
	}
]);</pre>
</div>
<p>...modifying an individual todo’s property will trigger updates to anything in your UI that depends on that specific property:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">todos[0].done = !todos[0].done;</pre>
</div>
<p>If you push a new object to the array, it will also be proxified:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">todos.push({
	done: false,
	text: 'eat lunch'
});</pre>
</div>
<blockquote class="note">
<p> When you update properties of proxies, the original object is <em>not</em> mutated. If you need to use your own proxy handlers in a state proxy, <a href="https://svelte.dev/playground/hello-world?version=latest#H4sIAAAAAAAACpWR3WoDIRCFX2UqhWyIJL3erAulL9C7XnQLMe5ksbUqOpsfln33YuyGFNJC8UKdc2bOhw7Myk9kJXsJ0nttO9jcR5KEG9AWJDwHdzwxznbaYGTl68Do5JM_FRifuh-9X8Y9Gkq1rYx4q66cJbQUWcmqqIL2VDe2IYMEbvuOikBADi-GJDSkXG-phId0G-frye2DO2psQYDFQ0Ys8gQO350dUkEydEg82T0GOs0nsSG9g2IqgxACZueo2ZUlpdvoDC6N64qsg1QKY8T2bpZp8gpIfbCQ85Zn50Ud82HkeY83uDjspenxv3jXcSDyjPWf9L1vJf0GH666J-jLu1ery4dV257IWXBWGa0-xFDMQdTTn2ScxWKsn86ROsLwQxqrVR5QM84Ij8TKFD2-cUZSm4O2LSt30kQcvwCgCmfZnAIAAA==">you should wrap the object <em>after</em> wrapping it in <code>$state</code></a>.</p> </blockquote>
<p>Note that if you destructure a reactive value, the references are not reactive — as in normal JavaScript, they are evaluated at the point of destructuring:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">let { done, text } = todos[0];

// this will not affect the value of `done`
todos[0].done = !todos[0].done;</pre>
</div>
<h3 id="Classes">
<span>Classes</span>
</h3>
<p>Class instances are not proxied. Instead, you can use <code>$state</code> in class fields (whether public or private), or as the first assignment to a property immediately inside the <code>constructor</code>:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">class Todo {
	done = $state(false);

	constructor(text) {
		this.text = $state(text);
	}

	reset() {
		this.text = '';
		this.done = false;
	}
}</pre>
</div>
<blockquote class="note">
<p> The compiler transforms <code>done</code> and <code>text</code> into <code>get</code> / <code>set</code> methods on the class prototype referencing private fields. This means the properties are not enumerable.</p> </blockquote>
<p>When calling methods in JavaScript, the value of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this"><code>this</code></a> matters. This won’t work, because <code>this</code> inside the <code>reset</code> method will be the <code>&lt;button&gt;</code> rather than the <code>Todo</code>:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;button onclick={todo.reset}&gt;
	reset
&lt;/button&gt;</pre>
</div>
<p>You can either use an inline function...</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;button onclick={() =&gt; todo.reset()}&gt;
	reset
&lt;/button&gt;</pre>
</div>
<p>...or use an arrow function in the class definition:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">class Todo {
	done = $state(false);

	constructor(text) {
		this.text = $state(text);
	}

	reset = () =&gt; {
		this.text = '';
		this.done = false;
	}
}</pre>
</div>
<h3 id="Built-in-classes">
<span>Built-in classes</span>
</h3>
<p>Svelte provides reactive implementations of built-in classes like <code>Set</code>, <code>Map</code>, <code>Date</code> and <code>URL</code> that can be imported from <a href="svelte-reactivity"><code>svelte/reactivity</code></a>.</p> <h2 id="$state.raw">
<span>$state.raw</span>
</h2>
<p>In cases where you don’t want objects and arrays to be deeply reactive you can use <code>$state.raw</code>.</p> <p>State declared with <code>$state.raw</code> cannot be mutated; it can only be <em>reassigned</em>. In other words, rather than assigning to a property of an object, or using an array method like <code>push</code>, replace the object or array altogether if you’d like to update it:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">let person = $state.raw({
	name: 'Heraclitus',
	age: 49
});

// this will have no effect
person.age += 1;

// this will work, because we're creating a new person
person = {
	name: 'Heraclitus',
	age: 50
};</pre>
</div>
<p>This can improve performance with large arrays and objects that you weren’t planning to mutate anyway, since it avoids the cost of making them reactive. Note that raw state can <em>contain</em> reactive state (for example, a raw array of reactive objects).</p> <p>As with <code>$state</code>, you can declare class fields using <code>$state.raw</code>.</p> <h2 id="$state.snapshot">
<span>$state.snapshot</span>
</h2>
<p>To take a static snapshot of a deeply reactive <code>$state</code> proxy, use <code>$state.snapshot</code>:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	let counter = $state({ count: 0 });

	function onclick() {
		// Will log `{ count: ... }` rather than `Proxy { ... }`
		console.log($state.snapshot(counter));
	}
&lt;/script&gt;</pre>
</div>
<p>This is handy when you want to pass some state to an external library or API that doesn’t expect a proxy, such as <code>structuredClone</code>.</p> <h2 id="Passing-state-into-functions">
<span>Passing state into functions</span>
</h2>
<p>JavaScript is a <em>pass-by-value</em> language — when you call a function, the arguments are the <em>values</em> rather than the <em>variables</em>. In other words:</p> <div class="code-block">
<div class="controls">
<span class="filename" data-ext=".js">index</span><input class="ts-toggle raised" checked title="Toggle language" type="checkbox" aria-label="Toggle JS/TS">
</div>
<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">/**
 * @param {number} a
 * @param {number} b
 */
function add(a, b) {
	return a + b;
}

let a = 1;
let b = 2;
let total = add(a, b);
console.log(total); // 3

a = 3;
b = 4;
console.log(total); // still 3!</pre>
<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function add(a: number, b: number) {
	return a + b;
}

let a = 1;
let b = 2;
let total = add(a, b);
console.log(total); // 3

a = 3;
b = 4;
console.log(total); // still 3!</pre>
</div>
<p>If <code>add</code> wanted to have access to the <em>current</em> values of <code>a</code> and <code>b</code>, and to return the current <code>total</code> value, you would need to use functions instead:</p> <div class="code-block">
<div class="controls">
<span class="filename" data-ext=".js">index</span><input class="ts-toggle raised" checked title="Toggle language" type="checkbox" aria-label="Toggle JS/TS">
</div>
<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">/**
 * @param {() =&gt; number} getA
 * @param {() =&gt; number} getB
 */
function add(getA, getB) {
	return () =&gt; getA() + getB();
}

let a = 1;
let b = 2;
let total = add(() =&gt; a, () =&gt; b);
console.log(total()); // 3

a = 3;
b = 4;
console.log(total()); // 7</pre>
<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function add(getA: () =&gt; number, getB: () =&gt; number) {
	return () =&gt; getA() + getB();
}

let a = 1;
let b = 2;
let total = add(() =&gt; a, () =&gt; b);
console.log(total()); // 3

a = 3;
b = 4;
console.log(total()); // 7</pre>
</div>
<p>State in Svelte is no different — when you reference something declared with the <code>$state</code> rune...</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">let a = 
namespace $state
namespace $state</pre>
<div class="twoslash-popup-docs">
<p>Declares reactive state.</p> <span class="highlight add"><p>Example:</p></span> <span class="highlight add"><div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">let count = $state(0);</pre>
</div>
<p><a href="$state">https://svelte.dev/docs/svelte/$state</a></p></span> 
</div>
<div class="twoslash-popup-docs twoslash-popup-docs-tags"><div class="tags">
<span class="tag">@param</span><span class="value"><span class="param">initial</span> The initial value</span>
</div></div>$state<span style="color:var(--shiki-foreground)">(</span><span style="color:var(--shiki-token-constant)">1</span><span style="color:var(--shiki-foreground)">)</span>; <span class="line"><span style="color:var(--shiki-token-keyword)">let</span> <span style="color:var(--shiki-foreground)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span style="color:var(--shiki-token-keyword)">let</span> <span style="color:var(--shiki-foreground)">b</span><span style="color:var(--shiki-token-keyword)">:</span> <span style="color:var(--shiki-token-constant)">number</span></code></span>b</span></span> <span style="color:var(--shiki-token-keyword)">=</span> <span class="highlight add"><span style="color:var(--shiki-token-function)"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><pre class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)" tabindex="0" data-language="typescript">function $state&lt;2&gt;(initial: 2): 2 (+1 overload)</pre></code></span> <span class="highlight add"><span class="line"><span style="color:var(--shiki-token-keyword)">namespace</span> <span style="color:var(--shiki-token-function)">$state</span></span><div class="twoslash-popup-docs">
<p>Declares reactive state.</p> <span class="highlight add"><p>Example:</p></span> <span class="highlight add"><div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">let count = $state(0);</pre>
</div>
<p><a href="$state">https://svelte.dev/docs/svelte/$state</a></p></span> 
</div>
<div class="twoslash-popup-docs twoslash-popup-docs-tags"><div class="tags">
<span class="tag">@param</span><span class="value"><span class="param">initial</span> The initial value</span>
</div></div></span>$state</span></span><span style="color:var(--shiki-foreground)">(</span><span style="color:var(--shiki-token-constant)">2</span><span style="color:var(--shiki-foreground)">)</span>;</span></span>
</div>
<p>...you’re accessing its <em>current value</em>.</p> <p>Note that ‘functions’ is broad — it encompasses properties of proxies and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get"><code>get</code></a>/<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set"><code>set</code></a> properties...</p> <div class="code-block">
<div class="controls">
<span class="filename" data-ext=".js">index</span><input class="ts-toggle raised" checked title="Toggle language" type="checkbox" aria-label="Toggle JS/TS">
</div>
<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">/**
 * @param {{ a: number, b: number }} input
 */
function add(input) {
	return {
		get value() {
			return input.a + input.b;
		}
	};
}

let input = $state({ a: 1, b: 2 });
let total = add(input);
console.log(total.value); // 3

input.a = 3;
input.b = 4;
console.log(total.value); // 7</pre>
<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function add(input: { a: number, b: number }) {
	return {
		get value() {
			return input.a + input.b;
		}
	};
}

let input = $state({ a: 1, b: 2 });
let total = add(input);
console.log(total.value); // 3

input.a = 3;
input.b = 4;
console.log(total.value); // 7</pre>
</div>
<p>...though if you find yourself writing code like that, consider using <a href="#Classes">classes</a> instead.</p> <h2 id="Passing-state-across-modules">
<span>Passing state across modules</span>
</h2>
<p>You can declare state in <code>.svelte.js</code> and <code>.svelte.ts</code> files, but you can only <em>export</em> that state if it’s not directly reassigned. In other words you can’t do this:</p> <div class="code-block">
<div class="controls">
<span class="filename" data-ext=".js">state.svelte</span>
</div>
<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">export let count = $state(0);

export function increment() {
	count += 1;
}</pre>
</div>
<p>That’s because every reference to <code>count</code> is transformed by the Svelte compiler — the code above is roughly equivalent to this:</p> <div class="code-block">
<div class="controls">
<span class="filename" data-ext=".js (compiler output)">state.svelte</span>
</div>
<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">export let count = $.state(0);

export function increment() {
	$.set(count, $.get(count) + 1);
}</pre>
</div>
<blockquote class="note">
<p> You can see the code Svelte generates by clicking the ‘JS Output’ tab in the <a href="https://svelte.dev/playground">playground</a>.</p> </blockquote>
<p>Since the compiler only operates on one file at a time, if another file imports <code>count</code> Svelte doesn’t know that it needs to wrap each reference in <code>$.get</code> and <code>$.set</code>:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">import { count } from './state.svelte.js';

console.log(typeof count); // 'object', not 'number'</pre>
</div>
<p>This leaves you with two options for sharing state between modules — either don’t reassign it...</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">// This is allowed — since we're updating
// `counter.count` rather than `counter`,
// Svelte doesn't wrap it in `$.state`
export const counter = $state({
	count: 0
});

export function increment() {
	counter.count += 1;
}</pre>
</div>
<p>...or don’t directly export it:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">let count = $state(0);

export function getCount() {
	return count;
}

export function increment() {
	count += 1;
}</pre>
</div>
</div></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016–2025 Rich Harris and contributors<br>Licensed under the MIT License.<br>
    <a href="https://svelte.dev/docs/svelte/$state" class="_attribution-link">https://svelte.dev/docs/svelte/$state</a>
  </p>
</div>
