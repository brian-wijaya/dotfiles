<header> <h1>svelte</h1></header> <aside class="on-this-page svelte-wtnkd6"><label class="svelte-wtnkd6"> <h3 class="svelte-wtnkd6">On this page</h3></label> <nav class="svelte-wtnkd6"><ul class="svelte-wtnkd6">
<li class="svelte-wtnkd6"><a href="svelte" class="svelte-wtnkd6 active">svelte</a></li> <li class="svelte-wtnkd6"><a href="#SvelteComponent" class="svelte-wtnkd6">SvelteComponent</a></li>
<li class="svelte-wtnkd6"><a href="#SvelteComponentTyped" class="svelte-wtnkd6">SvelteComponentTyped</a></li>
<li class="svelte-wtnkd6"><a href="#afterUpdate" class="svelte-wtnkd6">afterUpdate</a></li>
<li class="svelte-wtnkd6"><a href="#beforeUpdate" class="svelte-wtnkd6">beforeUpdate</a></li>
<li class="svelte-wtnkd6"><a href="#createEventDispatcher" class="svelte-wtnkd6">createEventDispatcher</a></li>
<li class="svelte-wtnkd6"><a href="#createRawSnippet" class="svelte-wtnkd6">createRawSnippet</a></li>
<li class="svelte-wtnkd6"><a href="#flushSync" class="svelte-wtnkd6">flushSync</a></li>
<li class="svelte-wtnkd6"><a href="#getAbortSignal" class="svelte-wtnkd6">getAbortSignal</a></li>
<li class="svelte-wtnkd6"><a href="#getAllContexts" class="svelte-wtnkd6">getAllContexts</a></li>
<li class="svelte-wtnkd6"><a href="#getContext" class="svelte-wtnkd6">getContext</a></li>
<li class="svelte-wtnkd6"><a href="#hasContext" class="svelte-wtnkd6">hasContext</a></li>
<li class="svelte-wtnkd6"><a href="#hydrate" class="svelte-wtnkd6">hydrate</a></li>
<li class="svelte-wtnkd6"><a href="#mount" class="svelte-wtnkd6">mount</a></li>
<li class="svelte-wtnkd6"><a href="#onDestroy" class="svelte-wtnkd6">onDestroy</a></li>
<li class="svelte-wtnkd6"><a href="#onMount" class="svelte-wtnkd6">onMount</a></li>
<li class="svelte-wtnkd6"><a href="#setContext" class="svelte-wtnkd6">setContext</a></li>
<li class="svelte-wtnkd6"><a href="#settled" class="svelte-wtnkd6">settled</a></li>
<li class="svelte-wtnkd6"><a href="#tick" class="svelte-wtnkd6">tick</a></li>
<li class="svelte-wtnkd6"><a href="#unmount" class="svelte-wtnkd6">unmount</a></li>
<li class="svelte-wtnkd6"><a href="#untrack" class="svelte-wtnkd6">untrack</a></li>
<li class="svelte-wtnkd6"><a href="#Component" class="svelte-wtnkd6">Component</a></li>
<li class="svelte-wtnkd6"><a href="#ComponentConstructorOptions" class="svelte-wtnkd6">ComponentConstructorOptions</a></li>
<li class="svelte-wtnkd6"><a href="#ComponentEvents" class="svelte-wtnkd6">ComponentEvents</a></li>
<li class="svelte-wtnkd6"><a href="#ComponentInternals" class="svelte-wtnkd6">ComponentInternals</a></li>
<li class="svelte-wtnkd6"><a href="#ComponentProps" class="svelte-wtnkd6">ComponentProps</a></li>
<li class="svelte-wtnkd6"><a href="#ComponentType" class="svelte-wtnkd6">ComponentType</a></li>
<li class="svelte-wtnkd6"><a href="#EventDispatcher" class="svelte-wtnkd6">EventDispatcher</a></li>
<li class="svelte-wtnkd6"><a href="#MountOptions" class="svelte-wtnkd6">MountOptions</a></li>
<li class="svelte-wtnkd6"><a href="#Snippet" class="svelte-wtnkd6">Snippet</a></li>
</ul></nav></aside> <div class="text content"><div class="text svelte-zb31s9">
<div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">import {
	SvelteComponent,
	SvelteComponentTyped,
	afterUpdate,
	beforeUpdate,
	createEventDispatcher,
	createRawSnippet,
	flushSync,
	getAbortSignal,
	getAllContexts,
	getContext,
	hasContext,
	hydrate,
	mount,
	onDestroy,
	onMount,
	setContext,
	settled,
	tick,
	unmount,
	untrack
} from 'svelte';</pre>
</div>
<h2 id="SvelteComponent">
<span>SvelteComponent</span>
</h2>
<p>This was the base class for Svelte components in Svelte 4. Svelte 5+ components are completely different under the hood. For typing, use <code>Component</code> instead. To instantiate components, use <code>mount</code> instead. See <a href="v5-migration-guide#Components-are-no-longer-classes">migration guide</a> for more info.</p> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">class SvelteComponent&lt;
	Props extends Record&lt;string, any&gt; = Record&lt;string, any&gt;,
	Events extends Record&lt;string, any&gt; = any,
	Slots extends Record&lt;string, any&gt; = any
&gt; {…}</pre></div>
<div class="ts-block-property"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">static element?: typeof HTMLElement;</pre></div>
<div class="ts-block-property-details"> <p>The custom element version of the component. Only present if compiled with the <code>customElement</code> compiler option</p> </div> </div> <div class="ts-block-property"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">[prop: string]: any;</pre></div>
 </div> <div class="ts-block-property"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">constructor(options: ComponentConstructorOptions&lt;Properties&lt;Props, Slots&gt;&gt;);</pre></div>
<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> <ul> <li>
<span class="tag deprecated">deprecated</span> This constructor only exists when using the <code>asClassComponent</code> compatibility helper, which is a stop-gap solution. Migrate towards using <code>mount</code> instead. See <a href="v5-migration-guide#Components-are-no-longer-classes">migration guide</a> for more info.</li> </ul> </div> </div> </div> <div class="ts-block-property"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">$destroy(): void;</pre></div>
<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> <ul> <li>
<span class="tag deprecated">deprecated</span> This method only exists when using one of the legacy compatibility helpers, which is a stop-gap solution. See <a href="v5-migration-guide#Components-are-no-longer-classes">migration guide</a> for more info.</li> </ul> </div> </div> </div> <div class="ts-block-property"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">$on&lt;K extends Extract&lt;keyof Events, string&gt;&gt;(
	type: K,
	callback: (e: Events[K]) =&gt; void
): () =&gt; void;</pre></div>
<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> <ul> <li>
<span class="tag deprecated">deprecated</span> This method only exists when using one of the legacy compatibility helpers, which is a stop-gap solution. See <a href="v5-migration-guide#Components-are-no-longer-classes">migration guide</a> for more info.</li> </ul> </div> </div> </div> <div class="ts-block-property"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">$set(props: Partial&lt;Props&gt;): void;</pre></div>
<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> <ul> <li>
<span class="tag deprecated">deprecated</span> This method only exists when using one of the legacy compatibility helpers, which is a stop-gap solution. See <a href="v5-migration-guide#Components-are-no-longer-classes">migration guide</a> for more info.</li> </ul> </div> </div> </div>
</div> <h2 id="SvelteComponentTyped">
<span>SvelteComponentTyped</span>
</h2>
<blockquote class="tag deprecated note"> <p>Use <code>Component</code> instead. See <a href="v5-migration-guide#Components-are-no-longer-classes">migration guide</a> for more information.</p> </blockquote> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">class SvelteComponentTyped&lt;
	Props extends Record&lt;string, any&gt; = Record&lt;string, any&gt;,
	Events extends Record&lt;string, any&gt; = any,
	Slots extends Record&lt;string, any&gt; = any
&gt; extends SvelteComponent&lt;Props, Events, Slots&gt; {}</pre></div>
</div> <h2 id="afterUpdate">
<span>afterUpdate</span>
</h2>
<blockquote class="tag deprecated note"> <p>Use <a href="$effect"><code>$effect</code></a> instead</p> </blockquote> <p>Schedules a callback to run immediately after the component has been updated.</p> <p>The first time the callback runs will be after the initial <code>onMount</code>.</p> <p>In runes mode use <code>$effect</code> instead.</p> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function afterUpdate(fn: () =&gt; void): void;</pre></div>
</div> <h2 id="beforeUpdate">
<span>beforeUpdate</span>
</h2>
<blockquote class="tag deprecated note"> <p>Use <a href="$effect#$effect.pre"><code>$effect.pre</code></a> instead</p> </blockquote> <p>Schedules a callback to run immediately before the component is updated after any state change.</p> <p>The first time the callback runs will be before the initial <code>onMount</code>.</p> <p>In runes mode use <code>$effect.pre</code> instead.</p> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function beforeUpdate(fn: () =&gt; void): void;</pre></div>
</div> <h2 id="createEventDispatcher">
<span>createEventDispatcher</span>
</h2>
<blockquote class="tag deprecated note"> <p>Use callback props and/or the <code>$host()</code> rune instead — see <a href="v5-migration-guide#Event-changes-Component-events">migration guide</a></p> </blockquote> <p>Creates an event dispatcher that can be used to dispatch <a href="legacy-on#Component-events">component events</a>. Event dispatchers are functions that can take two arguments: <code>name</code> and <code>detail</code>.</p> <p>Component events created with <code>createEventDispatcher</code> create a <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent">CustomEvent</a>. These events do not <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture">bubble</a>. The <code>detail</code> argument corresponds to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail">CustomEvent.detail</a> property and can contain any type of data.</p> <p>The event dispatcher can be typed to narrow the allowed event names and the type of the <code>detail</code> argument:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">const dispatch = createEventDispatcher&lt;{
 loaded: null; // does not take a detail argument
 change: string; // takes a detail argument of type string, which is required
 optional: number | null; // takes an optional detail argument of type number
}&gt;();</pre>
</div>
<div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function createEventDispatcher&lt;
	EventMap extends Record&lt;string, any&gt; = any
&gt;(): EventDispatcher&lt;EventMap&gt;;</pre></div>
</div> <h2 id="createRawSnippet">
<span>createRawSnippet</span>
</h2>
<p>Create a snippet programmatically</p> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function createRawSnippet&lt;Params extends unknown[]&gt;(
	fn: (...params: Getters&lt;Params&gt;) =&gt; {
		render: () =&gt; string;
		setup?: (element: Element) =&gt; void | (() =&gt; void);
	}
): Snippet&lt;Params&gt;;</pre></div>
</div> <h2 id="flushSync">
<span>flushSync</span>
</h2>
<p>Synchronously flush any pending updates. Returns void if no callback is provided, otherwise returns the result of calling the callback.</p> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function flushSync&lt;T = void&gt;(fn?: (() =&gt; T) | undefined): T;</pre></div>
</div> <h2 id="getAbortSignal">
<span>getAbortSignal</span>
</h2>
<p>Returns an <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal"><code>AbortSignal</code></a> that aborts when the current <a href="$derived">derived</a> or <a href="$effect">effect</a> re-runs or is destroyed.</p> <p>Must be called while a derived or effect is running.</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	import { getAbortSignal } from 'svelte';

	let { id } = $props();

	async function getData(id) {
		const response = await fetch(`/items/${id}`, {
			signal: getAbortSignal()
		});

		return await response.json();
	}

	const data = $derived(await getData(id));
&lt;/script&gt;</pre>
</div>
<div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function getAbortSignal(): AbortSignal;</pre></div>
</div> <h2 id="getAllContexts">
<span>getAllContexts</span>
</h2>
<p>Retrieves the whole context map that belongs to the closest parent component. Must be called during component initialisation. Useful, for example, if you programmatically create a component and want to pass the existing context to it.</p> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function getAllContexts&lt;
	T extends Map&lt;any, any&gt; = Map&lt;any, any&gt;
&gt;(): T;</pre></div>
</div> <h2 id="getContext">
<span>getContext</span>
</h2>
<p>Retrieves the context that belongs to the closest parent component with the specified <code>key</code>. Must be called during component initialisation.</p> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function getContext&lt;T&gt;(key: any): T;</pre></div>
</div> <h2 id="hasContext">
<span>hasContext</span>
</h2>
<p>Checks whether a given <code>key</code> has been set in the context of a parent component. Must be called during component initialisation.</p> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function hasContext(key: any): boolean;</pre></div>
</div> <h2 id="hydrate">
<span>hydrate</span>
</h2>
<p>Hydrates a component on the given target and returns the exports and potentially the props (if compiled with <code>accessors: true</code>) of the component</p> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function hydrate&lt;
	Props extends Record&lt;string, any&gt;,
	Exports extends Record&lt;string, any&gt;
&gt;(
	component:
		| ComponentType&lt;SvelteComponent&lt;Props&gt;&gt;
		| Component&lt;Props, Exports, any&gt;,
	options: {} extends Props
		? {
				target: Document | Element | ShadowRoot;
				props?: Props;
				events?: Record&lt;string, (e: any) =&gt; any&gt;;
				context?: Map&lt;any, any&gt;;
				intro?: boolean;
				recover?: boolean;
			}
		: {
				target: Document | Element | ShadowRoot;
				props: Props;
				events?: Record&lt;string, (e: any) =&gt; any&gt;;
				context?: Map&lt;any, any&gt;;
				intro?: boolean;
				recover?: boolean;
			}
): Exports;</pre></div>
</div> <h2 id="mount">
<span>mount</span>
</h2>
<p>Mounts a component to the given target and returns the exports and potentially the props (if compiled with <code>accessors: true</code>) of the component. Transitions will play during the initial render unless the <code>intro</code> option is set to <code>false</code>.</p> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function mount&lt;
	Props extends Record&lt;string, any&gt;,
	Exports extends Record&lt;string, any&gt;
&gt;(
	component:
		| ComponentType&lt;SvelteComponent&lt;Props&gt;&gt;
		| Component&lt;Props, Exports, any&gt;,
	options: MountOptions&lt;Props&gt;
): Exports;</pre></div>
</div> <h2 id="onDestroy">
<span>onDestroy</span>
</h2>
<p>Schedules a callback to run immediately before the component is unmounted.</p> <p>Out of <code>onMount</code>, <code>beforeUpdate</code>, <code>afterUpdate</code> and <code>onDestroy</code>, this is the only one that runs inside a server-side component.</p> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function onDestroy(fn: () =&gt; any): void;</pre></div>
</div> <h2 id="onMount">
<span>onMount</span>
</h2>
<p><code>onMount</code>, like <a href="$effect"><code>$effect</code></a>, schedules a function to run as soon as the component has been mounted to the DOM. Unlike <code>$effect</code>, the provided function only runs once.</p> <p>It must be called during the component’s initialisation (but doesn’t need to live <em>inside</em> the component; it can be called from an external module). If a function is returned <em>synchronously</em> from <code>onMount</code>, it will be called when the component is unmounted.</p> <p><code>onMount</code> functions do not run during <a href="svelte-server#render">server-side rendering</a>.</p> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function onMount&lt;T&gt;(
	fn: () =&gt;
		| NotFunction&lt;T&gt;
		| Promise&lt;NotFunction&lt;T&gt;&gt;
		| (() =&gt; any)
): void;</pre></div>
</div> <h2 id="setContext">
<span>setContext</span>
</h2>
<p>Associates an arbitrary <code>context</code> object with the current component and the specified <code>key</code> and returns that object. The context is then available to children of the component (including slotted content) with <code>getContext</code>.</p> <p>Like lifecycle functions, this must be called during component initialisation.</p> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function setContext&lt;T&gt;(key: any, context: T): T;</pre></div>
</div> <h2 id="settled">
<span>settled</span>
</h2>
<blockquote class="since note"> <p>Available since 5.36</p> </blockquote> <p>Returns a promise that resolves once any state changes, and asynchronous work resulting from them, have resolved and the DOM has been updated</p> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function settled(): Promise&lt;void&gt;;</pre></div>
</div> <h2 id="tick">
<span>tick</span>
</h2>
<p>Returns a promise that resolves once any pending state changes have been applied.</p> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function tick(): Promise&lt;void&gt;;</pre></div>
</div> <h2 id="unmount">
<span>unmount</span>
</h2>
<p>Unmounts a component that was previously mounted using <code>mount</code> or <code>hydrate</code>.</p> <p>Since 5.13.0, if <code>options.outro</code> is <code>true</code>, <a href="transition">transitions</a> will play before the component is removed from the DOM.</p> <p>Returns a <code>Promise</code> that resolves after transitions have completed if <code>options.outro</code> is true, or immediately otherwise (prior to 5.13.0, returns <code>void</code>).</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">import { mount, unmount } from 'svelte';
import App from './App.svelte';

const app = mount(App, { target: document.body });

// later...
unmount(app, { outro: true });</pre>
</div>
<div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function unmount(
	component: Record&lt;string, any&gt;,
	options?:
		| {
				outro?: boolean;
		  }
		| undefined
): Promise&lt;void&gt;;</pre></div>
</div> <h2 id="untrack">
<span>untrack</span>
</h2>
<p>When used inside a <a href="$derived"><code>$derived</code></a> or <a href="$effect"><code>$effect</code></a>, any state read inside <code>fn</code> will not be treated as a dependency.</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">$effect(() =&gt; {
	// this will run when `data` changes, but not when `time` changes
	save(data, {
		timestamp: untrack(() =&gt; time)
	});
});</pre>
</div>
<div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function untrack&lt;T&gt;(fn: () =&gt; T): T;</pre></div>
</div> <h2 id="Component">
<span>Component</span>
</h2>
<p>Can be used to create strongly typed Svelte components.</p> <h4 id="Component-Example:">
<span>Example:</span>
</h4>
<p>You have component library on npm called <code>component-library</code>, from which you export a component called <code>MyComponent</code>. For Svelte+TypeScript users, you want to provide typings. Therefore you create a <code>index.d.ts</code>:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">import type { Component } from 'svelte';
export declare const MyComponent: Component&lt;{ foo: string }&gt; {}</pre>
</div>
<p>Typing this makes it possible for IDEs like VS Code with the Svelte extension to provide intellisense and to use the component like this in a Svelte file with TypeScript:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script lang="ts"&gt;
	import { MyComponent } from "component-library";
&lt;/script&gt;
&lt;MyComponent foo={'bar'} /&gt;</pre>
</div>
<div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">interface Component&lt;
	Props extends Record&lt;string, any&gt; = {},
	Exports extends Record&lt;string, any&gt; = {},
	Bindings extends keyof Props | '' = string
&gt; {…}</pre></div>
<div class="ts-block-property"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">(
	this: void,
	internals: ComponentInternals,
	props: Props
): {
	/**
	 * @deprecated This method only exists when using one of the legacy compatibility helpers, which
	 * is a stop-gap solution. See [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes)
	 * for more info.
	 */
	$on?(type: string, callback: (e: any) =&gt; void): () =&gt; void;
	/**
	 * @deprecated This method only exists when using one of the legacy compatibility helpers, which
	 * is a stop-gap solution. See [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes)
	 * for more info.
	 */
	$set?(props: Partial&lt;Props&gt;): void;
} &amp; Exports;</pre></div>
<div class="ts-block-property-details"> <div class="ts-block-property-bullets"> <ul> <li>
<code>internal</code> An internal object used by Svelte. Do not use or modify.</li> <li>
<code>props</code> The props passed to the component.</li> </ul> </div> </div> </div> <div class="ts-block-property"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">element?: typeof HTMLElement;</pre></div>
<div class="ts-block-property-details"> <p>The custom element version of the component. Only present if compiled with the <code>customElement</code> compiler option</p> </div> </div>
</div> <h2 id="ComponentConstructorOptions">
<span>ComponentConstructorOptions</span>
</h2>
<blockquote class="tag deprecated note"> <p>In Svelte 4, components are classes. In Svelte 5, they are functions. Use <code>mount</code> instead to instantiate components. See <a href="v5-migration-guide#Components-are-no-longer-classes">migration guide</a> for more info.</p> </blockquote> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">interface ComponentConstructorOptions&lt;
	Props extends Record&lt;string, any&gt; = Record&lt;string, any&gt;
&gt; {…}</pre></div>
<div class="ts-block-property"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">target: Element | Document | ShadowRoot;</pre></div>
 </div> <div class="ts-block-property"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">anchor?: Element;</pre></div>
 </div> <div class="ts-block-property"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">props?: Props;</pre></div>
 </div> <div class="ts-block-property"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">context?: Map&lt;any, any&gt;;</pre></div>
 </div> <div class="ts-block-property"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">hydrate?: boolean;</pre></div>
 </div> <div class="ts-block-property"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">intro?: boolean;</pre></div>
 </div> <div class="ts-block-property"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">recover?: boolean;</pre></div>
 </div> <div class="ts-block-property"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">sync?: boolean;</pre></div>
 </div> <div class="ts-block-property"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">idPrefix?: string;</pre></div>
 </div> <div class="ts-block-property"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">$$inline?: boolean;</pre></div>
 </div>
</div> <h2 id="ComponentEvents">
<span>ComponentEvents</span>
</h2>
<blockquote class="tag deprecated note"> <p>The new <code>Component</code> type does not have a dedicated Events type. Use <code>ComponentProps</code> instead.</p> </blockquote> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">type ComponentEvents&lt;Comp extends SvelteComponent&gt; =
	Comp extends SvelteComponent&lt;any, infer Events&gt;
		? Events
		: never;</pre></div>
</div> <h2 id="ComponentInternals">
<span>ComponentInternals</span>
</h2>
<p>Internal implementation details that vary between environments</p> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">type ComponentInternals = Branded&lt;{}, 'ComponentInternals'&gt;;</pre></div>
</div> <h2 id="ComponentProps">
<span>ComponentProps</span>
</h2>
<p>Convenience type to get the props the given component expects.</p> <p>Example: Ensure a variable contains the props expected by <code>MyComponent</code>:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">import type { ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

// Errors if these aren't the correct props expected by MyComponent.
const props: ComponentProps&lt;typeof MyComponent&gt; = { foo: 'bar' };</pre>
</div>
<blockquote class="note">
<p> In Svelte 4, you would do <code>ComponentProps&lt;MyComponent&gt;</code> because <code>MyComponent</code> was a class.</p> </blockquote>
<p>Example: A generic function that accepts some component and infers the type of its props:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">import type { Component, ComponentProps } from 'svelte';
import MyComponent from './MyComponent.svelte';

function withProps&lt;TComponent extends Component&lt;any&gt;&gt;(
	component: TComponent,
	props: ComponentProps&lt;TComponent&gt;
) {};

// Errors if the second argument is not the correct props expected by the component in the first argument.
withProps(MyComponent, { foo: 'bar' });</pre>
</div>
<div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">type ComponentProps&lt;
	Comp extends SvelteComponent | Component&lt;any, any&gt;
&gt; =
	Comp extends SvelteComponent&lt;infer Props&gt;
		? Props
		: Comp extends Component&lt;infer Props, any&gt;
			? Props
			: never;</pre></div>
</div> <h2 id="ComponentType">
<span>ComponentType</span>
</h2>
<blockquote class="tag deprecated note"> <p>This type is obsolete when working with the new <code>Component</code> type.</p> </blockquote> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">type ComponentType&lt;
	Comp extends SvelteComponent = SvelteComponent
&gt; = (new (
	options: ComponentConstructorOptions&lt;
		Comp extends SvelteComponent&lt;infer Props&gt;
			? Props
			: Record&lt;string, any&gt;
	&gt;
) =&gt; Comp) &amp; {
	/** The custom element version of the component. Only present if compiled with the `customElement` compiler option */
	element?: typeof HTMLElement;
};</pre></div>
</div> <h2 id="EventDispatcher">
<span>EventDispatcher</span>
</h2>
<div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">interface EventDispatcher&lt;
	EventMap extends Record&lt;string, any&gt;
&gt; {…}</pre></div>
<div class="ts-block-property"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;Type extends keyof EventMap&gt;(
	...args: null extends EventMap[Type]
		? [type: Type, parameter?: EventMap[Type] | null | undefined, options?: DispatchOptions]
		: undefined extends EventMap[Type]
			? [type: Type, parameter?: EventMap[Type] | null | undefined, options?: DispatchOptions]
			: [type: Type, parameter: EventMap[Type], options?: DispatchOptions]
): boolean;</pre></div>
 </div>
</div> <h2 id="MountOptions">
<span>MountOptions</span>
</h2>
<p>Defines the options accepted by the <code>mount()</code> function.</p> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">type MountOptions&lt;
	Props extends Record&lt;string, any&gt; = Record&lt;string, any&gt;
&gt; = {
	/**
	 * Target element where the component will be mounted.
	 */
	target: Document | Element | ShadowRoot;
	/**
	 * Optional node inside `target`. When specified, it is used to render the component immediately before it.
	 */
	anchor?: Node;
	/**
	 * Allows the specification of events.
	 * @deprecated Use callback props instead.
	 */
	events?: Record&lt;string, (e: any) =&gt; any&gt;;
	/**
	 * Can be accessed via `getContext()` at the component level.
	 */
	context?: Map&lt;any, any&gt;;
	/**
	 * Whether or not to play transitions on initial render.
	 * @default true
	 */
	intro?: boolean;
} &amp; ({} extends Props
	? {
			/**
			 * Component properties.
			 */
			props?: Props;
		}
	: {
			/**
			 * Component properties.
			 */
			props: Props;
		});</pre></div>
</div> <h2 id="Snippet">
<span>Snippet</span>
</h2>
<p>The type of a <code>#snippet</code> block. You can use it to (for example) express that your component expects a snippet of a certain type:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">let { banner }: { banner: Snippet&lt;[{ text: string }]&gt; } = $props();</pre>
</div>
<p>You can only call a snippet through the <code>{@render ...}</code> tag.</p> <p>See the <a href="snippet">snippet documentation</a> for more info.</p> <div class="ts-block"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">interface Snippet&lt;Parameters extends unknown[] = []&gt; {…}</pre></div>
<div class="ts-block-property"> <div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">(
	this: void,
	// this conditional allows tuples but not arrays. Arrays would indicate a
	// rest parameter type, which is not supported. If rest parameters are added
	// in the future, the condition can be removed.
	...args: number extends Parameters['length'] ? never : Parameters
): {
	'{@render ...} must be called with a Snippet': "import type { Snippet } from 'svelte'";
} &amp; typeof SnippetReturn;</pre></div>
 </div>
</div>
</div></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016–2025 Rich Harris and contributors<br>Licensed under the MIT License.<br>
    <a href="https://svelte.dev/docs/svelte/svelte" class="_attribution-link">https://svelte.dev/docs/svelte/svelte</a>
  </p>
</div>
