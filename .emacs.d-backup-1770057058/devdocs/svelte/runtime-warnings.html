<header> <h1>Runtime warnings</h1></header> <aside class="on-this-page svelte-wtnkd6"><label class="svelte-wtnkd6"> <h3 class="svelte-wtnkd6">On this page</h3></label> <nav class="svelte-wtnkd6"><ul class="svelte-wtnkd6">
<li class="svelte-wtnkd6"><a href="runtime-warnings" class="svelte-wtnkd6 active">Runtime warnings</a></li> <li class="svelte-wtnkd6"><a href="#Client-warnings" class="svelte-wtnkd6">Client warnings</a></li>
<li class="svelte-wtnkd6"><a href="#Shared-warnings" class="svelte-wtnkd6">Shared warnings</a></li>
</ul></nav></aside> <div class="text content"><div class="text svelte-zb31s9">
<h2 id="Client-warnings">
<span>Client warnings</span>
</h2> <h3 id="Client-warnings-assignment_value_stale">
<span>assignment_value_stale</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Assignment to `%property%` property (%location%) will evaluate to the right-hand side, not the value of `%property%` following the assignment. This may result in unexpected behaviour.</pre></div>
<p>Given a case like this...</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	let object = $state({ array: null });

	function add() {
		(object.array ??= []).push(object.array.length);
	}
&lt;/script&gt;

&lt;button onclick={add}&gt;add&lt;/button&gt;
&lt;p&gt;items: {JSON.stringify(object.items)}&lt;/p&gt;</pre>
</div>
<p>...the array being pushed to when the button is first clicked is the <code>[]</code> on the right-hand side of the assignment, but the resulting value of <code>object.array</code> is an empty state proxy. As a result, the pushed value will be discarded.</p> <p>You can fix this by separating it into two statements:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">function add() {
	object.array ??= [];
	object.array.push(object.array.length);
}</pre>
</div>
<h3 id="Client-warnings-await_reactivity_loss">
<span>await_reactivity_loss</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Detected reactivity loss when reading `%name%`. This happens when state is read in an async function after an earlier `await`</pre></div>
<p>Svelte’s signal-based reactivity works by tracking which bits of state are read when a template or <code>$derived(...)</code> expression executes. If an expression contains an <code>await</code>, Svelte transforms it such that any state <em>after</em> the <code>await</code> is also tracked — in other words, in a case like this...</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">let total = $derived(await a + b);</pre>
</div>
<p>...both <code>a</code> and <code>b</code> are tracked, even though <code>b</code> is only read once <code>a</code> has resolved, after the initial execution.</p> <p>This does <em>not</em> apply to an <code>await</code> that is not ‘visible’ inside the expression. In a case like this...</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">async function sum() {
	return await a + b;
}

let total = $derived(await sum());</pre>
</div>
<p>...<code>total</code> will depend on <code>a</code> (which is read immediately) but not <code>b</code> (which is not). The solution is to pass the values into the function:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">/**
 * @param {Promise&lt;number&gt;} a
 * @param {number} b
 */
async function sum(a, b) {
	return await a + b;
}

let total = $derived(await sum(a, b));</pre>
</div>
<h3 id="Client-warnings-await_waterfall">
<span>await_waterfall</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">An async derived, `%name%` (%location%) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app</pre></div>
<p>In a case like this...</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">let a = $derived(await one());
let b = $derived(await two());</pre>
</div>
<p>...the second <code>$derived</code> will not be created until the first one has resolved. Since <code>await two()</code> does not depend on the value of <code>a</code>, this delay, often described as a ‘waterfall’, is unnecessary.</p> <p>(Note that if the values of <code>await one()</code> and <code>await two()</code> subsequently change, they can do so concurrently — the waterfall only occurs when the deriveds are first created.)</p> <p>You can solve this by creating the promises first and <em>then</em> awaiting them:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">let aPromise = $derived(one());
let bPromise = $derived(two());

let a = $derived(await aPromise);
let b = $derived(await bPromise);</pre>
</div>
<h3 id="Client-warnings-binding_property_non_reactive">
<span>binding_property_non_reactive</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">`%binding%` is binding to a non-reactive property</pre></div>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">`%binding%` (%location%) is binding to a non-reactive property</pre></div>
<h3 id="Client-warnings-console_log_state">
<span>console_log_state</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Your `console.%method%` contained `$state` proxies. Consider using `$inspect(...)` or `$state.snapshot(...)` instead</pre></div>
<p>When logging a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">proxy</a>, browser devtools will log the proxy itself rather than the value it represents. In the case of Svelte, the ‘target’ of a <code>$state</code> proxy might not resemble its current value, which can be confusing.</p> <p>The easiest way to log a value as it changes over time is to use the <a href="$inspect"><code>$inspect</code></a> rune. Alternatively, to log things on a one-off basis (for example, inside an event handler) you can use <a href="$state#$state.snapshot"><code>$state.snapshot</code></a> to take a snapshot of the current value.</p> <h3 id="Client-warnings-event_handler_invalid">
<span>event_handler_invalid</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">%handler% should be a function. Did you mean to %suggestion%?</pre></div>
<h3 id="Client-warnings-hydration_attribute_changed">
<span>hydration_attribute_changed</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">The `%attribute%` attribute on `%html%` changed its value between server and client renders. The client value, `%value%`, will be ignored in favour of the server value</pre></div>
<p>Certain attributes like <code>src</code> on an <code>&lt;img&gt;</code> element will not be repaired during hydration, i.e. the server value will be kept. That’s because updating these attributes can cause the image to be refetched (or in the case of an <code>&lt;iframe&gt;</code>, for the frame to be reloaded), even if they resolve to the same resource.</p> <p>To fix this, either silence the warning with a <a href="basic-markup#Comments"><code>svelte-ignore</code></a> comment, or ensure that the value stays the same between server and client. If you really need the value to change on hydration, you can force an update like this:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	let { src } = $props();

	if (typeof window !== 'undefined') {
		// stash the value...
		const initial = src;

		// unset it...
		src = undefined;

		$effect(() =&gt; {
			// ...and reset after we've mounted
			src = initial;
		});
	}
&lt;/script&gt;

&lt;img {src} /&gt;</pre>
</div>
<h3 id="Client-warnings-hydration_html_changed">
<span>hydration_html_changed</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">The value of an `{@html ...}` block changed between server and client renders. The client value will be ignored in favour of the server value</pre></div>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">The value of an `{@html ...}` block %location% changed between server and client renders. The client value will be ignored in favour of the server value</pre></div>
<p>If the <code>{@html ...}</code> value changes between the server and the client, it will not be repaired during hydration, i.e. the server value will be kept. That’s because change detection during hydration is expensive and usually unnecessary.</p> <p>To fix this, either silence the warning with a <a href="basic-markup#Comments"><code>svelte-ignore</code></a> comment, or ensure that the value stays the same between server and client. If you really need the value to change on hydration, you can force an update like this:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	let { markup } = $props();

	if (typeof window !== 'undefined') {
		// stash the value...
		const initial = markup;

		// unset it...
		markup = undefined;

		$effect(() =&gt; {
			// ...and reset after we've mounted
			markup = initial;
		});
	}
&lt;/script&gt;

{@html markup}</pre>
</div>
<h3 id="Client-warnings-hydration_mismatch">
<span>hydration_mismatch</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Hydration failed because the initial UI does not match what was rendered on the server</pre></div>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near %location%</pre></div>
<p>This warning is thrown when Svelte encounters an error while hydrating the HTML from the server. During hydration, Svelte walks the DOM, expecting a certain structure. If that structure is different (for example because the HTML was repaired by the DOM because of invalid HTML), then Svelte will run into issues, resulting in this warning.</p> <p>During development, this error is often preceeded by a <code>console.error</code> detailing the offending HTML, which needs fixing.</p> <h3 id="Client-warnings-invalid_raw_snippet_render">
<span>invalid_raw_snippet_render</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">The `render` function passed to `createRawSnippet` should return HTML for a single element</pre></div>
<h3 id="Client-warnings-legacy_recursive_reactive_block">
<span>legacy_recursive_reactive_block</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Detected a migrated `$:` reactive block in `%filename%` that both accesses and updates the same reactive value. This may cause recursive updates when converted to an `$effect`.</pre></div>
<h3 id="Client-warnings-lifecycle_double_unmount">
<span>lifecycle_double_unmount</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Tried to unmount a component that was not mounted</pre></div>
<h3 id="Client-warnings-ownership_invalid_binding">
<span>ownership_invalid_binding</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">%parent% passed property `%prop%` to %child% with `bind:`, but its parent component %owner% did not declare `%prop%` as a binding. Consider creating a binding between %owner% and %parent% (e.g. `bind:%prop%={...}` instead of `%prop%={...}`)</pre></div>
<p>Consider three components <code>GrandParent</code>, <code>Parent</code> and <code>Child</code>. If you do <code>&lt;GrandParent bind:value&gt;</code>, inside <code>GrandParent</code> pass on the variable via <code>&lt;Parent {value} /&gt;</code> (note the missing <code>bind:</code>) and then do <code>&lt;Child bind:value&gt;</code> inside <code>Parent</code>, this warning is thrown.</p> <p>To fix it, <code>bind:</code> to the value instead of just passing a property (i.e. in this example do <code>&lt;Parent bind:value /&gt;</code>).</p> <h3 id="Client-warnings-ownership_invalid_mutation">
<span>ownership_invalid_mutation</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Mutating unbound props (`%name%`, at %location%) is strongly discouraged. Consider using `bind:%prop%={...}` in %parent% (or using a callback) instead</pre></div>
<p>Consider the following code:</p> <div class="code-block">
<div class="controls">
<span class="filename" data-ext=".svelte">App</span><input class="ts-toggle raised" checked title="Toggle language" type="checkbox" aria-label="Toggle JS/TS">
</div>
<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	import Child from './Child.svelte';
	let person = $state({ name: 'Florida', surname: 'Man' });
&lt;/script&gt;

&lt;Child {person} /&gt;</pre>
<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script lang="ts"&gt;
	import Child from './Child.svelte';
	let person = $state({ name: 'Florida', surname: 'Man' });
&lt;/script&gt;

&lt;Child {person} /&gt;</pre>
</div>
<div class="code-block">
<div class="controls">
<span class="filename" data-ext=".svelte">Child</span><input class="ts-toggle raised" checked title="Toggle language" type="checkbox" aria-label="Toggle JS/TS">
</div>
<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	let { person } = $props();
&lt;/script&gt;

&lt;input bind:value={person.name}&gt;
&lt;input bind:value={person.surname}&gt;</pre>
<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script lang="ts"&gt;
	let { person } = $props();
&lt;/script&gt;

&lt;input bind:value={person.name}&gt;
&lt;input bind:value={person.surname}&gt;</pre>
</div>
<p><code>Child</code> is mutating <code>person</code> which is owned by <code>App</code> without being explicitly “allowed” to do so. This is strongly discouraged since it can create code that is hard to reason about at scale (“who mutated this value?”), hence the warning.</p> <p>To fix it, either create callback props to communicate changes, or mark <code>person</code> as <a href="$bindable"><code>$bindable</code></a>.</p> <h3 id="Client-warnings-select_multiple_invalid_value">
<span>select_multiple_invalid_value</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">The `value` property of a `&lt;select multiple&gt;` element should be an array, but it received a non-array value. The selection will be kept as is.</pre></div>
<p>When using <code>&lt;select multiple value={...}&gt;</code>, Svelte will mark all selected <code>&lt;option&gt;</code> elements as selected by iterating over the array passed to <code>value</code>. If <code>value</code> is not an array, Svelte will emit this warning and keep the selected options as they are.</p> <p>To silence the warning, ensure that <code>value</code>:</p> <ul> <li>is an array for an explicit selection</li> <li>is <code>null</code> or <code>undefined</code> to keep the selection as is</li> </ul> <h3 id="Client-warnings-state_proxy_equality_mismatch">
<span>state_proxy_equality_mismatch</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Reactive `$state(...)` proxies and the values they proxy have different identities. Because of this, comparisons with `%operator%` will produce unexpected results</pre></div>
<p><code>$state(...)</code> creates a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">proxy</a> of the value it is passed. The proxy and the value have different identities, meaning equality checks will always return <code>false</code>:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	let value = { foo: 'bar' };
	let proxy = $state(value);

	value === proxy; // always false
&lt;/script&gt;</pre>
</div>
<p>To resolve this, ensure you’re comparing values where both values were created with <code>$state(...)</code>, or neither were. Note that <code>$state.raw(...)</code> will <em>not</em> create a state proxy.</p> <h3 id="Client-warnings-svelte_boundary_reset_noop">
<span>svelte_boundary_reset_noop</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">A `&lt;svelte:boundary&gt;` `reset` function only resets the boundary the first time it is called</pre></div>
<p>When an error occurs while rendering the contents of a <a href="svelte-boundary"><code>&lt;svelte:boundary&gt;</code></a>, the <code>onerror</code> handler is called with the error plus a <code>reset</code> function that attempts to re-render the contents.</p> <p>This <code>reset</code> function should only be called once. After that, it has no effect — in a case like this, where a reference to <code>reset</code> is stored outside the boundary, clicking the button while <code>&lt;Contents /&gt;</code> is rendered will <em>not</em> cause the contents to be rendered again.</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">&lt;script&gt;
	let reset;
&lt;/script&gt;

&lt;button onclick={reset}&gt;reset&lt;/button&gt;

&lt;svelte:boundary onerror={(e, r) =&gt; (reset = r)}&gt;
	&lt;!-- contents --&gt;

	{#snippet failed(e)}
		&lt;p&gt;oops! {e.message}&lt;/p&gt;
	{/snippet}
&lt;/svelte:boundary&gt;</pre>
</div>
<h3 id="Client-warnings-transition_slide_display">
<span>transition_slide_display</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">The `slide` transition does not work correctly for elements with `display: %value%`</pre></div>
<p>The <a href="svelte-transition#slide">slide</a> transition works by animating the <code>height</code> of the element, which requires a <code>display</code> style like <code>block</code>, <code>flex</code> or <code>grid</code>. It does not work for:</p> <ul> <li>
<code>display: inline</code> (which is the default for elements like <code>&lt;span&gt;</code>), and its variants like <code>inline-block</code>, <code>inline-flex</code> and <code>inline-grid</code>
</li> <li>
<code>display: table</code> and <code>table-[name]</code>, which are the defaults for elements like <code>&lt;table&gt;</code> and <code>&lt;tr&gt;</code>
</li> <li><code>display: contents</code></li> </ul> <h2 id="Shared-warnings">
<span>Shared warnings</span>
</h2> <h3 id="Shared-warnings-dynamic_void_element_content">
<span>dynamic_void_element_content</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">`&lt;svelte:element this="%tag%"&gt;` is a void element — it cannot have content</pre></div>
<p>Elements such as <code>&lt;input&gt;</code> cannot have content, any children passed to these elements will be ignored.</p> <h3 id="Shared-warnings-state_snapshot_uncloneable">
<span>state_snapshot_uncloneable</span>
</h3>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">Value cannot be cloned with `$state.snapshot` — the original value was returned</pre></div>
<div class="code-block"><pre data-language="typescript" class="shiki css-variables" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">The following properties cannot be cloned with `$state.snapshot` — the return value contains the originals:

%properties%</pre></div>
<p><code>$state.snapshot</code> tries to clone the given value in order to return a reference that no longer changes. Certain objects may not be cloneable, in which case the original value is returned. In the following example, <code>property</code> is cloned, but <code>window</code> is not, because DOM elements are uncloneable:</p> <div class="code-block">

<pre data-language="typescript" class="shiki css-variables twoslash lsp" style="background-color:var(--shiki-background);color:var(--shiki-foreground)">const object = $state({ property: 'this is cloneable', window })
const snapshot = $state.snapshot(object);</pre>
</div>
</div></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016–2025 Rich Harris and contributors<br>Licensed under the MIT License.<br>
    <a href="https://svelte.dev/docs/svelte/runtime-warnings" class="_attribution-link">https://svelte.dev/docs/svelte/runtime-warnings</a>
  </p>
</div>
