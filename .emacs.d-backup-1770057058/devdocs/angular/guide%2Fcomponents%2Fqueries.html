<h1 tabindex="-1">Referencing component children with queries</h1> <header class="docs-header"> <docs-breadcrumb ng-version="21.0.3" _nghost-ng-c3945279308 ngh="8"></docs-breadcrumb>   </header> 
<div class="docs-alert docs-alert-tip"> <p><strong>TIP:</strong> This guide assumes you've already read the <a href="https://angular.dev/essentials">Essentials Guide</a>. Read that first if you're new to Angular.</p> </div>  <p>A component can define <strong>queries</strong> that find child elements and read values from their injectors.</p> <p>Developers most commonly use queries to retrieve references to child components, directives, DOM elements, and more.</p> <p>All query functions return signals that reflect the most up-to-date results. You can read the result by calling the signal function, including in reactive contexts like <a href="../../api/core/computed"><code>computed</code></a> and <a href="../../api/core/effect"><code>effect</code></a>.</p> <p>There are two categories of query: <strong>view queries</strong> and <strong>content queries.</strong></p> <h2 id="view-queries"> View queries </h2> <p>View queries retrieve results from the elements in the component's <em>view</em> — the elements defined in the component's own template. You can query for a single result with the <a href="../../api/core/viewchild"><code>viewChild</code></a> function.</p> <pre data-language="ts">@Component({
  selector: 'custom-card-header',
  /*...*/
})
export class CustomCardHeader {
  text: string;
}

@Component({
  selector: 'custom-card',
  template: '&lt;custom-card-header&gt;Visit sunny California!&lt;/custom-card-header&gt;',
})
export class CustomCard {
  header = viewChild(CustomCardHeader);
  headerText = computed(() =&gt; this.header()?.text);
}</pre>
<p>In this example, the <code>CustomCard</code> component queries for a child <code>CustomCardHeader</code> and uses the result in a <a href="../../api/core/computed"><code>computed</code></a>.</p> <p>If the query does not find a result, its value is <code>undefined</code>. This may occur if the target element is hidden by <code>@if</code>. Angular keeps the result of <a href="../../api/core/viewchild"><code>viewChild</code></a> up to date as your application state changes.</p> <p>You can also query for multiple results with the <a href="../../api/core/viewchildren"><code>viewChildren</code></a> function.</p> <pre data-language="ts">@Component({
  selector: 'custom-card-action',
  /*...*/
})
export class CustomCardAction {
  text: string;
}

@Component({
  selector: 'custom-card',
  template: `
    &lt;custom-card-action&gt;Save&lt;/custom-card-action&gt;
    &lt;custom-card-action&gt;Cancel&lt;/custom-card-action&gt;
  `,
})
export class CustomCard {
  actions = viewChildren(CustomCardAction);
  actionsTexts = computed(() =&gt; this.actions().map(action =&gt; action.text));
}</pre>
<p><a href="../../api/core/viewchildren"><code>viewChildren</code></a> creates a signal with an <code>Array</code> of the query results.</p> <p><strong>Queries never pierce through component boundaries.</strong> View queries can only retrieve results from the component's template.</p> <h2 id="content-queries"> Content queries </h2> <p>Content queries retrieve results from the elements in the component's <em>content</em>— the elements nested inside the component in the template where it's used. You can query for a single result with the <a href="../../api/core/contentchild"><code>contentChild</code></a> function.</p> <pre data-language="ts">@Component({
  selector: 'custom-toggle',
  /*...*/
})
export class CustomToggle {
  text: string;
}

@Component({
  selector: 'custom-expando',
  /* ... */
})
export class CustomExpando {
  toggle = contentChild(CustomToggle);
  toggleText = computed(() =&gt; this.toggle()?.text);
}

@Component({
/* ... */
// CustomToggle is used inside CustomExpando as content.
template: `
    &lt;custom-expando&gt;
      &lt;custom-toggle&gt;Show&lt;/custom-toggle&gt;
    &lt;/custom-expando&gt;
  `
})

export class UserProfile { }</pre>
<p>If the query does not find a result, its value is <code>undefined</code>. This may occur if the target element is absent or hidden by <code>@if</code>. Angular keeps the result of <a href="../../api/core/contentchild"><code>contentChild</code></a> up to date as your application state changes.</p> <p>By default, content queries find only <em>direct</em> children of the component and do not traverse into descendants.</p> <p>You can also query for multiple results with the <a href="../../api/core/contentchildren"><code>contentChildren</code></a> function.</p> <pre data-language="ts">@Component({
  selector: 'custom-menu-item',
  /*...*/
})
export class CustomMenuItem {
  text: string;
}

@Component({
  selector: 'custom-menu',
  /*...*/
})

export class CustomMenu {
  items = contentChildren(CustomMenuItem);
  itemTexts = computed(() =&gt; this.items().map(item =&gt; item.text));
}

@Component({
  selector: 'user-profile',
  template: `
    &lt;custom-menu&gt;
      &lt;custom-menu-item&gt;Cheese&lt;/custom-menu-item&gt;
      &lt;custom-menu-item&gt;Tomato&lt;/custom-menu-item&gt;
    &lt;/custom-menu&gt;
  `
})
export class UserProfile { }</pre>
<p><a href="../../api/core/contentchildren"><code>contentChildren</code></a> creates a signal with an <code>Array</code> of the query results.</p> <p><strong>Queries never pierce through component boundaries.</strong> Content queries can only retrieve results from the same template as the component itself.</p> <h2 id="required-queries"> Required queries </h2> <p>If a child query (<a href="../../api/core/viewchild"><code>viewChild</code></a> or <a href="../../api/core/contentchild"><code>contentChild</code></a>) does not find a result, its value is <code>undefined</code>. This may occur if the target element is hidden by a control flow statement like <code>@if</code> or <code>@for</code>. Because of this, the child queries return a signal that include <code>undefined</code> in their value type.</p> <p>In some cases, especially with <a href="../../api/core/viewchild"><code>viewChild</code></a>, you know with certainty that a specific child is always available. In other cases, you may want to strictly enforce that a specific child is present. For these cases, you can use a <em>required query</em>.</p> <pre data-language="ts">@Component({/* ... */})
export class CustomCard {
  header = viewChild.required(CustomCardHeader);
  body = contentChild.required(CustomCardBody);
}</pre>
<p>If a required query does not find a matching result, Angular reports an error. Because this guarantees that a result is available, required queries do not automatically include <code>undefined</code> in the signal's value type.</p> <h2 id="query-locators"> Query locators </h2> <p>This first parameter for each query decorator is its <strong>locator</strong>.</p> <p>Most of the time, you want to use a component or directive as your locator.</p> <p>You can alternatively specify a string locator corresponding to a <a href="../templates/variables#template-reference-variables">template reference variable</a>.</p> <pre data-language="ts">@Component({
  /*...*/
  template: `
    &lt;button #save&gt;Save&lt;/button&gt;
    &lt;button #cancel&gt;Cancel&lt;/button&gt;
  `
})
export class ActionBar {
  saveButton = viewChild&lt;ElementRef&lt;HTMLButtonElement&gt;&gt;('save');
}</pre>
<p>If more than one element defines the same template reference variable, the query retrieves the first matching element.</p> <p>Angular does not support CSS selectors as query locators.</p> <h3 id="queries-and-the-injector-tree"> Queries and the injector tree </h3> 
<div class="docs-alert docs-alert-tip"> <p><strong>TIP:</strong> See <a href="../di">Dependency Injection</a> for background on providers and Angular's injection tree.</p> </div>  <p>For more advanced cases, you can use any <a href="../../api/core/providertoken"><code>ProviderToken</code></a> as a locator. This lets you locate elements based on component and directive providers.</p> <pre data-language="ts">const SUB_ITEM = new InjectionToken&lt;string&gt;('sub-item');

@Component({
  /*...*/
  providers: [{provide: SUB_ITEM, useValue: 'special-item'}],
})
export class SpecialItem { }

@Component({/*...*/})
export class CustomList {
  subItemType = contentChild(SUB_ITEM);
}</pre>
<p>The above example uses an <a href="../../api/core/injectiontoken"><code>InjectionToken</code></a> as a locator, but you can use any <a href="../../api/core/providertoken"><code>ProviderToken</code></a> to locate specific elements.</p> <h2 id="query-options"> Query options </h2> <p>All query functions accept an options object as a second parameter. These options control how the query finds its results.</p> <h3 id="reading-specific-values-from-an-elements-injector"> Reading specific values from an element's injector </h3> <p>By default, the query locator indicates both the element you're searching for and the value retrieved. You can alternatively specify the <code>read</code> option to retrieve a different value from the element matched by the locator.</p> <pre data-language="ts">@Component({/*...*/})
export class CustomExpando {
  toggle = contentChild(ExpandoContent, {read: TemplateRef});
}</pre>
<p>The above example, locates an element with the directive <code>ExpandoContent</code> and retrieves the <a href="../../api/core/templateref"><code>TemplateRef</code></a> associated with that element.</p> <p>Developers most commonly use <code>read</code> to retrieve <a href="../../api/core/elementref"><code>ElementRef</code></a> and <a href="../../api/core/templateref"><code>TemplateRef</code></a>.</p> <h3 id="content-descendants"> Content descendants </h3> <p>By default, <a href="../../api/core/contentchildren"><code>contentChildren</code></a> queries find only <em>direct</em> children of the component and do not traverse into descendants. <a href="../../api/core/contentchild"><code>contentChild</code></a> queries do traverse into descendants by default.</p> <pre data-language="ts">@Component({
  selector: 'custom-expando',
  /*...*/
})
export class CustomExpando {
  toggle = contentChildren(CustomToggle); // none found
  // toggle = contentChild(CustomToggle); // found
}

@Component({
  selector: 'user-profile',
  template: `
    &lt;custom-expando&gt;
      &lt;some-other-component&gt;
        &lt;custom-toggle&gt;Show&lt;/custom-toggle&gt;
      &lt;/some-other-component&gt;
    &lt;/custom-expando&gt;
  `
})
export class UserProfile { }</pre>
<p>In the example above, <code>CustomExpando</code> cannot find <code>&lt;custom-toggle&gt;</code> with <a href="../../api/core/contentchildren"><code>contentChildren</code></a> because it is not a direct child of <code>&lt;custom-expando&gt;</code>. By setting <code>descendants: true</code>, you configure the query to traverse all descendants in the same template. Queries, however, <em>never</em> pierce into components to traverse elements in other templates.</p> <p>View queries do not have this option because they <em>always</em> traverse into descendants.</p> <h2 id="decorator-based-queries"> Decorator-based queries </h2> 
<div class="docs-alert docs-alert-tip"> <p><strong>TIP:</strong> While the Angular team recommends using the signal-based query function for new projects, the original decorator-based query APIs remain fully supported.</p> </div>  <p>You can alternatively declare queries by adding the corresponding decorator to a property. Decorator-based queries behave the same way as signal-based queries except as described below.</p> <h3 id="view-queries-1"> View queries </h3> <p>You can query for a single result with the <a href="../../api/core/viewchild"><code>@ViewChild</code></a> decorator.</p> <pre data-language="ts">@Component({
  selector: 'custom-card-header',
  /*...*/
})
export class CustomCardHeader {
  text: string;
}

@Component({
  selector: 'custom-card',
  template: '&lt;custom-card-header&gt;Visit sunny California!&lt;/custom-card-header&gt;',
})
export class CustomCard {
  @ViewChild(CustomCardHeader) header: CustomCardHeader;

  ngAfterViewInit() {
    console.log(this.header.text);
  }
}</pre>
<p>In this example, the <code>CustomCard</code> component queries for a child <code>CustomCardHeader</code> and accesses the result in <code>ngAfterViewInit</code>.</p> <p>Angular keeps the result of <a href="../../api/core/viewchild"><code>@ViewChild</code></a> up to date as your application state changes.</p> <p><strong>View query results become available in the <code>ngAfterViewInit</code> lifecycle method</strong>. Before this point, the value is <code>undefined</code>. See the <a href="lifecycle">Lifecycle</a> section for details on the component lifecycle.</p> <p>You can also query for multiple results with the <a href="../../api/core/viewchildren"><code>@ViewChildren</code></a> decorator.</p> <pre data-language="ts">@Component({
  selector: 'custom-card-action',
  /*...*/
})
export class CustomCardAction {
  text: string;
}

@Component({
  selector: 'custom-card',
  template: `
    &lt;custom-card-action&gt;Save&lt;/custom-card-action&gt;
    &lt;custom-card-action&gt;Cancel&lt;/custom-card-action&gt;
  `,
})
export class CustomCard {
  @ViewChildren(CustomCardAction) actions: QueryList&lt;CustomCardAction&gt;;

  ngAfterViewInit() {
    this.actions.forEach(action =&gt; {
      console.log(action.text);
    });
  }
}</pre>
<p><a href="../../api/core/viewchildren"><code>@ViewChildren</code></a> creates a <a href="../../api/core/querylist"><code>QueryList</code></a> object that contains the query results. You can subscribe to changes to the query results over time via the <code>changes</code> property.</p> <h3 id="content-queries-1"> Content queries </h3> <p>You can query for a single result with the <a href="../../api/core/contentchild"><code>@ContentChild</code></a> decorator.</p> <pre data-language="ts">@Component({
  selector: 'custom-toggle',
  /*...*/
})
export class CustomToggle {
  text: string;
}

@Component({
  selector: 'custom-expando',
  /*...*/
})

export class CustomExpando {
  @ContentChild(CustomToggle) toggle: CustomToggle;

  ngAfterContentInit() {
    console.log(this.toggle.text);
  }
}

@Component({
  selector: 'user-profile',
  template: `
    &lt;custom-expando&gt;
      &lt;custom-toggle&gt;Show&lt;/custom-toggle&gt;
    &lt;/custom-expando&gt;
  `
})
export class UserProfile { }</pre>
<p>In this example, the <code>CustomExpando</code> component queries for a child <code>CustomToggle</code> and accesses the result in <code>ngAfterContentInit</code>.</p> <p>Angular keeps the result of <a href="../../api/core/contentchild"><code>@ContentChild</code></a> up to date as your application state changes.</p> <p><strong>Content query results become available in the <code>ngAfterContentInit</code> lifecycle method</strong>. Before this point, the value is <code>undefined</code>. See the <a href="lifecycle">Lifecycle</a> section for details on the component lifecycle.</p> <p>You can also query for multiple results with the <a href="../../api/core/contentchildren"><code>@ContentChildren</code></a> decorator.</p> <pre data-language="ts">@Component({
  selector: 'custom-menu-item',
  /*...*/
})
export class CustomMenuItem {
  text: string;
}

@Component({
  selector: 'custom-menu',
  /*...*/
})

export class CustomMenu {
  @ContentChildren(CustomMenuItem) items: QueryList&lt;CustomMenuItem&gt;;

  ngAfterContentInit() {
    this.items.forEach(item =&gt; {
      console.log(item.text);
    });
  }
}

@Component({
  selector: 'user-profile',
  template: `
    &lt;custom-menu&gt;
      &lt;custom-menu-item&gt;Cheese&lt;/custom-menu-item&gt;
      &lt;custom-menu-item&gt;Tomato&lt;/custom-menu-item&gt;
    &lt;/custom-menu&gt;
  `
})
export class UserProfile { }</pre>
<p><a href="../../api/core/contentchildren"><code>@ContentChildren</code></a> creates a <a href="../../api/core/querylist"><code>QueryList</code></a> object that contains the query results. You can subscribe to changes to the query results over time via the <code>changes</code> property.</p> <h3 id="decorator-based-query-options"> Decorator-based query options </h3> <p>All query decorators accept an options object as a second parameter. These options work the same way as signal-based queries except where described below.</p> <h3 id="static-queries"> Static queries </h3> <p><a href="../../api/core/viewchild"><code>@ViewChild</code></a> and <a href="../../api/core/contentchild"><code>@ContentChild</code></a> decorators accept the <code>static</code> option.</p> <pre data-language="ts">@Component({
  selector: 'custom-card',
  template: '&lt;custom-card-header&gt;Visit sunny California!&lt;/custom-card-header&gt;',
})
export class CustomCard {
  @ViewChild(CustomCardHeader, {static: true}) header: CustomCardHeader;

  ngOnInit() {
    console.log(this.header.text);
  }
}</pre>
<p>By setting <code>static: true</code>, you guarantee to Angular that the target of this query is <em>always</em> present and is not conditionally rendered. This makes the result available earlier, in the <code>ngOnInit</code> lifecycle method.</p> <p>Static query results do not update after initialization.</p> <p>The <code>static</code> option is not available for <a href="../../api/core/viewchildren"><code>@ViewChildren</code></a> and <a href="../../api/core/contentchildren"><code>@ContentChildren</code></a> queries.</p> <h3 id="using-querylist"> Using QueryList </h3> <p><a href="../../api/core/viewchildren"><code>@ViewChildren</code></a> and <a href="../../api/core/contentchildren"><code>@ContentChildren</code></a> both provide a <a href="../../api/core/querylist"><code>QueryList</code></a> object that contains a list of results.</p> <p><a href="../../api/core/querylist"><code>QueryList</code></a> offers a number of convenience APIs for working with results in an array-like manner, such as <code>map</code>, <code>reduce</code>, and <code>forEach</code>. You can get an array of the current results by calling <code>toArray</code>.</p> <p>You can subscribe to the <code>changes</code> property to do something any time the results change.</p> <h2 id="common-query-pitfalls"> Common query pitfalls </h2> <p>When using queries, common pitfalls can make your code harder to understand and maintain.</p> <p>Always maintain a single source of truth for state shared between multiple components. This avoids scenarios where repeated state in different components becomes out of sync.</p> <p>Avoid directly writing state to child components. This pattern can lead to brittle code that is hard to understand and is prone to <a href="https://angular.dev/errors/NG0100">ExpressionChangedAfterItHasBeenChecked</a> errors.</p> <p>Never directly write state to parent or ancestor components. This pattern can lead to brittle code that is hard to understand and is prone to <a href="https://angular.dev/errors/NG0100">ExpressionChangedAfterItHasBeenChecked</a> errors.</p><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/guide/components/queries" class="_attribution-link">https://angular.dev/guide/components/queries</a>
  </p>
</div>
