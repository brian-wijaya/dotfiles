<h1 tabindex="-1">Using DOM APIs</h1> <header class="docs-header"> <docs-breadcrumb ng-version="21.0.3" _nghost-ng-c3945279308 ngh="8"></docs-breadcrumb>   </header> 
<div class="docs-alert docs-alert-tip"> <p><strong>TIP:</strong> This guide assumes you've already read the <a href="https://angular.dev/essentials">Essentials Guide</a>. Read that first if you're new to Angular.</p> </div>  <p>Angular handles most DOM creation, updates, and removals for you. However, you might rarely need to directly interact with a component's DOM. Components can inject ElementRef to get a reference to the component's host element:</p> <pre data-language="ts">@Component({...})
export class ProfilePhoto {
  constructor() {
    const elementRef = inject(ElementRef);
    console.log(elementRef.nativeElement);
  }
}</pre>
<p>The <code>nativeElement</code> property references the host <a href="https://developer.mozilla.org/docs/Web/API/Element" target="_blank">Element</a> instance.</p> <p>You can use Angular's <a href="../../api/core/aftereveryrender"><code>afterEveryRender</code></a> and <a href="../../api/core/afternextrender"><code>afterNextRender</code></a> functions to register a <strong>render callback</strong> that runs when Angular has finished rendering the page.</p> <pre data-language="ts">@Component({...})
export class ProfilePhoto {
  constructor() {
    const elementRef = inject(ElementRef);
    afterEveryRender(() =&gt; {
      // Focus the first input element in this component.
      elementRef.nativeElement.querySelector('input')?.focus();
    });
  }
}</pre>
<p><a href="../../api/core/aftereveryrender"><code>afterEveryRender</code></a> and <a href="../../api/core/afternextrender"><code>afterNextRender</code></a> must be called in an <em>injection context</em>, typically a component's constructor.</p> <p><strong>Avoid direct DOM manipulation whenever possible.</strong> Always prefer expressing your DOM's structure in component templates and updating that DOM with bindings.</p> <p><strong>Render callbacks never run during server-side rendering or build-time pre-rendering.</strong></p> <p><strong>Never directly manipulate the DOM inside of other Angular lifecycle hooks</strong>. Angular does not guarantee that a component's DOM is fully rendered at any point other than in render callbacks. Further, reading or modifying the DOM during other lifecycle hooks can negatively impact page performance by causing <a href="https://web.dev/avoid-large-complex-layouts-and-layout-thrashing" target="_blank">layout thrashing</a>.</p> <h2 id="using-a-components-renderer"> Using a component's renderer </h2> <p>Components can inject an instance of <a href="../../api/core/renderer2"><code>Renderer2</code></a> to perform certain DOM manipulations that are tied to other Angular features.</p> <p>Any DOM elements created by a component's <a href="../../api/core/renderer2"><code>Renderer2</code></a> participate in that component's <a href="styling#style-scoping">style encapsulation</a>.</p> <p>Certain <a href="../../api/core/renderer2"><code>Renderer2</code></a> APIs also tie into Angular's animation system. You can use the <code>setProperty</code> method to update synthetic animation properties and the <code>listen</code> method to add event listeners for synthetic animation events. See the <a href="../animations">Animations</a> guide for details.</p> <p>Aside from these two narrow use-cases, there is no difference between using <a href="../../api/core/renderer2"><code>Renderer2</code></a> and native DOM APIs. <a href="../../api/core/renderer2"><code>Renderer2</code></a> APIs do not support DOM manipulation in server-side rendering or build-time pre-rendering contexts.</p> <h2 id="when-to-use-dom-apis"> When to use DOM APIs </h2> <p>While Angular handles most rendering concerns, some behaviors may still require using DOM APIs. Some common use cases include:</p> <ul class="docs-list"> <li>Managing element focus</li> <li>Measuring element geometry, such as with <code>getBoundingClientRect</code>
</li> <li>Reading an element's text content</li> <li>Setting up native observers such as <a href="https://developer.mozilla.org/docs/Web/API/MutationObserver" target="_blank"><code>MutationObserver</code></a>, <a href="https://developer.mozilla.org/docs/Web/API/ResizeObserver" target="_blank"><code>ResizeObserver</code></a>, or <a href="https://developer.mozilla.org/docs/Web/API/Intersection_Observer_API" target="_blank"><code>IntersectionObserver</code></a>.</li> </ul> <p>Avoid inserting, removing, and modifying DOM elements. In particular, <strong>never directly set an element's <code>innerHTML</code> property</strong>, which can make your application vulnerable to <a href="https://developer.mozilla.org/docs/Glossary/Cross-site_scripting" target="_blank">cross-site scripting (XSS) exploits</a>. Angular's template bindings, including bindings for <code>innerHTML</code>, include safeguards that help protect against XSS attacks. See the <a href="https://angular.dev/best-practices/security">Security guide</a> for details.</p><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/guide/components/dom-apis" class="_attribution-link">https://angular.dev/guide/components/dom-apis</a>
  </p>
</div>
