<h1>ResolveFn</h1>
<router-outlet _ngcontent-ng-c1178817259></router-outlet><adev-main ngh="7"><router-outlet></router-outlet><adev-reference-page _nghost-ng-c972174807 ngh="6"><main _ngcontent-ng-c972174807 docsviewer class="docs-with-TOC" ngh="0"><div class="docs-api">
<header class="docs-reference-header"><section class="docs-reference-description"><p>Function type definition for a data provider.</p></section><nav class="docs-pill-row"><a class="docs-pill" href="route">Route</a><a class="docs-pill" href="../../guide/routing/data-resolvers">Data resolvers</a></nav></header><div class="docs-reference-section docs-reference-api-section">
<h2 id="api" class="docs-reference-section-heading">API</h2>
<pre data-language="ts">type ResolveFn&lt;T&gt; = (
  route: ActivatedRouteSnapshot,
  state: RouterStateSnapshot,
) =&gt; MaybeAsync&lt;T | RedirectCommand&gt;</pre>
</div>
<div class="docs-reference-section">
<h2 id="description" class="docs-reference-section-heading">Description</h2>
<div>
<p>Function type definition for a data provider.</p> <p>A data provider can be used with the router to resolve data during navigation. The router waits for the data to be resolved before the route is finally activated.</p> <p>A resolver can also redirect a <a href="redirectcommand"><code>RedirectCommand</code></a> and the Angular router will use it to redirect the current navigation to the new destination.</p>
</div>
</div>
<div class="docs-reference-section">
<h2 id="usage-notes" class="docs-reference-section-heading">Usage Notes</h2>
<div>
<p>The following example implements a function that retrieves the data needed to activate the requested route.</p> <pre data-language="ts">interface Hero {
  name: string;
}
@Injectable()
export class HeroService {
  getHero(id: string) {
    return {name: `Superman-${id}`};
  }
}

export const heroResolver: ResolveFn&lt;Hero&gt; = (
  route: ActivatedRouteSnapshot,
  state: RouterStateSnapshot,
) =&gt; {
  return inject(HeroService).getHero(route.paramMap.get('id')!);
};

bootstrapApplication(App, {
  providers: [
    provideRouter([
      {
        path: 'detail/:id',
        component: HeroDetailComponent,
        resolve: {hero: heroResolver},
      },
    ]),
  ],
});</pre>
<p>And you can access to your resolved data from <code>HeroComponent</code>:</p> <pre data-language="ts">@Component({template: ''})
export class HeroDetailComponent {
  private activatedRoute = inject(ActivatedRoute);

  ngOnInit() {
    this.activatedRoute.data.subscribe(({hero}) =&gt; {
      // do something with your resolved data ...
    });
  }
}</pre>
<p>If resolved data cannot be retrieved, you may want to redirect the user to a new page instead:</p> <pre data-language="ts">export const heroResolver: ResolveFn&lt;Hero&gt; = async (
  route: ActivatedRouteSnapshot,
  state: RouterStateSnapshot,
) =&gt; {
  const router = inject(Router);
  const heroService = inject(HeroService);
  try {
    return await heroService.getHero(route.paramMap.get('id')!);
  } catch {
    return new RedirectCommand(router.parseUrl('/404'));
  }
};</pre>
<p>When both guard and resolvers are specified, the resolvers are not executed until all guards have run and succeeded. For example, consider the following route configuration:</p> <pre data-language="ts">{
 path: 'base'
 canActivate: [baseGuard],
 resolve: {data: baseDataResolver}
 children: [
  {
    path: 'child',
    canActivate: [childGuard],
    component: ChildComponent,
    resolve: {childData: childDataResolver}
   }
 ]
}</pre>
<p>The order of execution is: baseGuard, childGuard, baseDataResolver, childDataResolver.</p> </div>
</div>
</div></main></adev-reference-page></adev-main><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/api/router/ResolveFn" class="_attribution-link">https://angular.dev/api/router/ResolveFn</a>
  </p>
</div>
