<h1>Route</h1>
<router-outlet _ngcontent-ng-c1178817259></router-outlet><adev-main ngh="7"><router-outlet></router-outlet><adev-reference-page _nghost-ng-c972174807 ngh="6"><main _ngcontent-ng-c972174807 docsviewer class="docs-with-TOC" ngh="0"><div class="docs-api">
<header class="docs-reference-header"><section class="docs-reference-description"><p>A configuration object that defines a single route. A set of routes are collected in a <a href="routes"><code>Routes</code></a> array to define a <a href="router"><code>Router</code></a> configuration. The router attempts to match segments of a given URL against each route, using the configuration options defined in this object.</p></section></header><div class="docs-reference-section docs-reference-api-section">
<h2 id="api" class="docs-reference-section-heading">API</h2>
<pre data-language="ts">interface Route {
  title?: string | Type&lt;Resolve&lt;string&gt;&gt; | ResolveFn&lt;string&gt; | undefined;
  path?: string | undefined;
  pathMatch?: "prefix" | "full" | undefined;
  matcher?: UrlMatcher | undefined;
  component?: Type&lt;any&gt; | undefined;
  loadComponent?: (() =&gt; any) | undefined;
  redirectTo?: string | RedirectFunction | undefined;
  outlet?: string | undefined;
  canActivate?: (CanActivateFn | DeprecatedGuard)[] | undefined;
  canMatch?: (CanMatchFn | DeprecatedGuard)[] | undefined;
  canActivateChild?: (CanActivateChildFn | DeprecatedGuard)[] | undefined;
  canDeactivate?: (DeprecatedGuard | CanDeactivateFn&lt;any&gt;)[] | undefined;
  canLoad?: (DeprecatedGuard | CanLoadFn)[] | undefined;
  data?: Data | undefined;
  resolve?: ResolveData | undefined;
  children?: Routes | undefined;
  loadChildren?: LoadChildrenCallback | undefined;
  runGuardsAndResolvers?: RunGuardsAndResolvers | undefined;
  providers?: (EnvironmentProviders | Provider)[] | undefined;
}</pre>
</div>
<div class="docs-reference-members"><div class="docs-reference-members">
<div id="title" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>title</h3>
<code>string | <a href="../core/type">Type</a>&lt;<a href="resolve">Resolve</a>&lt;string&gt;&gt; | <a href="resolvefn">ResolveFn</a>&lt;string&gt; | undefined</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>Used to define a page title for the route. This can be a static string or an <a href="../core/injectable"><code>Injectable</code></a> that implements <a href="resolve"><code>Resolve</code></a>.</p></div></div></div>
</div>
<div id="path" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>path</h3>
<code>string | undefined</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>The path to match against. Cannot be used together with a custom <code>matcher</code> function. A URL string that uses router matching notation. Can be a wild card (<code>**</code>) that matches any URL (see Usage Notes below). Default is "/" (the root path).</p></div></div></div>
</div>
<div id="pathMatch" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>pathMatch</h3>
<code>"prefix" | "full" | undefined</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div>
<p>The path-matching strategy, one of 'prefix' or 'full'. Default is 'prefix'.</p> <p>By default, the router checks URL elements from the left to see if the URL matches a given path and stops when there is a config match. Importantly there must still be a config match for each segment of the URL. For example, '/team/11/user' matches the prefix 'team/:id' if one of the route's children matches the segment 'user'. That is, the URL '/team/11/user' matches the config <code>{path: 'team/:id', children: [{path: ':user', component: User}]}</code> but does not match when there are no children as in <code>{path: 'team/:id', component: Team}</code>.</p> <p>The path-match strategy 'full' matches against the entire URL. It is important to do this when redirecting empty-path routes. Otherwise, because an empty path is a prefix of any URL, the router would apply the redirect even when navigating to the redirect destination, creating an endless loop.</p>
</div></div></div>
</div>
<div id="matcher" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>matcher</h3>
<code><a href="urlmatcher">UrlMatcher</a> | undefined</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>A custom URL-matching function. Cannot be used together with <code>path</code>.</p></div></div></div>
</div>
<div id="component" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>component</h3>
<code><a href="../core/type">Type</a>&lt;any&gt; | undefined</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>The component to instantiate when the path matches. Can be empty if child routes specify components.</p></div></div></div>
</div>
<div id="loadComponent" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>loadComponent</h3>
<code>(() =&gt; any) | undefined</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>An object specifying a lazy-loaded component.</p></div></div></div>
</div>
<div id="redirectTo" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>redirectTo</h3>
<code>string | <a href="redirectfunction">RedirectFunction</a> | undefined</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div>
<p>A URL or function that returns a URL to redirect to when the path matches.</p> <p>Absolute if the URL begins with a slash (/) or the function returns a <a href="urltree"><code>UrlTree</code></a>, otherwise relative to the path URL.</p> <p>The <a href="redirectfunction"><code>RedirectFunction</code></a> is run in an injection context so it can call <a href="../core/inject"><code>inject</code></a> to get any required dependencies.</p> <p>When not present, router does not redirect.</p>
</div></div></div>
</div>
<div id="outlet" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>outlet</h3>
<code>string | undefined</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>Name of a <a href="routeroutlet"><code>RouterOutlet</code></a> object where the component can be placed when the path matches.</p></div></div></div>
</div>
<div id="canActivate" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>canActivate</h3>
<code>(<a href="canactivatefn">CanActivateFn</a> | <a href="deprecatedguard">DeprecatedGuard</a>)[] | undefined</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div>
<p>An array of <a href="canactivatefn"><code>CanActivateFn</code></a> or DI tokens used to look up <a href="canactivate"><code>CanActivate()</code></a> handlers, in order to determine if the current user is allowed to activate the component. By default, any user can activate.</p> <p>When using a function rather than DI tokens, the function can call <a href="../core/inject"><code>inject</code></a> to get any required dependencies. This <a href="../core/inject"><code>inject</code></a> call must be done in a synchronous context.</p>
</div></div></div>
</div>
<div id="canMatch" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>canMatch</h3>
<code>(<a href="canmatchfn">CanMatchFn</a> | <a href="deprecatedguard">DeprecatedGuard</a>)[] | undefined</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div>
<p>An array of <a href="canmatchfn"><code>CanMatchFn</code></a> or DI tokens used to look up <a href="canmatch"><code>CanMatch()</code></a> handlers, in order to determine if the current user is allowed to match the <a href="route"><code>Route</code></a>. By default, any route can match.</p> <p>When using a function rather than DI tokens, the function can call <a href="../core/inject"><code>inject</code></a> to get any required dependencies. This <a href="../core/inject"><code>inject</code></a> call must be done in a synchronous context.</p>
</div></div></div>
</div>
<div id="canActivateChild" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>canActivateChild</h3>
<code>(<a href="canactivatechildfn">CanActivateChildFn</a> | <a href="deprecatedguard">DeprecatedGuard</a>)[] | undefined</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div>
<p>An array of <a href="canactivatechildfn"><code>CanActivateChildFn</code></a> or DI tokens used to look up <a href="canactivatechild"><code>CanActivateChild()</code></a> handlers, in order to determine if the current user is allowed to activate a child of the component. By default, any user can activate a child.</p> <p>When using a function rather than DI tokens, the function can call <a href="../core/inject"><code>inject</code></a> to get any required dependencies. This <a href="../core/inject"><code>inject</code></a> call must be done in a synchronous context.</p>
</div></div></div>
</div>
<div id="canDeactivate" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>canDeactivate</h3>
<code>(<a href="deprecatedguard">DeprecatedGuard</a> | <a href="candeactivatefn">CanDeactivateFn</a>&lt;any&gt;)[] | undefined</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div>
<p>An array of <a href="candeactivatefn"><code>CanDeactivateFn</code></a> or DI tokens used to look up <a href="candeactivate"><code>CanDeactivate()</code></a> handlers, in order to determine if the current user is allowed to deactivate the component. By default, any user can deactivate.</p> <p>When using a function rather than DI tokens, the function can call <a href="../core/inject"><code>inject</code></a> to get any required dependencies. This <a href="../core/inject"><code>inject</code></a> call must be done in a synchronous context.</p>
</div></div></div>
</div>
<div id="canLoad" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>canLoad</h3>
<code>(<a href="deprecatedguard">DeprecatedGuard</a> | <a href="canloadfn">CanLoadFn</a>)[] | undefined</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item">
<div class="docs-deprecation-message">
<span class="docs-param-keyword docs-deprecated">@deprecated</span><span><p>Use <code>canMatch</code> instead</p> </span>
</div>
<div>
<p>An array of <a href="canloadfn"><code>CanLoadFn</code></a> or DI tokens used to look up <a href="canload"><code>CanLoad()</code></a> handlers, in order to determine if the current user is allowed to load the component. By default, any user can load.</p> <p>When using a function rather than DI tokens, the function can call <a href="../core/inject"><code>inject</code></a> to get any required dependencies. This <a href="../core/inject"><code>inject</code></a> call must be done in a synchronous context.</p>
</div>
</div></div>
</div>
<div id="data" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>data</h3>
<code><a href="data">Data</a> | undefined</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>Additional developer-defined data provided to the component via <a href="activatedroute"><code>ActivatedRoute</code></a>. By default, no additional data is passed.</p></div></div></div>
</div>
<div id="resolve" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>resolve</h3>
<code><a href="resolvedata">ResolveData</a> | undefined</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>A map of DI tokens used to look up data resolvers. See <a href="resolve"><code>Resolve</code></a>.</p></div></div></div>
</div>
<div id="children" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>children</h3>
<code><a href="routes">Routes</a> | undefined</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>An array of child <a href="route"><code>Route</code></a> objects that specifies a nested route configuration.</p></div></div></div>
</div>
<div id="loadChildren" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>loadChildren</h3>
<code><a href="loadchildrencallback">LoadChildrenCallback</a> | undefined</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>An object specifying lazy-loaded child routes.</p></div></div></div>
</div>
<div id="runGuardsAndResolvers" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>runGuardsAndResolvers</h3>
<code><a href="runguardsandresolvers">RunGuardsAndResolvers</a> | undefined</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div>
<p>A policy for when to run guards and resolvers on a route.</p> <p>Guards and/or resolvers will always run when a route is activated or deactivated. When a route is unchanged, the default behavior is the same as <code>paramsChange</code>.</p> <p><code>paramsChange</code> : Rerun the guards and resolvers when path or path param changes. This does not include query parameters. This option is the default.</p> <ul class="docs-list"> <li>
<code>always</code> : Run on every execution.</li> <li>
<code>pathParamsChange</code> : Rerun guards and resolvers when the path params change. This does not compare matrix or query parameters.</li> <li>
<code>paramsOrQueryParamsChange</code> : Run when path, matrix, or query parameters change.</li> <li>
<code>pathParamsOrQueryParamsChange</code> : Rerun guards and resolvers when the path params change or query params have changed. This does not include matrix parameters.</li> </ul>
</div></div></div>
</div>
<div id="providers" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>providers</h3>
<code>(<a href="../core/environmentproviders">EnvironmentProviders</a> | <a href="../core/provider">Provider</a>)[] | undefined</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div>
<p>A <a href="../core/provider"><code>Provider</code></a> array to use for this <a href="route"><code>Route</code></a> and its <code>children</code>.</p> <p>The <a href="router"><code>Router</code></a> will create a new <a href="../core/environmentinjector"><code>EnvironmentInjector</code></a> for this <a href="route"><code>Route</code></a> and use it for this <a href="route"><code>Route</code></a> and its <code>children</code>. If this route also has a <code>loadChildren</code> function which returns an <code>NgModuleRef</code>, this injector will be used as the parent of the lazy loaded module.</p>
</div></div></div>
</div>
</div></div>
<div class="docs-reference-section">
<h2 id="description" class="docs-reference-section-heading">Description</h2>
<div>
<p>A configuration object that defines a single route. A set of routes are collected in a <a href="routes"><code>Routes</code></a> array to define a <a href="router"><code>Router</code></a> configuration. The router attempts to match segments of a given URL against each route, using the configuration options defined in this object.</p> <p>Supports static, parameterized, redirect, and wildcard routes, as well as custom route data and resolve methods.</p> <p>For detailed usage information, see the <a href="../../guide/routing/common-router-tasks">Routing Guide</a>.</p>
</div>
</div>
<div class="docs-reference-section">
<h2 id="usage-notes" class="docs-reference-section-heading">Usage Notes</h2>
<div> <h3 id="simple-configuration"> Simple Configuration </h3> <p>The following route specifies that when navigating to, for example, <code>/team/11/user/bob</code>, the router creates the 'Team' component with the 'User' child component in it.</p> <pre data-language="ts">[{
  path: 'team/:id',
 component: Team,
  children: [{
    path: 'user/:name',
    component: User
  }]
}]</pre> <h3 id="multiple-outlets"> Multiple Outlets </h3> <p>The following route creates sibling components with multiple outlets. When navigating to <code>/team/11(aux:chat/jim)</code>, the router creates the 'Team' component next to the 'Chat' component. The 'Chat' component is placed into the 'aux' outlet.</p> <pre data-language="ts">[{
  path: 'team/:id',
  component: Team
}, {
  path: 'chat/:user',
  component: Chat
  outlet: 'aux'
}]</pre> <h3 id="wild-cards"> Wild Cards </h3> <p>The following route uses wild-card notation to specify a component that is always instantiated regardless of where you navigate to.</p> <pre data-language="ts">[{
  path: '**',
  component: WildcardComponent
}]</pre> <h3 id="redirects"> Redirects </h3> <p>The following route uses the <code>redirectTo</code> property to ignore a segment of a given URL when looking for a child path.</p> <p>When navigating to '/team/11/legacy/user/jim', the router changes the URL segment '/team/11/legacy/user/jim' to '/team/11/user/jim', and then instantiates the Team component with the User child component in it.</p> <pre data-language="ts">[{
  path: 'team/:id',
  component: Team,
  children: [{
    path: 'legacy/user/:name',
    redirectTo: 'user/:name'
  }, {
    path: 'user/:name',
    component: User
  }]
}]</pre>
<p>The redirect path can be relative, as shown in this example, or absolute. If we change the <code>redirectTo</code> value in the example to the absolute URL segment '/user/:name', the result URL is also absolute, '/user/jim'.</p> <h3 id="empty-path"> Empty Path </h3> <p>Empty-path route configurations can be used to instantiate components that do not 'consume' any URL segments.</p> <p>In the following configuration, when navigating to <code>/team/11</code>, the router instantiates the 'AllUsers' component.</p> <pre data-language="ts">[{
  path: 'team/:id',
  component: Team,
  children: [{
    path: '',
    component: AllUsers
  }, {
    path: 'user/:name',
    component: User
  }]
}]</pre>
<p>Empty-path routes can have children. In the following example, when navigating to <code>/team/11/user/jim</code>, the router instantiates the wrapper component with the user component in it.</p> <p>Note that an empty path route inherits its parent's parameters and data.</p> <pre data-language="ts">[{
  path: 'team/:id',
  component: Team,
  children: [{
    path: '',
    component: WrapperCmp,
    children: [{
      path: 'user/:name',
      component: User
    }]
  }]
}]</pre> <h3 id="matching-strategy"> Matching Strategy </h3> <p>The default path-match strategy is 'prefix', which means that the router checks URL elements from the left to see if the URL matches a specified path. For example, '/team/11/user' matches 'team/:id'.</p> <pre data-language="ts">[{
  path: '',
  pathMatch: 'prefix', //default
  redirectTo: 'main'
}, {
  path: 'main',
  component: Main
}]</pre>
<p>You can specify the path-match strategy 'full' to make sure that the path covers the whole unconsumed URL. It is important to do this when redirecting empty-path routes. Otherwise, because an empty path is a prefix of any URL, the router would apply the redirect even when navigating to the redirect destination, creating an endless loop.</p> <p>In the following example, supplying the 'full' <code>pathMatch</code> strategy ensures that the router applies the redirect if and only if navigating to '/'.</p> <pre data-language="ts">[{
  path: '',
  pathMatch: 'full',
  redirectTo: 'main'
}, {
  path: 'main',
  component: Main
}]</pre> <h3 id="componentless-routes"> Componentless Routes </h3> <p>You can share parameters between sibling components. For example, suppose that two sibling components should go next to each other, and both of them require an ID parameter. You can accomplish this using a route that does not specify a component at the top level.</p> <p>In the following example, 'MainChild' and 'AuxChild' are siblings. When navigating to 'parent/10/(a//aux:b)', the route instantiates the main child and aux child components next to each other. For this to work, the application component must have the primary and aux outlets defined.</p> <pre data-language="ts">[{
   path: 'parent/:id',
   children: [
     { path: 'a', component: MainChild },
     { path: 'b', component: AuxChild, outlet: 'aux' }
   ]
}]</pre>
<p>The router merges the parameters, data, and resolve of the componentless parent into the parameters, data, and resolve of the children.</p> <p>This is especially useful when child components are defined with an empty path string, as in the following example. With this configuration, navigating to '/parent/10' creates the main child and aux components.</p> <pre data-language="ts">[{
   path: 'parent/:id',
   children: [
     { path: '', component: MainChild },
     { path: '', component: AuxChild, outlet: 'aux' }
   ]
}]</pre> <h3 id="lazy-loading"> Lazy Loading </h3> <p>Lazy loading speeds up application load time by splitting the application into multiple bundles and loading them on demand. To use lazy loading, provide the <code>loadChildren</code> property in the <a href="route"><code>Route</code></a> object, instead of the <code>children</code> property.</p> <p>Given the following example route, the router will lazy load the associated module on demand using the browser native import system.</p> <pre data-language="ts">[{
  path: 'lazy',
  loadChildren: () =&gt; import('./lazy-route/lazy.module').then(mod =&gt; mod.LazyModule),
}];</pre>
</div>
</div>
</div></main></adev-reference-page></adev-main><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/api/router/Route" class="_attribution-link">https://angular.dev/api/router/Route</a>
  </p>
</div>
