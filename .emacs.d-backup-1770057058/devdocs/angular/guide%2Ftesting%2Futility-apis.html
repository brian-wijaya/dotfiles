<h1 tabindex="-1">Testing Utility APIs</h1> <header class="docs-header"> <docs-breadcrumb ng-version="21.0.3" _nghost-ng-c3945279308 ngh="8"></docs-breadcrumb>   </header> 
<div class="docs-alert docs-alert-note"> <p><strong>NOTE:</strong> While this guide is being updated for Vitest, some descriptions and examples of utility APIs are currently presented within the context of Karma/Jasmine. We are actively working to provide Vitest equivalents and updated guidance where applicable.</p> </div>  <p>This page describes the most useful Angular testing features.</p> <p>The Angular testing utilities include the <a href="../../api/core/testing/testbed"><code>TestBed</code></a>, the <a href="../../api/core/testing/componentfixture"><code>ComponentFixture</code></a>, and a handful of functions that control the test environment. The <a href="../../api/core/testing/testbed"><code>TestBed</code></a> and <a href="../../api/core/testing/componentfixture"><code>ComponentFixture</code></a> classes are covered separately.</p> <p>Here's a summary of the stand-alone functions, in order of likely utility:</p> <div class="docs-table docs-scroll-track-transparent"> <table> <thead> <tr> <th align="left">Function</th> <th align="left">Details</th> </tr> </thead> <tbody> <tr> <td align="left"><code>inject</code></td> <td align="left">Injects one or more services from the current <a href="../../api/core/testing/testbed"><code>TestBed</code></a> injector into a test function. It cannot inject a service provided by the component itself. See discussion of the <a href="components-scenarios#get-injected-services">debugElement.injector</a>.</td> </tr> <tr> <td align="left"><a href="../../api/core/testing/componentfixtureautodetect"><code>ComponentFixtureAutoDetect</code></a></td> <td align="left">A provider token for a service that turns on <a href="components-scenarios#automatic-change-detection">automatic change detection</a>.</td> </tr> <tr> <td align="left"><a href="../../api/core/testing/gettestbed"><code>getTestBed</code></a></td> <td align="left">Gets the current instance of the <a href="../../api/core/testing/testbed"><code>TestBed</code></a>. Usually unnecessary because the static class methods of the <a href="../../api/core/testing/testbed"><code>TestBed</code></a> class are typically sufficient. The <a href="../../api/core/testing/testbed"><code>TestBed</code></a> instance exposes a few rarely used members that are not available as static methods.</td> </tr> </tbody> </table> </div> <p>For handling complex asynchronous scenarios or testing legacy Zone.js-based applications, see the <a href="zone-js-testing-utilities">Zone.js Testing Utilities</a> guide.</p> <h2 id="testbed-class-summary"> TestBed class summary </h2> <p>The <a href="../../api/core/testing/testbed"><code>TestBed</code></a> class is one of the principal Angular testing utilities. Its API is quite large and can be overwhelming until you've explored it, a little at a time. Read the early part of this guide first to get the basics before trying to absorb the full API.</p> <p>The module definition passed to <code>configureTestingModule</code> is a subset of the <a href="../../api/core/ngmodule"><code>@NgModule</code></a> metadata properties.</p> <pre data-language="ts">type TestModuleMetadata = {
providers?: any[];
declarations?: any[];
imports?: any[];
schemas?: Array&lt;SchemaMetadata | any[]&gt;;
};</pre>
<p>Each override method takes a <code>MetadataOverride&lt;T&gt;</code> where <code>T</code> is the kind of metadata appropriate to the method, that is, the parameter of an <a href="../../api/core/ngmodule"><code>@NgModule</code></a>, <a href="../../api/core/component"><code>@Component</code></a>, <a href="../../api/core/directive"><code>@Directive</code></a>, or <a href="../../api/core/pipe"><code>@Pipe</code></a>.</p> <pre data-language="ts">type MetadataOverride&lt;T&gt; = {
add?: Partial&lt;T&gt;;
remove?: Partial&lt;T&gt;;
set?: Partial&lt;T&gt;;
};</pre>
<p>The <a href="../../api/core/testing/testbed"><code>TestBed</code></a> API consists of static class methods that either update or reference a <em>global</em> instance of the <a href="../../api/core/testing/testbed"><code>TestBed</code></a>.</p> <p>Internally, all static methods cover methods of the current runtime <a href="../../api/core/testing/testbed"><code>TestBed</code></a> instance, which is also returned by the <a href="../../api/core/testing/gettestbed"><code>getTestBed()</code></a> function.</p> <p>Call <a href="../../api/core/testing/testbed"><code>TestBed</code></a> methods <em>within</em> a <code>beforeEach()</code> to ensure a fresh start before each individual test.</p> <p>Here are the most important static methods, in order of likely utility.</p> <div class="docs-table docs-scroll-track-transparent"> <table> <thead> <tr> <th align="left">Methods</th> <th align="left">Details</th> </tr> </thead> <tbody> <tr> <td align="left"><code>configureTestingModule</code></td> <td align="left">The testing shims establish the <a href="../testing">initial test environment</a> and a default testing module. The default testing module is configured with basic declaratives and some Angular service substitutes that every tester needs. <br> Call <code>configureTestingModule</code> to refine the testing module configuration for a particular set of tests by adding and removing imports, declarations (of components, directives, and pipes), and providers.</td> </tr> <tr> <td align="left"><code>compileComponents</code></td> <td align="left">Compile the testing module asynchronously after you've finished configuring it. You <strong>must</strong> call this method if <em>any</em> of the testing module components have a <code>templateUrl</code> or <code>styleUrls</code> because fetching component template and style files is necessarily asynchronous. See <a href="components-scenarios#calling-compilecomponents">compileComponents</a>. <br> After calling <code>compileComponents</code>, the <a href="../../api/core/testing/testbed"><code>TestBed</code></a> configuration is frozen for the duration of the current spec.</td> </tr> <tr> <td align="left"><code>createComponent&lt;T&gt;</code></td> <td align="left">Create an instance of a component of type <code>T</code> based on the current <a href="../../api/core/testing/testbed"><code>TestBed</code></a> configuration. After calling <a href="../../api/core/createcomponent"><code>createComponent</code></a>, the <a href="../../api/core/testing/testbed"><code>TestBed</code></a> configuration is frozen for the duration of the current spec.</td> </tr> <tr> <td align="left"><code>overrideModule</code></td> <td align="left">Replace metadata for the given <a href="../../api/core/ngmodule"><code>NgModule</code></a>. Recall that modules can import other modules. The <code>overrideModule</code> method can reach deeply into the current testing module to modify one of these inner modules.</td> </tr> <tr> <td align="left"><code>overrideComponent</code></td> <td align="left">Replace metadata for the given component class, which could be nested deeply within an inner module.</td> </tr> <tr> <td align="left"><code>overrideDirective</code></td> <td align="left">Replace metadata for the given directive class, which could be nested deeply within an inner module.</td> </tr> <tr> <td align="left"><code>overridePipe</code></td> <td align="left">Replace metadata for the given pipe class, which could be nested deeply within an inner module.</td> </tr> </tbody> </table> </div> <p>| <code>inject</code> | Retrieve a service from the current <a href="../../api/core/testing/testbed"><code>TestBed</code></a> injector. The <code>inject</code> function is often adequate for this purpose. But <code>inject</code> throws an error if it can't provide the service. <br> What if the service is optional? <br> The <a href="../../api/core/testing/testbed#inject"><code>TestBed.inject()</code></a> method takes an optional second parameter, the object to return if Angular can't find the provider (<code>null</code> in this example): <docs-code header="app/demo/demo.testbed.spec.ts" path="adev/src/content/examples/testing/src/app/demo/demo.testbed.spec.ts" region="testbed-get-w-null"> After calling <a href="../../api/core/testing/testbed#inject"><code>TestBed.inject</code></a>, the <a href="../../api/core/testing/testbed"><code>TestBed</code></a> configuration is frozen for the duration of the current spec. | | <code>initTestEnvironment</code> | Initialize the testing environment for the entire test run. <br> The testing shims call it for you so there is rarely a reason for you to call it yourself. <br> Call this method <em>exactly once</em>. To change this default in the middle of a test run, call <code>resetTestEnvironment</code> first. <br> Specify the Angular compiler factory, a <a href="../../api/core/platformref"><code>PlatformRef</code></a>, and a default Angular testing module. Alternatives for non-browser platforms are available in the general form <code>@angular/platform-&lt;platform_name&gt;/testing/&lt;platform_name&gt;</code>. | | <code>resetTestEnvironment</code> | Reset the initial test environment, including the default testing module. |</docs-code></p> <p>A few of the <a href="../../api/core/testing/testbed"><code>TestBed</code></a> instance methods are not covered by static <a href="../../api/core/testing/testbed"><code>TestBed</code></a> <em>class</em> methods. These are rarely needed.</p> <h2 id="the-componentfixture"> The ComponentFixture </h2> <p>The <a href="#"><code>TestBed.createComponent&lt;T&gt;</code></a> creates an instance of the component <code>T</code> and returns a strongly typed <a href="../../api/core/testing/componentfixture"><code>ComponentFixture</code></a> for that component.</p> <p>The <a href="../../api/core/testing/componentfixture"><code>ComponentFixture</code></a> properties and methods provide access to the component, its DOM representation, and aspects of its Angular environment.</p> <h3 id="componentfixture-properties"> ComponentFixture properties </h3> <p>Here are the most important properties for testers, in order of likely utility.</p> <div class="docs-table docs-scroll-track-transparent"> <table> <thead> <tr> <th align="left">Properties</th> <th align="left">Details</th> </tr> </thead> <tbody> <tr> <td align="left"><code>componentInstance</code></td> <td align="left">The instance of the component class created by <a href="../../api/core/testing/testbed#createComponent"><code>TestBed.createComponent</code></a>.</td> </tr> <tr> <td align="left"><code>debugElement</code></td> <td align="left">The <a href="../../api/core/debugelement"><code>DebugElement</code></a> associated with the root element of the component. <br> The <code>debugElement</code> provides insight into the component and its DOM element during test and debugging. It's a critical property for testers. The most interesting members are covered <a href="#debugelement">below</a>.</td> </tr> <tr> <td align="left"><code>nativeElement</code></td> <td align="left">The native DOM element at the root of the component.</td> </tr> <tr> <td align="left"><code>changeDetectorRef</code></td> <td align="left">The <a href="../../api/core/changedetectorref"><code>ChangeDetectorRef</code></a> for the component. <br> The <a href="../../api/core/changedetectorref"><code>ChangeDetectorRef</code></a> is most valuable when testing a component that has the <a href="../../api/core/changedetectionstrategy#OnPush"><code>ChangeDetectionStrategy.OnPush</code></a> method or the component's change detection is under your programmatic control.</td> </tr> </tbody> </table> </div> <h3 id="componentfixture-methods"> ComponentFixture methods </h3> <p>The <em>fixture</em> methods cause Angular to perform certain tasks on the component tree. Call these method to trigger Angular behavior in response to simulated user action.</p> <p>Here are the most useful methods for testers.</p> <div class="docs-table docs-scroll-track-transparent"> <table> <thead> <tr> <th align="left">Methods</th> <th align="left">Details</th> </tr> </thead> <tbody> <tr> <td align="left"><code>detectChanges</code></td> <td align="left">Trigger a change detection cycle for the component. <br> Call it to initialize the component (it calls <code>ngOnInit</code>) and after your test code, change the component's data bound property values. Angular can't see that you've changed <code>personComponent.name</code> and won't update the <code>name</code> binding until you call <code>detectChanges</code>. <br> Runs <code>checkNoChanges</code> afterwards to confirm that there are no circular updates unless called as <code>detectChanges(false)</code>;</td> </tr> <tr> <td align="left"><code>autoDetectChanges</code></td> <td align="left">Set this to <code>true</code> when you want the fixture to detect changes automatically. <br> When autodetect is <code>true</code>, the test fixture calls <code>detectChanges</code> immediately after creating the component. Then it listens for pertinent zone events and calls <code>detectChanges</code> accordingly. When your test code modifies component property values directly, you probably still have to call <code>fixture.detectChanges</code> to trigger data binding updates. <br> The default is <code>false</code>. Testers who prefer fine control over test behavior tend to keep it <code>false</code>.</td> </tr> <tr> <td align="left"><code>checkNoChanges</code></td> <td align="left">Do a change detection run to make sure there are no pending changes. Throws an exceptions if there are.</td> </tr> <tr> <td align="left"><code>isStable</code></td> <td align="left">If the fixture is currently <em>stable</em>, returns <code>true</code>. If there are async tasks that have not completed, returns <code>false</code>.</td> </tr> <tr> <td align="left"><code>whenStable</code></td> <td align="left">Returns a promise that resolves when the fixture is stable. <br> To resume testing after completion of asynchronous activity or asynchronous change detection, hook that promise. See <a href="components-scenarios#whenstable">whenStable</a>.</td> </tr> <tr> <td align="left"><code>destroy</code></td> <td align="left">Trigger component destruction.</td> </tr> </tbody> </table> </div> <h4 id="debugelement"> DebugElement </h4> <p>The <a href="../../api/core/debugelement"><code>DebugElement</code></a> provides crucial insights into the component's DOM representation.</p> <p>From the test root component's <a href="../../api/core/debugelement"><code>DebugElement</code></a> returned by <code>fixture.debugElement</code>, you can walk (and query) the fixture's entire element and component subtrees.</p> <p>Here are the most useful <a href="../../api/core/debugelement"><code>DebugElement</code></a> members for testers, in approximate order of utility:</p> <div class="docs-table docs-scroll-track-transparent"> <table> <thead> <tr> <th align="left">Members</th> <th align="left">Details</th> </tr> </thead> <tbody> <tr> <td align="left"><code>nativeElement</code></td> <td align="left">The corresponding DOM element in the browser</td> </tr> <tr> <td align="left"><a href="../../api/animations/query"><code>query</code></a></td> <td align="left">Calling <code>query(predicate: Predicate&lt;DebugElement&gt;)</code> returns the first <a href="../../api/core/debugelement"><code>DebugElement</code></a> that matches the predicate at any depth in the subtree.</td> </tr> <tr> <td align="left"><code>queryAll</code></td> <td align="left">Calling <code>queryAll(predicate: Predicate&lt;DebugElement&gt;)</code> returns all <code>DebugElements</code> that matches the predicate at any depth in subtree.</td> </tr> <tr> <td align="left"><code>injector</code></td> <td align="left">The host dependency injector. For example, the root element's component instance injector.</td> </tr> <tr> <td align="left"><code>componentInstance</code></td> <td align="left">The element's own component instance, if it has one.</td> </tr> <tr> <td align="left"><code>context</code></td> <td align="left">An object that provides parent context for this element. Often an ancestor component instance that governs this element. <br> When an element is repeated within <code>@for</code> block, the context is an <code>RepeaterContext</code> whose <code>$implicit</code> property is the value of the row instance value. For example, the <code>hero</code> in <code>@for(hero of heroes; ...)</code>.</td> </tr> <tr> <td align="left"><code>children</code></td> <td align="left">The immediate <a href="../../api/core/debugelement"><code>DebugElement</code></a> children. Walk the tree by descending through <code>children</code>. <a href="../../api/core/debugelement"><code>DebugElement</code></a> also has <code>childNodes</code>, a list of <a href="../../api/core/debugnode"><code>DebugNode</code></a> objects. <a href="../../api/core/debugelement"><code>DebugElement</code></a> derives from <a href="../../api/core/debugnode"><code>DebugNode</code></a> objects and there are often more nodes than elements. Testers can usually ignore plain nodes.</td> </tr> <tr> <td align="left"><code>parent</code></td> <td align="left">The <a href="../../api/core/debugelement"><code>DebugElement</code></a> parent. Null if this is the root element.</td> </tr> <tr> <td align="left"><code>name</code></td> <td align="left">The element tag name, if it is an element.</td> </tr> <tr> <td align="left"><code>triggerEventHandler</code></td> <td align="left">Triggers the event by its name if there is a corresponding listener in the element's <code>listeners</code> collection. The second parameter is the <em>event object</em> expected by the handler. See <a href="components-scenarios#trigger-event-handler">triggerEventHandler</a>. <br> If the event lacks a listener or there's some other problem, consider calling <code>nativeElement.dispatchEvent(eventObject)</code>.</td> </tr> <tr> <td align="left"><code>listeners</code></td> <td align="left">The callbacks attached to the component's <a href="../../api/core/output"><code>@Output</code></a> properties and/or the element's event properties.</td> </tr> <tr> <td align="left"><code>providerTokens</code></td> <td align="left">This component's injector lookup tokens. Includes the component itself plus the tokens that the component lists in its <code>providers</code> metadata.</td> </tr> <tr> <td align="left"><code>source</code></td> <td align="left">Where to find this element in the source component template.</td> </tr> <tr> <td align="left"><code>references</code></td> <td align="left">Dictionary of objects associated with template local variables (for example, <code>#foo</code>), keyed by the local variable name.</td> </tr> </tbody> </table> </div> <p>The <a href="../../api/core/debugelement#query(predicate)"><code>DebugElement.query(predicate)</code></a> and <a href="../../api/core/debugelement#queryAll(predicate)"><code>DebugElement.queryAll(predicate)</code></a> methods take a predicate that filters the source element's subtree for matching <a href="../../api/core/debugelement"><code>DebugElement</code></a>.</p> <p>The predicate is any method that takes a <a href="../../api/core/debugelement"><code>DebugElement</code></a> and returns a <em>truthy</em> value. The following example finds all <code>DebugElements</code> with a reference to a template local variable named "content":</p> <pre data-language="ts">// Filter for DebugElements with a #content reference
      const contentRefs = el.queryAll((de) =&gt; de.references['content']);</pre>
<p>The Angular <a href="../../api/platform-browser/by"><code>By</code></a> class has three static methods for common predicates:</p> <div class="docs-table docs-scroll-track-transparent"> <table> <thead> <tr> <th align="left">Static method</th> <th align="left">Details</th> </tr> </thead> <tbody> <tr> <td align="left"><a href="../../api/platform-browser/by#all"><code>By.all</code></a></td> <td align="left">Return all elements</td> </tr> <tr> <td align="left"><a href="../../api/platform-browser/by#css(selector)"><code>By.css(selector)</code></a></td> <td align="left">Return elements with matching CSS selectors</td> </tr> <tr> <td align="left"><a href="../../api/platform-browser/by#directive(directive)"><code>By.directive(directive)</code></a></td> <td align="left">Return elements that Angular matched to an instance of the directive class</td> </tr> </tbody> </table> </div> <pre data-language="ts">// Can find DebugElement either by css selector or by directive
    const h2 = fixture.debugElement.query(By.css('h2'));
    const directive = fixture.debugElement.query(By.directive(HighlightDirective));</pre><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/guide/testing/utility-apis" class="_attribution-link">https://angular.dev/guide/testing/utility-apis</a>
  </p>
</div>
