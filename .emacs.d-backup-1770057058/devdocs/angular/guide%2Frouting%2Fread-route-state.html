<h1 tabindex="-1">Read route state</h1> <header class="docs-header"> <docs-breadcrumb ng-version="21.0.3" _nghost-ng-c3945279308 ngh="8"></docs-breadcrumb>   </header> <p>Angular Router allows you to read and use information associated with a route to create responsive and context-aware components.</p> <h2 id="get-information-about-the-current-route-with-activatedroute"> Get information about the current route with ActivatedRoute </h2> <p><a href="../../api/router/activatedroute"><code>ActivatedRoute</code></a> is a service from <code>@angular/router</code> that provides all the information associated with the current route.</p> <pre data-language="ts">import { Component } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  selector: 'app-product',
})
export class ProductComponent {
  private activatedRoute = inject(ActivatedRoute);

  constructor() {
    console.log(this.activatedRoute);
  }
}</pre>
<p>The <a href="../../api/router/activatedroute"><code>ActivatedRoute</code></a> can provide different information about the route. Some common properties include:</p> <div class="docs-table docs-scroll-track-transparent"> <table> <thead> <tr> <th align="left">Property</th> <th align="left">Details</th> </tr> </thead> <tbody> <tr> <td align="left"><code>url</code></td> <td align="left">An <code>Observable</code> of the route paths, represented as an array of strings for each part of the route path.</td> </tr> <tr> <td align="left"><code>data</code></td> <td align="left">An <code>Observable</code> that contains the <code>data</code> object provided for the route. Also contains any resolved values from the resolve guard.</td> </tr> <tr> <td align="left"><code>params</code></td> <td align="left">An <code>Observable</code> that contains the required and optional parameters specific to the route.</td> </tr> <tr> <td align="left"><code>queryParams</code></td> <td align="left">An <code>Observable</code> that contains the query parameters available to all routes.</td> </tr> </tbody> </table> </div> <p>Check out the <a href="../../api/router/activatedroute"><code>ActivatedRoute</code></a> API docs for a complete list of what you can access with in the route.</p> <h2 id="understanding-route-snapshots"> Understanding route snapshots </h2> <p>Page navigations are events over time, and you can access the router state at a given time by retrieving a route snapshot.</p> <p>Route snapshots contain essential information about the route, including its parameters, data, and child routes. In addition, snapshots are static and will not reflect future changes.</p> <p>Here’s an example of how you’d access a route snapshot:</p> <pre data-language="ts">import { ActivatedRoute, ActivatedRouteSnapshot } from '@angular/router';

@Component({ ... })
export class UserProfileComponent {
  readonly userId: string;
  private route = inject(ActivatedRoute);

  constructor() {
    // Example URL: https://www.angular.dev/users/123?role=admin&amp;status=active#contact

    // Access route parameters from snapshot
    this.userId = this.route.snapshot.paramMap.get('id');

    // Access multiple route elements
    const snapshot = this.route.snapshot;
    console.log({
      url: snapshot.url,           // https://www.angular.dev
      // Route parameters object: {id: '123'}
      params: snapshot.params,
      // Query parameters object: {role: 'admin', status: 'active'}
      queryParams: snapshot.queryParams,  // Query parameters
    });
  }
}</pre>
<p>Check out the <a href="../../api/router/activatedroute"><code>ActivatedRoute</code></a> API docs and <a href="../../api/router/activatedroutesnapshot"><code>ActivatedRouteSnapshot</code></a> API docs for a complete list of all properties you can access.</p> <h2 id="reading-parameters-on-a-route"> Reading parameters on a route </h2> <p>There are two types of parameters that developers can utilize from a route: route and query parameters.</p> <h3 id="route-parameters"> Route Parameters </h3> <p>Route parameters allow you to pass data to a component through the URL. This is useful when you want to display specific content based on an identifier in the URL, like a user ID or a product ID.</p> <p>You can <a href="define-routes#define-url-paths-with-route-parameters">define route parameters</a> by prefixing the parameter name with a colon (<code>:</code>).</p> <pre data-language="ts">import { Routes } from '@angular/router';
import { ProductComponent } from './product/product.component';

const routes: Routes = [
  { path: 'product/:id', component: ProductComponent }
];</pre>
<p>You can access parameters by subscribing to <code>route.params</code>.</p> <pre data-language="ts">import { Component, inject, signal } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component({
  selector: 'app-product-detail',
  template: `&lt;h1&gt;Product Details: {{ productId() }}&lt;/h1&gt;`,
})
export class ProductDetailComponent {
  productId = signal('');
  private activatedRoute = inject(ActivatedRoute);

  constructor() {
    // Access route parameters
    this.activatedRoute.params.subscribe((params) =&gt; {
      this.productId.set(params['id']);
    });
  }
}</pre> <h3 id="query-parameters"> Query Parameters </h3> <p><a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams" target="_blank">Query parameters</a> provide a flexible way to pass optional data through URLs without affecting the route structure. Unlike route parameters, query parameters can persist across navigation events and are perfect for handling filtering, sorting, pagination, and other stateful UI elements.</p> <pre data-language="ts">// Single parameter structure
// /products?category=electronics
router.navigate(['/products'], {
  queryParams: { category: 'electronics' }
});

// Multiple parameters
// /products?category=electronics&amp;sort=price&amp;page=1
router.navigate(['/products'], {
  queryParams: {
    category: 'electronics',
    sort: 'price',
    page: 1
  }
});</pre>
<p>You can access query parameters with <code>route.queryParams</code>.</p> <p>Here is an example of a <code>ProductListComponent</code> that updates the query parameters that affect how it displays a list of products:</p> <pre data-language="ts">import { ActivatedRoute, Router } from '@angular/router';

@Component({
  selector: 'app-product-list',
  template: `
    &lt;div&gt;
      &lt;select (change)="updateSort($event)"&gt;
        &lt;option value="price"&gt;Price&lt;/option&gt;
        &lt;option value="name"&gt;Name&lt;/option&gt;
      &lt;/select&gt;
      &lt;!-- Products list --&gt;
    &lt;/div&gt;
  `
})
export class ProductListComponent implements OnInit {
  private route = inject(ActivatedRoute);
  private router = inject(Router);

  constructor() {
    // Access query parameters reactively
    this.route.queryParams.subscribe(params =&gt; {
      const sort = params['sort'] || 'price';
      const page = Number(params['page']) || 1;
      this.loadProducts(sort, page);
    });
  }

  updateSort(event: Event) {
    const sort = (event.target as HTMLSelectElement).value;
    // Update URL with new query parameter
    this.router.navigate([], {
      queryParams: { sort },
      queryParamsHandling: 'merge' // Preserve other query parameters
    });
  }
}</pre>
<p>In this example, users can use a select element to sort the product list by name or price. The associated change handler updates the URL’s query parameters, which in turn triggers a change event that can read the updated query parameters and update the product list.</p> <p>For more information, check out the <a href="../../api/router/queryparamshandling">official docs on QueryParamsHandling</a>.</p> <h3 id="matrix-parameters"> Matrix Parameters </h3> <p>Matrix parameters are optional parameters that belong to a specific URL segment, rather than applying to the entire route. Unlike query parameters which appear after a <code>?</code> and apply globally, matrix parameters use semicolons (<code>;</code>) and are scoped to individual path segments.</p> <p>Matrix parameters are useful when you need to pass auxiliary data to a specific route segment without affecting the route definition or matching behavior. Like query parameters, they don't need to be defined in your route configuration.</p> <pre data-language="ts">// URL format: /path;key=value
// Multiple parameters: /path;key1=value1;key2=value2

// Navigate with matrix parameters
this.router.navigate(['/awesome-products', { view: 'grid', filter: 'new' }]);
// Results in URL: /awesome-products;view=grid;filter=new</pre>
<p><strong>Using ActivatedRoute</strong></p> <pre data-language="ts">import { Component, inject } from '@angular/core';
import { ActivatedRoute } from '@angular/router';

@Component(/* ... */)
export class AwesomeProducts  {
  private route = inject(ActivatedRoute);

  constructor() {
    // Access matrix parameters via params
    this.route.params.subscribe((params) =&gt; {
      const view = params['view']; // e.g., 'grid'
      const filter = params['filter']; // e.g., 'new'
    });
  }
}</pre>

<div class="docs-alert docs-alert-note"> <p><strong>NOTE:</strong> As an alternative to using <a href="../../api/router/activatedroute"><code>ActivatedRoute</code></a>, matrix parameters are also bound to component inputs when using the <a href="../../api/router/withcomponentinputbinding"><code>withComponentInputBinding</code></a>.</p> </div>  <h2 id="detect-active-current-route-with-routerlinkactive"> Detect active current route with RouterLinkActive </h2> <p>You can use the <a href="../../api/router/routerlinkactive"><code>RouterLinkActive</code></a> directive to dynamically style navigation elements based on the current active route. This is common in navigation elements to inform users what the active route is.</p> <pre data-language="ts">&lt;nav&gt;
  &lt;a class="button"
     routerLink="/about"
     routerLinkActive="active-button"
     ariaCurrentWhenActive="page"&gt;
    About
  &lt;/a&gt; |
  &lt;a class="button"
     routerLink="/settings"
     routerLinkActive="active-button"
     ariaCurrentWhenActive="page"&gt;
    Settings
  &lt;/a&gt;
&lt;/nav&gt;</pre>
<p>In this example, Angular Router will apply the <code>active-button</code> class to the correct anchor link and <code>ariaCurrentWhenActive</code> to <code>page</code> when the URL matches the corresponding <code>routerLink</code>.</p> <p>If you need to add multiple classes onto the element, you can use either a space-separated string or an array:</p> <pre data-language="ts">&lt;!-- Space-separated string syntax --&gt;
&lt;a routerLink="/user/bob" routerLinkActive="class1 class2"&gt;Bob&lt;/a&gt;

&lt;!-- Array syntax --&gt;
&lt;a routerLink="/user/bob" [routerLinkActive]="['class1', 'class2']"&gt;Bob&lt;/a&gt;</pre>
<p>When you specify a value for routerLinkActive, you are also defining the same value for <code>ariaCurrentWhenActive</code>. This makes sure that visually impaired users (which may not perceive the different styling being applied) can also identify the active button.</p> <p>If you want to define a different value for aria, you’ll need to explicitly set the value using the <code>ariaCurrentWhenActive</code> directive.</p> <h3 id="route-matching-strategy"> Route matching strategy </h3> <p>By default, <a href="../../api/router/routerlinkactive"><code>RouterLinkActive</code></a> considers any ancestors in the route a match.</p> <pre data-language="ts">&lt;a [routerLink]="['/user/jane']" routerLinkActive="active-link"&gt;
  User
&lt;/a&gt;
&lt;a [routerLink]="['/user/jane/role/admin']" routerLinkActive="active-link"&gt;
  Role
&lt;/a&gt;</pre>
<p>When the user visits <code>/user/jane/role/admin</code>, both links would have the <code>active-link</code> class.</p> <h3 id="only-apply-routerlinkactive-on-exact-route-matches"> Only apply RouterLinkActive on exact route matches </h3> <p>If you only want to apply the class on an exact match, you need to provide the <code>routerLinkActiveOptions</code> directive with a configuration object that contains the value <code>exact: true</code>.</p> <pre data-language="ts">&lt;a [routerLink]="['/user/jane']"
  routerLinkActive="active-link"
  [routerLinkActiveOptions]="{exact: true}"
&gt;
  User
&lt;/a&gt;
&lt;a [routerLink]="['/user/jane/role/admin']"
  routerLinkActive="active-link"
  [routerLinkActiveOptions]="{exact: true}"
&gt;
  Role
&lt;/a&gt;</pre>
<p>If you want to be more precise in how a route is matched, it’s worth noting that <code>exact: true</code> is actually syntactic sugar for the full set of matching options:</p> <pre data-language="ts">// `exact: true` is equivalent to
{
  paths: 'exact',
  fragment: 'ignored',
  matrixParams: 'ignored',
  queryParams: 'exact',
}

// `exact: false` is equivalent
{
  paths: 'subset',
  fragment: 'ignored',
  matrixParams: 'ignored',
  queryParams: 'subset',
}</pre>
<p>For more information, check out the official docs for <a href="../../api/router/isactivematchoptions">isActiveMatchOptions</a>.</p> <h3 id="apply-routerlinkactive-to-an-ancestor"> Apply RouterLinkActive to an ancestor </h3> <p>The RouterLinkActive directive can also be applied to an ancestor element in order to allow developers to style the elements as desired.</p> <pre data-language="ts">&lt;div routerLinkActive="active-link" [routerLinkActiveOptions]="{exact: true}"&gt;
  &lt;a routerLink="/user/jim"&gt;Jim&lt;/a&gt;
  &lt;a routerLink="/user/bob"&gt;Bob&lt;/a&gt;
&lt;/div&gt;</pre>
<p>For more information, check out the <a href="../../api/router/routerlinkactive">API docs for RouterLinkActive</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/guide/routing/read-route-state" class="_attribution-link">https://angular.dev/guide/routing/read-route-state</a>
  </p>
</div>
