<h1 tabindex="-1">Angular without ZoneJS (Zoneless)</h1> <header class="docs-header"> <docs-breadcrumb ng-version="21.0.3" _nghost-ng-c3945279308 ngh="8"></docs-breadcrumb>   </header> <h2 id="why-use-zoneless"> Why use Zoneless? </h2> <p>The main advantages to removing ZoneJS as a dependency are:</p> <ul class="docs-list"> <li>
<strong>Improved performance</strong>: ZoneJS uses DOM events and async tasks as indicators of when application state <em>might</em> have updated and subsequently triggers application synchronization to run change detection on the application's views. ZoneJS does not have any insight into whether application state actually changed and so this synchronization is triggered more frequently than necessary.</li> <li>
<strong>Improved Core Web Vitals</strong>: ZoneJS brings a fair amount of overhead, both in payload size and in startup time cost.</li> <li>
<strong>Improved debugging experience</strong>: ZoneJS makes debugging code more difficult. Stack traces are harder to understand with ZoneJS. It's also difficult to understand when code breaks as a result of being outside the Angular Zone.</li> <li>
<strong>Better ecosystem compatibility</strong>: ZoneJS works by patching browser APIs but does not automatically have patches for every new browser API. Some APIs cannot be patched effectively, such as <code>async</code>/<code>await</code>, and have to be downleveled to work with ZoneJS. Sometimes libraries in the ecosystem are also incompatible with the way ZoneJS patches the native APIs. Removing ZoneJS as a dependency ensures better long-term compatibility by removing a source of complexity, monkey patching, and ongoing maintenance.</li> </ul> <h2 id="enabling-zoneless-in-an-application"> Enabling Zoneless in an application </h2> <pre data-language="ts">// standalone bootstrap
bootstrapApplication(MyApp, {providers: [
  provideZonelessChangeDetection(),
]});

// NgModule bootstrap
platformBrowser().bootstrapModule(AppModule);
@NgModule({
  providers: [provideZonelessChangeDetection()]
})
export class AppModule {}</pre> <h2 id="removing-zonejs"> Removing ZoneJS </h2> <p>Zoneless applications should remove ZoneJS entirely from the build to reduce bundle size. ZoneJS is typically loaded via the <code>polyfills</code> option in <code>angular.json</code>, both in the <code>build</code> and <code>test</code> targets. Remove <code>zone.js</code> and <code>zone.js/testing</code> from both to remove it from the build. Projects which use an explicit <code>polyfills.ts</code> file should remove <code>import 'zone.js';</code> and <code>import 'zone.js/testing';</code> from the file.</p> <p>After removing ZoneJS from the build, there is no longer a need for a <code>zone.js</code> dependency either and the package can be removed entirely:</p> <pre data-language="ts">npm uninstall zone.js</pre> <h2 id="requirements-for-zoneless-compatibility"> Requirements for Zoneless compatibility </h2> <p>Angular relies on notifications from core APIs in order to determine when to run change detection and on which views. These notifications include:</p> <ul class="docs-list"> <li>
<a href="../api/core/changedetectorref#markForCheck"><code>ChangeDetectorRef.markForCheck</code></a> (called automatically by <a href="../api/common/asyncpipe"><code>AsyncPipe</code></a>)</li> <li><a href="../api/core/componentref#setInput"><code>ComponentRef.setInput</code></a></li> <li>Updating a signal that's read in a template</li> <li>Bound host or template listeners callbacks</li> <li>Attaching a view that was marked dirty by one of the above</li> </ul> <h3 id="onpush-compatible-components"> OnPush-compatible components </h3> <p>One way to ensure that a component is using the correct notification mechanisms from above is to use <a href="https://angular.dev/best-practices/skipping-subtrees#using-onpush">ChangeDetectionStrategy.OnPush</a>.</p> <p>The <code>OnPush</code> change detection strategy is not required, but it is a recommended step towards zoneless compatibility for application components. It is not always possible for library components to use <a href="../api/core/changedetectionstrategy#OnPush"><code>ChangeDetectionStrategy.OnPush</code></a>. When a library component is a host for user-components which might use <a href="../api/core/changedetectionstrategy#Default"><code>ChangeDetectionStrategy.Default</code></a>, it cannot use <code>OnPush</code> because that would prevent the child component from being refreshed if it is not <code>OnPush</code> compatible and relies on ZoneJS to trigger change detection. Components can use the <code>Default</code> strategy as long as they notify Angular when change detection needs to run (calling <code>markForCheck</code>, using signals, <a href="../api/common/asyncpipe"><code>AsyncPipe</code></a>, etc.). Being a host for a user component means using an API such as <a href="../api/core/viewcontainerref#createComponent"><code>ViewContainerRef.createComponent</code></a> and not just hosting a portion of a template from a user component (i.e. content projection or a using a template ref input).</p> <h3 id="remove-ngzoneonmicrotaskempty-ngzoneonunstable-ngzoneisstable-or-ngzoneonstable"> Remove NgZone.onMicrotaskEmpty, NgZone.onUnstable, NgZone.isStable, or NgZone.onStable </h3> <p>Applications and libraries need to remove uses of <a href="../api/core/ngzone#onMicrotaskEmpty"><code>NgZone.onMicrotaskEmpty</code></a>, <a href="../api/core/ngzone#onUnstable"><code>NgZone.onUnstable</code></a> and <a href="../api/core/ngzone#onStable"><code>NgZone.onStable</code></a>. These observables will never emit when an Application enables zoneless change detection. Similarly, <a href="../api/core/ngzone#isStable"><code>NgZone.isStable</code></a> will always be <code>true</code> and should not be used as a condition for code execution.</p> <p>The <a href="../api/core/ngzone#onMicrotaskEmpty"><code>NgZone.onMicrotaskEmpty</code></a> and <a href="../api/core/ngzone#onStable"><code>NgZone.onStable</code></a> observables are most often used to wait for Angular to complete change detection before performing a task. Instead, these can be replaced by <a href="../api/core/afternextrender"><code>afterNextRender</code></a> if they need to wait for a single change detection or <a href="../api/core/aftereveryrender"><code>afterEveryRender</code></a> if there is some condition that might span several change detection rounds. In other cases, these observables were used because they happened to be familiar and have similar timing to what was needed. More straightforward or direct DOM APIs can be used instead, such as <code>MutationObserver</code> when code needs to wait for certain DOM state (rather than waiting for it indirectly through Angular's render hooks).</p> <div class="docs-callout docs-callout-helpful"> <h3>NgZone.run and NgZone.runOutsideAngular are compatible with Zoneless</h3> <p><a href="../api/core/ngzone#run"><code>NgZone.run</code></a> and <a href="../api/core/ngzone#runOutsideAngular"><code>NgZone.runOutsideAngular</code></a> do not need to be removed in order for code to be compatible with Zoneless applications. In fact, removing these calls can lead to performance regressions for libraries that are used in applications that still rely on ZoneJS.</p> </div> <h3 id="pendingtasks-for-server-side-rendering-ssr"> PendingTasks for Server Side Rendering (SSR) </h3> <p>If you are using SSR with Angular, you may know that it relies on ZoneJS to help determine when the application is "stable" and can be serialized. If there are asynchronous tasks that should prevent serialization, an application not using ZoneJS must make Angular aware of these with the <a href="../api/core/pendingtasks">PendingTasks</a> service. Serialization will wait for the first moment that all pending tasks have been removed.</p> <p>The two most straightforward uses of pending tasks are the <code>run</code> method:</p> <pre data-language="ts">const taskService = inject(PendingTasks);
taskService.run(async () =&gt; {
  const someResult = await doSomeWorkThatNeedsToBeRendered();
  this.someState.set(someResult);
});</pre>
<p>For more complicated use-cases, you can manually add and remove a pending task:</p> <pre data-language="ts">const taskService = inject(PendingTasks);
const taskCleanup = taskService.add();
try {
  await doSomeWorkThatNeedsToBeRendered();
} catch {
  // handle error
} finally {
  taskCleanup();
}</pre>
<p>In addition, the <a href="../api/core/rxjs-interop/pendinguntilevent#">pendingUntilEvent</a> helper in <code>rxjs-interop</code> ensures the application remains unstable until the observable emits, completes, errors, or is unsubscribed.</p> <pre data-language="ts">readonly myObservableState = someObservable.pipe(pendingUntilEvent());</pre>
<p>The framework uses this service internally as well to prevent serialization until asynchronous tasks are complete. These include, but are not limited to, an ongoing Router navigation and an incomplete <a href="../api/common/http/httpclient"><code>HttpClient</code></a> request.</p> <h2 id="testing-and-debugging"> Testing and Debugging </h2> <h3 id="using-zoneless-in-testbed"> Using Zoneless in TestBed </h3> <p>The zoneless provider function can also be used with <a href="../api/core/testing/testbed"><code>TestBed</code></a> to help ensure the components under test are compatible with a Zoneless Angular application.</p> <pre data-language="ts">TestBed.configureTestingModule({
  providers: [provideZonelessChangeDetection()]
});

const fixture = TestBed.createComponent(MyComponent);
await fixture.whenStable();</pre>
<p>To ensure tests have the most similar behavior to production code, avoid using <code>fixture.detectChanges()</code> when possible. This forces change detection to run when Angular might otherwise have not scheduled change detection. Tests should ensure these notifications are happening and allow Angular to handle when to synchronize state rather than manually forcing it to happen in the test.</p> <p>For existing test suites, using <code>fixture.detectChanges()</code> is a common pattern and it is likely not worth the effort of converting these to <code>await fixture.whenStable()</code>. <a href="../api/core/testing/testbed"><code>TestBed</code></a> will still enforce that the fixture's component is <code>OnPush</code> compatible and throws <code>ExpressionChangedAfterItHasBeenCheckedError</code> if it finds that template values were updated without a change notification (i.e. <code>fixture.componentInstance.someValue = 'newValue';</code>). If the component is used in production, this issue should be addressed by updating the component to use signals for state or call <a href="../api/core/changedetectorref#markForCheck"><code>ChangeDetectorRef.markForCheck()</code></a>. If the component is only used as a test wrapper and never used in an application, it is acceptable to use <code>fixture.changeDetectorRef.markForCheck()</code>.</p> <h3 id="debug-mode-check-to-ensure-updates-are-detected"> Debug-mode check to ensure updates are detected </h3> <p>Angular also provides an additional tool to help verify that an application is making updates to state in a zoneless-compatible way. <code>provideCheckNoChangesConfig({exhaustive: true, interval: &lt;milliseconds&gt;})</code> can be used to periodically check to ensure that no bindings have been updated without a notification. Angular throws <code>ExpressionChangedAfterItHasBeenCheckedError</code> if there is an updated binding that would not have refreshed by the zoneless change detection.</p><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/guide/zoneless" class="_attribution-link">https://angular.dev/guide/zoneless</a>
  </p>
</div>
