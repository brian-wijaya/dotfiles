<h1 tabindex="-1">Test requests</h1> <header class="docs-header"> <docs-breadcrumb ng-version="21.0.3" _nghost-ng-c3945279308 ngh="8"></docs-breadcrumb>   </header> <p>As for any external dependency, you must mock the HTTP backend so your tests can simulate interaction with a remote server. The <code>@angular/common/http/testing</code> library provides tools to capture requests made by the application, make assertions about them, and mock the responses to emulate your backend's behavior.</p> <p>The testing library is designed for a pattern in which the app executes code and makes requests first. The test then expects that certain requests have or have not been made, performs assertions against those requests, and finally provides responses by "flushing" each expected request.</p> <p>At the end, tests can verify that the app made no unexpected requests.</p> <h2 id="setup-for-testing"> Setup for testing </h2> <p>To begin testing usage of <a href="../../api/common/http/httpclient"><code>HttpClient</code></a>, configure <a href="../../api/core/testing/testbed"><code>TestBed</code></a> and include <a href="../../api/common/http/providehttpclient"><code>provideHttpClient()</code></a> and <a href="../../api/common/http/testing/providehttpclienttesting"><code>provideHttpClientTesting()</code></a> in your test's setup. This configures <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> to use a test backend instead of the real network. It also provides <a href="../../api/common/http/testing/httptestingcontroller"><code>HttpTestingController</code></a>, which you'll use to interact with the test backend, set expectations about which requests have been made, and flush responses to those requests. <a href="../../api/common/http/testing/httptestingcontroller"><code>HttpTestingController</code></a> can be injected from <a href="../../api/core/testing/testbed"><code>TestBed</code></a> once configured.</p> 
<div class="docs-alert docs-alert-important"> <p><strong>IMPORTANT:</strong> Keep in mind to provide <a href="../../api/common/http/providehttpclient"><code>provideHttpClient()</code></a> <strong>before</strong> <a href="../../api/common/http/testing/providehttpclienttesting"><code>provideHttpClientTesting()</code></a>, as <a href="../../api/common/http/testing/providehttpclienttesting"><code>provideHttpClientTesting()</code></a> will overwrite parts of <a href="../../api/common/http/providehttpclient"><code>provideHttpClient()</code></a>. Doing it the other way around can potentially break your tests.</p> </div>  <pre data-language="ts">TestBed.configureTestingModule({
  providers: [
    // ... other test providers
    provideHttpClient(),
    provideHttpClientTesting(),
  ],
});

const httpTesting = TestBed.inject(HttpTestingController);</pre>
<p>Now when your tests make requests, they will hit the testing backend instead of the normal one. You can use <code>httpTesting</code> to make assertions about those requests.</p> <h2 id="expecting-and-answering-requests"> Expecting and answering requests </h2> <p>For example, you can write a test that expects a GET request to occur and provides a mock response:</p> <pre data-language="ts">TestBed.configureTestingModule({
  providers: [
    ConfigService,
    provideHttpClient(),
    provideHttpClientTesting(),
  ],
});

const httpTesting = TestBed.inject(HttpTestingController);

// Load `ConfigService` and request the current configuration.
const service = TestBed.inject(ConfigService);
const config$ = service.getConfig&lt;Config&gt;();

// `firstValueFrom` subscribes to the `Observable`, which makes the HTTP request,
// and creates a `Promise` of the response.
const configPromise = firstValueFrom(config$);

// At this point, the request is pending, and we can assert it was made
// via the `HttpTestingController`:
const req = httpTesting.expectOne('/api/config', 'Request to load the configuration');

// We can assert various properties of the request if desired.
expect(req.request.method).toBe('GET');

// Flushing the request causes it to complete, delivering the result.
req.flush(DEFAULT_CONFIG);

// We can then assert that the response was successfully delivered by the `ConfigService`:
expect(await configPromise).toEqual(DEFAULT_CONFIG);

// Finally, we can assert that no other requests were made.
httpTesting.verify();</pre>

<div class="docs-alert docs-alert-note"> <p><strong>NOTE:</strong> <code>expectOne</code> will fail if the test has made more than one request which matches the given criteria.</p> </div>  <p>As an alternative to asserting on <code>req.method</code>, you could instead use an expanded form of <code>expectOne</code> to also match the request method:</p> <pre data-language="ts">const req = httpTesting.expectOne({
  method: 'GET',
  url: '/api/config',
}, 'Request to load the configuration');</pre>

<div class="docs-alert docs-alert-helpful"> <p><strong>HELPFUL:</strong> The expectation APIs match against the full URL of requests, including any query parameters.</p> </div>  <p>The last step, verifying that no requests remain outstanding, is common enough for you to move it into an <code>afterEach()</code> step:</p> <pre data-language="ts">afterEach(() =&gt; {
  // Verify that none of the tests make any extra HTTP requests.
  TestBed.inject(HttpTestingController).verify();
});</pre> <h2 id="handling-more-than-one-request-at-once"> Handling more than one request at once </h2> <p>If you need to respond to duplicate requests in your test, use the <code>match()</code> API instead of <code>expectOne()</code>. It takes the same arguments but returns an array of matching requests. Once returned, these requests are removed from future matching and you are responsible for flushing and verifying them.</p> <pre data-language="ts">const allGetRequests = httpTesting.match({method: 'GET'});
for (const req of allGetRequests) {
  // Handle responding to each request.
}</pre> <h2 id="advanced-matching"> Advanced matching </h2> <p>All matching functions accept a predicate function for custom matching logic:</p> <pre data-language="ts">// Look for one request that has a request body.
const requestsWithBody = httpTesting.expectOne(req =&gt; req.body !== null);</pre>
<p>The <code>expectNone</code> function asserts that no requests match the given criteria.</p> <pre data-language="ts">// Assert that no mutation requests have been issued.
httpTesting.expectNone(req =&gt; req.method !== 'GET');</pre> <h2 id="testing-error-handling"> Testing error handling </h2> <p>You should test your app's responses when HTTP requests fail.</p> <h3 id="backend-errors"> Backend errors </h3> <p>To test handling of backend errors (when the server returns a non-successful status code), flush requests with an error response that emulates what your backend would return when a request fails.</p> <pre data-language="ts">const req = httpTesting.expectOne('/api/config');
req.flush('Failed!', {status: 500, statusText: 'Internal Server Error'});

// Assert that the application successfully handled the backend error.</pre> <h3 id="network-errors"> Network errors </h3> <p>Requests can also fail due to network errors, which surface as <code>ProgressEvent</code> errors. These can be delivered with the <code>error()</code> method:</p> <pre data-language="ts">const req = httpTesting.expectOne('/api/config');
req.error(new ProgressEvent('network error!'));

// Assert that the application successfully handled the network error.</pre> <h2 id="testing-an-interceptor"> Testing an Interceptor </h2> <p>You should test that your interceptors work under the desired circumstances.</p> <p>For example, an application may be required to add an authentication token generated by a service to each outgoing request. This behavior can be enforced with the use of an interceptor:</p> <pre data-language="ts">export function authInterceptor(request: HttpRequest&lt;unknown&gt;, next: HttpHandlerFn): Observable&lt;HttpEvent&lt;unknown&gt;&gt; {
  const authService = inject(AuthService);

  const clonedRequest = request.clone({
    headers: request.headers.append('X-Authentication-Token', authService.getAuthToken()),
  });
  return next(clonedRequest);
}</pre>
<p>The <a href="../../api/core/testing/testbed"><code>TestBed</code></a> configuration for this interceptor should rely on the <a href="../../api/common/http/withinterceptors"><code>withInterceptors</code></a> feature.</p> <pre data-language="ts">TestBed.configureTestingModule({
  providers: [
    AuthService,
    // Testing one interceptor at a time is recommended.
    provideHttpClient(withInterceptors([authInterceptor])),
    provideHttpClientTesting(),
  ],
});</pre>
<p>The <a href="../../api/common/http/testing/httptestingcontroller"><code>HttpTestingController</code></a> can retrieve the request instance which can then be inspected to ensure that the request was modified.</p> <pre data-language="ts">const service = TestBed.inject(AuthService);
const req = httpTesting.expectOne('/api/config');

expect(req.request.headers.get('X-Authentication-Token')).toEqual(service.getAuthToken());</pre>
<p>A similar interceptor could be implemented with class based interceptors:</p> <pre data-language="ts">@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  private authService = inject(AuthService);

  intercept(request: HttpRequest&lt;unknown&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;unknown&gt;&gt; {
    const clonedRequest = request.clone({
      headers: request.headers.append('X-Authentication-Token', this.authService.getAuthToken()),
    });
    return next.handle(clonedRequest);
  }
}</pre>
<p>In order to test it, the <a href="../../api/core/testing/testbed"><code>TestBed</code></a> configuration should instead be:</p> <pre data-language="ts">TestBed.configureTestingModule({
  providers: [
    AuthService,
    provideHttpClient(withInterceptorsFromDi()),
    provideHttpClientTesting(),
    // We rely on the HTTP_INTERCEPTORS token to register the AuthInterceptor as an HttpInterceptor
    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },
  ],
});</pre><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/guide/http/testing" class="_attribution-link">https://angular.dev/guide/http/testing</a>
  </p>
</div>
