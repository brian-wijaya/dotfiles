<h1 tabindex="-1">Making HTTP requests</h1> <header class="docs-header"> <docs-breadcrumb ng-version="21.0.3" _nghost-ng-c3945279308 ngh="8"></docs-breadcrumb>   </header> <p><a href="../../api/common/http/httpclient"><code>HttpClient</code></a> has methods corresponding to the different HTTP verbs used to make requests, both to load data and to apply mutations on the server. Each method returns an <a href="https://rxjs.dev/guide/observable" target="_blank">RxJS <code>Observable</code></a> which, when subscribed, sends the request and then emits the results when the server responds.</p> 
<div class="docs-alert docs-alert-note"> <p><strong>NOTE:</strong> <code>Observable</code>s created by <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> may be subscribed any number of times and will make a new backend request for each subscription.</p> </div>  <p>Through an options object passed to the request method, various properties of the request and the returned response type can be adjusted.</p> <h2 id="fetching-json-data"> Fetching JSON data </h2> <p>Fetching data from a backend often requires making a GET request using the <a href="../../api/common/http/httpclient#get"><code>HttpClient.get()</code></a> method. This method takes two arguments: the string endpoint URL from which to fetch, and an <em>optional options</em> object to configure the request.</p> <p>For example, to fetch configuration data from a hypothetical API using the <a href="../../api/common/http/httpclient#get"><code>HttpClient.get()</code></a> method:</p> <pre data-language="ts">http.get&lt;Config&gt;('/api/config').subscribe(config =&gt; {
  // process the configuration.
});</pre>
<p>Note the generic type argument which specifies that the data returned by the server will be of type <code>Config</code>. This argument is optional, and if you omit it then the returned data will have type <code>Object</code>.</p> 
<div class="docs-alert docs-alert-tip"> <p><strong>TIP:</strong> When dealing with data of uncertain structure and potential <code>undefined</code> or <code>null</code> values, consider using the <code>unknown</code> type instead of <code>Object</code> as the response type.</p> </div>  
<div class="docs-alert docs-alert-critical"> <p><strong>CRITICAL:</strong> The generic type of request methods is a type <strong>assertion</strong> about the data returned by the server. <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> does not verify that the actual return data matches this type.</p> </div>  <h2 id="fetching-other-types-of-data"> Fetching other types of data </h2> <p>By default, <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> assumes that servers will return JSON data. When interacting with a non-JSON API, you can tell <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> what response type to expect and return when making the request. This is done with the <code>responseType</code> option.</p> <div class="docs-table docs-scroll-track-transparent"> <table> <thead> <tr> <th><strong><code>responseType</code> value</strong></th> <th><strong>Returned response type</strong></th> </tr> </thead> <tbody> <tr> <td>
<code>'json'</code> (default)</td> <td>JSON data of the given generic type</td> </tr> <tr> <td><code>'text'</code></td> <td>string data</td> </tr> <tr> <td><code>'arraybuffer'</code></td> <td>
<a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank"><code>ArrayBuffer</code></a> containing the raw response bytes</td> </tr> <tr> <td><code>'blob'</code></td> <td>
<a href="https://developer.mozilla.org/docs/Web/API/Blob" target="_blank"><code>Blob</code></a> instance</td> </tr> </tbody> </table> </div> <p>For example, you can ask <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> to download the raw bytes of a <code>.jpeg</code> image into an <code>ArrayBuffer</code>:</p> <pre data-language="ts">http.get('/images/dog.jpg', {responseType: 'arraybuffer'}).subscribe(buffer =&gt; {
  console.log('The image is ' + buffer.byteLength + ' bytes large');
});</pre> <div class="docs-callout docs-callout-important"> <h3>Literal value for responseType</h3> <p>Because the value of <code>responseType</code> affects the type returned by <a href="../../api/common/http/httpclient"><code>HttpClient</code></a>, it must have a literal type and not a <code>string</code> type.</p> <p>This happens automatically if the options object passed to the request method is a literal object, but if you're extracting the request options out into a variable or helper method you might need to explicitly specify it as a literal, such as <code>responseType: 'text' as const</code>.</p> </div> <h2 id="mutating-server-state"> Mutating server state </h2> <p>Server APIs which perform mutations often require making POST requests with a request body specifying the new state or the change to be made.</p> <p>The <a href="../../api/common/http/httpclient#post"><code>HttpClient.post()</code></a> method behaves similarly to <code>get()</code>, and accepts an additional <code>body</code> argument before its options:</p> <pre data-language="ts">http.post&lt;Config&gt;('/api/config', newConfig).subscribe(config =&gt; {
  console.log('Updated config:', config);
});</pre>
<p>Many different types of values can be provided as the request's <code>body</code>, and <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> will serialize them accordingly:</p> <div class="docs-table docs-scroll-track-transparent"> <table> <thead> <tr> <th><strong><code>body</code> type</strong></th> <th><strong>Serialized as</strong></th> </tr> </thead> <tbody> <tr> <td>string</td> <td>Plain text</td> </tr> <tr> <td>number, boolean, array, or plain object</td> <td>JSON</td> </tr> <tr> <td><a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank"><code>ArrayBuffer</code></a></td> <td>raw data from the buffer</td> </tr> <tr> <td><a href="https://developer.mozilla.org/docs/Web/API/Blob" target="_blank"><code>Blob</code></a></td> <td>raw data with the <code>Blob</code>'s content type</td> </tr> <tr> <td><a href="https://developer.mozilla.org/docs/Web/API/FormData" target="_blank"><code>FormData</code></a></td> <td>
<code>multipart/form-data</code> encoded data</td> </tr> <tr> <td>
<a href="../../api/common/http/httpparams"><code>HttpParams</code></a> or <a href="https://developer.mozilla.org/docs/Web/API/URLSearchParams" target="_blank"><code>URLSearchParams</code></a>
</td> <td>
<code>application/x-www-form-urlencoded</code> formatted string</td> </tr> </tbody> </table> </div> 
<div class="docs-alert docs-alert-important"> <p><strong>IMPORTANT:</strong> Remember to <code>.subscribe()</code> to mutation request <code>Observable</code>s in order to actually fire the request.</p> </div>  <h2 id="setting-url-parameters"> Setting URL parameters </h2> <p>Specify request parameters that should be included in the request URL using the <code>params</code> option.</p> <p>Passing an object literal is the simplest way of configuring URL parameters:</p> <pre data-language="ts">http.get('/api/config', {
  params: {filter: 'all'},
}).subscribe(config =&gt; {
  // ...
});</pre>
<p>Alternatively, pass an instance of <a href="../../api/common/http/httpparams"><code>HttpParams</code></a> if you need more control over the construction or serialization of the parameters.</p> 
<div class="docs-alert docs-alert-important"> <p><strong>IMPORTANT:</strong> Instances of <a href="../../api/common/http/httpparams"><code>HttpParams</code></a> are <em>immutable</em> and cannot be directly changed. Instead, mutation methods such as <code>append()</code> return a new instance of <a href="../../api/common/http/httpparams"><code>HttpParams</code></a> with the mutation applied.</p> </div>  <pre data-language="ts">const baseParams = new HttpParams().set('filter', 'all');

http.get('/api/config', {
  params: baseParams.set('details', 'enabled'),
}).subscribe(config =&gt; {
  // ...
});</pre>
<p>You can instantiate <a href="../../api/common/http/httpparams"><code>HttpParams</code></a> with a custom <a href="../../api/common/http/httpparametercodec"><code>HttpParameterCodec</code></a> that determines how <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> will encode the parameters into the URL.</p> <h3 id="custom-parameter-encoding"> Custom parameter encoding </h3> <p>By default, <a href="../../api/common/http/httpparams"><code>HttpParams</code></a> uses the built-in <a href="../../api/common/http/httpurlencodingcodec"><code>HttpUrlEncodingCodec</code></a> to encode and decode parameter keys and values.</p> <p>You can provide your own implementation of <a href="../../api/common/http/httpparametercodec"><code>HttpParameterCodec</code></a> to customize how encoding and decoding are applied.</p> <pre data-language="ts">import { HttpClient, HttpParams, HttpParameterCodec } from '@angular/common/http';
import { inject } from '@angular/core';

export class CustomHttpParamEncoder  implements HttpParameterCodec {
  encodeKey(key: string): string   {
    return encodeURIComponent(key);
  }

  encodeValue(value: string): string {
    return encodeURIComponent(value);
  }

  decodeKey(key: string): string {
    return decodeURIComponent(key);
  }

  decodeValue(value: string): string {
    return decodeURIComponent(value);
  }
}

export class ApiService {
  private http = inject(HttpClient);

  search() {
    const params = new HttpParams({
      encoder: new CustomHttpParamEncoder(),
    })
    .set('email', 'dev+alerts@example.com')
    .set('q', 'a &amp; b? c/d = e');

    return this.http.get('/api/items', { params });
  }
}</pre> <h2 id="setting-request-headers"> Setting request headers </h2> <p>Specify request headers that should be included in the request using the <code>headers</code> option.</p> <p>Passing an object literal is the simplest way of configuring request headers:</p> <pre data-language="ts">http.get('/api/config', {
  headers: {
    'X-Debug-Level': 'verbose',
  }
}).subscribe(config =&gt; {
  // ...
});</pre>
<p>Alternatively, pass an instance of <a href="../../api/common/http/httpheaders"><code>HttpHeaders</code></a> if you need more control over the construction of headers</p> 
<div class="docs-alert docs-alert-important"> <p><strong>IMPORTANT:</strong> Instances of <a href="../../api/common/http/httpheaders"><code>HttpHeaders</code></a> are <em>immutable</em> and cannot be directly changed. Instead, mutation methods such as <code>append()</code> return a new instance of <a href="../../api/common/http/httpheaders"><code>HttpHeaders</code></a> with the mutation applied.</p> </div>  <pre data-language="ts">const baseHeaders = new HttpHeaders().set('X-Debug-Level', 'minimal');

http.get&lt;Config&gt;('/api/config', {
  headers: baseHeaders.set('X-Debug-Level', 'verbose'),
}).subscribe(config =&gt; {
  // ...
});</pre> <h2 id="interacting-with-the-server-response-events"> Interacting with the server response events </h2> <p>For convenience, <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> by default returns an <code>Observable</code> of the data returned by the server (the response body). Occasionally it's desirable to examine the actual response, for example to retrieve specific response headers.</p> <p>To access the entire response, set the <code>observe</code> option to <code>'response'</code>:</p> <pre data-language="ts">http.get&lt;Config&gt;('/api/config', {observe: 'response'}).subscribe(res =&gt; {
  console.log('Response status:', res.status);
  console.log('Body:', res.body);
});</pre> <div class="docs-callout docs-callout-important"> <h3>Literal value for observe</h3> <p>Because the value of <code>observe</code> affects the type returned by <a href="../../api/common/http/httpclient"><code>HttpClient</code></a>, it must have a literal type and not a <code>string</code> type.</p> <p>This happens automatically if the options object passed to the request method is a literal object, but if you're extracting the request options out into a variable or helper method you might need to explicitly specify it as a literal, such as <code>observe: 'response' as const</code>.</p> </div> <h2 id="receiving-raw-progress-events"> Receiving raw progress events </h2> <p>In addition to the response body or response object, <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> can also return a stream of raw <em>events</em> corresponding to specific moments in the request lifecycle. These events include when the request is sent, when the response header is returned, and when the body is complete. These events can also include <em>progress events</em> which report upload and download status for large request or response bodies.</p> <p>Progress events are disabled by default (as they have a performance cost) but can be enabled with the <code>reportProgress</code> option.</p> 
<div class="docs-alert docs-alert-note"> <p><strong>NOTE:</strong> The optional <code>fetch</code> implementation of <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> does not report <em>upload</em> progress events.</p> </div>  <p>To observe the event stream, set the <code>observe</code> option to <code>'events'</code>:</p> <pre data-language="ts">http.post('/api/upload', myData, {
  reportProgress: true,
  observe: 'events',
}).subscribe(event =&gt; {
  switch (event.type) {
    case HttpEventType.UploadProgress:
      console.log('Uploaded ' + event.loaded + ' out of ' + event.total + ' bytes');
      break;
    case HttpEventType.Response:
      console.log('Finished uploading!');
      break;
  }
});</pre> <div class="docs-callout docs-callout-important"> <h3>Literal value for observe</h3> <p>Because the value of <code>observe</code> affects the type returned by <a href="../../api/common/http/httpclient"><code>HttpClient</code></a>, it must have a literal type and not a <code>string</code> type.</p> <p>This happens automatically if the options object passed to the request method is a literal object, but if you're extracting the request options out into a variable or helper method you might need to explicitly specify it as a literal, such as <code>observe: 'events' as const</code>.</p> </div> <p>Each <a href="../../api/common/http/httpevent"><code>HttpEvent</code></a> reported in the event stream has a <code>type</code> which distinguishes what the event represents:</p> <div class="docs-table docs-scroll-track-transparent"> <table> <thead> <tr> <th><strong><code>type</code> value</strong></th> <th><strong>Event meaning</strong></th> </tr> </thead> <tbody> <tr> <td><a href="../../api/common/http/httpeventtype#Sent"><code>HttpEventType.Sent</code></a></td> <td>The request has been dispatched to the server</td> </tr> <tr> <td><a href="../../api/common/http/httpeventtype#UploadProgress"><code>HttpEventType.UploadProgress</code></a></td> <td>An <a href="../../api/common/http/httpuploadprogressevent"><code>HttpUploadProgressEvent</code></a> reporting progress on uploading the request body</td> </tr> <tr> <td><a href="../../api/common/http/httpeventtype#ResponseHeader"><code>HttpEventType.ResponseHeader</code></a></td> <td>The head of the response has been received, including status and headers</td> </tr> <tr> <td><a href="../../api/common/http/httpeventtype#DownloadProgress"><code>HttpEventType.DownloadProgress</code></a></td> <td>An <a href="../../api/common/http/httpdownloadprogressevent"><code>HttpDownloadProgressEvent</code></a> reporting progress on downloading the response body</td> </tr> <tr> <td><a href="../../api/common/http/httpeventtype#Response"><code>HttpEventType.Response</code></a></td> <td>The entire response has been received, including the response body</td> </tr> <tr> <td><a href="../../api/common/http/httpeventtype#User"><code>HttpEventType.User</code></a></td> <td>A custom event from an Http interceptor.</td> </tr> </tbody> </table> </div> <h2 id="handling-request-failure"> Handling request failure </h2> <p>There are three ways an HTTP request can fail:</p> <ul class="docs-list"> <li>A network or connection error can prevent the request from reaching the backend server.</li> <li>A request didn't respond in time when the timeout option was set.</li> <li>The backend can receive the request but fail to process it, and return an error response.</li> </ul> <p><a href="../../api/common/http/httpclient"><code>HttpClient</code></a> captures all of the above kinds of errors in an <a href="../../api/common/http/httperrorresponse"><code>HttpErrorResponse</code></a> which it returns through the <code>Observable</code>'s error channel. Network and timeout errors have a <code>status</code> code of <code>0</code> and an <code>error</code> which is an instance of <a href="https://developer.mozilla.org/docs/Web/API/ProgressEvent" target="_blank"><code>ProgressEvent</code></a>. Backend errors have the failing <code>status</code> code returned by the backend, and the error response as the <code>error</code>. Inspect the response to identify the error's cause and the appropriate action to handle the error.</p> <p>The <a href="https://rxjs.dev/" target="_blank">RxJS library</a> offers several operators which can be useful for error handling.</p> <p>You can use the <code>catchError</code> operator to transform an error response into a value for the UI. This value can tell the UI to display an error page or value, and capture the error's cause if necessary.</p> <p>Sometimes transient errors such as network interruptions can cause a request to fail unexpectedly, and simply retrying the request will allow it to succeed. RxJS provides several <em>retry</em> operators which automatically re-subscribe to a failed <code>Observable</code> under certain conditions. For example, the <code>retry()</code> operator will automatically attempt to re-subscribe a specified number of times.</p> <h3 id="timeouts"> Timeouts </h3> <p>To set a timeout for a request, you can set the <code>timeout</code> option to a number of milliseconds along other request options. If the backend request does not complete within the specified time, the request will be aborted and an error will be emitted.</p> 
<div class="docs-alert docs-alert-note"> <p><strong>NOTE:</strong> The timeout will only apply to the backend HTTP request itself. It is not a timeout for the entire request handling chain. Therefore, this option is not affected by any delay introduced by interceptors.</p> </div>  <pre data-language="ts">http.get('/api/config', {
  timeout: 3000,
}).subscribe({
  next: config =&gt; {
    console.log('Config fetched successfully:', config);
  },
  error: err =&gt; {
    // If the request times out, an error will have been emitted.
  }
});</pre> <h2 id="advanced-fetch-options"> Advanced fetch options </h2> <p>When using the <a href="../../api/common/http/withfetch"><code>withFetch()</code></a> provider, Angular's <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> provides access to advanced fetch API options that can improve performance and user experience. These options are only available when using the fetch backend.</p> <h3 id="fetch-options"> Fetch options </h3> <p>The following options provide fine-grained control over request behavior when using the fetch backend.</p> <h4 id="keep-alive-connections"> Keep-alive connections </h4> <p>The <code>keepalive</code> option allows a request to outlive the page that initiated it. This is particularly useful for analytics or logging requests that need to complete even if the user navigates away from the page.</p> <pre data-language="ts">http.post('/api/analytics', analyticsData, {
  keepalive: true
}).subscribe();</pre> <h4 id="http-caching-control"> HTTP caching control </h4> <p>The <code>cache</code> option controls how the request interacts with the browser's HTTP cache, which can significantly improve performance for repeated requests.</p> <pre data-language="ts">//  Use cached response regardless of freshness
http.get('/api/config', {
  cache: 'force-cache'
}).subscribe(config =&gt; {
  // ...
});

// Always fetch from network, bypass cache
http.get('/api/live-data', {
  cache: 'no-cache'
}).subscribe(data =&gt; {
  // ...
});

// Use cached response only, fail if not in cache
http.get('/api/static-data', {
  cache: 'only-if-cached'
}).subscribe(data =&gt; {
  // ...
});</pre> <h4 id="request-priority-for-core-web-vitals"> Request priority for Core Web Vitals </h4> <p>The <code>priority</code> option allows you to indicate the relative importance of a request, helping browsers optimize resource loading for better Core Web Vitals scores.</p> <pre data-language="ts">// High priority for critical resources
http.get('/api/user-profile', {
  priority: 'high'
}).subscribe(profile =&gt; {
  // ...
});

// Low priority for non-critical resources
http.get('/api/recommendations', {
  priority: 'low'
}).subscribe(recommendations =&gt; {
  // ...
});

// Auto priority (default) lets the browser decide
http.get('/api/settings', {
  priority: 'auto'
}).subscribe(settings =&gt; {
  // ...
});</pre>
<p>Available <code>priority</code> values:</p> <ul class="docs-list"> <li>
<code>'high'</code>: High priority, loaded early (e.g., critical user data, above-the-fold content)</li> <li>
<code>'low'</code>: Low priority, loaded when resources are available (e.g., analytics, prefetch data)</li> <li>
<code>'auto'</code>: Browser determines priority based on request context (default)</li> </ul> 
<div class="docs-alert docs-alert-tip"> <p><strong>TIP:</strong> Use <code>priority: 'high'</code> for requests that affect Largest Contentful Paint (LCP) and <code>priority: 'low'</code> for requests that don't impact initial user experience.</p> </div>  <h4 id="request-mode"> Request mode </h4> <p>The <code>mode</code> option controls how the request handles cross-origin requests and determines the response type.</p> <pre data-language="ts">// Same-origin requests only
http.get('/api/local-data', {
  mode: 'same-origin'
}).subscribe(data =&gt; {
  // ...
});

// CORS-enabled cross-origin requests
http.get('https://api.external.com/data', {
  mode: 'cors'
}).subscribe(data =&gt; {
  // ...
});

// No-CORS mode for simple cross-origin requests
http.get('https://external-api.com/public-data', {
  mode: 'no-cors'
}).subscribe(data =&gt; {
  // ...
});</pre>
<p>Available <code>mode</code> values:</p> <ul class="docs-list"> <li>
<code>'same-origin'</code>: Only allow same-origin requests, fail for cross-origin requests</li> <li>
<code>'cors'</code>: Allow cross-origin requests with CORS (default)</li> <li>
<code>'no-cors'</code>: Allow simple cross-origin requests without CORS, response is opaque</li> </ul> 
<div class="docs-alert docs-alert-tip"> <p><strong>TIP:</strong> Use <code>mode: 'same-origin'</code> for sensitive requests that should never go cross-origin.</p> </div>  <h4 id="redirect-handling"> Redirect handling </h4> <p>The <code>redirect</code> option specifies how to handle redirect responses from the server.</p> <pre data-language="ts">// Follow redirects automatically (default behavior)
http.get('/api/resource', {
  redirect: 'follow'
}).subscribe(data =&gt; {
  // ...
});

// Prevent automatic redirects
http.get('/api/resource', {
  redirect: 'manual'
}).subscribe(response =&gt; {
  // Handle redirect manually
});

// Treat redirects as errors
http.get('/api/resource', {
  redirect: 'error'
}).subscribe({
  next: data =&gt; {
    // Success response
  },
  error: err =&gt; {
    // Redirect responses will trigger this error handler
  }
});</pre>
<p>Available <code>redirect</code> values:</p> <ul class="docs-list"> <li>
<code>'follow'</code>: Automatically follow redirects (default)</li> <li>
<code>'error'</code>: Treat redirects as errors</li> <li>
<code>'manual'</code>: Don't follow redirects automatically, return redirect response</li> </ul> 
<div class="docs-alert docs-alert-tip"> <p><strong>TIP:</strong> Use <code>redirect: 'manual'</code> when you need to handle redirects with custom logic.</p> </div>  <h4 id="credentials-handling"> Credentials handling </h4> <p>The <code>credentials</code> option controls whether cookies, authorization headers, and other credentials are sent with cross-origin requests. This is particularly important for authentication scenarios.</p> <pre data-language="ts">// Include credentials for cross-origin requests
http.get('https://api.example.com/protected-data', {
  credentials: 'include'
}).subscribe(data =&gt; {
  // ...
});

// Never send credentials (default for cross-origin)
http.get('https://api.example.com/public-data', {
  credentials: 'omit'
}).subscribe(data =&gt; {
  // ...
});

// Send credentials only for same-origin requests
http.get('/api/user-data', {
  credentials: 'same-origin'
}).subscribe(data =&gt; {
  // ...
});

// withCredentials overrides credentials setting
http.get('https://api.example.com/data', {
  credentials: 'omit',        // This will be ignored
  withCredentials: true       // This forces credentials: 'include'
}).subscribe(data =&gt; {
  // Request will include credentials despite credentials: 'omit'
});

// Legacy approach (still supported)
http.get('https://api.example.com/data', {
  withCredentials: true
}).subscribe(data =&gt; {
  // Equivalent to credentials: 'include'
});</pre>

<div class="docs-alert docs-alert-important"> <p><strong>IMPORTANT:</strong> The <code>withCredentials</code> option takes precedence over the <code>credentials</code> option. If both are specified, <code>withCredentials: true</code> will always result in <code>credentials: 'include'</code>, regardless of the explicit <code>credentials</code> value.</p> </div>  <p>Available <code>credentials</code> values:</p> <ul class="docs-list"> <li>
<code>'omit'</code>: Never send credentials</li> <li>
<code>'same-origin'</code>: Send credentials only for same-origin requests (default)</li> <li>
<code>'include'</code>: Always send credentials, even for cross-origin requests</li> </ul> 
<div class="docs-alert docs-alert-tip"> <p><strong>TIP:</strong> Use <code>credentials: 'include'</code> when you need to send authentication cookies or headers to a different domain that supports CORS. Avoid mixing <code>credentials</code> and <code>withCredentials</code> options to prevent confusion.</p> </div>  <h4 id="referrer"> Referrer </h4> <p>The <code>referrer</code> option allows you to control what referrer information is sent with the request. This is important for privacy and security considerations.</p> <pre data-language="ts">// Send a specific referrer URL
http.get('/api/data', {
  referrer: 'https://example.com/page'
}).subscribe(data =&gt; {
  // ...
});

// Use the current page as referrer (default behavior)
http.get('/api/analytics', {
  referrer: 'about:client'
}).subscribe(data =&gt; {
  // ...
});</pre>
<p>The <code>referrer</code> option accepts:</p> <ul class="docs-list"> <li>A valid URL string: Sets the specific referrer URL to send</li> <li>An empty string <code>''</code>: Sends no referrer information</li> <li>
<code>'about:client'</code>: Uses the default referrer (current page URL)</li> </ul> 
<div class="docs-alert docs-alert-tip"> <p><strong>TIP:</strong> Use <code>referrer: ''</code> for sensitive requests where you don't want to leak the referring page URL.</p> </div>  <h4 id="referrer-policy"> Referrer policy </h4> <p>The <code>referrerPolicy</code> option controls how much referrer information , the URL of the page making the request is sent along with an HTTP request. This setting affects both privacy and analytics, allowing you to balance data visibility with security considerations.</p> <pre data-language="ts">// Send no referrer information regardless of the current page
http.get('/api/data', {
  referrerPolicy: 'no-referrer'
}).subscribe();

// Send origin only (e.g. https://example.com)
http.get('/api/analytics', {
  referrerPolicy: 'origin'
}).subscribe();</pre>
<p>The <code>referrerPolicy</code> option accepts:</p> <ul class="docs-list"> <li>
<code>'no-referrer'</code> Never send the <code>Referer</code> header.</li> <li>
<code>'no-referrer-when-downgrade'</code> Sends the referrer for same-origin and secure (HTTPS→HTTPS) requests, but omits it when navigating from a secure to a less secure origin (HTTPS→HTTP).</li> <li>
<code>'origin'</code> Sends only the origin (scheme, host, port) of the referrer, omitting path and query information.</li> <li>
<code>'origin-when-cross-origin'</code> Sends the full URL for same-origin requests, but only the origin for cross-origin requests.</li> <li>
<code>'same-origin'</code> Sends the full URL for same-origin requests and no referrer for cross-origin requests.</li> <li>
<code>'strict-origin'</code> Sends only the origin, and only if the protocol security level is not downgraded (e.g., HTTPS→HTTPS). Omits the referrer on downgrade.</li> <li>
<code>'strict-origin-when-cross-origin'</code> Default browser behavior. Sends the full URL for same-origin requests, the origin for cross-origin requests when not downgraded, and omits the referrer on downgrade.</li> <li>
<code>'unsafe-url'</code>Always sends the full URL (including path and query). This can expose sensitive data and should be used with caution.</li> </ul> 
<div class="docs-alert docs-alert-tip"> <p><strong>TIP:</strong> Prefer conservative values such as <code>'no-referrer'</code>, <code>'origin'</code>, or <code>'strict-origin-when-cross-origin'</code> for privacy-sensitive requests.</p> </div>  <h4 id="integrity"> Integrity </h4> <p>The <code>integrity</code> option allows you to verify that the response hasn't been tampered with by providing a cryptographic hash of the expected content. This is particularly useful for loading scripts or other resources from CDNs.</p> <pre data-language="ts">// Verify response integrity with SHA-256 hash
http.get('/api/script.js', {
  integrity: 'sha256-ABC123...',
  responseType: 'text'
}).subscribe(script =&gt; {
  // Script content is verified against the hash
});</pre>

<div class="docs-alert docs-alert-important"> <p><strong>IMPORTANT:</strong> The <code>integrity</code> option requires an exact match between the response content and the provided hash. If the content doesn't match, the request will fail with a network error.</p> </div>  
<div class="docs-alert docs-alert-tip"> <p><strong>TIP:</strong> Use subresource integrity when loading critical resources from external sources to ensure they haven't been modified. Generate hashes using tools like <code>openssl</code>.</p> </div>  <h2 id="http-observables"> Http Observables </h2> <p>Each request method on <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> constructs and returns an <code>Observable</code> of the requested response type. Understanding how these <code>Observable</code>s work is important when using <a href="../../api/common/http/httpclient"><code>HttpClient</code></a>.</p> <p><a href="../../api/common/http/httpclient"><code>HttpClient</code></a> produces what RxJS calls "cold" <code>Observable</code>s, meaning that no actual request happens until the <code>Observable</code> is subscribed. Only then is the request actually dispatched to the server. Subscribing to the same <code>Observable</code> multiple times will trigger multiple backend requests. Each subscription is independent.</p> 
<div class="docs-alert docs-alert-tip"> <p><strong>TIP:</strong> You can think of <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> <code>Observable</code>s as <em>blueprints</em> for actual server requests.</p> </div>  <p>Once subscribed, unsubscribing will abort the in-progress request. This is very useful if the <code>Observable</code> is subscribed via the <code>async</code> pipe, as it will automatically cancel the request if the user navigates away from the current page. Additionally, if you use the <code>Observable</code> with an RxJS combinator like <code>switchMap</code>, this cancellation will clean up any stale requests.</p> <p>Once the response returns, <code>Observable</code>s from <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> usually complete (although interceptors can influence this).</p> <p>Because of the automatic completion, there is usually no risk of memory leaks if <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> subscriptions are not cleaned up. However, as with any async operation, we strongly recommend that you clean up subscriptions when the component using them is destroyed, as the subscription callback may otherwise run and encounter errors when it attempts to interact with the destroyed component.</p> 
<div class="docs-alert docs-alert-tip"> <p><strong>TIP:</strong> Using the <code>async</code> pipe or the <a href="../../api/core/rxjs-interop/tosignal"><code>toSignal</code></a> operation to subscribe to <code>Observable</code>s ensures that subscriptions are disposed properly.</p> </div>  <h2 id="best-practices"> Best practices </h2> <p>While <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> can be injected and used directly from components, generally we recommend you create reusable, injectable services which isolate and encapsulate data access logic. For example, this <code>UserService</code> encapsulates the logic to request data for a user by their id:</p> <pre data-language="ts">@Injectable({providedIn: 'root'})
export class UserService {
  private http = inject(HttpClient);

  getUser(id: string): Observable&lt;User&gt; {
    return this.http.get&lt;User&gt;(`/api/user/${id}`);
  }
}</pre>
<p>Within a component, you can combine <code>@if</code> with the <code>async</code> pipe to render the UI for the data only after it's finished loading:</p> <pre data-language="ts">import { AsyncPipe } from '@angular/common';

@Component({
  imports: [AsyncPipe],
  template: `
    @if (user$ | async; as user) {
      &lt;p&gt;Name: {{ user.name }}&lt;/p&gt;
      &lt;p&gt;Biography: {{ user.biography }}&lt;/p&gt;
    }
  `,
})
export class UserProfileComponent {
  userId = input.required&lt;string&gt;();
  user$!: Observable&lt;User&gt;;

  private userService = inject(UserService);

  constructor(): void {
    effect(() =&gt; {
      this.user$ = this.userService.getUser(this.userId());
    });
  }
}</pre><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/guide/http/making-requests" class="_attribution-link">https://angular.dev/guide/http/making-requests</a>
  </p>
</div>
