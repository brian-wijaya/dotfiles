<h1 tabindex="-1">Deferred loading with <code>@defer</code>
</h1> <header class="docs-header"> <docs-breadcrumb ng-version="21.0.3" _nghost-ng-c3945279308 ngh="8"></docs-breadcrumb>   </header> <p>Deferrable views, also known as <code>@defer</code> blocks, reduce the initial bundle size of your application by deferring the loading of code that is not strictly necessary for the initial rendering of a page. This often results in a faster initial load and improvement in Core Web Vitals (CWV), primarily Largest Contentful Paint (LCP) and Time to First Byte (TTFB).</p> <p>To use this feature, you can declaratively wrap a section of your template in a @defer block:</p> <pre data-language="ts">@defer {
  &lt;large-component /&gt;
}</pre>
<p>The code for any components, directives, and pipes inside the <code>@defer</code> block is split into a separate JavaScript file and loaded only when necessary, after the rest of the template has been rendered.</p> <p>Deferrable views support a variety of triggers, prefetching options, and sub-blocks for placeholder, loading, and error state management.</p> <h2 id="which-dependencies-are-deferred"> Which dependencies are deferred? </h2> <p>Components, directives, pipes, and any component CSS styles can be deferred when loading an application.</p> <p>In order for the dependencies within a <code>@defer</code> block to be deferred, they need to meet two conditions:</p> <ol class="docs-ordered-list"> <li>
<strong>They must be standalone.</strong> Non-standalone dependencies cannot be deferred and are still eagerly loaded, even if they are inside of <code>@defer</code> blocks.</li> <li>
<strong>They cannot be referenced outside of <code>@defer</code> blocks within the same file.</strong> If they are referenced outside the <code>@defer</code> block or referenced within ViewChild queries, the dependencies will be eagerly loaded.</li> </ol> <p>The <em>transitive</em> dependencies of the components, directives and pipes used in the <code>@defer</code> block do not strictly need to be standalone; transitive dependencies can still be declared in an <a href="../../api/core/ngmodule"><code>NgModule</code></a> and participate in deferred loading.</p> <p>Angular's compiler produces a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import" target="_blank">dynamic import</a> statement for each component, directive, and pipe used in the <code>@defer</code> block. The main content of the block renders after all the imports resolve. Angular does not guarantee any particular order for these imports.</p> <h2 id="how-to-manage-different-stages-of-deferred-loading"> How to manage different stages of deferred loading </h2> <p><code>@defer</code> blocks have several sub blocks to allow you to gracefully handle different stages in the deferred loading process.</p> <h3 id="defer"> @defer </h3> <p>This is the primary block that defines the section of content that is lazily loaded. It is not rendered initially– deferred content loads and renders once the specified <a href="defer#triggers">trigger</a> occurs or the <code>when</code> condition is met.</p> <p>By default, a <code>@defer</code> block is triggered when the browser state becomes <a href="defer#idle">idle</a>.</p> <pre data-language="ts">@defer {
  &lt;large-component /&gt;
}</pre> <h3 id="show-placeholder-content-with-placeholder"> Show placeholder content with @placeholder </h3> <p>By default, defer blocks do not render any content before they are triggered.</p> <p>The <code>@placeholder</code> is an optional block that declares what content to show before the <code>@defer</code> block is triggered.</p> <pre data-language="ts">@defer {
  &lt;large-component /&gt;
} @placeholder {
  &lt;p&gt;Placeholder content&lt;/p&gt;
}</pre>
<p>While optional, certain triggers may require the presence of either a <code>@placeholder</code> or a <a href="variables#template-reference-variables">template reference variable</a> to function. See the <a href="defer#triggers">Triggers</a> section for more details.</p> <p>Angular replaces placeholder content with the main content once loading is complete. You can use any content in the placeholder section including plain HTML, components, directives, and pipes. Keep in mind the <em>dependencies of the placeholder block are eagerly loaded</em>.</p> <p>The <code>@placeholder</code> block accepts an optional parameter to specify the <code>minimum</code> amount of time that this placeholder should be shown after the placeholder content initially renders.</p> <pre data-language="ts">@defer {
  &lt;large-component /&gt;
} @placeholder (minimum 500ms) {
  &lt;p&gt;Placeholder content&lt;/p&gt;
}</pre>
<p>This <code>minimum</code> parameter is specified in time increments of milliseconds (ms) or seconds (s). You can use this parameter to prevent fast flickering of placeholder content in the case that the deferred dependencies are fetched quickly.</p> <h3 id="show-loading-content-with-loading"> Show loading content with @loading </h3> <p>The <code>@loading</code> block is an optional block that allows you to declare content that is shown while deferred dependencies are loading. It replaces the <code>@placeholder</code> block once loading is triggered.</p> <pre data-language="ts">@defer {
  &lt;large-component /&gt;
} @loading {
  &lt;img alt="loading..." src="loading.gif" /&gt;
} @placeholder {
  &lt;p&gt;Placeholder content&lt;/p&gt;
}</pre>
<p>Its dependencies are eagerly loaded (similar to <code>@placeholder</code>).</p> <p>The <code>@loading</code> block accepts two optional parameters to help prevent fast flickering of content that may occur when deferred dependencies are fetched quickly,:</p> <ul class="docs-list"> <li>
<code>minimum</code> - the minimum amount of time that this placeholder should be shown</li> <li>
<code>after</code> - the amount of time to wait after loading begins before showing the loading template</li> </ul> <pre data-language="ts">@defer {
  &lt;large-component /&gt;
} @loading (after 100ms; minimum 1s) {
  &lt;img alt="loading..." src="loading.gif" /&gt;
}</pre>
<p>Both parameters are specified in time increments of milliseconds (ms) or seconds (s). In addition, the timers for both parameters begin immediately after the loading has been triggered.</p> <h3 id="show-error-state-when-deferred-loading-fails-with-error"> Show error state when deferred loading fails with @error </h3> <p>The <code>@error</code> block is an optional block that displays if deferred loading fails. Similar to <code>@placeholder</code> and <code>@loading</code>, the dependencies of the @error block are eagerly loaded.</p> <pre data-language="ts">@defer {
  &lt;large-component /&gt;
} @error {
  &lt;p&gt;Failed to load large component.&lt;/p&gt;
}</pre> <h2 id="controlling-deferred-content-loading-with-triggers"> Controlling deferred content loading with triggers </h2> <p>You can specify <strong>triggers</strong> that control when Angular loads and displays deferred content.</p> <p>When a <code>@defer</code> block is triggered, it replaces placeholder content with lazily loaded content.</p> <p>Multiple event triggers can be defined by separating them with a semicolon, <code>;</code> and will be evaluated as OR conditions.</p> <p>There are two types of triggers: <code>on</code> and <code>when</code>.</p> <h3 id="on"> on </h3> <p><code>on</code> specifies a condition for when the <code>@defer</code> block is triggered.</p> <p>The available triggers are as follows:</p> <div class="docs-table docs-scroll-track-transparent"> <table> <thead> <tr> <th>Trigger</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><a href="#idle"><code>idle</code></a></td> <td>Triggers when the browser is idle.</td> </tr> <tr> <td><a href="#viewport"><code>viewport</code></a></td> <td>Triggers when specified content enters the viewport</td> </tr> <tr> <td><a href="#interaction"><code>interaction</code></a></td> <td>Triggers when the user interacts with specified element</td> </tr> <tr> <td><a href="#hover"><code>hover</code></a></td> <td>Triggers when the mouse hovers over specified area</td> </tr> <tr> <td><a href="#immediate"><code>immediate</code></a></td> <td>Triggers immediately after non-deferred content has finished rendering</td> </tr> <tr> <td><a href="#timer"><code>timer</code></a></td> <td>Triggers after a specific duration</td> </tr> </tbody> </table> </div> <h4 id="idle"> idle </h4> <p>The <code>idle</code> trigger loads the deferred content once the browser has reached an idle state, based on requestIdleCallback. This is the default behavior with a defer block.</p> <pre data-language="ts">&lt;!-- @defer (on idle) --&gt;
@defer {
  &lt;large-cmp /&gt;
} @placeholder {
  &lt;div&gt;Large component placeholder&lt;/div&gt;
}</pre> <h4 id="viewport"> viewport </h4> <p>The <code>viewport</code> trigger loads the deferred content when the specified content enters the viewport using the <a href="https://developer.mozilla.org/docs/Web/API/Intersection_Observer_API" target="_blank">Intersection Observer API</a>. Observed content may be <code>@placeholder</code> content or an explicit element reference.</p> <p>By default, the <code>@defer</code> watches for the placeholder entering the viewport. Placeholders used this way must have a single root element.</p> <pre data-language="ts">@defer (on viewport) {
  &lt;large-cmp /&gt;
} @placeholder {
  &lt;div&gt;Large component placeholder&lt;/div&gt;
}</pre>
<p>Alternatively, you can specify a <a href="variables">template reference variable</a> in the same template as the <code>@defer</code> block as the element that is watched to enter the viewport. This variable is passed in as a parameter on the viewport trigger.</p> <pre data-language="ts">&lt;div #greeting&gt;Hello!&lt;/div&gt;
@defer (on viewport(greeting)) {
  &lt;greetings-cmp /&gt;
}</pre>
<p>If you want to customize the options of the <code>IntersectionObserver</code>, the <code>viewport</code> trigger supports passing in an object literal. The literal supports all properties from the second parameter of <code>IntersectionObserver</code>, except for <code>root</code>. When using the object literal notation, you have to pass your trigger using the <a href="../../api/animations/trigger"><code>trigger</code></a> property.</p> <pre data-language="ts">&lt;div #greeting&gt;Hello!&lt;/div&gt;

&lt;!-- With options and a trigger --&gt;
@defer (on viewport({trigger: greeting, rootMargin: '100px', threshold: 0.5})) {
  &lt;greetings-cmp /&gt;
}

&lt;!-- With options and an implied trigger --&gt;
@defer (on viewport({rootMargin: '100px', threshold: 0.5})) {
  &lt;greetings-cmp /&gt;
} @placeholder {
  &lt;div&gt;Implied trigger&lt;/div&gt;
}</pre> <h4 id="interaction"> interaction </h4> <p>The <code>interaction</code> trigger loads the deferred content when the user interacts with the specified element through <code>click</code> or <code>keydown</code> events.</p> <p>By default, the placeholder acts as the interaction element. Placeholders used this way must have a single root element.</p> <pre data-language="ts">@defer (on interaction) {
  &lt;large-cmp /&gt;
} @placeholder {
  &lt;div&gt;Large component placeholder&lt;/div&gt;
}</pre>
<p>Alternatively, you can specify a <a href="variables">template reference variable</a> in the same template as the <code>@defer</code> block as the element that is watched for interactions. This variable is passed in as a parameter on the viewport trigger.</p> <pre data-language="ts">&lt;div #greeting&gt;Hello!&lt;/div&gt;
@defer (on interaction(greeting)) {
  &lt;greetings-cmp /&gt;
}</pre> <h4 id="hover"> hover </h4> <p>The <code>hover</code> trigger loads the deferred content when the mouse has hovered over the triggered area through the <code>mouseover</code> and <code>focusin</code> events.</p> <p>By default, the placeholder acts as the interaction element. Placeholders used this way must have a single root element.</p> <pre data-language="ts">@defer (on hover) {
  &lt;large-cmp /&gt;
} @placeholder {
  &lt;div&gt;Large component placeholder&lt;/div&gt;
}</pre>
<p>Alternatively, you can specify a <a href="variables">template reference variable</a> in the same template as the <code>@defer</code> block as the element that is watched to enter the viewport. This variable is passed in as a parameter on the viewport trigger.</p> <pre data-language="ts">&lt;div #greeting&gt;Hello!&lt;/div&gt;
@defer (on hover(greeting)) {
  &lt;greetings-cmp /&gt;
}</pre> <h4 id="immediate"> immediate </h4> <p>The <code>immediate</code> trigger loads the deferred content immediately. This means that the deferred block loads as soon as all other non-deferred content has finished rendering.</p> <pre data-language="ts">@defer (on immediate) {
  &lt;large-cmp /&gt;
} @placeholder {
  &lt;div&gt;Large component placeholder&lt;/div&gt;
}</pre> <h4 id="timer"> timer </h4> <p>The <code>timer</code> trigger loads the deferred content after a specified duration.</p> <pre data-language="ts">@defer (on timer(500ms)) {
  &lt;large-cmp /&gt;
} @placeholder {
  &lt;div&gt;Large component placeholder&lt;/div&gt;
}</pre>
<p>The duration parameter must be specified in milliseconds (<code>ms</code>) or seconds (<code>s</code>).</p> <h3 id="when"> when </h3> <p>The <code>when</code> trigger accepts a custom conditional expression and loads the deferred content when the condition becomes truthy.</p> <pre data-language="ts">@defer (when condition) {
  &lt;large-cmp /&gt;
} @placeholder {
  &lt;div&gt;Large component placeholder&lt;/div&gt;
}</pre>
<p>This is a one-time operation– the <code>@defer</code> block does not revert back to the placeholder if the condition changes to a falsy value after becoming truthy.</p> <h2 id="prefetching-data-with-prefetch"> Prefetching data with prefetch </h2> <p>In addition to specifying a condition that determines when deferred content is shown, you can optionally specify a <strong>prefetch trigger</strong>. This trigger lets you load the JavaScript associated with the <code>@defer</code> block before the deferred content is shown.</p> <p>Prefetching enables more advanced behaviors, such as letting you start to prefetch resources before a user has actually seen or interacted with a defer block, but might interact with it soon, making the resources available faster.</p> <p>You can specify a prefetch trigger similarly to the block's main trigger, but prefixed with the <code>prefetch</code> keyword. The block's main trigger and prefetch trigger are separated with a semi-colon character (<code>;</code>).</p> <p>In the example below, the prefetching starts when a browser becomes idle and the contents of the block is rendered only once the user interacts with the placeholder.</p> <pre data-language="ts">@defer (on interaction; prefetch on idle) {
  &lt;large-cmp /&gt;
} @placeholder {
  &lt;div&gt;Large component placeholder&lt;/div&gt;
}</pre> <h2 id="testing-defer-blocks"> Testing @defer blocks </h2> <p>Angular provides TestBed APIs to simplify the process of testing <code>@defer</code> blocks and triggering different states during testing. By default, <code>@defer</code> blocks in tests play through like a defer block would behave in a real application. If you want to manually step through states, you can switch the defer block behavior to <code>Manual</code> in the TestBed configuration.</p> <pre data-language="ts">it('should render a defer block in different states', async () =&gt; {
  // configures the defer block behavior to start in "paused" state for manual control.
  TestBed.configureTestingModule({deferBlockBehavior: DeferBlockBehavior.Manual});
  @Component({
    // ...
    template: `
      @defer {
        &lt;large-component /&gt;
      } @placeholder {
        Placeholder
      } @loading {
        Loading...
      }
    `
  })
  class ComponentA {}
  // Create component fixture.
  const componentFixture = TestBed.createComponent(ComponentA);
  // Retrieve the list of all defer block fixtures and get the first block.
  const deferBlockFixture = (await componentFixture.getDeferBlocks())[0];
  // Renders placeholder state by default.
  expect(componentFixture.nativeElement.innerHTML).toContain('Placeholder');
  // Render loading state and verify rendered output.
  await deferBlockFixture.render(DeferBlockState.Loading);
  expect(componentFixture.nativeElement.innerHTML).toContain('Loading');
  // Render final state and verify the output.
  await deferBlockFixture.render(DeferBlockState.Complete);
  expect(componentFixture.nativeElement.innerHTML).toContain('large works!');
});</pre> <h2 id="does-defer-work-with-ngmodule"> Does @defer work with NgModule? </h2> <p><code>@defer</code> blocks are compatible with both standalone and NgModule-based components, directives and pipes. However, <strong>only standalone components, directives and pipes can be deferred</strong>. NgModule-based dependencies are not deferred and are included in the eagerly loaded bundle.</p> <h2 id="compatibility-between-defer-blocks-and-hot-module-reload-hmr"> Compatibility between @defer blocks and Hot Module Reload (HMR) </h2> <p>When Hot Module Replacement (HMR) is active, all <code>@defer</code> block chunks are fetched eagerly, overriding any configured triggers. To restore the standard trigger behavior, you must disable HMR by serving your application with the <code>--no-hmr</code> flag.</p> <h2 id="how-does-defer-work-with-server-side-rendering-ssr-and-static-site-generation-ssg"> How does @defer work with server-side rendering (SSR) and static-site generation (SSG)? </h2> <p>By default, when rendering an application on the server (either using SSR or SSG), defer blocks always render their <code>@placeholder</code> (or nothing if a placeholder is not specified) and triggers are not invoked. On the client, the content of the <code>@placeholder</code> is hydrated and triggers are activated.</p> <p>To render the main content of <code>@defer</code> blocks on the server (both SSR and SSG), you can enable <a href="../incremental-hydration">the Incremental Hydration feature</a> and configure <code>hydrate</code> triggers for the necessary blocks.</p> <h2 id="best-practices-for-deferring-views"> Best practices for deferring views </h2> <h3 id="avoid-cascading-loads-with-nested-defer-blocks"> Avoid cascading loads with nested @defer blocks </h3> <p>When you have nested <code>@defer</code> blocks, they should have different triggers in order to avoid loading simultaneously, which causes cascading requests and may negatively impact page load performance.</p> <h3 id="avoid-layout-shifts"> Avoid layout shifts </h3> <p>Avoid deferring components that are visible in the user’s viewport on initial load. Doing this may negatively affect Core Web Vitals by causing an increase in cumulative layout shift (CLS).</p> <p>In the event this is necessary, avoid <code>immediate</code>, <code>timer</code>, <code>viewport</code>, and custom <code>when</code> triggers that cause the content to load during the initial page render.</p> <h3 id="keep-accessibility-in-mind"> Keep accessibility in mind </h3> <p>When using <code>@defer</code> blocks, consider the impact on users with assistive technologies like screen readers. Screen readers that focus on a deferred section will initially read the placeholder or loading content, but may not announce changes when the deferred content loads.</p> <p>To ensure deferred content changes are announced to screen readers, you can wrap your <code>@defer</code> block in an element with a live region:</p> <pre data-language="ts">&lt;div aria-live="polite" aria-atomic="true"&gt;
  @defer (on timer(2000)) {
    &lt;user-profile [user]="currentUser" /&gt;
  } @placeholder {
    Loading user profile...
  } @loading {
    Please wait...
  } @error {
    Failed to load profile
  }
&lt;/div&gt;</pre>
<p>This ensures that changes are announced to the user when transitions (placeholder → loading → content/error) occur.</p><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/guide/templates/defer" class="_attribution-link">https://angular.dev/guide/templates/defer</a>
  </p>
</div>
