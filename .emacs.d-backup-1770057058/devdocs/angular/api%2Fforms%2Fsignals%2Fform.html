<h1>form</h1>
<router-outlet _ngcontent-ng-c1178817259></router-outlet><adev-main ngh="7"><router-outlet></router-outlet><adev-reference-page _nghost-ng-c972174807 ngh="6"><main _ngcontent-ng-c972174807 docsviewer class="docs-with-TOC" ngh="0"><div class="docs-api">
<div class="docs-reference-section docs-reference-api-section">
<h2 id="api" class="docs-reference-section-heading">API</h2>
<pre data-language="ts">function form&lt;TModel&gt;(model: WritableSignal&lt;TModel&gt;): FieldTree&lt;TModel&gt;;
function form&lt;TModel&gt;(
  model: WritableSignal&lt;TModel&gt;,
  schemaOrOptions: FormOptions | SchemaOrSchemaFn&lt;TModel&gt;,
): FieldTree&lt;TModel&gt;;
function form&lt;TModel&gt;(
  model: WritableSignal&lt;TModel&gt;,
  schema: SchemaOrSchemaFn&lt;TModel&gt;,
  options: FormOptions,
): FieldTree&lt;TModel&gt;;</pre>
</div>
<div class="docs-reference-members">
<div id="form_0" class="docs-reference-member-card">
<header class="docs-reference-card-header"><pre data-language="ts">function form&lt;TModel&gt;(model: WritableSignal&lt;TModel&gt;): FieldTree&lt;TModel&gt;;</pre></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Creates a form wrapped around the given model data. A form is represented as simply a <a href="fieldtree"><code>FieldTree</code></a> of the model data.</p> <p><a href="form"><code>form</code></a> uses the given model as the source of truth and <em>does not</em> maintain its own copy of the data. This means that updating the value on a <a href="fieldstate"><code>FieldState</code></a> updates the originally passed in model as well.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">model</span><code><a href="../../core/writablesignal">WritableSignal</a>&lt;TModel&gt;</code><div class="docs-parameter-description"><p>A writable signal that contains the model data for the form. The resulting field structure will match the shape of the model and any changes to the form data will be written to the model.</p></div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code><a href="fieldtree">FieldTree</a>&lt;TModel&gt;</code>
</div>
<div class="docs-usage-notes">
<span class="docs-usage-notes-heading">Usage notes</span><div><pre data-language="ts">const nameModel = signal({first: '', last: ''});
const nameForm = form(nameModel);
nameForm.first().value.set('John');
nameForm().value(); // {first: 'John', last: ''}
nameModel(); // {first: 'John', last: ''}</pre></div>
</div>
</div></div>
</div>
<div id="form_1" class="docs-reference-member-card">
<header class="docs-reference-card-header"><pre data-language="ts">function form&lt;TModel&gt;(model: WritableSignal&lt;TModel&gt;, schemaOrOptions: FormOptions | SchemaOrSchemaFn&lt;TModel&gt;): FieldTree&lt;TModel&gt;;</pre></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Creates a form wrapped around the given model data. A form is represented as simply a <a href="fieldtree"><code>FieldTree</code></a> of the model data.</p> <p><a href="form"><code>form</code></a> uses the given model as the source of truth and <em>does not</em> maintain its own copy of the data. This means that updating the value on a <a href="fieldstate"><code>FieldState</code></a> updates the originally passed in model as well.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">model</span><code><a href="../../core/writablesignal">WritableSignal</a>&lt;TModel&gt;</code><div class="docs-parameter-description"><p>A writable signal that contains the model data for the form. The resulting field structure will match the shape of the model and any changes to the form data will be written to the model.</p></div>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">schemaOrOptions</span><code><a href="formoptions">FormOptions</a> | <a href="schemaorschemafn">SchemaOrSchemaFn</a>&lt;TModel&gt;</code><div class="docs-parameter-description">
<p>The second argument can be either</p> <ol class="docs-ordered-list"> <li>A schema or a function used to specify logic for the form (e.g. validation, disabled fields, etc.). When passing a schema, the form options can be passed as a third argument if needed.</li> <li>The form options</li> </ol>
</div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code><a href="fieldtree">FieldTree</a>&lt;TModel&gt;</code>
</div>
<div class="docs-usage-notes">
<span class="docs-usage-notes-heading">Usage notes</span><div>
<pre data-language="ts">const nameModel = signal({first: '', last: ''});
const nameForm = form(nameModel);
nameForm.first().value.set('John');
nameForm().value(); // {first: 'John', last: ''}
nameModel(); // {first: 'John', last: ''}</pre>
<p>The form can also be created with a schema, which is a set of rules that define the logic for the form. The schema can be either a pre-defined schema created with the <a href="schema"><code>schema</code></a> function, or a function that builds the schema by binding logic to a parts of the field structure.</p> <pre data-language="ts">const nameForm = form(signal({first: '', last: ''}), (name) =&gt; {
  required(name.first);
  pattern(name.last, /^[a-z]+$/i, {message: 'Alphabet characters only'});
});
nameForm().valid(); // false
nameForm().value.set({first: 'John', last: 'Doe'});
nameForm().valid(); // true</pre>
</div>
</div>
</div></div>
</div>
<div id="form_2" class="docs-reference-member-card">
<header class="docs-reference-card-header"><pre data-language="ts">function form&lt;TModel&gt;(model: WritableSignal&lt;TModel&gt;, schema: SchemaOrSchemaFn&lt;TModel&gt;, options: FormOptions): FieldTree&lt;TModel&gt;;</pre></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Creates a form wrapped around the given model data. A form is represented as simply a <a href="fieldtree"><code>FieldTree</code></a> of the model data.</p> <p><a href="form"><code>form</code></a> uses the given model as the source of truth and <em>does not</em> maintain its own copy of the data. This means that updating the value on a <a href="fieldstate"><code>FieldState</code></a> updates the originally passed in model as well.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">model</span><code><a href="../../core/writablesignal">WritableSignal</a>&lt;TModel&gt;</code><div class="docs-parameter-description"><p>A writable signal that contains the model data for the form. The resulting field structure will match the shape of the model and any changes to the form data will be written to the model.</p></div>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">schema</span><code><a href="schemaorschemafn">SchemaOrSchemaFn</a>&lt;TModel&gt;</code><div class="docs-parameter-description"><p>A schema or a function used to specify logic for the form (e.g. validation, disabled fields, etc.)</p></div>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">options</span><code><a href="formoptions">FormOptions</a></code><div class="docs-parameter-description"><p>The form options</p></div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code><a href="fieldtree">FieldTree</a>&lt;TModel&gt;</code>
</div>
<div class="docs-usage-notes">
<span class="docs-usage-notes-heading">Usage notes</span><div>
<pre data-language="ts">const nameModel = signal({first: '', last: ''});
const nameForm = form(nameModel);
nameForm.first().value.set('John');
nameForm().value(); // {first: 'John', last: ''}
nameModel(); // {first: 'John', last: ''}</pre>
<p>The form can also be created with a schema, which is a set of rules that define the logic for the form. The schema can be either a pre-defined schema created with the <a href="schema"><code>schema</code></a> function, or a function that builds the schema by binding logic to a parts of the field structure.</p> <pre data-language="ts">const nameForm = form(signal({first: '', last: ''}), (name) =&gt; {
  required(name.first);
  validate(name.last, ({value}) =&gt; !/^[a-z]+$/i.test(value()) ? customError({kind: 'alphabet-only'}) : undefined);
});
nameForm().valid(); // false
nameForm().value.set({first: 'John', last: 'Doe'});
nameForm().valid(); // true</pre>
</div>
</div>
</div></div>
</div>
</div>
</div></main></adev-reference-page></adev-main><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/api/forms/signals/form" class="_attribution-link">https://angular.dev/api/forms/signals/form</a>
  </p>
</div>
