<h1>afterNextRender</h1>
<router-outlet _ngcontent-ng-c1178817259></router-outlet><adev-main ngh="7"><router-outlet></router-outlet><adev-reference-page _nghost-ng-c972174807 ngh="6"><main _ngcontent-ng-c972174807 docsviewer class="docs-with-TOC" ngh="0"><div class="docs-api">
<div class="docs-reference-section docs-reference-api-section">
<h2 id="api" class="docs-reference-section-heading">API</h2>
<pre data-language="ts">function afterNextRender&lt;E = never, W = never, M = never&gt;(
  spec: {
    earlyRead?: (() =&gt; E) | undefined;
    write?: ((...args: [E] extends [never] ? [] : [E]) =&gt; W) | undefined;
    mixedReadWrite?:
      | ((
          ...args: [W] extends [never] ? ([E] extends [never] ? [] : [E]) : [W]
        ) =&gt; M)
      | undefined;
    read?:
      | ((
          ...args: [M] extends [never]
            ? [W] extends [never]
              ? [E] extends [never]
                ? []
                : [E]
              : [W]
            : [M]
        ) =&gt; void)
      | undefined;
  },
  options?: AfterRenderOptions | undefined,
): AfterRenderRef;
function afterNextRender(
  callback: VoidFunction,
  options?: AfterRenderOptions | undefined,
): AfterRenderRef;</pre>
</div>
<div class="docs-reference-members">
<div id="afterNextRender_0" class="docs-reference-member-card">
<header class="docs-reference-card-header"><pre data-language="ts">function afterNextRender&lt;E = never, W = never, M = never&gt;(spec: { earlyRead?: (() =&gt; E) | undefined; write?: ((...args: [E] extends [never] ? [] : [E]) =&gt; W) | undefined; mixedReadWrite?: ((...args: [W] extends [never] ? [E] extends [never] ? [] : [E] : [W]) =&gt; M) | undefined; read?: ((...args: [M] extends [never] ? [W] extends [never] ? [E] extends [never] ? [] : [E] : [W] : [M]) =&gt; void) | undefined; }, options?: AfterRenderOptions | undefined): AfterRenderRef;</pre></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Register callbacks to be invoked the next time the application finishes rendering, during the specified phases. The available phases are:</p> <ul class="docs-list"> <li>
<code>earlyRead</code> Use this phase to <strong>read</strong> from the DOM before a subsequent <code>write</code> callback, for example to perform custom layout that the browser doesn't natively support. Prefer the <code>read</code> phase if reading can wait until after the write phase. <strong>Never</strong> write to the DOM in this phase.</li> <li>
<code>write</code> Use this phase to <strong>write</strong> to the DOM. <strong>Never</strong> read from the DOM in this phase.</li> <li>
<code>mixedReadWrite</code> Use this phase to read from and write to the DOM simultaneously. <strong>Never</strong> use this phase if it is possible to divide the work among the other phases instead.</li> <li>
<code>read</code> Use this phase to <strong>read</strong> from the DOM. <strong>Never</strong> write to the DOM in this phase.</li> </ul> <div class="docs-alert docs-alert-critical"> <p>You should prefer using the <code>read</code> and <code>write</code> phases over the <code>earlyRead</code> and <code>mixedReadWrite</code> phases when possible, to avoid performance degradation.</p> </div> <p>Note that:</p> <ul class="docs-list"> <li>Callbacks run in the following phase order <em>once, after the next render</em>: <ol class="docs-ordered-list"> <li><code>earlyRead</code></li> <li><code>write</code></li> <li><code>mixedReadWrite</code></li> <li><code>read</code></li> </ol> </li> <li>Callbacks in the same phase run in the order they are registered.</li> <li>Callbacks run on browser platforms only, they will not run on the server.</li> </ul> <p>The first phase callback to run as part of this spec will receive no parameters. Each subsequent phase callback in this spec will receive the return value of the previously run phase callback as a parameter. This can be used to coordinate work across multiple phases.</p> <p>Angular is unable to verify or enforce that phases are used correctly, and instead relies on each developer to follow the guidelines documented for each value and carefully choose the appropriate one, refactoring their code if necessary. By doing so, Angular is better able to minimize the performance degradation associated with manual DOM access, ensuring the best experience for the end users of your application or library.</p> <div class="docs-alert docs-alert-important"> <p>Components are not guaranteed to be <a href="../../guide/hydration">hydrated</a> before the callback runs. You must use caution when directly reading or writing the DOM and layout.</p> </div>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">spec</span><code>{ earlyRead?: (() =&gt; E) | undefined; write?: ((...args: [E] extends [never] ? [] : [E]) =&gt; W) | undefined; mixedReadWrite?: ((...args: [W] extends [never] ? [E] extends [never] ? [] : [E] : [W]) =&gt; M) | undefined; read?: ((...args: [M] extends [never] ? [W] extends [never] ? [E] extends [never] ? [] : [E] : [W] : [M]) =&gt; void) | undefined; }</code><div class="docs-parameter-description"><p>The callback functions to register</p></div>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">options</span><code><a href="afterrenderoptions">AfterRenderOptions</a> | undefined</code><div class="docs-parameter-description"><p>Options to control the behavior of the callback</p></div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code><a href="afterrenderref">AfterRenderRef</a></code>
</div>
<div class="docs-usage-notes">
<span class="docs-usage-notes-heading">Usage notes</span><div>
<p>Use <a href="afternextrender"><code>afterNextRender</code></a> to read or write the DOM once, for example to initialize a non-Angular library.</p> <h3 id="example"> Example </h3> <pre data-language="ts">@Component({
  selector: 'my-chart-cmp',
  template: `&lt;div #chart&gt;{{ ... }}&lt;/div&gt;`,
})
export class MyChartCmp {
  @ViewChild('chart') chartRef: ElementRef;
  chart: MyChart|null;

  constructor() {
    afterNextRender({
      write: () =&gt; {
        this.chart = new MyChart(this.chartRef.nativeElement);
      }
    });
  }
}</pre>
</div>
</div>
</div></div>
</div>
<div id="afterNextRender_1" class="docs-reference-member-card">
<header class="docs-reference-card-header"><pre data-language="ts">function afterNextRender(callback: VoidFunction, options?: AfterRenderOptions | undefined): AfterRenderRef;</pre></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Register a callback to be invoked the next time the application finishes rendering, during the <code>mixedReadWrite</code> phase.</p> <div class="docs-alert docs-alert-critical"> <p>You should prefer specifying an explicit phase for the callback instead, or you risk significant performance degradation.</p> </div> <p>Note that the callback will run</p> <ul class="docs-list"> <li>in the order it was registered</li> <li>on browser platforms only</li> <li>during the <code>mixedReadWrite</code> phase</li> </ul> <div class="docs-alert docs-alert-important"> <p>Components are not guaranteed to be <a href="../../guide/hydration">hydrated</a> before the callback runs. You must use caution when directly reading or writing the DOM and layout.</p> </div>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">callback</span><code>VoidFunction</code><div class="docs-parameter-description"><p>A callback function to register</p></div>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">options</span><code><a href="afterrenderoptions">AfterRenderOptions</a> | undefined</code><div class="docs-parameter-description"><p>Options to control the behavior of the callback</p></div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code><a href="afterrenderref">AfterRenderRef</a></code>
</div>
<div class="docs-usage-notes">
<span class="docs-usage-notes-heading">Usage notes</span><div>
<p>Use <a href="afternextrender"><code>afterNextRender</code></a> to read or write the DOM once, for example to initialize a non-Angular library.</p> <h3 id="example"> Example </h3> <pre data-language="ts">@Component({
  selector: 'my-chart-cmp',
  template: `&lt;div #chart&gt;{{ ... }}&lt;/div&gt;`,
})
export class MyChartCmp {
  @ViewChild('chart') chartRef: ElementRef;
  chart: MyChart|null;

  constructor() {
    afterNextRender({
      write: () =&gt; {
        this.chart = new MyChart(this.chartRef.nativeElement);
      }
    });
  }
}</pre>
</div>
</div>
</div></div>
</div>
</div>
</div></main></adev-reference-page></adev-main><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/api/core/afterNextRender" class="_attribution-link">https://angular.dev/api/core/afterNextRender</a>
  </p>
</div>
