<h1 tabindex="-1">Control route access with guards</h1> <header class="docs-header"> <docs-breadcrumb ng-version="21.0.3" _nghost-ng-c3945279308 ngh="8"></docs-breadcrumb>   </header> 
<div class="docs-alert docs-alert-critical"> <p><strong>CRITICAL:</strong> Never rely on client-side guards as the sole source of access control. All JavaScript that runs in a web browser can be modified by the user running the browser. Always enforce user authorization server-side, in addition to any client-side guards.</p> </div>  <p>Route guards are functions that control whether a user can navigate to or leave a particular route. They are like checkpoints that manage whether a user can access specific routes. Common examples of using route guards include authentication and access control.</p> <h2 id="creating-a-route-guard"> Creating a route guard </h2> <p>You can generate a route guard using the Angular CLI:</p> <pre data-language="ts">ng generate guard CUSTOM_NAME</pre>
<p>This will prompt you to select which <a href="#types-of-route-guards">type of route guard</a> to use and then create the corresponding <code>CUSTOM_NAME-guard.ts</code> file.</p> 
<div class="docs-alert docs-alert-tip"> <p><strong>TIP:</strong> You can also create a route guard manually by creating a separate TypeScript file in your Angular project. Developers typically add a suffix of <code>-guard.ts</code> in the filename to distinguish it from other files.</p> </div>  <h2 id="route-guard-return-types"> Route guard return types </h2> <p>All route guards share the same possible return types. This gives you flexibility in how you control navigation:</p> <div class="docs-table docs-scroll-track-transparent"> <table> <thead> <tr> <th>Return types</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code>boolean</code></td> <td>
<code>true</code> allows navigation, <code>false</code> blocks it (see note for <a href="../../api/router/canmatch"><code>CanMatch</code></a> route guard)</td> </tr> <tr> <td>
<a href="../../api/router/urltree"><code>UrlTree</code></a> or <a href="../../api/router/redirectcommand"><code>RedirectCommand</code></a>
</td> <td>Redirects to another route instead of blocking</td> </tr> <tr> <td>
<code>Promise&lt;T&gt;</code> or <code>Observable&lt;T&gt;</code>
</td> <td>Router uses the first emitted value and then unsubscribes</td> </tr> </tbody> </table> </div> 
<div class="docs-alert docs-alert-note"> <p><strong>NOTE:</strong> <a href="../../api/router/canmatch"><code>CanMatch</code></a> behaves differentlyâ€” when it returns <code>false</code>, Angular tries other matching routes instead of completely blocking navigation.</p> </div>  <h2 id="types-of-route-guards"> Types of route guards </h2> <p>Angular provides four types of route guards, each serving different purposes:</p> <nav class="docs-pill-row"> <a class="docs-pill" href="#canactivate"> CanActivate </a> <a class="docs-pill" href="#canactivatechild"> CanActivateChild </a> <a class="docs-pill" href="#candeactivate"> CanDeactivate </a> <a class="docs-pill" href="#canmatch"> CanMatch </a> </nav> <h3 id="canactivate"> CanActivate </h3> <p>The <a href="../../api/router/canactivate"><code>CanActivate</code></a> guard determines whether a user can access a route. It is most commonly used for authentication and authorization.</p> <p>It has access to the following default arguments:</p> <ul class="docs-list"> <li>
<code>route: ActivatedRouteSnapshot</code> - Contains information about the route being activated</li> <li>
<code>state: RouterStateSnapshot</code> - Contains the router's current state</li> </ul> <p>It can return the <a href="#route-guard-return-types">standard return guard types</a>.</p> <pre data-language="ts">export const authGuard: CanActivateFn = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) =&gt; {
  const authService = inject(AuthService);
  return authService.isAuthenticated();
};</pre>
<p>Tip: If you need to redirect the user, return a <a href="../../api/router/urltree"><code>URLTree</code></a> or <a href="../../api/router/redirectcommand"><code>RedirectCommand</code></a>. Do <strong>not</strong> return <code>false</code> and then programmatically <code>navigate</code> the user.</p> <p>For more information, check out the <a href="../../api/router/canactivatefn">API docs for CanActivateFn</a>.</p> <h3 id="canactivatechild"> CanActivateChild </h3> <p>The <a href="../../api/router/canactivatechild"><code>CanActivateChild</code></a> guard determines whether a user can access child routes of a particular parent route. This is useful when you want to protect an entire section of nested routes. In other words, <code>canActivateChild</code> runs for <em>all</em> children. If there is a child component with another child component underneath of it, <code>canActivateChild</code> will run once for both components.</p> <p>It has access to the following default arguments:</p> <ul class="docs-list"> <li>
<code>childRoute: ActivatedRouteSnapshot</code> - Contains information about the "future" snapshot (i.e., state the router is attempting to navigate to) of the child route being activated</li> <li>
<code>state: RouterStateSnapshot</code> - Contains the router's current state</li> </ul> <p>It can return the <a href="#route-guard-return-types">standard return guard types</a>.</p> <pre data-language="ts">export const adminChildGuard: CanActivateChildFn = (childRoute: ActivatedRouteSnapshot, state: RouterStateSnapshot) =&gt; {
  const authService = inject(AuthService);
  return authService.hasRole('admin');
};</pre>
<p>For more information, check out the <a href="../../api/router/canactivatechildfn">API docs for CanActivateChildFn</a>.</p> <h3 id="candeactivate"> CanDeactivate </h3> <p>The <a href="../../api/router/candeactivate"><code>CanDeactivate</code></a> guard determines whether a user can leave a route. A common scenario is preventing navigation away from unsaved forms.</p> <p>It has access to the following default arguments:</p> <ul class="docs-list"> <li>
<code>component: T</code> - The component instance being deactivated</li> <li>
<code>currentRoute: ActivatedRouteSnapshot</code> - Contains information about the current route</li> <li>
<code>currentState: RouterStateSnapshot</code> - Contains the current router state</li> <li>
<code>nextState: RouterStateSnapshot</code> - Contains the next router state being navigated to</li> </ul> <p>It can return the <a href="#route-guard-return-types">standard return guard types</a>.</p> <pre data-language="ts">export const unsavedChangesGuard: CanDeactivateFn&lt;FormComponent&gt; = (component: FormComponent, currentRoute: ActivatedRouteSnapshot, currentState: RouterStateSnapshot, nextState: RouterStateSnapshot) =&gt; {
  return component.hasUnsavedChanges()
    ? confirm('You have unsaved changes. Are you sure you want to leave?')
    : true;
};</pre>
<p>For more information, check out the <a href="../../api/router/candeactivatefn">API docs for CanDeactivateFn</a>.</p> <h3 id="canmatch"> CanMatch </h3> <p>The <a href="../../api/router/canmatch"><code>CanMatch</code></a> guard determines whether a route can be matched during path matching. Unlike other guards, rejection falls through to try other matching routes instead of blocking navigation entirely. This can be useful for feature flags, A/B testing, or conditional route loading.</p> <p>It has access to the following default arguments:</p> <ul class="docs-list"> <li>
<code>route: Route</code> - The route configuration being evaluated</li> <li>
<code>segments: UrlSegment[]</code> - The URL segments that have not been consumed by previous parent route evaluations</li> </ul> <p>It can return the <a href="#route-guard-return-types">standard return guard types</a>, but when it returns <code>false</code>, Angular tries other matching routes instead of completely blocking navigation.</p> <pre data-language="ts">export const featureToggleGuard: CanMatchFn = (route: Route, segments: UrlSegment[]) =&gt; {
  const featureService = inject(FeatureService);
  return featureService.isFeatureEnabled('newDashboard');
};</pre>
<p>It can also allow you to use different components for the same path.</p> <pre data-language="ts">// ðŸ“„ routes.ts
const routes: Routes = [
  {
    path: 'dashboard',
    component: AdminDashboard,
    canMatch: [adminGuard]
  },
  {
    path: 'dashboard',
    component: UserDashboard,
    canMatch: [userGuard]
  }
]</pre>
<p>In this example, when the user visits <code>/dashboard</code>, the first one that matches the correct guard will be used.</p> <p>For more information, check out the <a href="../../api/router/canmatchfn">API docs for CanMatchFn</a>.</p> <h2 id="applying-guards-to-routes"> Applying guards to routes </h2> <p>Once you've created your route guards, you need to configure them in your route definitions.</p> <p>Guards are specified as arrays in the route configuration in order to allow you to apply multiple guards to a single route. They are executed in the order they appear in the array.</p> <pre data-language="ts">import { Routes } from '@angular/router';
import { authGuard } from './guards/auth.guard';
import { adminGuard } from './guards/admin.guard';
import { canDeactivateGuard } from './guards/can-deactivate.guard';
import { featureToggleGuard } from './guards/feature-toggle.guard';

const routes: Routes = [
  // Basic CanActivate - requires authentication
  {
    path: 'dashboard',
    component: DashboardComponent,
    canActivate: [authGuard]
  },

  // Multiple CanActivate guards - requires authentication AND admin role
  {
    path: 'admin',
    component: AdminComponent,
    canActivate: [authGuard, adminGuard]
  },

  // CanActivate + CanDeactivate - protected route with unsaved changes check
  {
    path: 'profile',
    component: ProfileComponent,
    canActivate: [authGuard],
    canDeactivate: [canDeactivateGuard]
  },

  // CanActivateChild - protects all child routes
  {
    path: 'users', // /user - NOT protected
    canActivateChild: [authGuard],
    children: [
      // /users/list - PROTECTED
      { path: 'list', component: UserListComponent },
      // /users/detail/:id - PROTECTED
      { path: 'detail/:id', component: UserDetailComponent }
    ]
  },

  // CanMatch - conditionally matches route based on feature flag
  {
    path: 'beta-feature',
    component: BetaFeatureComponent,
    canMatch: [featureToggleGuard]
  },

  // Fallback route if beta feature is disabled
  {
    path: 'beta-feature',
    component: ComingSoonComponent
  }
];</pre><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/guide/routing/route-guards" class="_attribution-link">https://angular.dev/guide/routing/route-guards</a>
  </p>
</div>
