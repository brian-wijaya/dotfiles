<h1 tabindex="-1">Programmatically rendering components</h1> <header class="docs-header"> <docs-breadcrumb ng-version="21.0.3" _nghost-ng-c3945279308 ngh="8"></docs-breadcrumb>   </header> 
<div class="docs-alert docs-alert-tip"> <p><strong>TIP:</strong> This guide assumes you've already read the <a href="https://angular.dev/essentials">Essentials Guide</a>. Read that first if you're new to Angular.</p> </div>  <p>In addition to using a component directly in a template, you can also dynamically render components programmatically. This is helpful for situations when a component is unknown initially (thus can not be referenced in a template directly) and it depends on some conditions.</p> <p>There are two main ways to render a component programmatically: in a template using <a href="../../api/common/ngcomponentoutlet"><code>NgComponentOutlet</code></a>, or in your TypeScript code using <a href="../../api/core/viewcontainerref"><code>ViewContainerRef</code></a>.</p> 
<div class="docs-alert docs-alert-helpful"> <p><strong>HELPFUL:</strong> for lazy-loading use-cases (for example if you want to delay loading of a heavy component), consider using the built-in <a href="../templates/defer"><code>@defer</code> feature</a> instead. The <code>@defer</code> feature allows the code of any components, directives, and pipes inside the <code>@defer</code> block to be extracted into separate JavaScript chunks automatically and loaded only when necessary, based on the configured triggers.</p> </div>  <h2 id="using-ngcomponentoutlet"> Using NgComponentOutlet </h2> <p><a href="../../api/common/ngcomponentoutlet"><code>NgComponentOutlet</code></a> is a structural directive that dynamically renders a given component in a template.</p> <pre data-language="ts">@Component({ ... })
export class AdminBio { /* ... */ }

@Component({ ... })
export class StandardBio { /* ... */ }

@Component({
  ...,
  template: `
    &lt;p&gt;Profile for {{user.name}}&lt;/p&gt;
    &lt;ng-container *ngComponentOutlet="getBioComponent()" /&gt; `
})
export class CustomDialog {
  user = input.required&lt;User&gt;();

  getBioComponent() {
    return this.user().isAdmin ? AdminBio : StandardBio;
  }
}</pre>
<p>See the <a href="../../api/common/ngcomponentoutlet">NgComponentOutlet API reference</a> for more information on the directive's capabilities.</p> <h2 id="using-viewcontainerref"> Using ViewContainerRef </h2> <p>A <strong>view container</strong> is a node in Angular's component tree that can contain content. Any component or directive can inject <a href="../../api/core/viewcontainerref"><code>ViewContainerRef</code></a> to get a reference to a view container corresponding to that component or directive's location in the DOM.</p> <p>You can use the <a href="../../api/core/createcomponent"><code>createComponent</code></a>method on <a href="../../api/core/viewcontainerref"><code>ViewContainerRef</code></a> to dynamically create and render a component. When you create a new component with a <a href="../../api/core/viewcontainerref"><code>ViewContainerRef</code></a>, Angular appends it into the DOM as the next sibling of the component or directive that injected the <a href="../../api/core/viewcontainerref"><code>ViewContainerRef</code></a>.</p> <pre data-language="ts">@Component({
  selector: 'leaf-content',
  template: `
    This is the leaf content
  `,
})
export class LeafContent {}

@Component({
  selector: 'outer-container',
  template: `
    &lt;p&gt;This is the start of the outer container&lt;/p&gt;
    &lt;inner-item /&gt;
    &lt;p&gt;This is the end of the outer container&lt;/p&gt;
  `,
})
export class OuterContainer {}

@Component({
  selector: 'inner-item',
  template: `
    &lt;button (click)="loadContent()"&gt;Load content&lt;/button&gt;
  `,
})
export class InnerItem {
  private viewContainer = inject(ViewContainerRef);

  loadContent() {
    this.viewContainer.createComponent(LeafContent);
  }
}</pre>
<p>In the example above, clicking the "Load content" button results in the following DOM structure</p> <pre data-language="ts">&lt;outer-container&gt;
  &lt;p&gt;This is the start of the outer container&lt;/p&gt;
  &lt;inner-item&gt;
    &lt;button&gt;Load content&lt;/button&gt;
  &lt;/inner-item&gt;
  &lt;leaf-content&gt;This is the leaf content&lt;/leaf-content&gt;
  &lt;p&gt;This is the end of the outer container&lt;/p&gt;
&lt;/outer-container&gt;</pre> <h2 id="lazy-loading-components"> Lazy-loading components </h2> 
<div class="docs-alert docs-alert-helpful"> <p><strong>HELPFUL:</strong> if you want to lazy-load some components, you may consider using the built-in <a href="../templates/defer"><code>@defer</code> feature</a> instead.</p> </div>  <p>If your use-case is not covered by the <code>@defer</code> feature, you can use either <a href="../../api/common/ngcomponentoutlet"><code>NgComponentOutlet</code></a> or <a href="../../api/core/viewcontainerref"><code>ViewContainerRef</code></a> with a standard JavaScript <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/import" target="_blank">dynamic import</a>.</p> <pre data-language="ts">@Component({
  ...,
  template: `
    &lt;section&gt;
      &lt;h2&gt;Basic settings&lt;/h2&gt;
      &lt;basic-settings /&gt;
    &lt;/section&gt;
    &lt;section&gt;
      &lt;h2&gt;Advanced settings&lt;/h2&gt;
      @if(!advancedSettings) {
        &lt;button (click)="loadAdvanced()"&gt;
          Load advanced settings
        &lt;/button&gt;
      }
      &lt;ng-container *ngComponentOutlet="advancedSettings" /&gt;
    &lt;/section&gt;
  `
})
export class AdminSettings {
  advancedSettings: {new(): AdvancedSettings} | undefined;

  async loadAdvanced() {
    const { AdvancedSettings } = await import('path/to/advanced_settings.js');
    this.advancedSettings = AdvancedSettings;
  }
}</pre>
<p>The example above loads and displays the <code>AdvancedSettings</code> upon receiving a button click.</p> <h2 id="binding-inputs-outputs-and-setting-host-directives-at-creation"> Binding inputs, outputs and setting host directives at creation </h2> <p>When dynamically creating components, manually setting inputs and subscribing to outputs can be error-prone. You often need to write extra code just to wire up bindings after the component is instantiated.</p> <p>To simplify this, both <a href="../../api/core/createcomponent"><code>createComponent</code></a> and <a href="../../api/core/viewcontainerref#createComponent"><code>ViewContainerRef.createComponent</code></a> support passing a <code>bindings</code> array with helpers like <a href="../../api/core/inputbinding"><code>inputBinding()</code></a>, <a href="../../api/core/outputbinding"><code>outputBinding()</code></a>, and <a href="../../api/core/twowaybinding"><code>twoWayBinding()</code></a> to configure inputs and outputs up front. You can also specify a <code>directives</code> array to apply any host directives. This enables creating components programmatically with template-like bindings in a single, declarative call.</p> <h3 id="host-view-using-viewcontainerrefcreatecomponent"> Host view using ViewContainerRef.createComponent </h3> <p><a href="../../api/core/viewcontainerref#createComponent"><code>ViewContainerRef.createComponent</code></a> creates a component and automatically inserts its host view and host element into the container’s view hierarchy at the container’s location. Use this when the dynamic component should become part of the container’s logical and visual structure (for example, adding list items or inline UI).</p> <p>By contrast, the standalone <a href="../../api/core/createcomponent"><code>createComponent</code></a> API does not attach the new component to any existing view or DOM location — it returns a <a href="../../api/core/componentref"><code>ComponentRef</code></a> and gives you explicit control over where to place the component’s host element.</p> <pre data-language="ts">import { Component, input, model, output } from "@angular/core";

@Component({
  selector: 'app-warning',
  template: `
      @if(isExpanded()) {
        &lt;section&gt;
            &lt;p&gt;Warning: Action needed!&lt;/p&gt;
            &lt;button (click)="close.emit(true)"&gt;Close&lt;/button&gt;
        &lt;/section&gt;
      }
  `
})
export class AppWarningComponent {
  readonly canClose = input.required&lt;boolean&gt;();
  readonly isExpanded = model&lt;boolean&gt;();
  readonly close = output&lt;boolean&gt;();
}</pre>
<pre data-language="ts">import { Component, ViewContainerRef, signal, inputBinding, outputBinding, twoWayBinding, inject } from '@angular/core';
import { FocusTrap } from "@angular/cdk/a11y";
import { ThemeDirective } from '../theme.directive';

@Component({
  template: `&lt;ng-container #container /&gt;`
})
export class HostComponent {
  private vcr = inject(ViewContainerRef);
  readonly canClose = signal(true);
  readonly isExpanded = signal(true);

  showWarning() {
    const compRef = this.vcr.createComponent(AppWarningComponent, {
      bindings: [
        inputBinding('canClose', this.canClose),
        twoWayBinding('isExpanded', this.isExpanded),
        outputBinding&lt;boolean&gt;('close', (confirmed) =&gt; {
          console.log('Closed with result:', confirmed);
        })
      ],
      directives: [
        FocusTrap,
        { type: ThemeDirective, bindings: [inputBinding('theme', () =&gt; 'warning')] }
      ]
    });
  }
}</pre>
<p>In the example above, the dynamic <strong>AppWarningComponent</strong> is created with its <code>canClose</code> input bound to a reactive signal, a two-way binding on its <code>isExpanded</code> state, and an output listener for <code>close</code>. The <code>FocusTrap</code> and <code>ThemeDirective</code> are attached to the host element via <code>directives</code>.</p> <h3 id="popup-attached-to-documentbody-with-createcomponent--hostelement"> Popup attached to document.body with createComponent + hostElement </h3> <p>Use this when rendering outside the current view hierarchy (e.g., overlays). The provided <code>hostElement</code> becomes the component’s host in the DOM, so Angular doesn’t create a new element matching the selector. Lets you configure <strong>bindings</strong> directly.</p> <pre data-language="ts">import {
  ApplicationRef,
  createComponent,
  EnvironmentInjector,
  inject,
  Injectable,
  inputBinding,
  outputBinding,
} from '@angular/core';
import { PopupComponent } from './popup.component';

@Injectable({ providedIn: 'root' })
export class PopupService {
  private readonly injector = inject(EnvironmentInjector);
  private readonly appRef = inject(ApplicationRef);

  show(message: string) {
    // Create a host element for the popup
    const host = document.createElement('popup-host');

    // Create the component and bind in one call
    const ref = createComponent(PopupComponent, {
      environmentInjector: this.injector,
      hostElement: host,
      bindings: [
        inputBinding('message', () =&gt; message),
        outputBinding('closed', () =&gt; {
          document.body.removeChild(host);
          this.appRef.detachView(ref.hostView);
          ref.destroy();
        }),
      ],
    });

    // Registers the component’s view so it participates in change detection cycle.
    this.appRef.attachView(ref.hostView);
    // Inserts the provided host element into the DOM (outside the normal Angular view hierarchy).
    // This is what makes the popup visible on screen, typically used for overlays or modals.
    document.body.appendChild(host);
  }
}</pre><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/guide/components/programmatic-rendering" class="_attribution-link">https://angular.dev/guide/components/programmatic-rendering</a>
  </p>
</div>
