<h1 tabindex="-1">Typed Forms</h1> <header class="docs-header"> <docs-breadcrumb ng-version="21.0.3" _nghost-ng-c3945279308 ngh="8"></docs-breadcrumb>   </header> <p>As of Angular 14, reactive forms are strictly typed by default.</p> <p>As background for this guide, you should already be familiar with <a href="reactive-forms">Angular Reactive Forms</a>.</p> <h2 id="overview-of-typed-forms"> Overview of Typed Forms </h2> <div class="docs-video-container"> <iframe class="docs-video" src="https://www.youtube.com/embed/L-odCf4MfJc" allow="accelerometer; encrypted-media; gyroscope; picture-in-picture" allowfullscreen credentialless title="Video player"></iframe> </div> <p>With Angular reactive forms, you explicitly specify a <em>form model</em>. As a simple example, consider this basic user login form:</p> <pre data-language="ts">const login = new FormGroup({
  email: new FormControl(''),
  password: new FormControl(''),
});</pre>
<p>Angular provides many APIs for interacting with this <a href="../../api/forms/formgroup"><code>FormGroup</code></a>. For example, you may call <code>login.value</code>, <code>login.controls</code>, <code>login.patchValue</code>, etc. (For a full API reference, see the <a href="../../api/forms/formgroup">API documentation</a>.)</p> <p>In previous Angular versions, most of these APIs included <code>any</code> somewhere in their types, and interacting with the structure of the controls, or the values themselves, was not type-safe. For example: you could write the following invalid code:</p> <pre data-language="ts">const emailDomain = login.value.email.domain;</pre>
<p>With strictly typed reactive forms, the above code does not compile, because there is no <code>domain</code> property on <a href="../../api/forms/signals/email"><code>email</code></a>.</p> <p>In addition to the added safety, the types enable a variety of other improvements, such as better autocomplete in IDEs, and an explicit way to specify form structure.</p> <p>These improvements currently apply only to <em>reactive</em> forms (not <a href="template-driven-forms"><em>template-driven</em> forms</a>).</p> <h2 id="untyped-forms"> Untyped Forms </h2> <p>Non-typed forms are still supported, and will continue to work as before. To use them, you must import the <code>Untyped</code> symbols from <code>@angular/forms</code>:</p> <pre data-language="ts">const login = new UntypedFormGroup({
  email: new UntypedFormControl(''),
  password: new UntypedFormControl(''),
});</pre>
<p>Each <code>Untyped</code> symbol has exactly the same semantics as in previous Angular version. By removing the <code>Untyped</code> prefixes, you can incrementally enable the types.</p> <h2 id="formcontrol-getting-started"> FormControl: Getting Started </h2> <p>The simplest possible form consists of a single control:</p> <pre data-language="ts">const email = new FormControl('angularrox@gmail.com');</pre>
<p>This control will be automatically inferred to have the type <code>FormControl&lt;string|null&gt;</code>. TypeScript will automatically enforce this type throughout the <a href="../../api/forms/formcontrol"><code>FormControl</code></a> API, such as <a href="../../api/forms/signals/email#value"><code>email.value</code></a>, <a href="../../api/forms/signals/email#valueChanges"><code>email.valueChanges</code></a>, <code>email.setValue(...)</code>, etc.</p> <h3 id="nullability"> Nullability </h3> <p>You might wonder: why does the type of this control include <code>null</code>? This is because the control can become <code>null</code> at any time, by calling reset:</p> <pre data-language="ts">const email = new FormControl('angularrox@gmail.com');
email.reset();
console.log(email.value); // null</pre>
<p>TypeScript will enforce that you always handle the possibility that the control has become <code>null</code>. If you want to make this control non-nullable, you may use the <code>nonNullable</code> option. This will cause the control to reset to its initial value, instead of <code>null</code>:</p> <pre data-language="ts">const email = new FormControl('angularrox@gmail.com', {nonNullable: true});
email.reset();
console.log(email.value); // angularrox@gmail.com</pre>
<p>To reiterate, this option affects the runtime behavior of your form when <code>.reset()</code> is called, and should be flipped with care.</p> <h3 id="specifying-an-explicit-type"> Specifying an Explicit Type </h3> <p>It is possible to specify the type, instead of relying on inference. Consider a control that is initialized to <code>null</code>. Because the initial value is <code>null</code>, TypeScript will infer <code>FormControl&lt;null&gt;</code>, which is narrower than we want.</p> <pre data-language="ts">const email = new FormControl(null);
email.setValue('angularrox@gmail.com'); // Error!</pre>
<p>To prevent this, we explicitly specify the type as <code>string|null</code>:</p> <pre data-language="ts">const email = new FormControl&lt;string|null&gt;(null);
email.setValue('angularrox@gmail.com');</pre> <h2 id="formarray-dynamic-homogenous-collections"> FormArray: Dynamic, Homogenous Collections </h2> <p>A <a href="../../api/forms/formarray"><code>FormArray</code></a> contains an open-ended list of controls. The type parameter corresponds to the type of each inner control:</p> <pre data-language="ts">const names = new FormArray([new FormControl('Alex')]);
names.push(new FormControl('Jess'));</pre>
<p>Pass an array of controls to <code>aliases.push()</code> when you need to add several entries at once.</p> <pre data-language="ts">const aliases = new FormArray([new FormControl('ng')]);
aliases.push([new FormControl('ngDev'), new FormControl('ngAwesome')]);</pre>
<p>This <a href="../../api/forms/formarray"><code>FormArray</code></a> will have the inner controls type <code>FormControl&lt;string|null&gt;</code>.</p> <p>If you want to have multiple different element types inside the array, you must use <a href="../../api/forms/untypedformarray"><code>UntypedFormArray</code></a>, because TypeScript cannot infer which element type will occur at which position.</p> <p>A <a href="../../api/forms/formarray"><code>FormArray</code></a> also provides a <code>clear()</code> method to remove all controls it contains:</p> <pre data-language="ts">const aliases = new FormArray([new FormControl('ngDev'), new FormControl('ngAwesome')]);
aliases.clear();
console.log(aliases.length); // 0</pre> <h2 id="formgroup-and-formrecord"> FormGroup and FormRecord </h2> <p>Angular provides the <a href="../../api/forms/formgroup"><code>FormGroup</code></a> type for forms with an enumerated set of keys, and a type called <a href="../../api/forms/formrecord"><code>FormRecord</code></a>, for open-ended or dynamic groups.</p> <h3 id="partial-values"> Partial Values </h3> <p>Consider again a login form:</p> <pre data-language="ts">const login = new FormGroup({
    email: new FormControl('', {nonNullable: true}),
    password: new FormControl('', {nonNullable: true}),
});</pre>
<p>On any <a href="../../api/forms/formgroup"><code>FormGroup</code></a>, it is <a href="../../api/forms/formgroup">possible to disable controls</a>. Any disabled control will not appear in the group's value.</p> <p>As a consequence, the type of <code>login.value</code> is <code>Partial&lt;{email: string, password: string}&gt;</code>. The <code>Partial</code> in this type means that each member might be undefined.</p> <p>More specifically, the type of <code>login.value.email</code> is <code>string|undefined</code>, and TypeScript will enforce that you handle the possibly <code>undefined</code> value (if you have <code>strictNullChecks</code> enabled).</p> <p>If you want to access the value <em>including</em> disabled controls, and thus bypass possible <code>undefined</code> fields, you can use <code>login.getRawValue()</code>.</p> <h3 id="optional-controls-and-dynamic-groups"> Optional Controls and Dynamic Groups </h3> <p>Some forms have controls that may or may not be present, which can be added and removed at runtime. You can represent these controls using <em>optional fields</em>:</p> <pre data-language="ts">interface LoginForm {
  email: FormControl&lt;string&gt;;
  password?: FormControl&lt;string&gt;;
}

const login = new FormGroup&lt;LoginForm&gt;({
  email: new FormControl('', {nonNullable: true}),
  password: new FormControl('', {nonNullable: true}),
});

login.removeControl('password');</pre>
<p>In this form, we explicitly specify the type, which allows us to make the <code>password</code> control optional. TypeScript will enforce that only optional controls can be added or removed.</p> <h3 id="formrecord"> FormRecord </h3> <p>Some <a href="../../api/forms/formgroup"><code>FormGroup</code></a> usages do not fit the above pattern because the keys are not known ahead of time. The <a href="../../api/forms/formrecord"><code>FormRecord</code></a> class is designed for that case:</p> <pre data-language="ts">const addresses = new FormRecord&lt;FormControl&lt;string|null&gt;&gt;({});
addresses.addControl('Andrew', new FormControl('2340 Folsom St'));</pre>
<p>Any control of type <code>string|null</code> can be added to this <a href="../../api/forms/formrecord"><code>FormRecord</code></a>.</p> <p>If you need a <a href="../../api/forms/formgroup"><code>FormGroup</code></a> that is both dynamic (open-ended) and heterogeneous (the controls are different types), no improved type safety is possible, and you should use <a href="../../api/forms/untypedformgroup"><code>UntypedFormGroup</code></a>.</p> <p>A <a href="../../api/forms/formrecord"><code>FormRecord</code></a> can also be built with the <a href="../../api/forms/formbuilder"><code>FormBuilder</code></a>:</p> <pre data-language="ts">const addresses = fb.record({'Andrew': '2340 Folsom St'});</pre> <h2 id="formbuilder-and-nonnullableformbuilder"> FormBuilder and NonNullableFormBuilder </h2> <p>The <a href="../../api/forms/formbuilder"><code>FormBuilder</code></a> class has been upgraded to support the new types as well, in the same manner as the above examples.</p> <p>Additionally, an additional builder is available: <a href="../../api/forms/nonnullableformbuilder"><code>NonNullableFormBuilder</code></a>. This type is shorthand for specifying <code>{nonNullable: true}</code> on every control, and can eliminate significant boilerplate from large non-nullable forms. You can access it using the <code>nonNullable</code> property on a <a href="../../api/forms/formbuilder"><code>FormBuilder</code></a>:</p> <pre data-language="ts">const fb = new FormBuilder();
const login = fb.nonNullable.group({
  email: '',
  password: '',
});</pre>
<p>On the above example, both inner controls will be non-nullable (i.e. <code>nonNullable</code> will be set).</p> <p>You can also inject it using the name <a href="../../api/forms/nonnullableformbuilder"><code>NonNullableFormBuilder</code></a>.</p><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/guide/forms/typed-forms" class="_attribution-link">https://angular.dev/guide/forms/typed-forms</a>
  </p>
</div>
