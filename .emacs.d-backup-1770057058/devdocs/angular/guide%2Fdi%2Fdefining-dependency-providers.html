<h1 tabindex="-1">Defining dependency providers</h1> <header class="docs-header"> <docs-breadcrumb ng-version="21.0.3" _nghost-ng-c3945279308 ngh="8"></docs-breadcrumb>   </header> <p>Angular provides two ways to make services available for injection:</p> <ol class="docs-ordered-list"> <li>
<strong>Automatic provision</strong> - Using <code>providedIn</code> in the <a href="../../api/core/injectable"><code>@Injectable</code></a> decorator or by providing a factory in the <a href="../../api/core/injectiontoken"><code>InjectionToken</code></a> configuration</li> <li>
<strong>Manual provision</strong> - Using the <code>providers</code> array in components, directives, routes, or application config</li> </ol> <p>In the <a href="creating-and-using-services">previous guide</a>, you learned how to create services using <code>providedIn: 'root'</code>, which handles most common use cases. This guide explores additional patterns for both automatic and manual provider configuration.</p> <h2 id="automatic-provision-for-non-class-dependencies"> Automatic provision for non-class dependencies </h2> <p>While the <a href="../../api/core/injectable"><code>@Injectable</code></a> decorator with <code>providedIn: 'root'</code> works great for services (classes), you might need to provide other types of values globally - like configuration objects, functions, or primitive values. Angular provides <a href="../../api/core/injectiontoken"><code>InjectionToken</code></a> for this purpose.</p> <h3 id="what-is-an-injectiontoken"> What is an InjectionToken? </h3> <p>An <a href="../../api/core/injectiontoken"><code>InjectionToken</code></a> is an object that Angular's dependency injection system uses to uniquely identify values for injection. Think of it as a special key that lets you store and retrieve any type of value in Angular's DI system:</p> <pre data-language="ts">import { InjectionToken } from '@angular/core';

// Create a token for a string value
export const API_URL = new InjectionToken&lt;string&gt;('api.url');

// Create a token for a function
export const LOGGER = new InjectionToken&lt;(msg: string) =&gt; void&gt;('logger.function');

// Create a token for a complex type
export interface Config {
  apiUrl: string;
  timeout: number;
}
export const CONFIG_TOKEN = new InjectionToken&lt;Config&gt;('app.config');</pre>

<div class="docs-alert docs-alert-note"> <p><strong>NOTE:</strong> The string parameter (e.g., <code>'api.url'</code>) is a description purely for debugging ‚Äî Angular identifies tokens by their object reference, not this string.</p> </div>  <h3 id="injectiontoken-with-providedin-root"> InjectionToken with providedIn: 'root' </h3> <p>An <a href="../../api/core/injectiontoken"><code>InjectionToken</code></a> that has a <code>factory</code> results in <code>providedIn: 'root'</code> by default (but can be overidden via the <code>providedIn</code> prop).</p> <pre data-language="ts">// üìÅ /app/config.token.ts
import { InjectionToken } from '@angular/core';

export interface AppConfig {
  apiUrl: string;
  version: string;
  features: Record&lt;string, boolean&gt;;
}

// Globally available configuration using providedIn
export const APP_CONFIG = new InjectionToken&lt;AppConfig&gt;('app.config', {
  providedIn: 'root',
  factory: () =&gt; ({
    apiUrl: 'https://api.example.com',
    version: '1.0.0',
    features: {
      darkMode: true,
      analytics: false
    }
  })
});

// No need to add to providers array - available everywhere!
@Component({
  selector: 'app-header',
  template: `&lt;h1&gt;Version: {{ config.version }}&lt;/h1&gt;`
})
export class HeaderComponent {
  config = inject(APP_CONFIG); // Automatically available
}</pre> <h3 id="when-to-use-injectiontoken-with-factory-functions"> When to use InjectionToken with factory functions </h3> <p>InjectionToken with factory functions is ideal when you can't use a class but need to provide dependencies globally:</p> <pre data-language="ts">// üìÅ /app/logger.token.ts
import { InjectionToken, inject } from '@angular/core';
import { APP_CONFIG } from './config.token';

// Logger function type
export type LoggerFn = (level: string, message: string) =&gt; void;

// Global logger function with dependencies
export const LOGGER_FN = new InjectionToken&lt;LoggerFn&gt;('logger.function', {
  providedIn: 'root',
  factory: () =&gt; {
    const config = inject(APP_CONFIG);

    return (level: string, message: string) =&gt; {
      if (config.features.logging !== false) {
        console[level](`[${new Date().toISOString()}] ${message}`);
      }
    };
  }
});

// üìÅ /app/storage.token.ts
// Providing browser APIs as tokens
export const LOCAL_STORAGE = new InjectionToken&lt;Storage&gt;('localStorage', {
  // providedIn: 'root' is configured as the default
  factory: () =&gt; window.localStorage
});

export const SESSION_STORAGE = new InjectionToken&lt;Storage&gt;('sessionStorage', {
  providedIn: 'root',
  factory: () =&gt; window.sessionStorage
});

// üìÅ /app/feature-flags.token.ts
// Complex configuration with runtime logic
export const FEATURE_FLAGS = new InjectionToken&lt;Map&lt;string, boolean&gt;&gt;('feature.flags', {
  providedIn: 'root',
  factory: () =&gt; {
    const flags = new Map&lt;string, boolean&gt;();

    // Parse from environment or URL params
    const urlParams = new URLSearchParams(window.location.search);
    const enableBeta = urlParams.get('beta') === 'true';

    flags.set('betaFeatures', enableBeta);
    flags.set('darkMode', true);
    flags.set('newDashboard', false);

    return flags;
  }
});</pre>
<p>This approach offers several advantages:</p> <ul class="docs-list"> <li>
<strong>No manual provider configuration needed</strong> - Works just like <code>providedIn: 'root'</code> for services</li> <li>
<strong>Tree-shakeable</strong> - Only included if actually used</li> <li>
<strong>Type-safe</strong> - Full TypeScript support for non-class values</li> <li>
<strong>Can inject other dependencies</strong> - Factory functions can use <code>inject()</code> to access other services</li> </ul> <h2 id="understanding-manual-provider-configuration"> Understanding manual provider configuration </h2> <p>When you need more control than <code>providedIn: 'root'</code> offers, you can manually configure providers. Manual configuration through the <code>providers</code> array is useful when:</p> <ol class="docs-ordered-list"> <li>
<strong>The service doesn't have <code>providedIn</code></strong> - Services without automatic provision must be manually provided</li> <li>
<strong>You want a new instance</strong> - To create a separate instance at the component/directive level instead of using the shared one</li> <li>
<strong>You need runtime configuration</strong> - When service behavior depends on runtime values</li> <li>
<strong>You're providing non-class values</strong> - Configuration objects, functions, or primitive values</li> </ol> <h3 id="example-service-without-providedin"> Example: Service without providedIn </h3> <pre data-language="ts">import { Injectable, Component, inject } from '@angular/core';

// Service without providedIn
@Injectable()
export class LocalDataStore {
  private data: string[] = [];

  addData(item: string) {
    this.data.push(item);
  }
}

// Component must provide it
@Component({
  selector: 'app-example',
  // A provider is required here because the `LocalDataStore` service has no providedIn.
  providers: [LocalDataStore],
  template: `...`
})
export class ExampleComponent {
  dataStore = inject(LocalDataStore);
}</pre> <h3 id="example-creating-component-specific-instances"> Example: Creating component-specific instances </h3> <p>Services with <code>providedIn: 'root'</code> can be overridden at the component level. This ties the instance of the service to the life of a component. As a result, when the component gets destroyed, the provided service is also destroyed as well.</p> <pre data-language="ts">import { Injectable, Component, inject } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class DataStore {
  private data: ListItem[] = [];
}

// This component gets its own instance
@Component({
  selector: 'app-isolated',
  // Creates new instance of `DataStore` rather than using the root-provided instance.
  providers: [DataStore],
  template: `...`
})
export class IsolatedComponent {
  dataStore = inject(DataStore); // Component-specific instance
}</pre> <h2 id="injector-hierarchy-in-angular"> Injector hierarchy in Angular </h2> <p>Angular's dependency injection system is hierarchical. When a component requests a dependency, Angular starts with that component's injector and walks up the tree until it finds a provider for that dependency. Each component in your application tree can have its own injector, and these injectors form a hierarchy that mirrors your component tree.</p> <p>This hierarchy enables:</p> <ul class="docs-list"> <li>
<strong>Scoped instances</strong>: Different parts of your app can have different instances of the same service</li> <li>
<strong>Override behavior</strong>: Child components can override providers from parent components</li> <li>
<strong>Memory efficiency</strong>: Services are only instantiated where needed</li> </ul> <p>In Angular, any element with a component or directive can provide values to all of its descendants.</p> <svg id="mermaid-generated-diagram" width="100%" xmlns="http://www.w3.org/2000/svg" class="flowchart" style="max-width: 486.6171875px;" viewbox="0 0 486.6171875 548" role="graphics-document document" aria-roledescription="flowchart-v2"><g><marker id="mermaid-generated-diagram_flowchart-v2-pointEnd" class="marker flowchart-v2" viewbox="0 0 10 10" refx="5" refy="5" markerunits="userSpaceOnUse" markerwidth="8" markerheight="8" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker><marker id="mermaid-generated-diagram_flowchart-v2-pointStart" class="marker flowchart-v2" viewbox="0 0 10 10" refx="4.5" refy="5" markerunits="userSpaceOnUse" markerwidth="8" markerheight="8" orient="auto"><path d="M 0 5 L 10 10 L 10 0 z" class="arrowMarkerPath" style="stroke-width: 1; stroke-dasharray: 1, 0;"></path></marker><marker id="mermaid-generated-diagram_flowchart-v2-crossEnd" class="marker cross flowchart-v2" viewbox="0 0 11 11" refx="12" refy="5.2" markerunits="userSpaceOnUse" markerwidth="11" markerheight="11" orient="auto"><path d="M 1,1 l 9,9 M 10,1 l -9,9" class="arrowMarkerPath" style="stroke-width: 2; stroke-dasharray: 1, 0;"></path></marker><marker id="mermaid-generated-diagram_flowchart-v2-crossStart" class="marker cross flowchart-v2" viewbox="0 0 11 11" refx="-1" refy="5.2" markerunits="userSpaceOnUse" markerwidth="11" markerheight="11" orient="auto"><path d="M 1,1 l 9,9 M 10,1 l -9,9" class="arrowMarkerPath" style="stroke-width: 2; stroke-dasharray: 1, 0;"></path></marker><g class="root"><g class="nodes"><g class="root" transform="translate(0, 0)"><g class="clusters"><g class="cluster" id="platform" data-look="classic"><rect style="" x="8" y="8" width="470.6171875" height="532"></rect><g class="cluster-label" transform="translate(214.41015625, 8)"><foreignobject width="57.796875" height="24"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel"><p>platform</p></span></div></foreignobject></g></g></g><g class="nodes"><g class="root" transform="translate(37.5, 35)"><g class="clusters"><g class="cluster" id="root" data-look="classic"><rect style="" x="8" y="8" width="395.6171875" height="462"></rect><g class="cluster-label" transform="translate(192.01953125, 8)"><foreignobject width="27.578125" height="24"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel"><p>root</p></span></div></foreignobject></g></g></g><g class="edgePaths"><path d="M172.536,112L162.542,120.333C152.548,128.667,132.559,145.333,122.565,161.333C112.57,177.333,112.57,192.667,112.57,200.333L112.57,208" id="L_A_B_0" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" style=";" data-edge="true" data-et="edge" data-id="L_A_B_0" data-points="W3sieCI6MTcyLjUzNjMyMzA1MTk0ODA1LCJ5IjoxMTJ9LHsieCI6MTEyLjU3MDMxMjUsInkiOjE2Mn0seyJ4IjoxMTIuNTcwMzEyNSwieSI6MjEyfV0=" marker-end="url(#mermaid-generated-diagram_flowchart-v2-pointEnd)"></path><path d="M237.3,112L247.294,120.333C257.288,128.667,277.277,145.333,287.271,161.333C297.266,177.333,297.266,192.667,297.266,200.333L297.266,208" id="L_A_C_0" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" style=";" data-edge="true" data-et="edge" data-id="L_A_C_0" data-points="W3sieCI6MjM3LjI5OTYxNDQ0ODA1MTk1LCJ5IjoxMTJ9LHsieCI6Mjk3LjI2NTYyNSwieSI6MTYyfSx7IngiOjI5Ny4yNjU2MjUsInkiOjIxMn1d" marker-end="url(#mermaid-generated-diagram_flowchart-v2-pointEnd)"></path><path d="M297.266,266L297.266,274.333C297.266,282.667,297.266,299.333,297.266,315.333C297.266,331.333,297.266,346.667,297.266,354.333L297.266,362" id="L_C_D_0" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" style=";" data-edge="true" data-et="edge" data-id="L_C_D_0" data-points="W3sieCI6Mjk3LjI2NTYyNSwieSI6MjY2fSx7IngiOjI5Ny4yNjU2MjUsInkiOjMxNn0seyJ4IjoyOTcuMjY1NjI1LCJ5IjozNjZ9XQ==" marker-end="url(#mermaid-generated-diagram_flowchart-v2-pointEnd)"></path></g><g class="nodes"><g class="node default" id="flowchart-A-0" transform="translate(204.91796875, 85)"><rect class="basic label-container" style="" x="-66.0234375" y="-27" width="132.046875" height="54"></rect><g class="label" style="" transform="translate(-36.0234375, -12)"><rect></rect><foreignobject width="72.046875" height="24"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel"><p>SocialApp</p></span></div></foreignobject></g></g><g class="node default" id="flowchart-B-1" transform="translate(112.5703125, 239)"><rect class="basic label-container" style="" x="-69.5703125" y="-27" width="139.140625" height="54"></rect><g class="label" style="" transform="translate(-39.5703125, -12)"><rect></rect><foreignobject width="79.140625" height="24"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel"><p>UserProfile</p></span></div></foreignobject></g></g><g class="node default" id="flowchart-C-3" transform="translate(297.265625, 239)"><rect class="basic label-container" style="" x="-65.125" y="-27" width="130.25" height="54"></rect><g class="label" style="" transform="translate(-35.125, -12)"><rect></rect><foreignobject width="70.25" height="24"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel"><p>FriendList</p></span></div></foreignobject></g></g><g class="node default" id="flowchart-D-5" transform="translate(297.265625, 393)"><rect class="basic label-container" style="" x="-71.3515625" y="-27" width="142.703125" height="54"></rect><g class="label" style="" transform="translate(-41.3515625, -12)"><rect></rect><foreignobject width="82.703125" height="24"><div xmlns="http://www.w3.org/1999/xhtml" style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;"><span class="nodeLabel"><p>FriendEntry</p></span></div></foreignobject></g></g></g></g></g></g></g></g></g></svg><p>In the example above:</p> <ol class="docs-ordered-list"> <li>
<code>SocialApp</code> can provide values for <code>UserProfile</code> and <code>FriendList</code>
</li> <li>
<code>FriendList</code> can provide values for injection to <code>FriendEntry</code>, but cannot provide values for injection in <code>UserProfile</code> because it's not part of the tree</li> </ol> <h2 id="declaring-a-provider"> Declaring a provider </h2> <p>Think of Angular's dependency injection system as a hash map or dictionary. Each provider configuration object defines a key-value pair:</p> <ul class="docs-list"> <li>
<strong>Key (Provider identifier)</strong>: The unique identifier you use to request a dependency</li> <li>
<strong>Value</strong>: What Angular should return when that token is requested</li> </ul> <p>When manually providing dependencies, you typically see this shorthand syntax:</p> <pre data-language="ts">import { Component } from '@angular/core';
import { LocalService } from './local-service';

@Component({
  selector: 'app-example',
  providers: [LocalService]  // Service without providedIn
})
export class ExampleComponent { }</pre>
<p>This is actually a shorthand for a more detailed provider configuration:</p> <pre data-language="ts">{
  // This is the shorthand version
  providers: [LocalService],

  // This is the full version
  providers: [
    { provide: LocalService, useClass: LocalService }
  ]
}</pre> <h3 id="provider-configuration-object"> Provider configuration object </h3> <p>Every provider configuration object has two primary parts:</p> <ol class="docs-ordered-list"> <li>
<strong>Provider identifier</strong>: The unique key that Angular uses to get the dependency (set via the <code>provide</code> property)</li> <li>
<strong>Value</strong>: The actual dependency that you want Angular to fetch, configured with different keys based on the desired type: <ul class="docs-list"> <li>
<code>useClass</code> - Provides a JavaScript class</li> <li>
<code>useValue</code> - Provides a static value</li> <li>
<code>useFactory</code> - Provides a factory function that returns the value</li> <li>
<code>useExisting</code> - Provides an alias to an existing provider</li> </ul> </li> </ol> <h3 id="provider-identifiers"> Provider identifiers </h3> <p>Provider identifiers allow Angular's dependency injection (DI) system to retrieve a dependency through a unique ID. You can generate provider identifiers in two ways:</p> <ol class="docs-ordered-list"> <li><a href="#class-names">Class names</a></li> <li><a href="#injection-tokens">Injection tokens</a></li> </ol> <h4 id="class-names"> Class names </h4> <p>Class name use the imported class directly as the identifier:</p> <pre data-language="ts">import { Component } from '@angular/core';
import { LocalService } from './local-service';

@Component({
  selector: 'app-example',
  providers: [
    { provide: LocalService, useClass: LocalService }
  ]
})
export class ExampleComponent { /* ... */ }</pre>
<p>The class serves as both the identifier and the implementation, which is why Angular provides the shorthand <code>providers: [LocalService]</code>.</p> <h4 id="injection-tokens"> Injection tokens </h4> <p>Angular provides a built-in <a href="../../api/core/injectiontoken"><code>InjectionToken</code></a> class that creates a unique object reference for injectable values or when you want to provide multiple implementations of the same interface.</p> <pre data-language="ts">// üìÅ /app/tokens.ts
import { InjectionToken } from '@angular/core';
import { DataService } from './data-service.interface';

export const DATA_SERVICE_TOKEN = new InjectionToken&lt;DataService&gt;('DataService');</pre>

<div class="docs-alert docs-alert-note"> <p><strong>NOTE:</strong> The string <code>'DataService'</code> is a description used purely for debugging purposes. Angular identifies the token by its object reference, not this string.</p> </div>  <p>Use the token in your provider configuration:</p> <pre data-language="ts">import { Component, inject } from '@angular/core';
import { LocalDataService } from './local-data-service';
import { DATA_SERVICE_TOKEN } from './tokens';

@Component({
  selector: 'app-example',
  providers: [
    { provide: DATA_SERVICE_TOKEN, useClass: LocalDataService }
  ]
})
export class ExampleComponent {
  private dataService = inject(DATA_SERVICE_TOKEN);
}</pre> <h4 id="can-typescript-interfaces-be-identifiers-for-injection"> Can TypeScript interfaces be identifiers for injection? </h4> <p>TypeScript interfaces cannot be used for injection because they don't exist at runtime:</p> <pre data-language="ts">// ‚ùå This won't work!
interface DataService {
  getData(): string[];
}

// Interfaces disappear after TypeScript compilation
@Component({
  providers: [
    { provide: DataService, useClass: LocalDataService } // Error!
  ]
})
export class ExampleComponent {
  private dataService = inject(DataService); // Error!
}

// ‚úÖ Use InjectionToken instead
export const DATA_SERVICE_TOKEN = new InjectionToken&lt;DataService&gt;('DataService');

@Component({
  providers: [
    { provide: DATA_SERVICE_TOKEN, useClass: LocalDataService }
  ]
})
export class ExampleComponent {
  private dataService = inject(DATA_SERVICE_TOKEN); // Works!
}</pre>
<p>The InjectionToken provides a runtime value that Angular's DI system can use, while still maintaining type safety through TypeScript's generic type parameter.</p> <h3 id="provider-value-types"> Provider value types </h3> <h4 id="useclass"> useClass </h4> <p><code>useClass</code> provides a JavaScript class as a dependency. This is the default when using the shorthand syntax:</p> <pre data-language="ts">// Shorthand
providers: [DataService]

// Full syntax
providers: [
  { provide: DataService, useClass: DataService }
]

// Different implementation
providers: [
  { provide: DataService, useClass: MockDataService }
]

// Conditional implementation
providers: [
  {
    provide: StorageService,
    useClass: environment.production ? CloudStorageService : LocalStorageService
  }
]</pre> <h4 id="practical-example-logger-substitution"> Practical example: Logger substitution </h4> <p>You can substitute implementations to extend functionality:</p> <pre data-language="ts">import { Injectable, Component, inject } from '@angular/core';

// Base logger
@Injectable()
export class Logger {
  log(message: string) {
    console.log(message);
  }
}

// Enhanced logger with timestamp
@Injectable()
export class BetterLogger extends Logger {
  override log(message: string) {
    super.log(`[${new Date().toISOString()}] ${message}`);
  }
}

// Logger that includes user context
@Injectable()
export class EvenBetterLogger extends Logger {
  private userService = inject(UserService);

  override log(message: string) {
    const name = this.userService.user.name;
    super.log(`Message to ${name}: ${message}`);
  }
}

// In your component
@Component({
  selector: 'app-example',
  providers: [
    UserService, // EvenBetterLogger needs this
    { provide: Logger, useClass: EvenBetterLogger }
  ]
})
export class ExampleComponent {
  private logger = inject(Logger); // Gets EvenBetterLogger instance
}</pre> <h4 id="usevalue"> useValue </h4> <p><code>useValue</code> provides any JavaScript data type as a static value:</p> <pre data-language="ts">providers: [
  { provide: API_URL_TOKEN, useValue: 'https://api.example.com' },
  { provide: MAX_RETRIES_TOKEN, useValue: 3 },
  { provide: FEATURE_FLAGS_TOKEN, useValue: { darkMode: true, beta: false } }
]</pre>

<div class="docs-alert docs-alert-important"> <p><strong>IMPORTANT:</strong> TypeScript types and interfaces cannot serve as dependency values. They exist only at compile-time.</p> </div>  <h4 id="practical-example-application-configuration"> Practical example: Application configuration </h4> <p>A common use case for <code>useValue</code> is providing application configuration:</p> <pre data-language="ts">// Define configuration interface
export interface AppConfig {
  apiUrl: string;
  appTitle: string;
  features: {
    darkMode: boolean;
    analytics: boolean;
  };
}

// Create injection token
export const APP_CONFIG = new InjectionToken&lt;AppConfig&gt;('app.config');

// Define configuration
const appConfig: AppConfig = {
  apiUrl: 'https://api.example.com',
  appTitle: 'My Application',
  features: {
    darkMode: true,
    analytics: false
  }
};

// Provide in bootstrap
bootstrapApplication(AppComponent, {
  providers: [
    { provide: APP_CONFIG, useValue: appConfig }
  ]
});

// Use in component
@Component({
  selector: 'app-header',
  template: `&lt;h1&gt;{{ title }}&lt;/h1&gt;`
})
export class HeaderComponent {
  private config = inject(APP_CONFIG);
  title = this.config.appTitle;
}</pre> <h4 id="usefactory"> useFactory </h4> <p><code>useFactory</code> provides a function that generates a new value for injection:</p> <pre data-language="ts">export const loggerFactory = (config: AppConfig) =&gt; {
  return new LoggerService(config.logLevel, config.endpoint);
};

providers: [
  {
    provide: LoggerService,
    useFactory: loggerFactory,
    deps: [APP_CONFIG]  // Dependencies for the factory function
  }
]</pre>
<p>You can mark factory dependencies as optional:</p> <pre data-language="ts">import { Optional } from '@angular/core';

providers: [
  {
    provide: MyService,
    useFactory: (required: RequiredService, optional?: OptionalService) =&gt; {
      return new MyService(required, optional || new DefaultService());
    },
    deps: [RequiredService, [new Optional(), OptionalService]]
  }
]</pre> <h4 id="practical-example-configuration-based-api-client"> Practical example: Configuration-based API client </h4> <p>Here's a complete example showing how to use a factory to create a service with runtime configuration:</p> <pre data-language="ts">// Service that needs runtime configuration
class ApiClient {
  constructor(
    private http: HttpClient,
    private baseUrl: string,
    private rateLimitMs: number
  ) {}

  async fetchData(endpoint: string) {
    // Apply rate limiting based on user tier
    await this.applyRateLimit();
    return this.http.get(`${this.baseUrl}/${endpoint}`);
  }

  private async applyRateLimit() {
    // Simplified example - real implementation would track request timing
    return new Promise(resolve =&gt; setTimeout(resolve, this.rateLimitMs));
  }
}

// Factory function that configures based on user tier
import { inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
const apiClientFactory = () =&gt; {
  const http = inject(HttpClient);
  const userService = inject(UserService);

  // Assuming userService provides these values
  const baseUrl = userService.getApiBaseUrl();
  const rateLimitMs = userService.getRateLimit();

  return new ApiClient(http, baseUrl, rateLimitMs);
};

// Provider configuration
export const apiClientProvider = {
  provide: ApiClient,
  useFactory: apiClientFactory
};

// Usage in component
@Component({
  selector: 'app-dashboard',
  providers: [apiClientProvider]
})
export class DashboardComponent {
  private apiClient = inject(ApiClient);
}</pre> <h4 id="useexisting"> useExisting </h4> <p><code>useExisting</code> creates an alias for a provider that was already defined. Both tokens return the same instance:</p> <pre data-language="ts">providers: [
  NewLogger,  // The actual service
  { provide: OldLogger, useExisting: NewLogger }  // The alias
]</pre>

<div class="docs-alert docs-alert-important"> <p><strong>IMPORTANT:</strong> Don't confuse <code>useExisting</code> with <code>useClass</code>. <code>useClass</code> creates separate instances, while <code>useExisting</code> ensures you get the same singleton instance.</p> </div>  <h3 id="multiple-providers"> Multiple providers </h3> <p>Use the <code>multi: true</code> flag when multiple providers contribute values to the same token:</p> <pre data-language="ts">export const INTERCEPTOR_TOKEN = new InjectionToken&lt;Interceptor[]&gt;('interceptors');

providers: [
  { provide: INTERCEPTOR_TOKEN, useClass: AuthInterceptor, multi: true },
  { provide: INTERCEPTOR_TOKEN, useClass: LoggingInterceptor, multi: true },
  { provide: INTERCEPTOR_TOKEN, useClass: RetryInterceptor, multi: true }
]</pre>
<p>When you inject <code>INTERCEPTOR_TOKEN</code>, you'll receive an array containing instances of all three interceptors.</p> <h2 id="where-can-you-specify-providers"> Where can you specify providers? </h2> <p>Angular offers several levels where you can register providers, each with different implications for scope, lifecycle, and performance:</p> <ul class="docs-list"> <li>
<a href="#application-bootstrap"><strong>Application bootstrap</strong></a> - Global singletons available everywhere</li> <li>
<a href="#component-or-directive-providers"><strong>On an element (component or directive)</strong></a> - Isolated instances for specific component trees</li> <li>
<a href="#route-providers"><strong>Route</strong></a> - Feature-specific services for lazy-loaded modules</li> </ul> <h3 id="application-bootstrap"> Application bootstrap </h3> <p>Use application-level providers in <a href="../../api/platform-browser/bootstrapapplication"><code>bootstrapApplication</code></a> when:</p> <ul class="docs-list"> <li>
<strong>The service is used across multiple feature areas</strong> - Services like HTTP clients, logging, or authentication that many parts of your app need</li> <li>
<strong>You want a true singleton</strong> - One instance shared by the entire application</li> <li>
<strong>The service has no component-specific configuration</strong> - General-purpose utilities that work the same everywhere</li> <li>
<strong>You're providing global configuration</strong> - API endpoints, feature flags, or environment settings</li> </ul> <pre data-language="ts">// main.ts
bootstrapApplication(AppComponent, {
  providers: [
    { provide: API_BASE_URL, useValue: 'https://api.example.com' },
    { provide: INTERCEPTOR_TOKEN, useClass: AuthInterceptor, multi: true },
    LoggingService,  // Used throughout the app
    { provide: ErrorHandler, useClass: GlobalErrorHandler }
  ]
});</pre>
<p><strong>Benefits:</strong></p> <ul class="docs-list"> <li>Single instance reduces memory usage</li> <li>Available everywhere without additional setup</li> <li>Easier to manage global state</li> </ul> <p><strong>Drawbacks:</strong></p> <ul class="docs-list"> <li>Always included in your JavaScript bundle, even if the value is never injected</li> <li>Cannot be easily customized per feature</li> <li>Harder to test individual components in isolation</li> </ul> <h4 id="why-provide-during-bootstrap-instead-of-using-providedin-root"> Why provide during bootstrap instead of using providedIn: 'root'? </h4> <p>You might want a provider during bootstrap when:</p> <ul class="docs-list"> <li>The provider has side-effects (e.g., installing the client-side router)</li> <li>The provider requires configuration (e.g., routes)</li> <li>You're using Angular's <code>provideSomething</code> pattern (e.g., <a href="../../api/router/providerouter"><code>provideRouter</code></a>, <a href="../../api/common/http/providehttpclient"><code>provideHttpClient</code></a>)</li> </ul> <h3 id="component-or-directive-providers"> Component or directive providers </h3> <p>Use component or directive providers when:</p> <ul class="docs-list"> <li>
<strong>The service has component-specific state</strong> - Form validators, component-specific caches, or UI state managers</li> <li>
<strong>You need isolated instances</strong> - Each component needs its own copy of the service</li> <li>
<strong>The service is only used by one component tree</strong> - Specialized services that don't need global access</li> <li>
<strong>You're creating reusable components</strong> - Components that should work independently with their own services</li> </ul> <pre data-language="ts">// Specialized form component with its own validation service
@Component({
  selector: 'app-advanced-form',
  providers: [
    FormValidationService,  // Each form gets its own validator
    { provide: FORM_CONFIG, useValue: { strictMode: true } }
  ]
})
export class AdvancedFormComponent { }

// Modal component with isolated state management
@Component({
  selector: 'app-modal',
  providers: [
    ModalStateService  // Each modal manages its own state
  ]
})
export class ModalComponent { }</pre>
<p><strong>Benefits:</strong></p> <ul class="docs-list"> <li>Better encapsulation and isolation</li> <li>Easier to test components individually</li> <li>Multiple instances can coexist with different configurations</li> </ul> <p><strong>Drawbacks:</strong></p> <ul class="docs-list"> <li>New instance created for each component (higher memory usage)</li> <li>No shared state between components</li> <li>Must be provided wherever needed</li> <li>Always included in the same JavaScript bundle as the component or directive, even if the value is never injected</li> </ul> 
<div class="docs-alert docs-alert-note"> <p><strong>NOTE:</strong> If multiple directives on the same element provide the same token, one will win, but which one is undefined.</p> </div>  <h3 id="route-providers"> Route providers </h3> <p>Use route-level providers for:</p> <ul class="docs-list"> <li>
<strong>Feature-specific services</strong> - Services only needed for particular routes or feature modules</li> <li>
<strong>Lazy-loaded module dependencies</strong> - Services that should only load with specific features</li> <li>
<strong>Route-specific configuration</strong> - Settings that vary by application area</li> </ul> <pre data-language="ts">// routes.ts
export const routes: Routes = [
  {
    path: 'admin',
    providers: [
      AdminService,  // Only loaded with admin routes
      { provide: FEATURE_FLAGS, useValue: { adminMode: true } }
    ],
    loadChildren: () =&gt; import('./admin/admin.routes')
  },
  {
    path: 'shop',
    providers: [
      ShoppingCartService,  // Isolated shopping state
      PaymentService
    ],
    loadChildren: () =&gt; import('./shop/shop.routes')
  }
];</pre> <h2 id="library-author-patterns"> Library author patterns </h2> <p>When creating Angular libraries, you often need to provide flexible configuration options for consumers while maintaining clean APIs. Angular's own libraries demonstrate powerful patterns for achieving this.</p> <h3 id="the-provide-pattern"> The provide pattern </h3> <p>Instead of requiring users to manually configure complex providers, library authors can export functions that return provider configurations:</p> <pre data-language="ts">// üìÅ /libs/analytics/src/providers.ts
import { InjectionToken, Provider, inject } from '@angular/core';

// Configuration interface
export interface AnalyticsConfig {
  trackingId: string;
  enableDebugMode?: boolean;
  anonymizeIp?: boolean;
}

// Internal token for configuration
const ANALYTICS_CONFIG = new InjectionToken&lt;AnalyticsConfig&gt;('analytics.config');

// Main service that uses the configuration
export class AnalyticsService {
  private config = inject(ANALYTICS_CONFIG);

  track(event: string, properties?: any) {
    // Implementation using config
  }
}

// Provider function for consumers
export function provideAnalytics(config: AnalyticsConfig): Provider[] {
  return [
    { provide: ANALYTICS_CONFIG, useValue: config },
    AnalyticsService
  ];
}

// Usage in consumer app
// main.ts
bootstrapApplication(AppComponent, {
  providers: [
    provideAnalytics({
      trackingId: 'GA-12345',
      enableDebugMode: !environment.production
    })
  ]
});</pre> <h3 id="advanced-provider-patterns-with-options"> Advanced provider patterns with options </h3> <p>For more complex scenarios, you can combine multiple configuration approaches:</p> <pre data-language="ts">// üìÅ /libs/http-client/src/provider.ts
import { Provider, InjectionToken, inject } from '@angular/core';

// Feature flags for optional functionality
export enum HttpFeatures {
  Interceptors = 'interceptors',
  Caching = 'caching',
  Retry = 'retry'
}

// Configuration interfaces
export interface HttpConfig {
  baseUrl?: string;
  timeout?: number;
  headers?: Record&lt;string, string&gt;;
}

export interface RetryConfig {
  maxAttempts: number;
  delayMs: number;
}

// Internal tokens
const HTTP_CONFIG = new InjectionToken&lt;HttpConfig&gt;('http.config');
const RETRY_CONFIG = new InjectionToken&lt;RetryConfig&gt;('retry.config');
const HTTP_FEATURES = new InjectionToken&lt;Set&lt;HttpFeatures&gt;&gt;('http.features');

// Core service
class HttpClientService {
  private config = inject(HTTP_CONFIG, { optional: true });
  private features = inject(HTTP_FEATURES);

  get(url: string) {
    // Use config and check features
  }
}

// Feature services
class RetryInterceptor {
  private config = inject(RETRY_CONFIG);
  // Retry logic
}

class CacheInterceptor {
  // Caching logic
}

// Main provider function
export function provideHttpClient(
  config?: HttpConfig,
  ...features: HttpFeature[]
): Provider[] {
  const providers: Provider[] = [
    { provide: HTTP_CONFIG, useValue: config || {} },
    { provide: HTTP_FEATURES, useValue: new Set(features.map(f =&gt; f.kind)) },
    HttpClientService
  ];

  // Add feature-specific providers
  features.forEach(feature =&gt; {
    providers.push(...feature.providers);
  });

  return providers;
}

// Feature configuration functions
export interface HttpFeature {
  kind: HttpFeatures;
  providers: Provider[];
}

export function withInterceptors(...interceptors: any[]): HttpFeature {
  return {
    kind: HttpFeatures.Interceptors,
    providers: interceptors.map(interceptor =&gt; ({
      provide: INTERCEPTOR_TOKEN,
      useClass: interceptor,
      multi: true
    }))
  };
}

export function withCaching(): HttpFeature {
  return {
    kind: HttpFeatures.Caching,
    providers: [CacheInterceptor]
  };
}

export function withRetry(config: RetryConfig): HttpFeature {
  return {
    kind: HttpFeatures.Retry,
    providers: [
      { provide: RETRY_CONFIG, useValue: config },
      RetryInterceptor
    ]
  };
}

// Consumer usage with multiple features
bootstrapApplication(AppComponent, {
  providers: [
    provideHttpClient(
      { baseUrl: 'https://api.example.com' },
      withInterceptors(AuthInterceptor, LoggingInterceptor),
      withCaching(),
      withRetry({ maxAttempts: 3, delayMs: 1000 })
    )
  ]
});</pre> <h3 id="why-use-provider-functions-instead-of-direct-configuration"> Why use provider functions instead of direct configuration? </h3> <p>Provider functions offer several advantages for library authors:</p> <ol class="docs-ordered-list"> <li>
<strong>Encapsulation</strong> - Internal tokens and implementation details remain private</li> <li>
<strong>Type safety</strong> - TypeScript ensures correct configuration at compile time</li> <li>
<strong>Flexibility</strong> - Easily compose features with <code>with*</code> pattern</li> <li>
<strong>Future-proofing</strong> - Internal implementation can change without breaking consumers</li> <li>
<strong>Consistency</strong> - Aligns with Angular's own patterns (<a href="../../api/router/providerouter"><code>provideRouter</code></a>, <a href="../../api/common/http/providehttpclient"><code>provideHttpClient</code></a>, etc.)</li> </ol> <p>This pattern is extensively used in Angular's own libraries and is considered a best practice for library authors who need to provide configurable services.</p><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/guide/di/defining-dependency-providers" class="_attribution-link">https://angular.dev/guide/di/defining-dependency-providers</a>
  </p>
</div>
