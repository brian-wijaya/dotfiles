<h1 tabindex="-1">Incremental Hydration</h1> <header class="docs-header"> <docs-breadcrumb ng-version="21.0.3" _nghost-ng-c3945279308 ngh="8"></docs-breadcrumb>   </header> <p><strong>Incremental hydration</strong> is an advanced type of <a href="hydration">hydration</a> that can leave sections of your application dehydrated and <em>incrementally</em> trigger hydration of those sections as they are needed.</p> <h2 id="why-use-incremental-hydration"> Why use incremental hydration? </h2> <p>Incremental hydration is a performance improvement that builds on top of full application hydration. It can produce smaller initial bundles while still providing an end-user experience that is comparable to a full application hydration experience. Smaller bundles improve initial load times, reducing <a href="https://web.dev/fid" target="_blank">First Input Delay (FID)</a> and <a href="https://web.dev/cls" target="_blank">Cumulative Layout Shift (CLS)</a>.</p> <p>Incremental hydration also lets you use deferrable views (<code>@defer</code>) for content that may not have been deferrable before. Specifically, you can now use deferrable views for content that is above the fold. Prior to incremental hydration, putting a <code>@defer</code> block above the fold would result in placeholder content rendering and then being replaced by the <code>@defer</code> block's main template content. This would result in a layout shift. Incremental hydration means the main template of the <code>@defer</code> block will render with no layout shift on hydration.</p> <h2 id="how-do-you-enable-incremental-hydration-in-angular"> How do you enable incremental hydration in Angular? </h2> <p>You can enable incremental hydration for applications that already use server-side rendering (SSR) with hydration. Follow the <a href="ssr">Angular SSR Guide</a> to enable server-side rendering and the <a href="hydration">Angular Hydration Guide</a> to enable hydration first.</p> <p>Enable incremental hydration by adding the <a href="../api/platform-browser/withincrementalhydration"><code>withIncrementalHydration()</code></a> function to the <a href="../api/platform-browser/provideclienthydration"><code>provideClientHydration</code></a> provider.</p> <pre data-language="ts">import {
  bootstrapApplication,
  provideClientHydration,
  withIncrementalHydration,
} from '@angular/platform-browser';
...

bootstrapApplication(AppComponent, {
  providers: [provideClientHydration(withIncrementalHydration())]
});</pre>
<p>Incremental Hydration depends on and enables <a href="hydration#capturing-and-replaying-events">event replay</a> automatically. If you already have <a href="../api/platform-browser/witheventreplay"><code>withEventReplay()</code></a> in your list, you can safely remove it after enabling incremental hydration.</p> <h2 id="how-does-incremental-hydration-work"> How does incremental hydration work? </h2> <p>Incremental hydration builds on top of full-application <a href="hydration">hydration</a>, <a href="templates/defer">deferrable views</a>, and <a href="hydration#capturing-and-replaying-events">event replay</a>. With incremental hydration, you can add additional triggers to <code>@defer</code> blocks that define incremental hydration boundaries. Adding a <code>hydrate</code> trigger to a defer block tells Angular that it should load that defer block's dependencies during server-side rendering and render the main template rather than the <code>@placeholder</code>. When client-side rendering, the dependencies are still deferred, and the defer block content stays dehydrated until its <code>hydrate</code> trigger fires. That trigger tells the defer block to fetch its dependencies and hydrate the content. Any browser events, specifically those that match listeners registered in your component, that are triggered by the user prior to hydration are queued up and replayed once the hydration process is complete.</p> <h2 id="controlling-hydration-of-content-with-triggers"> Controlling hydration of content with triggers </h2> <p>You can specify <strong>hydrate triggers</strong> that control when Angular loads and hydrates deferred content. These are additional triggers that can be used alongside regular <code>@defer</code> triggers.</p> <p>Each <code>@defer</code> block may have multiple hydrate event triggers, separated with a semicolon (<code>;</code>). Angular triggers hydration when <em>any</em> of the triggers fire.</p> <p>There are three types of hydrate triggers: <code>hydrate on</code>, <code>hydrate when</code>, and <code>hydrate never</code>.</p> <h3 id="hydrate-on"> hydrate on </h3> <p><code>hydrate on</code> specifies a condition for when hydration is triggered for the <code>@defer</code> block.</p> <p>The available triggers are as follows:</p> <div class="docs-table docs-scroll-track-transparent"> <table> <thead> <tr> <th>Trigger</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><a href="#hydrate-on-idle"><code>hydrate on idle</code></a></td> <td>Triggers when the browser is idle.</td> </tr> <tr> <td><a href="#hydrate-on-viewport"><code>hydrate on viewport</code></a></td> <td>Triggers when specified content enters the viewport</td> </tr> <tr> <td><a href="#hydrate-on-interaction"><code>hydrate on interaction</code></a></td> <td>Triggers when the user interacts with specified element</td> </tr> <tr> <td><a href="#hydrate-on-hover"><code>hydrate on hover</code></a></td> <td>Triggers when the mouse hovers over specified area</td> </tr> <tr> <td><a href="#hydrate-on-immediate"><code>hydrate on immediate</code></a></td> <td>Triggers immediately after non-deferred content has finished rendering</td> </tr> <tr> <td><a href="#hydrate-on-timer"><code>hydrate on timer</code></a></td> <td>Triggers after a specific duration</td> </tr> </tbody> </table> </div> <h4 id="hydrate-on-idle"> hydrate on idle </h4> <p>The <code>hydrate on idle</code> trigger loads the deferrable view's dependencies and hydrates the content once the browser has reached an idle state, based on <code>requestIdleCallback</code>.</p> <pre data-language="ts">@defer (hydrate on idle) {
  &lt;large-cmp /&gt;
} @placeholder {
  &lt;div&gt;Large component placeholder&lt;/div&gt;
}</pre> <h4 id="hydrate-on-viewport"> hydrate on viewport </h4> <p>The <code>hydrate on viewport</code> trigger loads the deferrable view's dependencies and hydrates the corresponding page of the app when the specified content enters the viewport using the <a href="https://developer.mozilla.org/docs/Web/API/Intersection_Observer_API" target="_blank">Intersection Observer API</a>.</p> <pre data-language="ts">@defer (hydrate on viewport) {
  &lt;large-cmp /&gt;
} @placeholder {
  &lt;div&gt;Large component placeholder&lt;/div&gt;
}</pre> <h4 id="hydrate-on-interaction"> hydrate on interaction </h4> <p>The <code>hydrate on interaction</code> trigger loads the deferrable view's dependencies and hydrates the content when the user interacts with the specified element through <code>click</code> or <code>keydown</code> events.</p> <pre data-language="ts">@defer (hydrate on interaction) {
  &lt;large-cmp /&gt;
} @placeholder {
  &lt;div&gt;Large component placeholder&lt;/div&gt;
}</pre> <h4 id="hydrate-on-hover"> hydrate on hover </h4> <p>The <code>hydrate on hover</code> trigger loads the deferrable view's dependencies and hydrates the content when the mouse has hovered over the triggered area through the <code>mouseover</code> and <code>focusin</code> events.</p> <pre data-language="ts">@defer (hydrate on hover) {
  &lt;large-cmp /&gt;
} @placeholder {
  &lt;div&gt;Large component placeholder&lt;/div&gt;
}</pre> <h4 id="hydrate-on-immediate"> hydrate on immediate </h4> <p>The <code>hydrate on immediate</code> trigger loads the deferrable view's dependencies and hydrates the content immediately. This means that the deferred block loads as soon as all other non-deferred content has finished rendering.</p> <pre data-language="ts">@defer (hydrate on immediate) {
  &lt;large-cmp /&gt;
} @placeholder {
  &lt;div&gt;Large component placeholder&lt;/div&gt;
}</pre> <h4 id="hydrate-on-timer"> hydrate on timer </h4> <p>The <code>hydrate on timer</code> trigger loads the deferrable view's dependencies and hydrates the content after a specified duration.</p> <pre data-language="ts">@defer (hydrate on timer(500ms)) {
  &lt;large-cmp /&gt;
} @placeholder {
  &lt;div&gt;Large component placeholder&lt;/div&gt;
}</pre>
<p>The duration parameter must be specified in milliseconds (<code>ms</code>) or seconds (<code>s</code>).</p> <h3 id="hydrate-when"> hydrate when </h3> <p>The <code>hydrate when</code> trigger accepts a custom conditional expression and loads the deferrable view's dependencies and hydrates the content when the condition becomes truthy.</p> <pre data-language="ts">@defer (hydrate when condition) {
  &lt;large-cmp /&gt;
} @placeholder {
  &lt;div&gt;Large component placeholder&lt;/div&gt;
}</pre>

<div class="docs-alert docs-alert-note"> <p><strong>NOTE:</strong> <code>hydrate when</code> conditions only trigger when they are the top-most dehydrated <code>@defer</code> block. The condition provided for the trigger is specified in the parent component, which needs to exist before it can be triggered. If the parent block is dehydrated, that expression will not yet be resolvable by Angular.</p> </div>  <h3 id="hydrate-never"> hydrate never </h3> <p>The <code>hydrate never</code> allows users to specify that the content in the defer block should remain dehydrated indefinitely, effectively becoming static content. Note that this applies to the initial render only. During a subsequent client-side render, a <code>@defer</code> block with <code>hydrate never</code> would still fetch dependencies, as hydration only applies to initial load of server-side rendered content. In the example below, subsequent client-side renders would load the <code>@defer</code> block dependencies on viewport.</p> <pre data-language="ts">@defer (on viewport; hydrate never) {
  &lt;large-cmp /&gt;
} @placeholder {
  &lt;div&gt;Large component placeholder&lt;/div&gt;
}</pre>

<div class="docs-alert docs-alert-note"> <p><strong>NOTE:</strong> Using <code>hydrate never</code> prevents hydration of the entire nested subtree of a given <code>@defer</code> block. No other <code>hydrate</code> triggers fire for content nested underneath that block.</p> </div>  <h2 id="hydrate-triggers-alongside-regular-triggers"> Hydrate triggers alongside regular triggers </h2> <p>Hydrate triggers are additional triggers that are used alongside regular triggers on a <code>@defer</code> block. Hydration is an initial load optimization, and that means hydrate triggers only apply to that initial load. Any subsequent client side render will still use the regular trigger.</p> <pre data-language="ts">@defer (on idle; hydrate on interaction) {
  &lt;example-cmp /&gt;
} @placeholder{
  &lt;div&gt;Example Placeholder&lt;/div&gt;
}</pre>
<p>In this example, on the initial load, the <code>hydrate on interaction</code> applies. Hydration will be triggered on interaction with the <code>&lt;example-cmp /&gt;</code> component. On any subsequent page load that is client-side rendered, for example when a user clicks a routerLink that loads a page with this component, the <code>on idle</code> will apply.</p> <h2 id="how-does-incremental-hydration-work-with-nested-defer-blocks"> How does incremental hydration work with nested @defer blocks? </h2> <p>Angular's component and dependency system is hierarchical, which means hydrating any component requires all of its parents also be hydrated. So if hydration is triggered for a child <code>@defer</code> block of a nested set of dehydrated <code>@defer</code> blocks, hydration is triggered from the top-most dehydrated <code>@defer</code> block down to the triggered child and fire in that order.</p> <pre data-language="ts">@defer (hydrate on interaction) {
  &lt;parent-block-cmp /&gt;
  @defer (hydrate on hover) {
    &lt;child-block-cmp /&gt;
  } @placeholder {
    &lt;div&gt;Child placeholder&lt;/div&gt;
  }
} @placeholder{
  &lt;div&gt;Parent Placeholder&lt;/div&gt;
}</pre>
<p>In the above example, hovering over the nested <code>@defer</code> block triggers hydration. The parent <code>@defer</code> block with the <code>&lt;parent-block-cmp /&gt;</code> hydrates first, then the child <code>@defer</code> block with <code>&lt;child-block-cmp /&gt;</code> hydrates after.</p> <h2 id="constraints"> Constraints </h2> <p>Incremental hydration has the same constraints as full-application hydration, including limits on direct DOM manipulation and requiring valid HTML structure. Visit the <a href="hydration#constraints">Hydration guide constraints</a> section for more details.</p> <h2 id="do-i-still-need-to-specify-placeholder-blocks"> Do I still need to specify @placeholder blocks? </h2> <p>Yes. <code>@placeholder</code> block content is not used for incremental hydration, but a <code>@placeholder</code> is still necessary for subsequent client-side rendering cases. If your content was not on the route that was part of the initial load, then any navigation to the route that has your <code>@defer</code> block content renders like a regular <code>@defer</code> block. So the <code>@placeholder</code> is rendered in those client-side rendering cases.</p><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/guide/incremental-hydration" class="_attribution-link">https://angular.dev/guide/incremental-hydration</a>
  </p>
</div>
