<h1 tabindex="-1">Data resolvers</h1> <header class="docs-header"> <docs-breadcrumb ng-version="21.0.3" _nghost-ng-c3945279308 ngh="8"></docs-breadcrumb>   </header> <p>Data resolvers allow you to fetch data before navigating to a route, ensuring that your components receive the data they need before rendering. This can help prevent the need for loading states and improve the user experience by pre-loading essential data.</p> <h2 id="what-are-data-resolvers"> What are data resolvers? </h2> <p>A data resolver is a service that implements the <a href="../../api/router/resolvefn"><code>ResolveFn</code></a> function. It runs before a route activates and can fetch data from APIs, databases, or other sources. The resolved data becomes available to the component through the <a href="../../api/router/activatedroute"><code>ActivatedRoute</code></a>.</p> <h2 id="why-use-data-resolvers"> Why use data resolvers? </h2> <p>Data resolvers solve common routing challenges:</p> <ul class="docs-list"> <li>
<strong>Prevent empty states</strong>: Components receive data immediately upon loading</li> <li>
<strong>Better user experience</strong>: No loading spinners for critical data</li> <li>
<strong>Error handling</strong>: Handle data fetching errors before navigation</li> <li>
<strong>Data consistency</strong>: Ensure required data is available before rendering which is important for SSR</li> </ul> <h2 id="creating-a-resolver"> Creating a resolver </h2> <p>You create a resolver by writing a function with the <a href="../../api/router/resolvefn"><code>ResolveFn</code></a> type.</p> <p>It receives the <a href="../../api/router/activatedroutesnapshot"><code>ActivatedRouteSnapshot</code></a> and <a href="../../api/router/routerstatesnapshot"><code>RouterStateSnapshot</code></a> as parameters.</p> <p>Here is a resolver that gets the user information before rendering a route using the <a href="../../api/core/inject"><code>inject</code></a> function:</p> <pre data-language="ts">import { inject } from '@angular/core';
import { UserStore, SettingsStore } from './user-store';
import type { ActivatedRouteSnapshot, ResolveFn, RouterStateSnapshot } from '@angular/router';
import type { User, Settings } from './types';

export const userResolver: ResolveFn&lt;User&gt; = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) =&gt; {
  const userStore = inject(UserStore);
  const userId = route.paramMap.get('id')!;
  return userStore.getUser(userId);
};

export const settingsResolver: ResolveFn&lt;Settings&gt; = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) =&gt; {
  const settingsStore = inject(SettingsStore);
  const userId = route.paramMap.get('id')!;
  return settingsStore.getUserSettings(userId);
};</pre> <h2 id="configuring-routes-with-resolvers"> Configuring routes with resolvers </h2> <p>When you want to add one or more data resolvers to a route, you can add it under the <code>resolve</code> key in the route configuration. The <a href="../../api/router/routes"><code>Routes</code></a> type defines the structure for route configurations:</p> <pre data-language="ts">import { Routes } from '@angular/router';

export const routes: Routes = [
  {
    path: 'user/:id',
    component: UserDetail,
    resolve: {
      user: userResolver,
      settings: settingsResolver
    }
  }
];</pre>
<p>You can learn more about the <a href="../../api/router/route#resolve"><code>resolve</code> configuration in the API docs</a>.</p> <h2 id="accessing-resolved-data-in-components"> Accessing resolved data in components </h2> <h3 id="using-activatedroute"> Using ActivatedRoute </h3> <p>You can access the resolved data in a component by accessing the snapshot data from the <a href="../../api/router/activatedroute"><code>ActivatedRoute</code></a> using the <a href="../../api/core/signal"><code>signal</code></a> function:</p> <pre data-language="ts">import { Component, inject, computed } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { toSignal } from '@angular/core/rxjs-interop';
import type { User, Settings } from './types';

@Component({
  template: `
    &lt;h1&gt;{{ user().name }}&lt;/h1&gt;
    &lt;p&gt;{{ user().email }}&lt;/p&gt;
    &lt;div&gt;Theme: {{ settings().theme }}&lt;/div&gt;
  `
})
export class UserDetail {
  private route = inject(ActivatedRoute);
  private data = toSignal(this.route.data);
  user = computed(() =&gt; this.data().user as User);
  settings = computed(() =&gt; this.data().settings as Settings);
}</pre> <h3 id="using-withcomponentinputbinding"> Using withComponentInputBinding </h3> <p>A different approach to accessing the resolved data is to use <a href="../../api/router/withcomponentinputbinding"><code>withComponentInputBinding()</code></a> when configuring your router with <a href="../../api/router/providerouter"><code>provideRouter</code></a>. This allows resolved data to be passed directly as component inputs:</p> <pre data-language="ts">import { bootstrapApplication } from '@angular/platform-browser';
import { provideRouter, withComponentInputBinding } from '@angular/router';
import { routes } from './app.routes';

bootstrapApplication(App, {
  providers: [
    provideRouter(routes, withComponentInputBinding())
  ]
});</pre>
<p>With this configuration, you can define inputs in your component that match the resolver keys using the <a href="../../api/core/input"><code>input</code></a> function and <a href="../../api/core/input#required"><code>input.required</code></a> for required inputs:</p> <pre data-language="ts">import { Component, input } from '@angular/core';
import type { User, Settings } from './types';

@Component({
  template: `
    &lt;h1&gt;{{ user().name }}&lt;/h1&gt;
    &lt;p&gt;{{ user().email }}&lt;/p&gt;
    &lt;div&gt;Theme: {{ settings().theme }}&lt;/div&gt;
  `
})
export class UserDetail {
  user = input.required&lt;User&gt;();
  settings = input.required&lt;Settings&gt;();
}</pre>
<p>This approach provides better type safety and eliminates the need to inject <a href="../../api/router/activatedroute"><code>ActivatedRoute</code></a> just to access resolved data.</p> <h2 id="error-handling-in-resolvers"> Error handling in resolvers </h2> <p>In the event of navigation failures, it is important to handle errors gracefully in your data resolvers. Otherwise, a <a href="../../api/router/navigationerror"><code>NavigationError</code></a> will occur and the navigation to the current route will fail which will lead to a poor experience for your users.</p> <p>There are three primary ways to handle errors with data resolvers:</p> <ol class="docs-ordered-list"> <li>Centralize error handling in <a href="../../api/router/withnavigationerrorhandler"><code>withNavigationErrorHandler</code></a>
</li> <li>Manage errors through a subscription to router events</li> <li>Handle errors directly in the resolver</li> </ol> <h3 id="centralize-error-handling-in-withnavigationerrorhandler"> Centralize error handling in withNavigationErrorHandler </h3> <p>The <a href="../../api/router/withnavigationerrorhandler"><code>withNavigationErrorHandler</code></a> feature provides a centralized way to handle all navigation errors, including those from failed data resolvers. This approach keeps error handling logic in one place and prevents duplicate error handling code across resolvers.</p> <pre data-language="ts">import { bootstrapApplication } from '@angular/platform-browser';
import { provideRouter, withNavigationErrorHandler } from '@angular/router';
import { inject } from '@angular/core';
import { Router } from '@angular/router';
import { routes } from './app.routes';

bootstrapApplication(App, {
  providers: [
    provideRouter(routes, withNavigationErrorHandler((error) =&gt; {
      const router = inject(Router);

      if (error?.message) {
        console.error('Navigation error occurred:', error.message)
      }

      router.navigate(['/error']);
    }))
  ]
});</pre>
<p>With this configuration, your resolvers can focus on data fetching while letting the centralized handler manage error scenarios:</p> <pre data-language="ts">export const userResolver: ResolveFn&lt;User&gt; = (route) =&gt; {
  const userStore = inject(UserStore);
  const userId = route.paramMap.get('id')!;
  // No need for explicit error handling - let it bubble up
  return userStore.getUser(userId);
};</pre> <h3 id="managing-errors-through-a-subscription-to-router-events"> Managing errors through a subscription to router events </h3> <p>You can also handle resolver errors by subscribing to router events and listening for <a href="../../api/router/navigationerror"><code>NavigationError</code></a> events. This approach gives you more granular control over error handling and allows you to implement custom error recovery logic.</p> <pre data-language="ts">import { Component, inject, signal } from '@angular/core';
import { Router, NavigationError } from '@angular/router';
import { toSignal } from '@angular/core/rxjs-interop';
import { map } from 'rxjs';

@Component({
  selector: 'app-root',
  template: `
    @if (errorMessage()) {
      &lt;div class="error-banner"&gt;
        {{ errorMessage() }}
        &lt;button (click)="retryNavigation()"&gt;Retry&lt;/button&gt;
      &lt;/div&gt;
    }
    &lt;router-outlet /&gt;
  `
})
export class App {
  private router = inject(Router);
  private lastFailedUrl = signal('');

  private navigationErrors = toSignal(
    this.router.events.pipe(
      map(event =&gt; {
        if (event instanceof NavigationError) {
          this.lastFailedUrl.set(event.url);
  
          if (event.error) {
            console.error('Navigation error', event.error)
          }
  
          return 'Navigation failed. Please try again.';
        }
        return '';
      })
    ),
    { initialValue: '' }
  );

  errorMessage = this.navigationErrors;

  retryNavigation() {
    if (this.lastFailedUrl()) {
      this.router.navigateByUrl(this.lastFailedUrl());
    }
  }
}</pre>
<p>This approach is particularly useful when you need to:</p> <ul class="docs-list"> <li>Implement custom retry logic for failed navigation</li> <li>Show specific error messages based on the type of failure</li> <li>Track navigation failures for analytics purposes</li> </ul> <h3 id="handling-errors-directly-in-the-resolver"> Handling errors directly in the resolver </h3> <p>Here's an updated example of the <code>userResolver</code> that logs the error and navigates back to the generic <code>/users</code> page using the <a href="../../api/router/router"><code>Router</code></a> service:</p> <pre data-language="ts">import { inject } from '@angular/core';
import { ResolveFn, RedirectCommand, Router } from '@angular/router';
import { catchError, of, EMPTY } from 'rxjs';
import { UserStore } from './user-store';
import type { User } from './types';

export const userResolver: ResolveFn&lt;User | RedirectCommand&gt; = (route) =&gt; {
  const userStore = inject(UserStore);
  const router = inject(Router);
  const userId = route.paramMap.get('id')!;

  return userStore.getUser(userId).pipe(
    catchError(error =&gt; {
      console.error('Failed to load user:', error);
      return of(new RedirectCommand(router.parseUrl('/users')));
    })
  );
};</pre> <h2 id="navigation-loading-considerations"> Navigation loading considerations </h2> <p>While data resolvers prevent loading states within components, they introduce a different UX consideration: navigation is blocked while resolvers execute. Users may experience delays between clicking a link and seeing the new route, especially with slow network requests.</p> <h3 id="providing-navigation-feedback"> Providing navigation feedback </h3> <p>To improve user experience during resolver execution, you can listen to router events and show loading indicators:</p> <pre data-language="ts">import { Component, inject } from '@angular/core';
import { Router } from '@angular/router';
import { toSignal } from '@angular/core/rxjs-interop';
import { map } from 'rxjs';

@Component({
  selector: 'app-root',
  template: `
    @if (isNavigating()) {
      &lt;div class="loading-bar"&gt;Loading...&lt;/div&gt;
    }
    &lt;router-outlet /&gt;
  `
})
export class App {
  private router = inject(Router);
  isNavigating = computed(() =&gt; !!this.router.currentNavigation());
}</pre>
<p>This approach ensures users receive visual feedback that navigation is in progress while resolvers fetch data.</p> <h2 id="best-practices"> Best practices </h2> <ul class="docs-list"> <li>
<strong>Keep resolvers lightweight</strong>: Resolvers should fetch essential data only and not everything the page could possibly need</li> <li>
<strong>Handle errors</strong>: Always remember to handle errors gracefully to provide the best experience possible to users</li> <li>
<strong>Use caching</strong>: Consider caching resolved data to improve performance</li> <li>
<strong>Consider navigation UX</strong>: Implement loading indicators for resolver execution since navigation is blocked during data fetching</li> <li>
<strong>Set reasonable timeouts</strong>: Avoid resolvers that could hang indefinitely and block navigation</li> <li>
<strong>Type safety</strong>: Use TypeScript interfaces for resolved data</li> </ul> <h2 id="reading-parent-resolved-data-in-child-resolvers"> Reading parent resolved data in child resolvers </h2> <p>Resolvers execute from parent to child. When a parent route defines a resolver, its resolved data is available to child resolvers that run afterward.</p> <pre data-language="ts">import { inject } from '@angular/core';
import { provideRouter , ActivatedRouteSnapshot } from '@angular/router';
import { userResolver } from './resolvers';
import { UserPosts } from './pages';
import { PostService } from './services',
import type { User } from './types';

provideRouter([
  {
    path: 'users/:id',
    resolve: { user: userResolver }, // user resolver in the parent route
    children: [
      {
        path: 'posts',
        component: UserPosts,
        // route.data.user is available here while this resolver runs
        resolve: {
          posts: (route: ActivatedRouteSnapshot) =&gt; {
            const postService = inject(PostService);
            const user = route.data['user'] as User; // parent data
            const userId = user.id;
            return postService.getPostByUser(userId);
          },
        },
      },
    ],
  },
]);</pre><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/guide/routing/data-resolvers" class="_attribution-link">https://angular.dev/guide/routing/data-resolvers</a>
  </p>
</div>
