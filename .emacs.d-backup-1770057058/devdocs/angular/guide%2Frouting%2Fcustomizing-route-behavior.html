<h1 tabindex="-1">Customizing route behavior</h1> <header class="docs-header"> <docs-breadcrumb ng-version="21.0.3" _nghost-ng-c3945279308 ngh="8"></docs-breadcrumb>   </header> <p>Angular Router provides powerful extension points that allow you to customize how routes behave in your application. While the default routing behavior works well for most applications, specific requirements often demand custom implementations for performance optimization, specialized URL handling, or complex routing logic.</p> <p>Route customization can become valuable when your application needs:</p> <ul class="docs-list"> <li>
<strong>Component state preservation</strong> across navigations to avoid re-fetching data</li> <li>
<strong>Strategic lazy module loading</strong> based on user behavior or network conditions</li> <li>
<strong>External URL integration</strong> or handling Angular routes alongside legacy systems</li> <li>
<strong>Dynamic route matching</strong> based on runtime conditions beyond simple path patterns</li> </ul> 
<div class="docs-alert docs-alert-note"> <p><strong>NOTE:</strong> Before implementing custom strategies, ensure the default router behavior doesn't meet your needs. Angular's default routing is optimized for common use cases and provides the best balance of performance and simplicity. Customizing route strategies can create additional code complexity and have performance implications on memory usage if not carefully managed.</p> </div>  <h2 id="router-configuration-options"> Router configuration options </h2> <p>The <a href="../../api/router/withrouterconfig"><code>withRouterConfig</code></a> or <a href="../../api/router/routermodule#forRoot"><code>RouterModule.forRoot</code></a> allows providing additional <a href="../../api/router/routerconfigoptions"><code>RouterConfigOptions</code></a> to adjust the Router’s behavior.</p> <h3 id="handle-canceled-navigations"> Handle canceled navigations </h3> <p><code>canceledNavigationResolution</code> controls how the Router restores browser history when a navigation is canceled. The default value is <code>'replace'</code>, which reverts to the pre-navigation URL with <code>location.replaceState</code>. In practice, this means that any time the address bar has already been updated for the navigation, such as with the browser back or forward buttons, the history entry is overwritten with the "rollback" if the navigation fails or is rejected by a guard. Switching to <code>'computed'</code> keeps the in-flight history index in sync with the Angular navigation, so canceling a back button navigation triggers a forward navigation (and vice versa) to return to the original page.</p> <p>This setting is most helpful when your app uses <code>urlUpdateStrategy: 'eager'</code> or when guards frequently cancel popstate navigations initiated by the browser.</p> <pre data-language="ts">provideRouter(routes, withRouterConfig({ canceledNavigationResolution: 'computed' }));</pre> <h3 id="react-to-same-url-navigations"> React to same-URL navigations </h3> <p><code>onSameUrlNavigation</code> configures what should happen when the user asks to navigate to the current URL. The default <code>'ignore'</code> skips work, while <code>'reload'</code> re-runs guards and resolvers and refreshes component instances.</p> <p>This is useful when you want repeated clicks on a list filter, left-nav item, or refresh button to trigger new data retrieval even though the URL does not change.</p> <pre data-language="ts">provideRouter(routes, withRouterConfig({ onSameUrlNavigation: 'reload' }));</pre>
<p>You can also control this behavior on individual navigations rather than globally. This allows you to keep the keep the default of <code>'ignore'</code> while selectively enabling reload behavior for specific use cases:</p> <pre data-language="ts">router.navigate(['/some-path'], { onSameUrlNavigation: 'reload' });</pre> <h3 id="control-parameter-inheritance"> Control parameter inheritance </h3> <p><code>paramsInheritanceStrategy</code> defines how route parameters and data flow from parent routes.</p> <p>With the default <code>'emptyOnly'</code>, child routes inherit params only when their path is empty or the parent does not declare a component.</p> <pre data-language="ts">provideRouter(routes, withRouterConfig({ paramsInheritanceStrategy: 'always' }));</pre>
<pre data-language="ts">export const routes: Routes = [
  {
    path: 'org/:orgId',
    component: Organization,
    children: [
      {
        path: 'projects/:projectId',
        component: Project,
        children: [
          {
            path: 'customers/:customerId',
            component: Customer
          }
        ]
      }
    ]
  }
];</pre>
<pre data-language="ts">@Component({ /* ... */})
export class CustomerComponent {
  private route = inject(ActivatedRoute);

  orgId = this.route.parent?.parent?.snapshot.params['orgId'];
  projectId = this.route.parent?.snapshot.params['projectId'];
  customerId = this.route.snapshot.params['customerId'];
}</pre>
<p>Using <code>'always'</code> ensures matrix parameters, route data, and resolved values are available further down the route tree—handy when you share contextual identifiers across feature areas such as <code>/org/:orgId/projects/:projectId/customers/:customerId</code>.</p> <pre data-language="ts">@Component({ /* ... */})
export class CustomerComponent {
  private route = inject(ActivatedRoute);

  // All parent parameters are available directly
  orgId = this.route.snapshot.params['orgId'];
  projectId = this.route.snapshot.params['projectId'];
  customerId = this.route.snapshot.params['customerId'];
}</pre> <h3 id="decide-when-the-url-updates"> Decide when the URL updates </h3> <p><code>urlUpdateStrategy</code> determines when Angular writes to the browser address bar. The default <code>'deferred'</code> waits for a successful navigation before changing the URL. Use <code>'eager'</code> to update immediately when navigation starts. Eager updates make it easier to surface the attempted URL if navigation fails due to guards or errors, but can briefly show an in-progress URL if you have long-running guards.</p> <p>Consider this when your analytics pipeline needs to see the attempted route even if guards block it.</p> <pre data-language="ts">provideRouter(routes, withRouterConfig({ urlUpdateStrategy: 'eager' }));</pre> <h3 id="choose-default-query-parameter-handling"> Choose default query parameter handling </h3> <p><code>defaultQueryParamsHandling</code> sets the fallback behavior for <a href="../../api/router/router#createUrlTree"><code>Router.createUrlTree</code></a> when the call does not specify <code>queryParamsHandling</code>. <code>'replace'</code> is the default and swaps out the existing query string. <code>'merge'</code> combines the provided values with the current ones, and <code>'preserve'</code> keeps the existing query parameters unless you explicitly supply new ones.</p> <pre data-language="ts">provideRouter(routes, withRouterConfig({ defaultQueryParamsHandling: 'merge' }));</pre>
<p>This is especially helpful for search and filter pages to automatically retain existing filters when additional parameters are provided.</p> <p>Angular Router exposes four main areas for customization:</p> <nav class="docs-pill-row"> <a class="docs-pill" href="#route-reuse-strategy"> Route reuse strategy </a> <a class="docs-pill" href="#preloading-strategy"> Preloading strategy </a> <a class="docs-pill" href="#url-handling-strategy"> URL handling strategy </a> <a class="docs-pill" href="#custom-route-matchers"> Custom route matchers </a> </nav> <h2 id="route-reuse-strategy"> Route reuse strategy </h2> <p>Route reuse strategy controls whether Angular destroys and recreates components during navigation or preserves them for reuse. By default, Angular destroys component instances when navigating away from a route and creates new instances when navigating back.</p> <h3 id="when-to-implement-route-reuse"> When to implement route reuse </h3> <p>Custom route reuse strategies benefit applications that need:</p> <ul class="docs-list"> <li>
<strong>Form state preservation</strong> - Keep partially completed forms when users navigate away and return</li> <li>
<strong>Expensive data retention</strong> - Avoid re-fetching large datasets or complex calculations</li> <li>
<strong>Scroll position maintenance</strong> - Preserve scroll positions in long lists or infinite scroll implementations</li> <li>
<strong>Tab-like interfaces</strong> - Maintain component state when switching between tabs</li> </ul> <h3 id="creating-a-custom-route-reuse-strategy"> Creating a custom route reuse strategy </h3> <p>Angular's <a href="../../api/router/routereusestrategy"><code>RouteReuseStrategy</code></a> class allows you to customize navigation behavior through the concept of "detached route handles."</p> <p>"Detached route handles" are Angular's way of storing component instances and their entire view hierarchy. When a route is detached, Angular preserves the component instance, its child components, and all associated state in memory. This preserved state can later be reattached when navigating back to the route.</p> <p>The <a href="../../api/router/routereusestrategy"><code>RouteReuseStrategy</code></a> class provides five methods that control the lifecycle of route components:</p> <div class="docs-table docs-scroll-track-transparent"> <table> <thead> <tr> <th>Method</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><a href="../../api/router/routereusestrategy#shouldDetach"><code>shouldDetach</code></a></td> <td>Determines if a route should be stored for later reuse when navigating away</td> </tr> <tr> <td><a href="../../api/router/routereusestrategy#store"><code>store</code></a></td> <td>Stores the detached route handle when <code>shouldDetach</code> returns true</td> </tr> <tr> <td><a href="../../api/router/routereusestrategy#shouldAttach"><code>shouldAttach</code></a></td> <td>Determines if a stored route should be reattached when navigating to it</td> </tr> <tr> <td><a href="../../api/router/routereusestrategy#retrieve"><code>retrieve</code></a></td> <td>Returns the previously stored route handle for reattachment</td> </tr> <tr> <td><a href="../../api/router/routereusestrategy#shouldReuseRoute"><code>shouldReuseRoute</code></a></td> <td>Determines if the router should reuse the current route instance instead of destroying it during navigation</td> </tr> </tbody> </table> </div> <p>The following example demonstrates a custom route reuse strategy that selectively preserves component state based on route metadata:</p> <pre data-language="ts">import { RouteReuseStrategy, Route, ActivatedRouteSnapshot, DetachedRouteHandle } from '@angular/router';
import { Injectable } from '@angular/core';

@Injectable()
export class CustomRouteReuseStrategy implements RouteReuseStrategy {
  private handlers = new Map&lt;Route | null, DetachedRouteHandle&gt;();

  shouldDetach(route: ActivatedRouteSnapshot): boolean {
    // Determines if a route should be stored for later reuse
    return route.data['reuse'] === true;
  }

  store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle | null): void {
    // Stores the detached route handle when shouldDetach returns true
    if (handle &amp;&amp; route.data['reuse'] === true) {
      const key = this.getRouteKey(route);
      this.handlers.set(key, handle);
    }
  }

  shouldAttach(route: ActivatedRouteSnapshot): boolean {
    // Checks if a stored route should be reattached
    const key = this.getRouteKey(route);
    return route.data['reuse'] === true &amp;&amp; this.handlers.has(key);
  }

  retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null {
    // Returns the stored route handle for reattachment
    const key = this.getRouteKey(route);
    return route.data['reuse'] === true ? this.handlers.get(key) ?? null : null;
  }

  shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean {
    // Determines if the router should reuse the current route instance
    return future.routeConfig === curr.routeConfig;
  }

  private getRouteKey(route: ActivatedRouteSnapshot): Route | null {
    return route.routeConfig;
  }
}</pre>

<div class="docs-alert docs-alert-note"> <p><strong>NOTE:</strong> Avoid using the route path as the key when <code>canMatch</code> guards are involved, as it may lead to duplicate entries.</p> </div>  <h3 id="configuring-a-route-to-use-a-custom-route-reuse-strategy"> Configuring a route to use a custom route reuse strategy </h3> <p>Routes can opt into reuse behavior through route configuration metadata. This approach keeps the reuse logic separate from component code, making it easy to adjust behavior without modifying components:</p> <pre data-language="ts">export const routes: Routes = [
  {
    path: 'products',
    component: ProductListComponent,
    data: { reuse: true }  // Component state persists across navigations
  },
  {
    path: 'products/:id',
    component: ProductDetailComponent,
    // No reuse flag - component recreates on each navigation
  },
  {
    path: 'search',
    component: SearchComponent,
    data: { reuse: true }  // Preserves search results and filter state
  }
];</pre>
<p>You can also configure a custom route reuse strategy at the application level through Angular's dependency injection system. In this case, Angular creates a single instance of the strategy that manages all route reuse decisions throughout the application:</p> <pre data-language="ts">export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes),
    { provide: RouteReuseStrategy, useClass: CustomRouteReuseStrategy }
  ]
};</pre> <h2 id="preloading-strategy"> Preloading strategy </h2> <p>Preloading strategies determine when Angular loads lazy-loaded route modules in the background. While lazy loading improves initial load time by deferring module downloads, users still experience a delay when first navigating to a lazy route. Preloading strategies eliminate this delay by loading modules before users request them.</p> <h3 id="built-in-preloading-strategies"> Built-in preloading strategies </h3> <p>Angular provides two preloading strategies out of the box:</p> <div class="docs-table docs-scroll-track-transparent"> <table> <thead> <tr> <th>Strategy</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td>
<a href="../../api/router/nopreloading"><code>NoPreloading</code></a>
</td> <td>The default strategy that disables all preloading. In other words, modules only load when users navigate to them</td> </tr> <tr> <td>
<a href="../../api/router/preloadallmodules"><code>PreloadAllModules</code></a>
</td> <td>Loads all lazy-loaded modules immediately after the initial navigation</td> </tr> </tbody> </table> </div> <p>The <a href="../../api/router/preloadallmodules"><code>PreloadAllModules</code></a> strategy can be configured as follows:</p> <pre data-language="ts">import { ApplicationConfig } from '@angular/core';
import { provideRouter, withPreloading, PreloadAllModules } from '@angular/router';
import { routes } from './app.routes';

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(
      routes,
      withPreloading(PreloadAllModules)
    )
  ]
};</pre>
<p>The <a href="../../api/router/preloadallmodules"><code>PreloadAllModules</code></a> strategy works well for small to medium applications where downloading all modules doesn't significantly impact performance. However, larger applications with many feature modules might benefit from more selective preloading.</p> <h3 id="creating-a-custom-preloading-strategy"> Creating a custom preloading strategy </h3> <p>Custom preloading strategies implement the <a href="../../api/router/preloadingstrategy"><code>PreloadingStrategy</code></a> interface, which requires a single <code>preload</code> method. This method receives the route configuration and a function that triggers the actual module load. The strategy returns an Observable that emits when preloading completes or an empty Observable to skip preloading:</p> <pre data-language="ts">import { Injectable } from '@angular/core';
import { PreloadingStrategy, Route } from '@angular/router';
import { Observable, of, timer } from 'rxjs';
import { mergeMap } from 'rxjs/operators';

@Injectable()
export class SelectivePreloadingStrategy implements PreloadingStrategy {
  preload(route: Route, load: () =&gt; Observable&lt;any&gt;): Observable&lt;any&gt; {
    // Only preload routes marked with data: { preload: true }
    if (route.data?.['preload']) {
      return load();
    }
    return of(null);
  }
}</pre>
<p>This selective strategy checks route metadata to determine preloading behavior. Routes can opt into preloading through their configuration:</p> <pre data-language="ts">import { Routes } from '@angular/router';

export const routes: Routes = [
  {
    path: 'dashboard',
    loadChildren: () =&gt; import('./dashboard/dashboard.routes'),
    data: { preload: true }  // Preload immediately after initial navigation
  },
  {
    path: 'reports',
    loadChildren: () =&gt; import('./reports/reports.routes'),
    data: { preload: false } // Only load when user navigates to reports
  },
  {
    path: 'admin',
    loadChildren: () =&gt; import('./admin/admin.routes')
    // No preload flag - won't be preloaded
  }
];</pre> <h3 id="performance-considerations-for-preloading"> Performance considerations for preloading </h3> <p>Preloading impacts both network usage and memory consumption. Each preloaded module consumes bandwidth and increases the application's memory footprint. Mobile users on metered connections might prefer minimal preloading, while desktop users on fast networks can handle aggressive preloading strategies.</p> <p>The timing of preloading also matters. Immediate preloading after initial load might compete with other critical resources like images or API calls. Strategies should consider the application's post-load behavior and coordinate with other background tasks to avoid performance degradation.</p> <p>Browser resource limits also affect preloading behavior. Browsers limit concurrent HTTP connections, so aggressive preloading might queue behind other requests. Service workers can help by providing fine-grained control over caching and network requests, complementing the preloading strategy.</p> <h2 id="url-handling-strategy"> URL handling strategy </h2> <p>URL handling strategies determine which URLs the Angular router processes versus which ones it ignores. By default, Angular attempts to handle all navigation events within the application, but real-world applications often need to coexist with other systems, handle external links, or integrate with legacy applications that manage their own routes.</p> <p>The <a href="../../api/router/urlhandlingstrategy"><code>UrlHandlingStrategy</code></a> class gives you control over this boundary between Angular-managed routes and external URLs. This becomes essential when migrating applications to Angular incrementally or when Angular applications need to share URL space with other frameworks.</p> <h3 id="implementing-a-custom-url-handling-strategy"> Implementing a custom URL handling strategy </h3> <p>Custom URL handling strategies extend the <a href="../../api/router/urlhandlingstrategy"><code>UrlHandlingStrategy</code></a> class and implement three methods. The <code>shouldProcessUrl</code> method determines whether Angular should handle a given URL, <code>extract</code> returns the portion of the URL that Angular should process, and <code>merge</code> combines the URL fragment with the rest of the URL:</p> <pre data-language="ts">import { Injectable } from '@angular/core';
import { UrlHandlingStrategy, UrlTree } from '@angular/router';

@Injectable()
export class CustomUrlHandlingStrategy implements UrlHandlingStrategy {
  shouldProcessUrl(url: UrlTree): boolean {
    // Only handle URLs that start with /app or /admin
    return url.toString().startsWith('/app') ||
           url.toString().startsWith('/admin');
  }

  extract(url: UrlTree): UrlTree {
    // Return the URL unchanged if we should process it
    return url;
  }

  merge(newUrlPart: UrlTree, rawUrl: UrlTree): UrlTree {
    // Combine the URL fragment with the rest of the URL
    return newUrlPart;
  }
}</pre>
<p>This strategy creates clear boundaries in the URL space. Angular handles <code>/app</code> and <code>/admin</code> paths while ignoring everything else. This pattern works well when migrating legacy applications where Angular controls specific sections while the legacy system maintains others.</p> <h3 id="configuring-a-custom-url-handling-strategy"> Configuring a custom URL handling strategy </h3> <p>You can register a custom strategy through Angular's dependency injection system:</p> <pre data-language="ts">import { ApplicationConfig } from '@angular/core';
import { provideRouter } from '@angular/router';
import { UrlHandlingStrategy } from '@angular/router';

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes),
    { provide: UrlHandlingStrategy, useClass: CustomUrlHandlingStrategy }
  ]
};</pre> <h2 id="custom-route-matchers"> Custom route matchers </h2> <p>By default, Angular's router iterates through routes in the order they're defined, attempting to match the URL path against each route's path pattern. It supports static segments, parameterized segments (<code>:id</code>), and wildcards (<code>**</code>). The first route that matches wins, and the router stops searching.</p> <p>When applications require more sophisticated matching logic based on runtime conditions, complex URL patterns, or other custom rules, custom matchers provide this flexibility without compromising the simplicity of standard routes.</p> <p>The router evaluates custom matchers during the route matching phase, before path matching occurs. When a matcher returns a successful match, it can also extract parameters from the URL, making them available to the activated component just like standard route parameters.</p> <h3 id="creating-a-custom-matcher"> Creating a custom matcher </h3> <p>A custom matcher is a function that receives URL segments and returns either a match result with consumed segments and parameters, or null to indicate no match. The matcher function runs before Angular evaluates the route's path property:</p> <pre data-language="ts">import { Route, UrlSegment, UrlSegmentGroup, UrlMatchResult } from '@angular/router';

export function customMatcher(
  segments: UrlSegment[],
  group: UrlSegmentGroup,
  route: Route
): UrlMatchResult | null {
  // Matching logic here
  if (matchSuccessful) {
    return {
      consumed: segments,
      posParams: {
        paramName: new UrlSegment('paramValue', {})
      }
    };
  }
  return null;
}</pre> <h3 id="implementing-version-based-routing"> Implementing version-based routing </h3> <p>Consider an API documentation site that needs to route based on version numbers in the URL. Different versions might have different component structures or feature sets:</p> <pre data-language="ts">import { Routes, UrlSegment, UrlMatchResult } from '@angular/router';

export function versionMatcher(segments: UrlSegment[]): UrlMatchResult | null {
  // Match patterns like /v1/docs, /v2.1/docs, /v3.0.1/docs
  if (segments.length &gt;= 2 &amp;&amp; segments[0].path.match(/^v\d+(\.\d+)*$/)) {
    return {
      consumed: segments.slice(0, 2),  // Consume version and 'docs'
      posParams: {
        version: segments[0],  // Make version available as a parameter
        section: segments[1]   // Make section available too
      }
    };
  }
  return null;
}

// Route configuration
export const routes: Routes = [
  {
    matcher: versionMatcher,
    component: DocumentationComponent
  },
  {
    path: 'latest/docs',
    redirectTo: 'v3/docs'
  }
];</pre>
<p>The component receives the extracted parameters through route inputs:</p> <pre data-language="ts">import { Component, input, inject } from '@angular/core';
import { resource } from '@angular/core';

@Component({
  selector: 'app-documentation',
  template: `
    @if (documentation.isLoading()) {
      &lt;div&gt;Loading documentation...&lt;/div&gt;
    } @else if (documentation.error()) {
      &lt;div&gt;Error loading documentation&lt;/div&gt;
    } @else if (documentation.value(); as docs) {
      &lt;article&gt;{{ docs.content }}&lt;/article&gt;
    }
  `
})
export class DocumentationComponent {
  // Route parameters are automatically bound to signal inputs
  version = input.required&lt;string&gt;();  // Receives the version parameter
  section = input.required&lt;string&gt;();  // Receives the section parameter

  private docsService = inject(DocumentationService);

  // Resource automatically loads documentation when version or section changes
  documentation = resource({
    params: () =&gt; {
      if (!this.version() || !this.section()) return;

      return {
        version: this.version(),
        section: this.section()
      }
    },
    loader: ({ params }) =&gt; {
      return this.docsService.loadDocumentation(params.version, params.section);
    }
  })
}</pre> <h3 id="locale-aware-routing"> Locale-aware routing </h3> <p>International applications often encode locale information in URLs. A custom matcher can extract locale codes and route to appropriate components while making the locale available as a parameter:</p> <pre data-language="ts">// Supported locales
const locales = ['en', 'es', 'fr', 'de', 'ja', 'zh'];

export function localeMatcher(segments: UrlSegment[]): UrlMatchResult | null {
  if (segments.length &gt; 0) {
    const potentialLocale = segments[0].path;

    if (locales.includes(potentialLocale)) {
      // This is a locale prefix, consume it and continue matching
      return {
        consumed: [segments[0]],
        posParams: {
          locale: segments[0]
        }
      };
    } else {
      // No locale prefix, use default locale
      return {
        consumed: [],  // Don't consume any segments
        posParams: {
          locale: new UrlSegment('en', {})
        }
      };
    }
  }

  return null;
}</pre> <h3 id="complex-business-logic-matching"> Complex business logic matching </h3> <p>Custom matchers excel at implementing business rules that would be awkward to express in path patterns. Consider an e-commerce site where product URLs follow different patterns based on product type:</p> <pre data-language="ts">export function productMatcher(segments: UrlSegment[]): UrlMatchResult | null {
  if (segments.length === 0) return null;

  const firstSegment = segments[0].path;

  // Books: /isbn-1234567890
  if (firstSegment.startsWith('isbn-')) {
    return {
      consumed: [segments[0]],
      posParams: {
        productType: new UrlSegment('book', {}),
        identifier: new UrlSegment(firstSegment.substring(5), {})
      }
    };
  }

  // Electronics: /sku/ABC123
  if (firstSegment === 'sku' &amp;&amp; segments.length &gt; 1) {
    return {
      consumed: segments.slice(0, 2),
      posParams: {
        productType: new UrlSegment('electronics', {}),
        identifier: segments[1]
      }
    };
  }

  // Clothing: /style/BRAND/ITEM
  if (firstSegment === 'style' &amp;&amp; segments.length &gt; 2) {
    return {
      consumed: segments.slice(0, 3),
      posParams: {
        productType: new UrlSegment('clothing', {}),
        brand: segments[1],
        identifier: segments[2]
      }
    };
  }

  return null;
}</pre> <h3 id="performance-considerations-for-custom-matchers"> Performance considerations for custom matchers </h3> <p>Custom matchers run for every navigation attempt until a match is found. As a result, complex matching logic can impact navigation performance, especially in applications with many routes. Keep matchers focused and efficient:</p> <ul class="docs-list"> <li>Return early when a match is impossible</li> <li>Avoid expensive operations like API calls or complex regular expressions</li> <li>Consider caching results for repeated URL patterns</li> </ul> <p>While custom matchers solve complex routing requirements elegantly, overuse can make route configuration harder to understand and maintain. Reserve custom matchers for scenarios where standard path matching genuinely falls short.</p><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/guide/routing/customizing-route-behavior" class="_attribution-link">https://angular.dev/guide/routing/customizing-route-behavior</a>
  </p>
</div>
