<h1 tabindex="-1">Animating your applications with <code>animate.enter</code> and <code>animate.leave</code>
</h1> <header class="docs-header"> <docs-breadcrumb ng-version="21.0.3" _nghost-ng-c3945279308 ngh="8"></docs-breadcrumb>   </header> <p>Well-designed animations can make your application more fun and straightforward to use, but they aren't just cosmetic. Animations can improve your application and user experience in a number of ways:</p> <ul class="docs-list"> <li>Without animations, web page transitions can seem abrupt and jarring</li> <li>Motion greatly enhances the user experience, so animations give users a chance to detect the application's response to their actions</li> <li>Good animations can smoothly direct the user's attention throughout a workflow</li> </ul> <p>Angular provides <code>animate.enter</code> and <code>animate.leave</code> to animate your application's elements. These two features apply enter and leave CSS classes at the appropriate times or call functions to apply animations from third party libraries. <code>animate.enter</code> and <code>animate.leave</code> are not directives. They are special API supported directly by the Angular compiler. They can be used on elements directly and can also be used as a host binding.</p> <h2 id="animateenter"> animate.enter </h2> <p>You can use <code>animate.enter</code> to animate elements as they <em>enter</em> the DOM. You can define enter animations using CSS classes with either transitions or keyframe animations.</p> <div class="docs-code-multifile" style="display: none" path="adev/src/content/examples/animations/src/app/enter-and-leave/enter.ts" preview="true"> <pre data-language="ts">import {Component, signal} from '@angular/core';

@Component({
  selector: 'app-enter',
  templateUrl: 'enter.html',
  styleUrls: ['enter.css'],
})
export class Enter {
  isShown = signal(false);

  toggle() {
    this.isShown.update((isShown) =&gt; !isShown);
  }
}
</pre>
<pre data-language="ts">&lt;h2&gt;&lt;code&gt;animate.enter&lt;/code&gt; Example&lt;/h2&gt;

&lt;button type="button" (click)="toggle()"&gt;Toggle Element&lt;/button&gt;

@if (isShown()) {
  &lt;div class="enter-container" animate.enter="enter-animation"&gt;
    &lt;p&gt;The box is entering.&lt;/p&gt;
  &lt;/div&gt;
}
</pre>
<pre data-language="ts">:host {
  display: block;
  height: 200px;
}

.enter-container {
  border: 1px solid #dddddd;
  margin-top: 1em;
  padding: 20px 20px 0px 20px;
  font-weight: bold;
  font-size: 20px;
}

.enter-animation {
  animation: slide-fade 1s;
}

@keyframes slide-fade {
  from {
    opacity: 0;
    transform: translateY(20px);
  }

  to {
    opacity: 1;
    transform: translateY(0);
  }
}
</pre> </div>
<p>When the animation completes, Angular removes the class or classes that you specified in <code>animate.enter</code> from the DOM. Animation classes are only be present while the animation is active.</p> 
<div class="docs-alert docs-alert-note"> <p><strong>NOTE:</strong> When using multiple keyframe animations or transition properties on an element, Angular removes all classes only <em>after</em> the longest animation has completed.</p> </div>  <p>You can use <code>animate.enter</code> with any other Angular features, such as control flow or dynamic expressions. <code>animate.enter</code> accepts both a single class string (with multiple classes separated by spaces), or an array of class strings.</p> <p>A quick note about using CSS transitions: If you choose to use transitions instead of keyframe animations, the classes added to the element with <code>animate.enter</code> represent the state that the transition will animate <em>to</em>. Your base element CSS is what the element will look like when no animations run, which is likely similar to the end state of the CSS transition. So you would still need to pair it with <code>@starting-style</code> to have an appropriate <em>from</em> state for your transition to work.</p> <div class="docs-code-multifile" style="display: none" path="adev/src/content/examples/animations/src/app/enter-and-leave/enter-binding.ts" preview="true"> <pre data-language="ts">import {Component, signal} from '@angular/core';

@Component({
  selector: 'app-enter-binding',
  templateUrl: 'enter-binding.html',
  styleUrls: ['enter-binding.css'],
})
export class EnterBinding {
  isShown = signal(false);

  toggle() {
    this.isShown.update((isShown) =&gt; !isShown);
  }

  enterClass = signal('enter-animation');
}
</pre>
<pre data-language="ts">&lt;h2&gt;&lt;code&gt;animate.enter&lt;/code&gt; Binding Example&lt;/h2&gt;

&lt;button type="button" (click)="toggle()"&gt;Toggle Element&lt;/button&gt;

@if (isShown()) {
  &lt;div class="enter-container" [animate.enter]="enterClass()"&gt;
    &lt;p&gt;The box is entering.&lt;/p&gt;
  &lt;/div&gt;
}
</pre>
<pre data-language="ts">:host {
  display: block;
  height: 200px;
}

.enter-container {
  border: 1px solid #dddddd;
  margin-top: 1em;
  padding: 20px 20px 0px 20px;
  font-weight: bold;
  font-size: 20px;
}

.enter-animation {
  animation: slide-fade 1s;
}

@keyframes slide-fade {
  from {
    opacity: 0;
    transform: translateY(20px);
  }

  to {
    opacity: 1;
    transform: translateY(0);
  }
}
</pre> </div> <h2 id="animateleave"> animate.leave </h2> <p>You can use <code>animate.leave</code> to animate elements as they <em>leave</em> the DOM. You can define leave animations using CSS classes with either transforms or keyframe animations.</p> <div class="docs-code-multifile" style="display: none" path="adev/src/content/examples/animations/src/app/enter-and-leave/leave.ts" preview="true"> <pre data-language="ts">import {Component, signal} from '@angular/core';

@Component({
  selector: 'app-leave',
  templateUrl: 'leave.html',
  styleUrls: ['leave.css'],
})
export class Leave {
  isShown = signal(false);

  toggle() {
    this.isShown.update((isShown) =&gt; !isShown);
  }
}
</pre>
<pre data-language="ts">&lt;h2&gt;&lt;code&gt;animate.leave&lt;/code&gt; Example&lt;/h2&gt;

&lt;button type="button" (click)="toggle()"&gt;Toggle Element&lt;/button&gt;

@if (isShown()) {
  &lt;div class="leave-container" animate.leave="leaving"&gt;
    &lt;p&gt;Goodbye&lt;/p&gt;
  &lt;/div&gt;
}
</pre>
<pre data-language="ts">:host {
  display: block;
  height: 200px;
}

.leave-container {
  border: 1px solid #dddddd;
  margin-top: 1em;
  padding: 20px 20px 0px 20px;
  font-weight: bold;
  font-size: 20px;
  opacity: 1;
  transition: opacity 200ms ease-in;

  @starting-style {
    opacity: 0;
  }
}

.leaving {
  opacity: 0;
  transform: translateY(20px);
  transition: opacity 500ms ease-out, transform 500ms ease-out;
}
</pre> </div>
<p>When the animation completes, Angular automatically removes the animated element from the DOM.</p> 
<div class="docs-alert docs-alert-note"> <p><strong>NOTE:</strong> When using multiple keyframe animations or transition properties on a an element, Angular waits to remove the element only <em>after</em> the longest of those animations has completed.</p> </div>  <p><code>animate.leave</code> can also be used with signals, and other bindings. You can use <code>animate.leave</code> with a single class or multiple classes. Either specify it as a simple string with spaces or a string array.</p> <div class="docs-code-multifile" style="display: none" path="adev/src/content/examples/animations/src/app/enter-and-leave/leave-binding.ts" preview="true"> <pre data-language="ts">import {Component, signal} from '@angular/core';

@Component({
  selector: 'app-leave-binding',
  templateUrl: 'leave-binding.html',
  styleUrls: ['leave-binding.css'],
})
export class LeaveBinding {
  isShown = signal(false);

  toggle() {
    this.isShown.update((isShown) =&gt; !isShown);
  }

  farewell = signal('leaving');
}
</pre>
<pre data-language="ts">&lt;h2&gt;&lt;code&gt;animate.leave&lt;/code&gt; Binding Example&lt;/h2&gt;

&lt;button type="button" (click)="toggle()"&gt;Toggle Element&lt;/button&gt;

@if (isShown()) {
  &lt;div class="leave-container" [animate.leave]="farewell()"&gt;
    &lt;p&gt;Goodbye&lt;/p&gt;
  &lt;/div&gt;
}
</pre>
<pre data-language="ts">:host {
  display: block;
  height: 200px;
}

.leave-container {
  border: 1px solid #dddddd;
  margin-top: 1em;
  padding: 20px 20px 0px 20px;
  font-weight: bold;
  font-size: 20px;
  opacity: 1;
  transition: opacity 200ms ease-in;

  @starting-style {
    opacity: 0;
  }
}

.leaving {
  opacity: 0;
  transform: translateY(20px);
  transition: opacity 500ms ease-out, transform 500ms ease-out;
}
</pre> </div> <h2 id="event-bindings-functions-and-third-party-libraries"> Event Bindings, Functions, and Third-party Libraries </h2> <p>Both <code>animate.enter</code> and <code>animate.leave</code> support event binding syntax that allows for function calls. You can use this syntax to call a function in your component code or utilize third-party animation libraries, like <a href="https://gsap.com/" target="_blank">GSAP</a>, <a href="https://animejs.com/" target="_blank">anime.js</a>, or any other JavaScript animation library.</p> <div class="docs-code-multifile" style="display: none" path="adev/src/content/examples/animations/src/app/enter-and-leave/leave-event.ts" preview="true"> <pre data-language="ts">import {AnimationCallbackEvent, Component, signal} from '@angular/core';

@Component({
  selector: 'app-leave-binding',
  templateUrl: 'leave-event.html',
  styleUrls: ['leave-event.css'],
})
export class LeaveEvent {
  isShown = signal(false);

  toggle() {
    this.isShown.update((isShown) =&gt; !isShown);
  }

  leavingFn(event: AnimationCallbackEvent) {
    // Example of calling GSAP
    // gsap.to(event.target, {
    //   duration: 1,
    //   x: 100,
    //   // arrow functions are handy for concise callbacks
    //   onComplete: () =&gt; event.animationComplete()
    // });
    event.animationComplete();
  }
}
</pre>
<pre data-language="ts">&lt;h2&gt;&lt;code&gt;animate.leave&lt;/code&gt; Function Example&lt;/h2&gt;

&lt;button type="button" (click)="toggle()"&gt;Toggle Element&lt;/button&gt;

@if (isShown()) {
  &lt;div class="leave-container" (animate.leave)="leavingFn($event)"&gt;
    &lt;p&gt;Goodbye&lt;/p&gt;
  &lt;/div&gt;
}
</pre>
<pre data-language="ts">:host {
  display: block;
  height: 200px;
}

.leave-container {
  border: 1px solid #dddddd;
  margin-top: 1em;
  padding: 20px 20px 0px 20px;
  font-weight: bold;
  font-size: 20px;
  opacity: 1;
  transition: opacity 200ms ease-in;

  @starting-style {
    opacity: 0;
  }
}

.leaving {
  opacity: 0;
  transform: translateY(20px);
  transition: opacity 500ms ease-out, transform 500ms ease-out;
}
</pre> </div>
<p>The <code>$event</code> object has the type <a href="../api/core/animationcallbackevent"><code>AnimationCallbackEvent</code></a>. It includes the element as the <code>target</code> and provides an <code>animationComplete()</code> function to notify the framework when the animation finishes.</p> 
<div class="docs-alert docs-alert-important"> <p><strong>IMPORTANT:</strong> You <strong>must</strong> call the <code>animationComplete()</code> function when using <code>animate.leave</code> for Angular to remove the element.</p> </div>  <p>If you don't call <code>animationComplete()</code> when using <code>animate.leave</code>, Angular calls the function automatically after a four-second delay. You can configure the duration of the delay by providing the token <a href="../api/core/max_animation_timeout"><code>MAX_ANIMATION_TIMEOUT</code></a> in milliseconds.</p> <pre data-language="ts">  { provide: MAX_ANIMATION_TIMEOUT, useValue: 6000 }</pre> <h2 id="compatibility-with-legacy-angular-animations"> Compatibility with Legacy Angular Animations </h2> <p>You cannot use legacy animations alongside <code>animate.enter</code> and <code>animate.leave</code> within the same component. Doing so would result in enter classes remaining on the element or leaving nodes not being removed. It is otherwise fine to use both legacy animations and the new <code>animate.enter</code> and <code>animate.leave</code> animations within the same <em>application</em>. The only caveat is content projection. If you are projecting content from one component with legacy animations into another component with <code>animate.enter</code> or <code>animate.leave</code>, or vice versa, this will result in the same behavior as if they are used together in the same component. This is not supported.</p> <h2 id="testing"> Testing </h2> <p>TestBed provides built-in support for enabling or disabling animations in your test environment. CSS animations require a browser to run, and many of the APIs are not available in a test environment. By default, TestBed disables animations for you in your test environments.</p> <p>If you want to test that the animations are animating in a browser test, for example an end-to-end test, you can configure TestBed to enable animations by specifying <code>animationsEnabled: true</code> in your test configuration.</p> <pre data-language="ts">  TestBed.configureTestingModule({animationsEnabled: true});</pre>
<p>This will configure animations in your test environment to behave normally.</p> 
<div class="docs-alert docs-alert-note"> <p><strong>NOTE:</strong> Some test environments do not emit animation events like <code>animationstart</code>, <code>animationend</code> and their transition event equivalents.</p> </div>  <h2 id="more-on-angular-animations"> More on Angular animations </h2> <p>You might also be interested in the following:</p> <nav class="docs-pill-row"> <a class="docs-pill" href="animations/css"> Complex Animations with CSS </a> <a class="docs-pill" href="routing/route-transition-animations"> Route transition animations </a> </nav><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/guide/animations" class="_attribution-link">https://angular.dev/guide/animations</a>
  </p>
</div>
