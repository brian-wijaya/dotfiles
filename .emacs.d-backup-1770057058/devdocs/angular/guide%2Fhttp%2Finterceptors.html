<h1 tabindex="-1">Interceptors</h1> <header class="docs-header"> <docs-breadcrumb ng-version="21.0.3" _nghost-ng-c3945279308 ngh="8"></docs-breadcrumb>   </header> <p><a href="../../api/common/http/httpclient"><code>HttpClient</code></a> supports a form of middleware known as <em>interceptors</em>.</p> 
<div class="docs-alert docs-alert-tldr"> <p><strong>TL;DR:</strong> Interceptors are middleware that allows common patterns around retrying, caching, logging, and authentication to be abstracted away from individual requests.</p> </div>  <p><a href="../../api/common/http/httpclient"><code>HttpClient</code></a> supports two kinds of interceptors: functional and DI-based. Our recommendation is to use functional interceptors because they have more predictable behavior, especially in complex setups. Our examples in this guide use functional interceptors, and we cover <a href="#di-based-interceptors">DI-based interceptors</a> in their own section at the end.</p> <h2 id="interceptors"> Interceptors </h2> <p>Interceptors are generally functions which you can run for each request, and have broad capabilities to affect the contents and overall flow of requests and responses. You can install multiple interceptors, which form an interceptor chain where each interceptor processes the request or response before forwarding it to the next interceptor in the chain.</p> <p>You can use interceptors to implement a variety of common patterns, such as:</p> <ul class="docs-list"> <li>Adding authentication headers to outgoing requests to a particular API.</li> <li>Retrying failed requests with exponential backoff.</li> <li>Caching responses for a period of time, or until invalidated by mutations.</li> <li>Customizing the parsing of responses.</li> <li>Measuring server response times and log them.</li> <li>Driving UI elements such as a loading spinner while network operations are in progress.</li> <li>Collecting and batch requests made within a certain timeframe.</li> <li>Automatically failing requests after a configurable deadline or timeout.</li> <li>Regularly polling the server and refreshing results.</li> </ul> <h2 id="defining-an-interceptor"> Defining an interceptor </h2> <p>The basic form of an interceptor is a function which receives the outgoing <a href="../../api/common/http/httprequest"><code>HttpRequest</code></a> and a <code>next</code> function representing the next processing step in the interceptor chain.</p> <p>For example, this <code>loggingInterceptor</code> will log the outgoing request URL to <code>console.log</code> before forwarding the request:</p> <pre data-language="ts">export function loggingInterceptor(req: HttpRequest&lt;unknown&gt;, next: HttpHandlerFn): Observable&lt;HttpEvent&lt;unknown&gt;&gt; {
  console.log(req.url);
  return next(req);
}</pre>
<p>In order for this interceptor to actually intercept requests, you must configure <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> to use it.</p> <h2 id="configuring-interceptors"> Configuring interceptors </h2> <p>You declare the set of interceptors to use when configuring <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> through dependency injection, by using the <a href="../../api/common/http/withinterceptors"><code>withInterceptors</code></a> feature:</p> <pre data-language="ts">bootstrapApplication(AppComponent, {providers: [
  provideHttpClient(
    withInterceptors([loggingInterceptor, cachingInterceptor]),
  )
]});</pre>
<p>The interceptors you configure are chained together in the order that you've listed them in the providers. In the above example, the <code>loggingInterceptor</code> would process the request and then forward it to the <code>cachingInterceptor</code>.</p> <h3 id="intercepting-response-events"> Intercepting response events </h3> <p>An interceptor may transform the <code>Observable</code> stream of <a href="../../api/common/http/httpevent"><code>HttpEvent</code></a>s returned by <code>next</code> in order to access or manipulate the response. Because this stream includes all response events, inspecting the <code>.type</code> of each event may be necessary in order to identify the final response object.</p> <pre data-language="ts">export function loggingInterceptor(req: HttpRequest&lt;unknown&gt;, next: HttpHandlerFn): Observable&lt;HttpEvent&lt;unknown&gt;&gt; {
  return next(req).pipe(tap(event =&gt; {
    if (event.type === HttpEventType.Response) {
      console.log(req.url, 'returned a response with status', event.status);
    }
  }));
}</pre>

<div class="docs-alert docs-alert-tip"> <p><strong>TIP:</strong> Interceptors naturally associate responses with their outgoing requests, because they transform the response stream in a closure that captures the request object.</p> </div>  <h2 id="modifying-requests"> Modifying requests </h2> <p>Most aspects of <a href="../../api/common/http/httprequest"><code>HttpRequest</code></a> and <a href="../../api/common/http/httpresponse"><code>HttpResponse</code></a> instances are <em>immutable</em>, and interceptors cannot directly modify them. Instead, interceptors apply mutations by cloning these objects using the <code>.clone()</code> operation, and specifying which properties should be mutated in the new instance. This might involve performing immutable updates on the value itself (like <a href="../../api/common/http/httpheaders"><code>HttpHeaders</code></a> or <a href="../../api/common/http/httpparams"><code>HttpParams</code></a>).</p> <p>For example, to add a header to a request:</p> <pre data-language="ts">const reqWithHeader = req.clone({
  headers: req.headers.set('X-New-Header', 'new header value'),
});</pre>
<p>This immutability allows most interceptors to be idempotent if the same <a href="../../api/common/http/httprequest"><code>HttpRequest</code></a> is submitted to the interceptor chain multiple times. This can happen for a few reasons, including when a request is retried after failure.</p> 
<div class="docs-alert docs-alert-critical"> <p><strong>CRITICAL:</strong> The body of a request or response is <strong>not</strong> protected from deep mutations. If an interceptor must mutate the body, take care to handle running multiple times on the same request.</p> </div>  <h2 id="dependency-injection-in-interceptors"> Dependency injection in interceptors </h2> <p>Interceptors are run in the <em>injection context</em> of the injector which registered them, and can use Angular's <a href="../../api/core/inject"><code>inject</code></a> API to retrieve dependencies.</p> <p>For example, suppose an application has a service called <code>AuthService</code>, which creates authentication tokens for outgoing requests. An interceptor can inject and use this service:</p> <pre data-language="ts">export function authInterceptor(req: HttpRequest&lt;unknown&gt;, next: HttpHandlerFn) {
  // Inject the current `AuthService` and use it to get an authentication token:
  const authToken = inject(AuthService).getAuthToken();

  // Clone the request to add the authentication header.
  const newReq = req.clone({
    headers: req.headers.append('X-Authentication-Token', authToken),
  });
  return next(newReq);
}</pre> <h2 id="request-and-response-metadata"> Request and response metadata </h2> <p>Often it's useful to include information in a request that's not sent to the backend, but is specifically meant for interceptors. <a href="../../api/common/http/httprequest"><code>HttpRequest</code></a>s have a <code>.context</code> object which stores this kind of metadata as an instance of <a href="../../api/common/http/httpcontext"><code>HttpContext</code></a>. This object functions as a typed map, with keys of type <a href="../../api/common/http/httpcontexttoken"><code>HttpContextToken</code></a>.</p> <p>To illustrate how this system works, let's use metadata to control whether a caching interceptor is enabled for a given request.</p> <h3 id="defining-context-tokens"> Defining context tokens </h3> <p>To store whether the caching interceptor should cache a particular request in that request's <code>.context</code> map, define a new <a href="../../api/common/http/httpcontexttoken"><code>HttpContextToken</code></a> to act as a key:</p> <pre data-language="ts">export const CACHING_ENABLED = new HttpContextToken&lt;boolean&gt;(() =&gt; true);</pre>
<p>The provided function creates the default value for the token for requests that haven't explicitly set a value for it. Using a function ensures that if the token's value is an object or array, each request gets its own instance.</p> <h3 id="reading-the-token-in-an-interceptor"> Reading the token in an interceptor </h3> <p>An interceptor can then read the token and choose to apply caching logic or not based on its value:</p> <pre data-language="ts">export function cachingInterceptor(req: HttpRequest&lt;unknown&gt;, next: HttpHandlerFn): Observable&lt;HttpEvent&lt;unknown&gt;&gt; {
  if (req.context.get(CACHING_ENABLED)) {
    // apply caching logic
    return ...;
  } else {
    // caching has been disabled for this request
    return next(req);
  }
}</pre> <h3 id="setting-context-tokens-when-making-a-request"> Setting context tokens when making a request </h3> <p>When making a request via the <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> API, you can provide values for <a href="../../api/common/http/httpcontexttoken"><code>HttpContextToken</code></a>s:</p> <pre data-language="ts">const data$ = http.get('/sensitive/data', {
  context: new HttpContext().set(CACHING_ENABLED, false),
});</pre>
<p>Interceptors can read these values from the <a href="../../api/common/http/httpcontext"><code>HttpContext</code></a> of the request.</p> <h3 id="the-request-context-is-mutable"> The request context is mutable </h3> <p>Unlike other properties of <a href="../../api/common/http/httprequest"><code>HttpRequest</code></a>s, the associated <a href="../../api/common/http/httpcontext"><code>HttpContext</code></a> is <em>mutable</em>. If an interceptor changes the context of a request that is later retried, the same interceptor will observe the context mutation when it runs again. This is useful for passing state across multiple retries if needed.</p> <h2 id="synthetic-responses"> Synthetic responses </h2> <p>Most interceptors will simply invoke the <code>next</code> handler while transforming either the request or the response, but this is not strictly a requirement. This section discusses several of the ways in which an interceptor may incorporate more advanced behavior.</p> <p>Interceptors are not required to invoke <code>next</code>. They may instead choose to construct responses through some other mechanism, such as from a cache or by sending the request through an alternate mechanism.</p> <p>Constructing a response is possible using the <a href="../../api/common/http/httpresponse"><code>HttpResponse</code></a> constructor:</p> <pre data-language="ts">const resp = new HttpResponse({
  body: 'response body',
});</pre> <h2 id="working-with-redirect-information"> Working with redirect information </h2> <p>When using <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> with the <a href="../../api/common/http/withfetch"><code>withFetch</code></a> provider, responses include a <code>redirected</code> property that indicates whether the response was the result of a redirect. This property aligns with the native Fetch API specification and can be useful in interceptors for handling redirect scenarios.</p> <p>An interceptor can access and act upon the redirect information:</p> <pre data-language="ts">export function redirectTrackingInterceptor(req: HttpRequest&lt;unknown&gt;, next: HttpHandlerFn): Observable&lt;HttpEvent&lt;unknown&gt;&gt; {
  return next(req).pipe(tap(event =&gt; {
    if (event.type === HttpEventType.Response &amp;&amp; event.redirected) {
      console.log('Request to', req.url, 'was redirected to', event.url);
      // Handle redirect logic - maybe update analytics, security checks, etc.
    }
  }));
}</pre>
<p>You can also use the redirect information to implement conditional logic in your interceptors:</p> <pre data-language="ts">export function authRedirectInterceptor(req: HttpRequest&lt;unknown&gt;, next: HttpHandlerFn): Observable&lt;HttpEvent&lt;unknown&gt;&gt; {
  return next(req).pipe(tap(event =&gt; {
    if (event.type === HttpEventType.Response &amp;&amp; event.redirected) {
      // Check if we were redirected to a login page
      if (event.url?.includes('/login')) {
        // Handle authentication redirect
        handleAuthRedirect();
      }
    }
  }));
}</pre> <h2 id="working-with-response-types"> Working with response types </h2> <p>When using <a href="../../api/common/http/httpclient"><code>HttpClient</code></a> with the <a href="../../api/common/http/withfetch"><code>withFetch</code></a> provider, responses include a <code>type</code> property that indicates how the browser handled the response based on CORS policies and request mode. This property aligns with the native Fetch API specification and provides valuable insights for debugging CORS issues and understanding response accessibility.</p> <p>The response <code>type</code> property can have the following values:</p> <ul class="docs-list"> <li>
<code>'basic'</code> - Same-origin response with all headers accessible</li> <li>
<code>'cors'</code> - Cross-origin response with CORS headers properly configured</li> <li>
<code>'opaque'</code> - Cross-origin response without CORS, headers and body may be limited</li> <li>
<code>'opaqueredirect'</code> - Response from a redirected request in no-cors mode</li> <li>
<code>'error'</code> - Network error occurred</li> </ul> <p>An interceptor can use response type information for CORS debugging and error handling:</p> <pre data-language="ts">export function responseTypeInterceptor(req: HttpRequest&lt;unknown&gt;, next: HttpHandlerFn): Observable&lt;HttpEvent&lt;unknown&gt;&gt; {
  return next(req).pipe(map(event =&gt; {
    if (event.type === HttpEventType.Response) {
      // Handle different response types appropriately
      switch (event.responseType) {
        case 'opaque':
          // Limited access to response data
          console.warn('Limited response data due to CORS policy');
          break;
        case 'cors':
        case 'basic':
          // Full access to response data
          break;
        case 'error':
          // Handle network errors
          console.error('Network error in response');
          break;
      }
    }
  }));
}</pre> <h2 id="di-based-interceptors"> DI-based interceptors </h2> <p><a href="../../api/common/http/httpclient"><code>HttpClient</code></a> also supports interceptors which are defined as injectable classes and configured through the DI system. The capabilities of DI-based interceptors are identical to those of functional interceptors, but the configuration mechanism is different.</p> <p>A DI-based interceptor is an injectable class which implements the <a href="../../api/common/http/httpinterceptor"><code>HttpInterceptor</code></a> interface:</p> <pre data-language="ts">@Injectable()
export class LoggingInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest&lt;any&gt;, handler: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {
    console.log('Request URL: ' + req.url);
    return handler.handle(req);
  }
}</pre>
<p>DI-based interceptors are configured through a dependency injection multi-provider:</p> <pre data-language="ts">bootstrapApplication(AppComponent, {providers: [
  provideHttpClient(
    // DI-based interceptors must be explicitly enabled.
    withInterceptorsFromDi(),
  ),

  {provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true},
]});</pre>
<p>DI-based interceptors run in the order that their providers are registered. In an app with an extensive and hierarchical DI configuration, this order can be very hard to predict.</p><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/guide/http/interceptors" class="_attribution-link">https://angular.dev/guide/http/interceptors</a>
  </p>
</div>
