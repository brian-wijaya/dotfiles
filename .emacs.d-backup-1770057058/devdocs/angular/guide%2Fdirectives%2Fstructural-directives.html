<h1 tabindex="-1">Structural directives</h1> <header class="docs-header"> <docs-breadcrumb ng-version="21.0.3" _nghost-ng-c3945279308 ngh="8"></docs-breadcrumb>   </header> <p>Structural directives are directives applied to an <code>&lt;ng-template&gt;</code> element that conditionally or repeatedly render the content of that <code>&lt;ng-template&gt;</code>.</p> <h2 id="example-use-case"> Example use case </h2> <p>In this guide you'll build a structural directive which fetches data from a given data source and renders its template when that data is available. This directive is called <code>SelectDirective</code>, after the SQL keyword <code>SELECT</code>, and match it with an attribute selector <code>[select]</code>.</p> <p><code>SelectDirective</code> will have an input naming the data source to be used, which you will call <code>selectFrom</code>. The <code>select</code> prefix for this input is important for the <a href="#structural-directive-shorthand">shorthand syntax</a>. The directive will instantiate its <code>&lt;ng-template&gt;</code> with a template context providing the selected data.</p> <p>The following is an example of using this directive directly on an <code>&lt;ng-template&gt;</code> would look like:</p> <pre data-language="ts">&lt;ng-template select let-data [selectFrom]="source"&gt;
  &lt;p&gt;The data is: {{ data }}&lt;/p&gt;
&lt;/ng-template&gt;</pre>
<p>The structural directive can wait for the data to become available and then render its <code>&lt;ng-template&gt;</code>.</p> 
<div class="docs-alert docs-alert-helpful"> <p><strong>HELPFUL:</strong> Note that Angular's <code>&lt;ng-template&gt;</code> element defines a template that doesn't render anything by default, if you just wrap elements in an <code>&lt;ng-template&gt;</code> without applying a structural directive those elements will not be rendered.</p> </div>  <p>For more information, see the <a href="../../api/core/ng-template">ng-template API</a> documentation.</p> <h2 id="structural-directive-shorthand"> Structural directive shorthand </h2> <p>Angular supports a shorthand syntax for structural directives which avoids the need to explicitly author an <code>&lt;ng-template&gt;</code> element.</p> <p>Structural directives can be applied directly on an element by prefixing the directive attribute selector with an asterisk (<code>*</code>), such as <code>*select</code>. Angular transforms the asterisk in front of a structural directive into an <code>&lt;ng-template&gt;</code> that hosts the directive and surrounds the element and its descendants.</p> <p>You can use this with <code>SelectDirective</code> as follows:</p> <pre data-language="ts">&lt;p *select="let data from source"&gt;The data is: {{data}}&lt;/p&gt;</pre>
<p>This example shows the flexibility of structural directive shorthand syntax, which is sometimes called <em>microsyntax</em>.</p> <p>When used in this way, only the structural directive and its bindings are applied to the <code>&lt;ng-template&gt;</code>. Any other attributes or bindings on the <code>&lt;p&gt;</code> tag are left alone. For example, these two forms are equivalent:</p> <pre data-language="ts">&lt;!-- Shorthand syntax: --&gt;
&lt;p class="data-view" *select="let data from source"&gt;The data is: {{data}}&lt;/p&gt;

&lt;!-- Long-form syntax: --&gt;
&lt;ng-template select let-data [selectFrom]="source"&gt;
  &lt;p class="data-view"&gt;The data is: {{data}}&lt;/p&gt;
&lt;/ng-template&gt;</pre>
<p>Shorthand syntax is expanded through a set of conventions. A more thorough <a href="#structural-directive-syntax-reference">grammar</a> is defined below, but in the above example, this transformation can be explained as follows:</p> <p>The first part of the <code>*select</code> expression is <code>let data</code>, which declares a template variable <code>data</code>. Since no assignment follows, the template variable is bound to the template context property <code>$implicit</code>.</p> <p>The second piece of syntax is a key-expression pair, <code>from source</code>. <code>from</code> is a binding key and <code>source</code> is a regular template expression. Binding keys are mapped to properties by transforming them to PascalCase and prepending the structural directive selector. The <code>from</code> key is mapped to <code>selectFrom</code>, which is then bound to the expression <code>source</code>. This is why many structural directives will have inputs that are all prefixed with the structural directive's selector.</p> <h2 id="one-structural-directive-per-element"> One structural directive per element </h2> <p>You can only apply one structural directive per element when using the shorthand syntax. This is because there is only one <code>&lt;ng-template&gt;</code> element onto which that directive gets unwrapped. Multiple directives would require multiple nested <code>&lt;ng-template&gt;</code>, and it's unclear which directive should be first. <code>&lt;ng-container&gt;</code> can be used when to create wrapper layers when multiple structural directives need to be applied around the same physical DOM element or component, which allows the user to define the nested structure.</p> <h2 id="creating-a-structural-directive"> Creating a structural directive </h2> <p>This section guides you through creating the <code>SelectDirective</code>.</p> <ol class="docs-steps"> <li>  <h3 id="generate-the-directive"> Generate the directive </h3> <p>Using the Angular CLI, run the following command, where <code>select</code> is the name of the directive:</p> <pre data-language="ts">ng generate directive select</pre>
<p>Angular creates the directive class and specifies the CSS selector, <code>[select]</code>, that identifies the directive in a template.</p> </li> <li>  <h3 id="make-the-directive-structural"> Make the directive structural </h3> <p>Import <a href="../../api/core/templateref"><code>TemplateRef</code></a>, and <a href="../../api/core/viewcontainerref"><code>ViewContainerRef</code></a>. Inject <a href="../../api/core/templateref"><code>TemplateRef</code></a> and <a href="../../api/core/viewcontainerref"><code>ViewContainerRef</code></a> in the directive as private properties.</p> <pre data-language="ts">import {Directive, TemplateRef, ViewContainerRef} from '@angular/core';

@Directive({
  selector: '[select]',
})
export class SelectDirective {
  private templateRef = inject(TemplateRef);
  private viewContainerRef = inject(ViewContainerRef);
}</pre> </li> <li>  <h3 id="add-the-selectfrom-input"> Add the 'selectFrom' input </h3> <p>Add a <code>selectFrom</code> <a href="../../api/core/input"><code>input()</code></a> property.</p> <pre data-language="ts">export class SelectDirective {
  // ...

  selectFrom = input.required&lt;DataSource&gt;();
}</pre> </li> <li>  <h3 id="add-the-business-logic"> Add the business logic </h3> <p>With <code>SelectDirective</code> now scaffolded as a structural directive with its input, you can now add the logic to fetch the data and render the template with it:</p> <pre data-language="ts">export class SelectDirective {
  // ...

  async ngOnInit() {
    const data = await this.selectFrom.load();
    this.viewContainerRef.createEmbeddedView(this.templateRef, {
      // Create the embedded view with a context object that contains
      // the data via the key `$implicit`.
      $implicit: data,
    });
  }
}</pre> </li> </ol> <p>That's it - <code>SelectDirective</code> is up and running. A follow-up step might be to <a href="#typing-the-directives-context">add template type-checking support</a>.</p> <h2 id="structural-directive-syntax-reference"> Structural directive syntax reference </h2> <p>When you write your own structural directives, use the following syntax:</p> <pre data-language="ts">_:prefix="( :let | :expression ) (';' | ',')? ( :let | :as | :keyExp )_"</pre>
<p>The following patterns describe each portion of the structural directive grammar:</p> <pre data-language="ts">as = :export "as" :local ";"?
keyExp = :key ":"? :expression ("as" :local)? ";"?
let = "let" :local "=" :export ";"?</pre> <div class="docs-table docs-scroll-track-transparent"> <table> <thead> <tr> <th align="left">Keyword</th> <th align="left">Details</th> </tr> </thead> <tbody> <tr> <td align="left"><code>prefix</code></td> <td align="left">HTML attribute key</td> </tr> <tr> <td align="left"><code>key</code></td> <td align="left">HTML attribute key</td> </tr> <tr> <td align="left"><code>local</code></td> <td align="left">Local variable name used in the template</td> </tr> <tr> <td align="left"><code>export</code></td> <td align="left">Value exported by the directive under a given name</td> </tr> <tr> <td align="left"><code>expression</code></td> <td align="left">Standard Angular expression</td> </tr> </tbody> </table> </div> <h3 id="how-angular-translates-shorthand"> How Angular translates shorthand </h3> <p>Angular translates structural directive shorthand into the normal binding syntax as follows:</p> <div class="docs-table docs-scroll-track-transparent"> <table> <thead> <tr> <th align="left">Shorthand</th> <th align="left">Translation</th> </tr> </thead> <tbody> <tr> <td align="left">
<code>prefix</code> and naked <code>expression</code>
</td> <td align="left"><code>[prefix]="expression"</code></td> </tr> <tr> <td align="left"><code>keyExp</code></td> <td align="left">
<code>[prefixKey]="expression"</code> (The <code>prefix</code> is added to the <code>key</code>)</td> </tr> <tr> <td align="left"><code>let local</code></td> <td align="left"><code>let-local="export"</code></td> </tr> </tbody> </table> </div> <h3 id="shorthand-examples"> Shorthand examples </h3> <p>The following table provides shorthand examples:</p> <div class="docs-table docs-scroll-track-transparent"> <table> <thead> <tr> <th align="left">Shorthand</th> <th align="left">How Angular interprets the syntax</th> </tr> </thead> <tbody> <tr> <td align="left"><code>*myDir="let item of [1,2,3]"</code></td> <td align="left"><code>&lt;ng-template myDir let-item [myDirOf]="[1, 2, 3]"&gt;</code></td> </tr> <tr> <td align="left"><code>*myDir="let item of [1,2,3] as items; trackBy: myTrack; index as i"</code></td> <td align="left"><code>&lt;ng-template myDir let-item [myDirOf]="[1,2,3]" let-items="myDirOf" [myDirTrackBy]="myTrack" let-i="index"&gt;</code></td> </tr> <tr> <td align="left"><code>*ngComponentOutlet="componentClass";</code></td> <td align="left"><code>&lt;ng-template [ngComponentOutlet]="componentClass"&gt;</code></td> </tr> <tr> <td align="left"><code>*ngComponentOutlet="componentClass; inputs: myInputs";</code></td> <td align="left"><code>&lt;ng-template [ngComponentOutlet]="componentClass" [ngComponentOutletInputs]="myInputs"&gt;</code></td> </tr> <tr> <td align="left"><code>*myDir="exp as value"</code></td> <td align="left"><code>&lt;ng-template [myDir]="exp" let-value="myDir"&gt;</code></td> </tr> </tbody> </table> </div> <h2 id="improving-template-type-checking-for-custom-directives"> Improving template type checking for custom directives </h2> <p>You can improve template type checking for custom directives by adding template guards to your directive definition. These guards help the Angular template type checker find mistakes in the template at compile time, which can avoid runtime errors. Two different types of guards are possible:</p> <ul class="docs-list"> <li>
<code>ngTemplateGuard_(input)</code> lets you control how an input expression should be narrowed based on the type of a specific input.</li> <li>
<code>ngTemplateContextGuard</code> is used to determine the type of the context object for the template, based on the type of the directive itself.</li> </ul> <p>This section provides examples of both kinds of guards. For more information, see <a href="https://angular.dev/tools/cli/template-typecheck" title="Template type-checking guide">Template type checking</a>.</p> <h3 id="type-narrowing-with-template-guards"> Type narrowing with template guards </h3> <p>A structural directive in a template controls whether that template is rendered at run time. Some structural directives want to perform type narrowing based on the type of input expression.</p> <p>There are two narrowings which are possible with input guards:</p> <ul class="docs-list"> <li>Narrowing the input expression based on a TypeScript type assertion function.</li> <li>Narrowing the input expression based on its truthiness.</li> </ul> <p>To narrow the input expression by defining a type assertion function:</p> <pre data-language="ts">// This directive only renders its template if the actor is a user.
// You want to assert that within the template, the type of the `actor`
// expression is narrowed to `User`.
@Directive(...)
class ActorIsUser {
  actor = input&lt;User | Robot&gt;();

  static ngTemplateGuard_actor(dir: ActorIsUser, expr: User | Robot): expr is User {
    // The return statement is unnecessary in practice, but included to
    // prevent TypeScript errors.
    return true;
  }
}</pre>
<p>Type-checking will behave within the template as if the <code>ngTemplateGuard_actor</code> has been asserted on the expression bound to the input.</p> <p>Some directives only render their templates when an input is truthy. It's not possible to capture the full semantics of truthiness in a type assertion function, so instead a literal type of <code>'binding'</code> can be used to signal to the template type-checker that the binding expression itself should be used as the guard:</p> <pre data-language="ts">@Directive(...)
class CustomIf {
  condition = input.required&lt;boolean&gt;();

  static ngTemplateGuard_condition: 'binding';
}</pre>
<p>The template type-checker will behave as if the expression bound to <code>condition</code> was asserted to be truthy within the template.</p> <h3 id="typing-the-directives-context"> Typing the directive's context </h3> <p>If your structural directive provides a context to the instantiated template, you can properly type it inside the template by providing a static <code>ngTemplateContextGuard</code> type assertion function. This function can use the type of the directive to derive the type of the context, which is useful when the type of the directive is generic.</p> <p>For the <code>SelectDirective</code> described above, you can implement an <code>ngTemplateContextGuard</code> to correctly specify the data type, even if the data source is generic.</p> <pre data-language="ts">// Declare an interface for the template context:
export interface SelectTemplateContext&lt;T&gt; {
  $implicit: T;
}

@Directive(...)
export class SelectDirective&lt;T&gt; {
  // The directive's generic type `T` will be inferred from the `DataSource` type
  // passed to the input.
  selectFrom = input.required&lt;DataSource&lt;T&gt;&gt;();

  // Narrow the type of the context using the generic type of the directive.
  static ngTemplateContextGuard&lt;T&gt;(dir: SelectDirective&lt;T&gt;, ctx: any): ctx is SelectTemplateContext&lt;T&gt; {
    // As before the guard body is not used at runtime, and included only to avoid
    // TypeScript errors.
    return true;
  }
}</pre><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/guide/directives/structural-directives" class="_attribution-link">https://angular.dev/guide/directives/structural-directives</a>
  </p>
</div>
