<h1>FormGroup</h1>
<router-outlet _ngcontent-ng-c1178817259></router-outlet><adev-main ngh="7"><router-outlet></router-outlet><adev-reference-page _nghost-ng-c972174807 ngh="6"><main _ngcontent-ng-c972174807 docsviewer class="docs-with-TOC" ngh="0"><div class="docs-api">
<header class="docs-reference-header"><section class="docs-reference-description"><p>Tracks the value and validity state of a group of <a href="formcontrol"><code>FormControl</code></a> instances.</p></section><nav class="docs-pill-row"><a class="docs-pill" href="../../guide/forms/reactive-forms#grouping-form-controls">Grouping form controls</a><a class="docs-pill" href="../../guide/forms/typed-forms#formgroup-and-formrecord">FormGroup and FormRecord</a></nav></header><div class="docs-reference-section docs-reference-api-section">
<h2 id="api" class="docs-reference-section-heading">API</h2>
<pre data-language="ts">class FormGroup&lt;TControl extends {[K in keyof TControl]: AbstractControl&lt;any&gt;} = any&gt; extends AbstractControl&lt;
  ɵTypedOrUntyped&lt;TControl, ɵFormGroupValue&lt;TControl&gt;, any&gt;,
  ɵTypedOrUntyped&lt;TControl, ɵFormGroupRawValue&lt;TControl&gt;, any&gt;,
  ɵTypedOrUntyped&lt;TControl, ɵFormGroupArgumentValue&lt;TControl&gt;, any&gt;
&gt; {
  constructor(controls: TControl, validatorOrOpts?: ValidatorFn | AbstractControlOptions | ValidatorFn[] | null | undefined, asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null | undefined): FormGroup&lt;TControl&gt;;
  controls: ɵTypedOrUntyped&lt;TControl, TControl, { [key: string]: AbstractControl&lt;any, any, any&gt;; }&gt;;
  registerControl&lt;K extends string &amp; keyof TControl&gt;(name: K, control: TControl[K]): TControl[K];
  registerControl(this: FormGroup&lt;{ [key: string]: AbstractControl&lt;any, any, any&gt;; }&gt;, name: string, control: AbstractControl&lt;any, any, any&gt;): AbstractControl&lt;any, any, any&gt;;
  addControl(this: FormGroup&lt;{ [key: string]: AbstractControl&lt;any, any, any&gt;; }&gt;, name: string, control: AbstractControl&lt;any, any, any&gt;, options?: { emitEvent?: boolean | undefined; } | undefined): void;
  addControl&lt;K extends string &amp; keyof TControl&gt;(name: K, control: Required&lt;TControl&gt;[K], options?: { emitEvent?: boolean | undefined; } | undefined): void;
  removeControl(this: FormGroup&lt;{ [key: string]: AbstractControl&lt;any, any, any&gt;; }&gt;, name: string, options?: { emitEvent?: boolean | undefined; } | undefined): void;
  removeControl&lt;S extends string&gt;(name: ɵOptionalKeys&lt;TControl&gt; &amp; S, options?: { emitEvent?: boolean | undefined; } | undefined): void;
  setControl&lt;K extends string &amp; keyof TControl&gt;(name: K, control: TControl[K], options?: { emitEvent?: boolean | undefined; } | undefined): void;
  setControl(this: FormGroup&lt;{ [key: string]: AbstractControl&lt;any, any, any&gt;; }&gt;, name: string, control: AbstractControl&lt;any, any, any&gt;, options?: { emitEvent?: boolean | undefined; } | undefined): void;
  contains&lt;K extends string&gt;(controlName: K): boolean;
  contains(this: FormGroup&lt;{ [key: string]: AbstractControl&lt;any, any, any&gt;; }&gt;, controlName: string): boolean;
  setValue(value: ɵIsAny&lt;TControl, { [key: string]: any; }, { [K in keyof TControl]: ɵRawValue&lt;TControl[K]&gt;; }&gt;, options?: { onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; }): void;
  patchValue(value: ɵIsAny&lt;TControl, { [key: string]: any; }, Partial&lt;{ [K in keyof TControl]: ɵValue&lt;TControl[K]&gt;; }&gt;&gt;, options?: { onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; }): void;
  reset(value?: ɵTypedOrUntyped&lt;TControl, ɵIsAny&lt;TControl, { [key: string]: any; }, Partial&lt;{ [K in keyof TControl]: ɵValue&lt;TControl[K]&gt; | FormControlState&lt;ɵValue&lt;TControl[K]&gt;&gt;; }&gt;&gt;, any&gt;, options?: { onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; overwriteDefaultValue?: boolean | undefined; }): void;
  getRawValue(): ɵTypedOrUntyped&lt;TControl, ɵIsAny&lt;TControl, { [key: string]: any; }, { [K in keyof TControl]: ɵRawValue&lt;TControl[K]&gt;; }&gt;, any&gt;;
  readonly override value: TValue;
  override get validator(): ValidatorFn | null;
  override get asyncValidator(): AsyncValidatorFn | null;
  override readonly parent: FormGroup&lt;any&gt; | FormArray&lt;any&gt; | null;
  override readonly status: FormControlStatus;
  override readonly valid: boolean;
  override readonly invalid: boolean;
  override readonly pending: boolean;
  override readonly disabled: boolean;
  override readonly enabled: boolean;
  readonly override errors: ValidationErrors | null;
  override readonly pristine: boolean;
  override readonly dirty: boolean;
  override readonly touched: boolean;
  override readonly untouched: boolean;
  readonly override events: any;
  readonly override valueChanges: Observable&lt;TValue&gt;;
  readonly override statusChanges: Observable&lt;FormControlStatus&gt;;
  override readonly updateOn: FormHooks;
  override setValidators(validators: ValidatorFn | ValidatorFn[] | null): void;
  override setAsyncValidators(validators: AsyncValidatorFn | AsyncValidatorFn[] | null): void;
  override addValidators(validators: ValidatorFn | ValidatorFn[]): void;
  override addAsyncValidators(validators: AsyncValidatorFn | AsyncValidatorFn[]): void;
  override removeValidators(validators: ValidatorFn | ValidatorFn[]): void;
  override removeAsyncValidators(validators: AsyncValidatorFn | AsyncValidatorFn[]): void;
  override hasValidator(validator: ValidatorFn): boolean;
  override hasAsyncValidator(validator: AsyncValidatorFn): boolean;
  override clearValidators(): void;
  override clearAsyncValidators(): void;
  override markAsTouched(opts?: { onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; } | undefined): void;
  override markAsTouched(opts?: { onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; sourceControl?: AbstractControl&lt;any, any, any&gt; | undefined; } | undefined): void;
  override markAllAsDirty(opts?: { emitEvent?: boolean | undefined; }): void;
  override markAllAsTouched(opts?: { emitEvent?: boolean | undefined; }): void;
  override markAsUntouched(opts?: { onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; } | undefined): void;
  override markAsUntouched(opts: { onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; sourceControl?: AbstractControl&lt;any, any, any&gt; | undefined; }): void;
  override markAsDirty(opts?: { onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; } | undefined): void;
  override markAsDirty(opts: { onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; sourceControl?: AbstractControl&lt;any, any, any&gt; | undefined; }): void;
  override markAsPristine(opts?: { onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; } | undefined): void;
  override markAsPristine(opts: { onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; sourceControl?: AbstractControl&lt;any, any, any&gt; | undefined; }): void;
  override markAsPending(opts?: { onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; } | undefined): void;
  override markAsPending(opts: { onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; sourceControl?: AbstractControl&lt;any, any, any&gt; | undefined; }): void;
  override disable(opts?: { onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; } | undefined): void;
  override disable(opts: { onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; sourceControl?: AbstractControl&lt;any, any, any&gt; | undefined; }): void;
  override enable(opts?: { onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; }): void;
  override setParent(parent: FormGroup&lt;any&gt; | FormArray&lt;any&gt; | null): void;
  override updateValueAndValidity(opts?: { onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; } | undefined): void;
  override updateValueAndValidity(opts: { onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; sourceControl?: AbstractControl&lt;any, any, any&gt; | undefined; }): void;
  override setErrors(errors: ValidationErrors | null, opts?: { emitEvent?: boolean | undefined; } | undefined): void;
  override setErrors(errors: ValidationErrors | null, opts?: { emitEvent?: boolean | undefined; shouldHaveEmitted?: boolean | undefined; } | undefined): void;
  override get&lt;P extends string | readonly (string | number)[]&gt;(path: P): AbstractControl&lt;ɵGetProperty&lt;TRawValue, P&gt;, ɵGetProperty&lt;TRawValue, P&gt;, any&gt; | null;
  override get&lt;P extends string | Array&lt;string | number&gt;&gt;(path: P): AbstractControl&lt;ɵGetProperty&lt;TRawValue, P&gt;, ɵGetProperty&lt;TRawValue, P&gt;, any&gt; | null;
  override getError(errorCode: string, path?: string | (string | number)[] | undefined): any;
  override hasError(errorCode: string, path?: string | (string | number)[] | undefined): boolean;
  override readonly root: AbstractControl&lt;any, any, any&gt;;
}</pre>
</div>
<div class="docs-reference-members"><div class="docs-reference-members">
<div id="constructor" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>constructor</h3>
<code><a href="formgroup">FormGroup</a>&lt;TControl&gt;</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition"><p>Creates a new <a href="formgroup"><code>FormGroup</code></a> instance.</p></div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">controls</span><code>TControl</code><div class="docs-parameter-description"><p>A collection of child controls. The key for each child is the name under which it is registered.</p></div>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">validatorOrOpts</span><code><a href="validatorfn">ValidatorFn</a> | <a href="abstractcontroloptions">AbstractControlOptions</a> | <a href="validatorfn">ValidatorFn</a>[] | null | undefined</code><div class="docs-parameter-description"><p>A synchronous validator function, or an array of such functions, or an <a href="abstractcontroloptions"><code>AbstractControlOptions</code></a> object that contains validation functions and a validation trigger.</p></div>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">asyncValidator</span><code><a href="asyncvalidatorfn">AsyncValidatorFn</a> | <a href="asyncvalidatorfn">AsyncValidatorFn</a>[] | null | undefined</code><div class="docs-parameter-description"><p>A single async validator or array of async validator functions</p></div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code><a href="formgroup">FormGroup</a>&lt;TControl&gt;</code>
</div>
</div></div>
</div>
<div id="controls" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>controls</h3>
<code>ɵTypedOrUntyped&lt;TControl, TControl, { [key: string]: <a href="abstractcontrol">AbstractControl</a>&lt;any, any, any&gt;; }&gt;</code></header>
</div>
<div id="registerControl" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>registerControl</h3>
<span>2 overloads</span></header><div class="docs-reference-card-body">
<div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Registers a control with the group's list of controls. In a strongly-typed group, the control must be in the group's type (possibly as an optional key).</p> <p>This method does not update the value or validity of the control. Use <a href="formgroup#addControl"><code>addControl</code></a> instead.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">name</span><code>K</code><div class="docs-parameter-description"><p>The control name to register in the collection</p></div>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">control</span><code>TControl[K]</code><div class="docs-parameter-description"><p>Provides the control for the given name</p></div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>TControl[K]</code>
</div>
</div>
<div class="docs-reference-card-item ">

<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">this</span><code><a href="formgroup">FormGroup</a>&lt;{ [key: string]: <a href="abstractcontrol">AbstractControl</a>&lt;any, any, any&gt;; }&gt;</code>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">name</span><code>string</code>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">control</span><code><a href="abstractcontrol">AbstractControl</a>&lt;any, any, any&gt;</code>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code><a href="abstractcontrol">AbstractControl</a>&lt;any, any, any&gt;</code>
</div>
</div>
</div>
</div>
<div id="addControl" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>addControl</h3>
<span>2 overloads</span></header><div class="docs-reference-card-body">
<div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Add a control to this group. In a strongly-typed group, the control must be in the group's type (possibly as an optional key).</p> <p>If a control with a given name already exists, it would <em>not</em> be replaced with a new one. If you want to replace an existing control, use the <a href="formgroup#setControl"><code>setControl</code></a> method instead. This method also updates the value and validity of the control.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">this</span><code><a href="formgroup">FormGroup</a>&lt;{ [key: string]: <a href="abstractcontrol">AbstractControl</a>&lt;any, any, any&gt;; }&gt;</code>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">name</span><code>string</code><div class="docs-parameter-description"><p>The control name to add to the collection</p></div>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">control</span><code><a href="abstractcontrol">AbstractControl</a>&lt;any, any, any&gt;</code><div class="docs-parameter-description"><p>Provides the control for the given name</p></div>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">options</span><code>{ emitEvent?: boolean | undefined; } | undefined</code><div class="docs-parameter-description">
<p>Specifies whether this FormGroup instance should emit events after a new control is added.</p> <ul class="docs-list"> <li>
<code>emitEvent</code>: When true or not supplied (the default), both the <code>statusChanges</code> and <code>valueChanges</code> observables emit events with the latest status and value when the control is added. When false, no events are emitted.</li> </ul>
</div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
<div class="docs-reference-card-item ">

<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">name</span><code>K</code>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">control</span><code>Required&lt;TControl&gt;[K]</code>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">options</span><code>{ emitEvent?: boolean | undefined; } | undefined</code>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
</div>
</div>
<div id="removeControl" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>removeControl</h3>
<span>2 overloads</span></header><div class="docs-reference-card-body">
<div class="docs-reference-card-item ">

<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">this</span><code><a href="formgroup">FormGroup</a>&lt;{ [key: string]: <a href="abstractcontrol">AbstractControl</a>&lt;any, any, any&gt;; }&gt;</code>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">name</span><code>string</code>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">options</span><code>{ emitEvent?: boolean | undefined; } | undefined</code>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
<div class="docs-reference-card-item ">

<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">name</span><code>ɵOptionalKeys&lt;TControl&gt; &amp; S</code>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">options</span><code>{ emitEvent?: boolean | undefined; } | undefined</code>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
</div>
</div>
<div id="setControl" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>setControl</h3>
<span>2 overloads</span></header><div class="docs-reference-card-body">
<div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Replace an existing control. In a strongly-typed group, the control must be in the group's type (possibly as an optional key).</p> <p>If a control with a given name does not exist in this <a href="formgroup"><code>FormGroup</code></a>, it will be added.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">name</span><code>K</code><div class="docs-parameter-description"><p>The control name to replace in the collection</p></div>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">control</span><code>TControl[K]</code><div class="docs-parameter-description"><p>Provides the control for the given name</p></div>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">options</span><code>{ emitEvent?: boolean | undefined; } | undefined</code><div class="docs-parameter-description">
<p>Specifies whether this FormGroup instance should emit events after an existing control is replaced.</p> <ul class="docs-list"> <li>
<code>emitEvent</code>: When true or not supplied (the default), both the <code>statusChanges</code> and <code>valueChanges</code> observables emit events with the latest status and value when the control is replaced with a new one. When false, no events are emitted.</li> </ul>
</div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
<div class="docs-reference-card-item ">

<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">this</span><code><a href="formgroup">FormGroup</a>&lt;{ [key: string]: <a href="abstractcontrol">AbstractControl</a>&lt;any, any, any&gt;; }&gt;</code>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">name</span><code>string</code>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">control</span><code><a href="abstractcontrol">AbstractControl</a>&lt;any, any, any&gt;</code>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">options</span><code>{ emitEvent?: boolean | undefined; } | undefined</code>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
</div>
</div>
<div id="contains" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>contains</h3>
<span>2 overloads</span></header><div class="docs-reference-card-body">
<div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Check whether there is an enabled control with the given name in the group.</p> <p>Reports false for disabled controls. If you'd like to check for existence in the group only, use <a href="abstractcontrol#get"><code>get</code></a> instead.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">controlName</span><code>K</code><div class="docs-parameter-description"><p>The control name to check for existence in the collection</p></div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>boolean</code>
</div>
</div>
<div class="docs-reference-card-item ">

<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">this</span><code><a href="formgroup">FormGroup</a>&lt;{ [key: string]: <a href="abstractcontrol">AbstractControl</a>&lt;any, any, any&gt;; }&gt;</code>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">controlName</span><code>string</code>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>boolean</code>
</div>
</div>
</div>
</div>
<div id="setValue" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>setValue</h3>
<code>void</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition"><p>Sets the value of the <a href="formgroup"><code>FormGroup</code></a>. It accepts an object that matches the structure of the group, with control names as keys.</p></div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">value</span><code>ɵIsAny&lt;TControl, { [key: string]: any; }, { [K in keyof TControl]: ɵRawValue&lt;TControl[K]&gt;; }&gt;</code><div class="docs-parameter-description"><p>The new value for the control that matches the structure of the group.</p></div>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">options</span><code>{ onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; }</code><div class="docs-parameter-description">
<p>Configuration options that determine how the control propagates changes and emits events after the value changes. The configuration options are passed to the <a href="abstractcontrol#updateValueAndValidity"><code>* updateValueAndValidity</code></a> method.</p> <ul class="docs-list"> <li>
<code>onlySelf</code>: When true, each change only affects this control, and not its parent. Default is false.</li> <li>
<code>emitEvent</code>: When true or not supplied (the default), both the <code>statusChanges</code> and <code>valueChanges</code> observables emit events with the latest status and value when the control value is updated. When false, no events are emitted.</li> </ul>
</div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
<div class="docs-usage-notes">
<span class="docs-usage-notes-heading">Usage notes</span><div> <h3 id="set-the-complete-value-for-the-form-group"> Set the complete value for the form group </h3> <pre data-language="ts">const form = new FormGroup({
  first: new FormControl(),
  last: new FormControl()
});

console.log(form.value);   // {first: null, last: null}

form.setValue({first: 'Nancy', last: 'Drew'});
console.log(form.value);   // {first: 'Nancy', last: 'Drew'}</pre>
</div>
</div>
</div></div>
</div>
<div id="patchValue" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>patchValue</h3>
<code>void</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Patches the value of the <a href="formgroup"><code>FormGroup</code></a>. It accepts an object with control names as keys, and does its best to match the values to the correct controls in the group.</p> <p>It accepts both super-sets and sub-sets of the group without throwing an error.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">value</span><code>ɵIsAny&lt;TControl, { [key: string]: any; }, Partial&lt;{ [K in keyof TControl]: ɵValue&lt;TControl[K]&gt;; }&gt;&gt;</code><div class="docs-parameter-description"><p>The object that matches the structure of the group.</p></div>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">options</span><code>{ onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; }</code><div class="docs-parameter-description">
<p>Configuration options that determine how the control propagates changes and emits events after the value is patched.</p> <ul class="docs-list"> <li>
<code>onlySelf</code>: When true, each change only affects this control and not its parent. Default is true.</li> <li>
<code>emitEvent</code>: When true or not supplied (the default), both the <code>statusChanges</code> and <code>valueChanges</code> observables emit events with the latest status and value when the control value is updated. When false, no events are emitted. The configuration options are passed to the <a href="abstractcontrol#updateValueAndValidity"><code>updateValueAndValidity</code></a> method.</li> </ul>
</div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
<div class="docs-usage-notes">
<span class="docs-usage-notes-heading">Usage notes</span><div> <h3 id="patch-the-value-for-a-form-group"> Patch the value for a form group </h3> <pre data-language="ts">const form = new FormGroup({
   first: new FormControl(),
   last: new FormControl()
});
console.log(form.value);   // {first: null, last: null}

form.patchValue({first: 'Nancy'});
console.log(form.value);   // {first: 'Nancy', last: null}</pre>
</div>
</div>
</div></div>
</div>
<div id="reset" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>reset</h3>
<code>void</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Resets the <a href="formgroup"><code>FormGroup</code></a>, marks all descendants <code>pristine</code> and <code>untouched</code> and sets the value of all descendants to their default values, or null if no defaults were provided.</p> <p>You reset to a specific form state by passing in a map of states that matches the structure of your form, with control names as keys. The state is a standalone value or a form state object with both a value and a disabled status.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">value</span><code>ɵTypedOrUntyped&lt;TControl, ɵIsAny&lt;TControl, { [key: string]: any; }, Partial&lt;{ [K in keyof TControl]: ɵValue&lt;TControl[K]&gt; | <a href="formcontrolstate">FormControlState</a>&lt;ɵValue&lt;TControl[K]&gt;&gt;; }&gt;&gt;, any&gt;</code><div class="docs-parameter-description"><p>Resets the control with an initial value, or an object that defines the initial value and disabled state.</p></div>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">options</span><code>{ onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; overwriteDefaultValue?: boolean | undefined; }</code><div class="docs-parameter-description">
<p>Configuration options that determine how the control propagates changes and emits events when the group is reset.</p> <ul class="docs-list"> <li>
<code>onlySelf</code>: When true, each change only affects this control, and not its parent. Default is false.</li> <li>
<code>emitEvent</code>: When true or not supplied (the default), both the <code>statusChanges</code> and <code>valueChanges</code> observables emit events with the latest status and value when the control is reset. When false, no events are emitted. The configuration options are passed to the <a href="abstractcontrol#updateValueAndValidity"><code>* updateValueAndValidity</code></a> method.</li> </ul>
</div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
<div class="docs-usage-notes">
<span class="docs-usage-notes-heading">Usage notes</span><div> <h3 id="reset-the-form-group-values"> Reset the form group values </h3> <pre data-language="ts">const form = new FormGroup({
  first: new FormControl('first name'),
  last: new FormControl('last name')
});

console.log(form.value);  // {first: 'first name', last: 'last name'}

form.reset({ first: 'name', last: 'last name' });

console.log(form.value);  // {first: 'name', last: 'last name'}</pre> <h3 id="reset-the-form-group-values-and-disabled-status"> Reset the form group values and disabled status </h3> <pre data-language="ts">const form = new FormGroup({
  first: new FormControl('first name'),
  last: new FormControl('last name')
});

form.reset({
  first: {value: 'name', disabled: true},
  last: 'last'
});

console.log(form.value);  // {last: 'last'}
console.log(form.get('first').status);  // 'DISABLED'</pre>
</div>
</div>
</div></div>
</div>
<div id="getRawValue" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>getRawValue</h3>
<code>ɵTypedOrUntyped&lt;TControl, ɵIsAny&lt;TControl, { [key: string]: any; }, { [K in keyof TControl]: ɵRawValue&lt;TControl[K]&gt;; }&gt;, any&gt;</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>The aggregate value of the <a href="formgroup"><code>FormGroup</code></a>, including any disabled controls.</p> <p>Retrieves all values regardless of disabled status.</p>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>ɵTypedOrUntyped&lt;TControl, ɵIsAny&lt;TControl, { [key: string]: any; }, { [K in keyof TControl]: ɵRawValue&lt;TControl[K]&gt;; }&gt;, any&gt;</code>
</div>
</div></div>
</div>
<div id="value" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>value</h3>
<code>TValue</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div>
<p>The current value of the control.</p> <ul class="docs-list"> <li>For a <a href="formcontrol"><code>FormControl</code></a>, the current value.</li> <li>For an enabled <a href="formgroup"><code>FormGroup</code></a>, the values of enabled controls as an object with a key-value pair for each member of the group.</li> <li>For a disabled <a href="formgroup"><code>FormGroup</code></a>, the values of all controls as an object with a key-value pair for each member of the group.</li> <li>For a <a href="formarray"><code>FormArray</code></a>, the values of enabled controls as an array.</li> </ul>
</div></div></div>
</div>
<div id="validator" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>validator</h3>
<code><a href="validatorfn">ValidatorFn</a> | null</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>Returns the function that is used to determine the validity of this control synchronously. If multiple validators have been added, this will be a single composed function. See <a href="validators#compose"><code>Validators.compose()</code></a> for additional information.</p></div></div></div>
</div>
<div id="validator" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>validator</h3>
<code><a href="validatorfn">ValidatorFn</a> | null</code></header>
</div>
<div id="asyncValidator" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>asyncValidator</h3>
<code><a href="asyncvalidatorfn">AsyncValidatorFn</a> | null</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>Returns the function that is used to determine the validity of this control asynchronously. If multiple validators have been added, this will be a single composed function. See <a href="validators#compose"><code>Validators.compose()</code></a> for additional information.</p></div></div></div>
</div>
<div id="asyncValidator" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>asyncValidator</h3>
<code><a href="asyncvalidatorfn">AsyncValidatorFn</a> | null</code></header>
</div>
<div id="parent" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>parent</h3>
<code><a href="formgroup">FormGroup</a>&lt;any&gt; | <a href="formarray">FormArray</a>&lt;any&gt; | null</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>The parent control.</p></div></div></div>
</div>
<div id="status" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>status</h3>
<code><a href="formcontrolstatus">FormControlStatus</a></code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>The validation status of the control.</p></div></div></div>
</div>
<div id="valid" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>valid</h3>
<code>boolean</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>A control is <code>valid</code> when its <code>status</code> is <code>VALID</code>.</p></div></div></div>
</div>
<div id="invalid" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>invalid</h3>
<code>boolean</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>A control is <code>invalid</code> when its <code>status</code> is <code>INVALID</code>.</p></div></div></div>
</div>
<div id="pending" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>pending</h3>
<code>boolean</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>A control is <code>pending</code> when its <code>status</code> is <code>PENDING</code>.</p></div></div></div>
</div>
<div id="disabled" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>disabled</h3>
<code>boolean</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div>
<p>A control is <code>disabled</code> when its <code>status</code> is <code>DISABLED</code>.</p> <p>Disabled controls are exempt from validation checks and are not included in the aggregate value of their ancestor controls.</p>
</div></div></div>
</div>
<div id="enabled" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>enabled</h3>
<code>boolean</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>A control is <code>enabled</code> as long as its <code>status</code> is not <code>DISABLED</code>.</p></div></div></div>
</div>
<div id="errors" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>errors</h3>
<code><a href="validationerrors">ValidationErrors</a> | null</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>An object containing any errors generated by failing validation, or null if there are no errors.</p></div></div></div>
</div>
<div id="pristine" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>pristine</h3>
<code>boolean</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>A control is <code>pristine</code> if the user has not yet changed the value in the UI.</p></div></div></div>
</div>
<div id="dirty" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>dirty</h3>
<code>boolean</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>A control is <code>dirty</code> if the user has changed the value in the UI.</p></div></div></div>
</div>
<div id="touched" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>touched</h3>
<code>boolean</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div>
<p>True if the control is marked as <code>touched</code>.</p> <p>A control is marked <code>touched</code> once the user has triggered a <code>blur</code> event on it.</p>
</div></div></div>
</div>
<div id="untouched" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>untouched</h3>
<code>boolean</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div>
<p>True if the control has not been marked as touched</p> <p>A control is <code>untouched</code> if the user has not yet triggered a <code>blur</code> event on it.</p>
</div></div></div>
</div>
<div id="events" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>events</h3>
<code>any</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div>
<p>A multicasting observable that emits an event every time the state of the control changes. It emits for value, status, pristine or touched changes.</p> <p><strong>Note</strong>: On value change, the emit happens right after a value of this control is updated. The value of a parent control (for example if this FormControl is a part of a FormGroup) is updated later, so accessing a value of a parent control (using the <code>value</code> property) from the callback of this event might result in getting a value that has not been updated yet. Subscribe to the <code>events</code> of the parent control instead. For other event types, the events are emitted after the parent control has been updated.</p>
</div></div></div>
</div>
<div id="valueChanges" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>valueChanges</h3>
<code>Observable&lt;TValue&gt;</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div>
<p>A multicasting observable that emits an event every time the value of the control changes, in the UI or programmatically. It also emits an event each time you call enable() or disable() without passing along {emitEvent: false} as a function argument.</p> <p><strong>Note</strong>: the emit happens right after a value of this control is updated. The value of a parent control (for example if this FormControl is a part of a FormGroup) is updated later, so accessing a value of a parent control (using the <code>value</code> property) from the callback of this event might result in getting a value that has not been updated yet. Subscribe to the <code>valueChanges</code> event of the parent control instead.</p>
</div></div></div>
</div>
<div id="statusChanges" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>statusChanges</h3>
<code>Observable&lt;<a href="formcontrolstatus">FormControlStatus</a>&gt;</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>A multicasting observable that emits an event every time the validation <code>status</code> of the control recalculates.</p></div></div></div>
</div>
<div id="updateOn" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>updateOn</h3>
<code>FormHooks</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>Reports the update strategy of the <a href="abstractcontrol"><code>AbstractControl</code></a> (meaning the event on which the control updates itself). Possible values: <code>'change'</code> | <code>'blur'</code> | <code>'submit'</code> Default value: <code>'change'</code></p></div></div></div>
</div>
<div id="setValidators" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>setValidators</h3>
<code>void</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Sets the synchronous validators that are active on this control. Calling this overwrites any existing synchronous validators.</p> <p>When you add or remove a validator at run time, you must call <code>updateValueAndValidity()</code> for the new validation to take effect.</p> <p>If you want to add a new validator without affecting existing ones, consider using <code>addValidators()</code> method instead.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">validators</span><code><a href="validatorfn">ValidatorFn</a> | <a href="validatorfn">ValidatorFn</a>[] | null</code>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div></div>
</div>
<div id="setAsyncValidators" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>setAsyncValidators</h3>
<code>void</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Sets the asynchronous validators that are active on this control. Calling this overwrites any existing asynchronous validators.</p> <p>When you add or remove a validator at run time, you must call <code>updateValueAndValidity()</code> for the new validation to take effect.</p> <p>If you want to add a new validator without affecting existing ones, consider using <code>addAsyncValidators()</code> method instead.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">validators</span><code><a href="asyncvalidatorfn">AsyncValidatorFn</a> | <a href="asyncvalidatorfn">AsyncValidatorFn</a>[] | null</code>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div></div>
</div>
<div id="addValidators" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>addValidators</h3>
<code>void</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Add a synchronous validator or validators to this control, without affecting other validators.</p> <p>When you add or remove a validator at run time, you must call <code>updateValueAndValidity()</code> for the new validation to take effect.</p> <p>Adding a validator that already exists will have no effect. If duplicate validator functions are present in the <code>validators</code> array, only the first instance would be added to a form control.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">validators</span><code><a href="validatorfn">ValidatorFn</a> | <a href="validatorfn">ValidatorFn</a>[]</code><div class="docs-parameter-description"><p>The new validator function or functions to add to this control.</p></div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div></div>
</div>
<div id="addAsyncValidators" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>addAsyncValidators</h3>
<code>void</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Add an asynchronous validator or validators to this control, without affecting other validators.</p> <p>When you add or remove a validator at run time, you must call <code>updateValueAndValidity()</code> for the new validation to take effect.</p> <p>Adding a validator that already exists will have no effect.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">validators</span><code><a href="asyncvalidatorfn">AsyncValidatorFn</a> | <a href="asyncvalidatorfn">AsyncValidatorFn</a>[]</code><div class="docs-parameter-description"><p>The new asynchronous validator function or functions to add to this control.</p></div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div></div>
</div>
<div id="removeValidators" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>removeValidators</h3>
<code>void</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition"><p>Remove a synchronous validator from this control, without affecting other validators. Validators are compared by function reference; you must pass a reference to the exact same validator function as the one that was originally set. If a provided validator is not found, it is ignored.</p></div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">validators</span><code><a href="validatorfn">ValidatorFn</a> | <a href="validatorfn">ValidatorFn</a>[]</code><div class="docs-parameter-description"><p>The validator or validators to remove.</p></div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
<div class="docs-usage-notes">
<span class="docs-usage-notes-heading">Usage notes</span><div> <h3 id="reference-to-a-validatorfn"> Reference to a ValidatorFn </h3> <pre data-language="ts">// Reference to the RequiredValidator
const ctrl = new FormControl&lt;string | null&gt;('', Validators.required);
ctrl.removeValidators(Validators.required);

// Reference to anonymous function inside MinValidator
const minValidator = Validators.min(3);
const ctrl = new FormControl&lt;string | null&gt;('', minValidator);
expect(ctrl.hasValidator(minValidator)).toEqual(true)
expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)

ctrl.removeValidators(minValidator);</pre>
<p>When you add or remove a validator at run time, you must call <code>updateValueAndValidity()</code> for the new validation to take effect.</p> </div>
</div>
</div></div>
</div>
<div id="removeAsyncValidators" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>removeAsyncValidators</h3>
<code>void</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Remove an asynchronous validator from this control, without affecting other validators. Validators are compared by function reference; you must pass a reference to the exact same validator function as the one that was originally set. If a provided validator is not found, it is ignored.</p> <p>When you add or remove a validator at run time, you must call <code>updateValueAndValidity()</code> for the new validation to take effect.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">validators</span><code><a href="asyncvalidatorfn">AsyncValidatorFn</a> | <a href="asyncvalidatorfn">AsyncValidatorFn</a>[]</code><div class="docs-parameter-description"><p>The asynchronous validator or validators to remove.</p></div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div></div>
</div>
<div id="hasValidator" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>hasValidator</h3>
<code>boolean</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition"><p>Check whether a synchronous validator function is present on this control. The provided validator must be a reference to the exact same function that was provided.</p></div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">validator</span><code><a href="validatorfn">ValidatorFn</a></code><div class="docs-parameter-description"><p>The validator to check for presence. Compared by function reference.</p></div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>boolean</code>
</div>
<div class="docs-usage-notes">
<span class="docs-usage-notes-heading">Usage notes</span><div> <h3 id="reference-to-a-validatorfn"> Reference to a ValidatorFn </h3> <pre data-language="ts">// Reference to the RequiredValidator
const ctrl = new FormControl&lt;number | null&gt;(0, Validators.required);
expect(ctrl.hasValidator(Validators.required)).toEqual(true)

// Reference to anonymous function inside MinValidator
const minValidator = Validators.min(3);
const ctrl = new FormControl&lt;number | null&gt;(0, minValidator);
expect(ctrl.hasValidator(minValidator)).toEqual(true)
expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)</pre>
</div>
</div>
</div></div>
</div>
<div id="hasAsyncValidator" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>hasAsyncValidator</h3>
<code>boolean</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition"><p>Check whether an asynchronous validator function is present on this control. The provided validator must be a reference to the exact same function that was provided.</p></div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">validator</span><code><a href="asyncvalidatorfn">AsyncValidatorFn</a></code><div class="docs-parameter-description"><p>The asynchronous validator to check for presence. Compared by function reference.</p></div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>boolean</code>
</div>
</div></div>
</div>
<div id="clearValidators" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>clearValidators</h3>
<code>void</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Empties out the synchronous validator list.</p> <p>When you add or remove a validator at run time, you must call <code>updateValueAndValidity()</code> for the new validation to take effect.</p>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div></div>
</div>
<div id="clearAsyncValidators" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>clearAsyncValidators</h3>
<code>void</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Empties out the async validator list.</p> <p>When you add or remove a validator at run time, you must call <code>updateValueAndValidity()</code> for the new validation to take effect.</p>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div></div>
</div>
<div id="markAsTouched" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>markAsTouched</h3>
<span>2 overloads</span></header><div class="docs-reference-card-body">
<div class="docs-reference-card-item ">
<div class="docs-function-definition"><p>Marks the control as <code>touched</code>. A control is touched by focus and blur events that do not change the value.</p></div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">opts</span><code>{ onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; } | undefined</code><div class="docs-parameter-description">
<p>Configuration options that determine how the control propagates changes and emits events after marking is applied.</p> <ul class="docs-list"> <li>
<code>onlySelf</code>: When true, mark only this control. When false or not supplied, marks all direct ancestors. Default is false.</li> <li>
<code>emitEvent</code>: When true or not supplied (the default), the <code>events</code> observable emits a <a href="touchedchangeevent"><code>TouchedChangeEvent</code></a> with the <code>touched</code> property being <code>true</code>. When false, no events are emitted.</li> </ul>
</div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
<div class="docs-reference-card-item ">

<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">opts</span><code>{ onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; sourceControl?: <a href="abstractcontrol">AbstractControl</a>&lt;any, any, any&gt; | undefined; } | undefined</code>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
</div>
</div>
<div id="markAllAsDirty" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>markAllAsDirty</h3>
<code>void</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition"><p>Marks the control and all its descendant controls as <code>dirty</code>.</p></div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">opts</span><code>{ emitEvent?: boolean | undefined; }</code><div class="docs-parameter-description">
<p>Configuration options that determine how the control propagates changes and emits events after marking is applied.</p> <ul class="docs-list"> <li>
<code>emitEvent</code>: When true or not supplied (the default), the <code>events</code> observable emits a <a href="pristinechangeevent"><code>PristineChangeEvent</code></a> with the <code>pristine</code> property being <code>false</code>. When false, no events are emitted.</li> </ul>
</div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div></div>
</div>
<div id="markAllAsTouched" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>markAllAsTouched</h3>
<code>void</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition"><p>Marks the control and all its descendant controls as <code>touched</code>.</p></div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">opts</span><code>{ emitEvent?: boolean | undefined; }</code><div class="docs-parameter-description">
<p>Configuration options that determine how the control propagates changes and emits events after marking is applied.</p> <ul class="docs-list"> <li>
<code>emitEvent</code>: When true or not supplied (the default), the <code>events</code> observable emits a <a href="touchedchangeevent"><code>TouchedChangeEvent</code></a> with the <code>touched</code> property being <code>true</code>. When false, no events are emitted.</li> </ul>
</div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div></div>
</div>
<div id="markAsUntouched" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>markAsUntouched</h3>
<span>2 overloads</span></header><div class="docs-reference-card-body">
<div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Marks the control as <code>untouched</code>.</p> <p>If the control has any children, also marks all children as <code>untouched</code> and recalculates the <code>touched</code> status of all parent controls.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">opts</span><code>{ onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; } | undefined</code><div class="docs-parameter-description">
<p>Configuration options that determine how the control propagates changes and emits events after the marking is applied.</p> <ul class="docs-list"> <li>
<code>onlySelf</code>: When true, mark only this control. When false or not supplied, marks all direct ancestors. Default is false.</li> <li>
<code>emitEvent</code>: When true or not supplied (the default), the <code>events</code> observable emits a <a href="touchedchangeevent"><code>TouchedChangeEvent</code></a> with the <code>touched</code> property being <code>false</code>. When false, no events are emitted.</li> </ul>
</div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
<div class="docs-reference-card-item ">

<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">opts</span><code>{ onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; sourceControl?: <a href="abstractcontrol">AbstractControl</a>&lt;any, any, any&gt; | undefined; }</code>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
</div>
</div>
<div id="markAsDirty" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>markAsDirty</h3>
<span>2 overloads</span></header><div class="docs-reference-card-body">
<div class="docs-reference-card-item ">
<div class="docs-function-definition"><p>Marks the control as <code>dirty</code>. A control becomes dirty when the control's value is changed through the UI; compare <code>markAsTouched</code>.</p></div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">opts</span><code>{ onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; } | undefined</code><div class="docs-parameter-description">
<p>Configuration options that determine how the control propagates changes and emits events after marking is applied.</p> <ul class="docs-list"> <li>
<code>onlySelf</code>: When true, mark only this control. When false or not supplied, marks all direct ancestors. Default is false.</li> <li>
<code>emitEvent</code>: When true or not supplied (the default), the <code>events</code> observable emits a <a href="pristinechangeevent"><code>PristineChangeEvent</code></a> with the <code>pristine</code> property being <code>false</code>. When false, no events are emitted.</li> </ul>
</div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
<div class="docs-reference-card-item ">

<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">opts</span><code>{ onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; sourceControl?: <a href="abstractcontrol">AbstractControl</a>&lt;any, any, any&gt; | undefined; }</code>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
</div>
</div>
<div id="markAsPristine" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>markAsPristine</h3>
<span>2 overloads</span></header><div class="docs-reference-card-body">
<div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Marks the control as <code>pristine</code>.</p> <p>If the control has any children, marks all children as <code>pristine</code>, and recalculates the <code>pristine</code> status of all parent controls.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">opts</span><code>{ onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; } | undefined</code><div class="docs-parameter-description">
<p>Configuration options that determine how the control emits events after marking is applied.</p> <ul class="docs-list"> <li>
<code>onlySelf</code>: When true, mark only this control. When false or not supplied, marks all direct ancestors. Default is false.</li> <li>
<code>emitEvent</code>: When true or not supplied (the default), the <code>events</code> observable emits a <a href="pristinechangeevent"><code>PristineChangeEvent</code></a> with the <code>pristine</code> property being <code>true</code>. When false, no events are emitted.</li> </ul>
</div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
<div class="docs-reference-card-item ">

<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">opts</span><code>{ onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; sourceControl?: <a href="abstractcontrol">AbstractControl</a>&lt;any, any, any&gt; | undefined; }</code>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
</div>
</div>
<div id="markAsPending" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>markAsPending</h3>
<span>2 overloads</span></header><div class="docs-reference-card-body">
<div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Marks the control as <code>pending</code>.</p> <p>A control is pending while the control performs async validation.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">opts</span><code>{ onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; } | undefined</code><div class="docs-parameter-description">
<p>Configuration options that determine how the control propagates changes and emits events after marking is applied.</p> <ul class="docs-list"> <li>
<code>onlySelf</code>: When true, mark only this control. When false or not supplied, marks all direct ancestors. Default is false.</li> <li>
<code>emitEvent</code>: When true or not supplied (the default), the <code>statusChanges</code> observable emits an event with the latest status the control is marked pending and the <code>events</code> observable emits a <a href="statuschangeevent"><code>StatusChangeEvent</code></a> with the <code>status</code> property being <code>PENDING</code> When false, no events are emitted.</li> </ul>
</div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
<div class="docs-reference-card-item ">

<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">opts</span><code>{ onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; sourceControl?: <a href="abstractcontrol">AbstractControl</a>&lt;any, any, any&gt; | undefined; }</code>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
</div>
</div>
<div id="disable" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>disable</h3>
<span>2 overloads</span></header><div class="docs-reference-card-body">
<div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Disables the control. This means the control is exempt from validation checks and excluded from the aggregate value of any parent. Its status is <code>DISABLED</code>.</p> <p>If the control has children, all children are also disabled.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">opts</span><code>{ onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; } | undefined</code><div class="docs-parameter-description">
<p>Configuration options that determine how the control propagates changes and emits events after the control is disabled.</p> <ul class="docs-list"> <li>
<code>onlySelf</code>: When true, mark only this control. When false or not supplied, marks all direct ancestors. Default is false.</li> <li>
<code>emitEvent</code>: When true or not supplied (the default), the <code>statusChanges</code>, <code>valueChanges</code> and <code>events</code> observables emit events with the latest status and value when the control is disabled. When false, no events are emitted.</li> </ul>
</div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
<div class="docs-reference-card-item ">

<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">opts</span><code>{ onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; sourceControl?: <a href="abstractcontrol">AbstractControl</a>&lt;any, any, any&gt; | undefined; }</code>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
</div>
</div>
<div id="enable" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>enable</h3>
<code>void</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Enables the control. This means the control is included in validation checks and the aggregate value of its parent. Its status recalculates based on its value and its validators.</p> <p>By default, if the control has children, all children are enabled.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">opts</span><code>{ onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; }</code><div class="docs-parameter-description">
<p>Configure options that control how the control propagates changes and emits events when marked as untouched</p> <ul class="docs-list"> <li>
<code>onlySelf</code>: When true, mark only this control. When false or not supplied, marks all direct ancestors. Default is false.</li> <li>
<code>emitEvent</code>: When true or not supplied (the default), the <code>statusChanges</code>, <code>valueChanges</code> and <code>events</code> observables emit events with the latest status and value when the control is enabled. When false, no events are emitted.</li> </ul>
</div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div></div>
</div>
<div id="setParent" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>setParent</h3>
<code>void</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition"><p>Sets the parent of the control</p></div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">parent</span><code><a href="formgroup">FormGroup</a>&lt;any&gt; | <a href="formarray">FormArray</a>&lt;any&gt; | null</code><div class="docs-parameter-description"><p>The new parent.</p></div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div></div>
</div>
<div id="updateValueAndValidity" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>updateValueAndValidity</h3>
<span>2 overloads</span></header><div class="docs-reference-card-body">
<div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Recalculates the value and validation status of the control.</p> <p>By default, it also updates the value and validity of its ancestors.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">opts</span><code>{ onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; } | undefined</code><div class="docs-parameter-description">
<p>Configuration options determine how the control propagates changes and emits events after updates and validity checks are applied.</p> <ul class="docs-list"> <li>
<code>onlySelf</code>: When true, only update this control. When false or not supplied, update all direct ancestors. Default is false.</li> <li>
<code>emitEvent</code>: When true or not supplied (the default), the <code>statusChanges</code>, <code>valueChanges</code> and <code>events</code> observables emit events with the latest status and value when the control is updated. When false, no events are emitted.</li> </ul>
</div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
<div class="docs-reference-card-item ">

<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">opts</span><code>{ onlySelf?: boolean | undefined; emitEvent?: boolean | undefined; sourceControl?: <a href="abstractcontrol">AbstractControl</a>&lt;any, any, any&gt; | undefined; }</code>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
</div>
</div>
<div id="setErrors" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>setErrors</h3>
<span>2 overloads</span></header><div class="docs-reference-card-body">
<div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Sets errors on a form control when running validations manually, rather than automatically.</p> <p>Calling <code>setErrors</code> also updates the validity of the parent control.</p> <p>Note: Manually set errors are always overwritten by the results of the next validation run.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">errors</span><code><a href="validationerrors">ValidationErrors</a> | null</code>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">opts</span><code>{ emitEvent?: boolean | undefined; } | undefined</code><div class="docs-parameter-description">
<p>Configuration options that determine how the control propagates changes and emits events after the control errors are set.</p> <ul class="docs-list"> <li>
<code>emitEvent</code>: When true or not supplied (the default), the <code>statusChanges</code> observable emits an event after the errors are set.</li> </ul>
</div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
<div class="docs-usage-notes">
<span class="docs-usage-notes-heading">Usage notes</span><div> <h3 id="manually-set-the-errors-for-a-control"> Manually set the errors for a control </h3> <pre data-language="ts">const login = new FormControl('someLogin');
login.setErrors({
  notUnique: true
});

expect(login.valid).toEqual(false);
expect(login.errors).toEqual({ notUnique: true });

login.setValue('someOtherLogin');

expect(login.valid).toEqual(true);</pre>
</div>
</div>
</div>
<div class="docs-reference-card-item ">

<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">errors</span><code><a href="validationerrors">ValidationErrors</a> | null</code>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">opts</span><code>{ emitEvent?: boolean | undefined; shouldHaveEmitted?: boolean | undefined; } | undefined</code>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>void</code>
</div>
</div>
</div>
</div>
<div id="get" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>get</h3>
<span>2 overloads</span></header><div class="docs-reference-card-body">
<div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Retrieves a child control given the control's name or path.</p> <p>This signature for get supports strings and <code>const</code> arrays (<code>.get(['foo', 'bar'] as const)</code>).</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">path</span><code>P</code>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code><a href="abstractcontrol">AbstractControl</a>&lt;ɵGetProperty&lt;TRawValue, P&gt;, ɵGetProperty&lt;TRawValue, P&gt;, any&gt; | null</code>
</div>
</div>
<div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>Retrieves a child control given the control's name or path.</p> <p>This signature for <code>get</code> supports non-const (mutable) arrays. Inferred type information will not be as robust, so prefer to pass a <code>readonly</code> array if possible.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">path</span><code>P</code>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code><a href="abstractcontrol">AbstractControl</a>&lt;ɵGetProperty&lt;TRawValue, P&gt;, ɵGetProperty&lt;TRawValue, P&gt;, any&gt; | null</code>
</div>
</div>
</div>
</div>
<div id="getError" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>getError</h3>
<code>any</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition"><p>Reports error data for the control with the given path.</p></div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">errorCode</span><code>string</code><div class="docs-parameter-description"><p>The code of the error to check</p></div>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">path</span><code>string | (string | number)[] | undefined</code><div class="docs-parameter-description"><p>A list of control names that designates how to move from the current control to the control that should be queried for errors.</p></div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>any</code>
</div>
<div class="docs-usage-notes">
<span class="docs-usage-notes-heading">Usage notes</span><div>
<p>For example, for the following <a href="formgroup"><code>FormGroup</code></a>:</p> <pre data-language="ts">form = new FormGroup({
  address: new FormGroup({ street: new FormControl() })
});</pre>
<p>The path to the 'street' control from the root form would be 'address' -&gt; 'street'.</p> <p>It can be provided to this method in one of two formats:</p> <ol class="docs-ordered-list"> <li>An array of string control names, e.g. <code>['address', 'street']</code>
</li> <li>A period-delimited list of control names in one string, e.g. <code>'address.street'</code>
</li> </ol> </div>
</div>
</div></div>
</div>
<div id="hasError" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>hasError</h3>
<code>boolean</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition"><p>Reports whether the control with the given path has the error specified.</p></div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">errorCode</span><code>string</code><div class="docs-parameter-description"><p>The code of the error to check</p></div>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">path</span><code>string | (string | number)[] | undefined</code><div class="docs-parameter-description"><p>A list of control names that designates how to move from the current control to the control that should be queried for errors.</p></div>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>boolean</code>
</div>
<div class="docs-usage-notes">
<span class="docs-usage-notes-heading">Usage notes</span><div>
<p>For example, for the following <a href="formgroup"><code>FormGroup</code></a>:</p> <pre data-language="ts">form = new FormGroup({
  address: new FormGroup({ street: new FormControl() })
});</pre>
<p>The path to the 'street' control from the root form would be 'address' -&gt; 'street'.</p> <p>It can be provided to this method in one of two formats:</p> <ol class="docs-ordered-list"> <li>An array of string control names, e.g. <code>['address', 'street']</code>
</li> <li>A period-delimited list of control names in one string, e.g. <code>'address.street'</code>
</li> </ol> <p>If no path is given, this method checks for the error on the current control.</p> </div>
</div>
</div></div>
</div>
<div id="root" class="docs-reference-member-card">
<header class="docs-reference-card-header"><h3>root</h3>
<code><a href="abstractcontrol">AbstractControl</a>&lt;any, any, any&gt;</code></header><div class="docs-reference-card-body"><div class="docs-reference-card-item"><div><p>Retrieves the top-level ancestor of this control.</p></div></div></div>
</div>
</div></div>
<div class="docs-reference-section">
<h2 id="description" class="docs-reference-section-heading">Description</h2>
<div>
<p>Tracks the value and validity state of a group of <a href="formcontrol"><code>FormControl</code></a> instances.</p> <p>A <a href="formgroup"><code>FormGroup</code></a> aggregates the values of each child <a href="formcontrol"><code>FormControl</code></a> into one object, with each control name as the key. It calculates its status by reducing the status values of its children. For example, if one of the controls in a group is invalid, the entire group becomes invalid.</p> <p><a href="formgroup"><code>FormGroup</code></a> is one of the four fundamental building blocks used to define forms in Angular, along with <a href="formcontrol"><code>FormControl</code></a>, <a href="formarray"><code>FormArray</code></a>, and <a href="formrecord"><code>FormRecord</code></a>.</p> <p>When instantiating a <a href="formgroup"><code>FormGroup</code></a>, pass in a collection of child controls as the first argument. The key for each child registers the name for the control.</p> <p><a href="formgroup"><code>FormGroup</code></a> is intended for use cases where the keys are known ahead of time. If you need to dynamically add and remove controls, use <a href="formrecord"><code>FormRecord</code></a> instead.</p> <p><a href="formgroup"><code>FormGroup</code></a> accepts an optional type parameter <code>TControl</code>, which is an object type with inner control types as values.</p>
</div>
</div>
<div class="docs-reference-section">
<h2 id="usage-notes" class="docs-reference-section-heading">Usage Notes</h2>
<div> <h3 id="create-a-form-group-with-2-controls"> Create a form group with 2 controls </h3> <pre data-language="ts">const form = new FormGroup({
  first: new FormControl('Nancy', Validators.minLength(2)),
  last: new FormControl('Drew'),
});

console.log(form.value);   // {first: 'Nancy', last; 'Drew'}
console.log(form.status);  // 'VALID'</pre> <h3 id="the-type-argument-and-optional-controls"> The type argument, and optional controls </h3> <p><a href="formgroup"><code>FormGroup</code></a> accepts one generic argument, which is an object containing its inner controls. This type will usually be inferred automatically, but you can always specify it explicitly if you wish.</p> <p>If you have controls that are optional (i.e. they can be removed, you can use the <code>?</code> in the type):</p> <pre data-language="ts">const form = new FormGroup&lt;{
  first: FormControl&lt;string|null&gt;,
  middle?: FormControl&lt;string|null&gt;, // Middle name is optional.
  last: FormControl&lt;string|null&gt;,
}&gt;({
  first: new FormControl('Nancy'),
  last: new FormControl('Drew'),
});</pre> <h3 id="create-a-form-group-with-a-group-level-validator"> Create a form group with a group-level validator </h3> <p>You include group-level validators as the second arg, or group-level async validators as the third arg. These come in handy when you want to perform validation that considers the value of more than one child control.</p> <pre data-language="ts">const form = new FormGroup({
  password: new FormControl('', Validators.minLength(2)),
  passwordConfirm: new FormControl('', Validators.minLength(2)),
}, passwordMatchValidator);


function passwordMatchValidator(g: FormGroup) {
   return g.get('password').value === g.get('passwordConfirm').value
      ? null : {'mismatch': true};
}</pre>
<p>Like <a href="formcontrol"><code>FormControl</code></a> instances, you choose to pass in validators and async validators as part of an options object.</p> <pre data-language="ts">const form = new FormGroup({
  password: new FormControl('')
  passwordConfirm: new FormControl('')
}, { validators: passwordMatchValidator, asyncValidators: otherValidator });</pre> <h3 id="set-the-updateon-property-for-all-controls-in-a-form-group"> Set the updateOn property for all controls in a form group </h3> <p>The options object is used to set a default value for each child control's <code>updateOn</code> property. If you set <code>updateOn</code> to <code>'blur'</code> at the group level, all child controls default to 'blur', unless the child has explicitly specified a different <code>updateOn</code> value.</p> <pre data-language="ts">const c = new FormGroup({
  one: new FormControl()
}, { updateOn: 'blur' });</pre> <h3 id="using-a-formgroup-with-optional-controls"> Using a FormGroup with optional controls </h3> <p>It is possible to have optional controls in a FormGroup. An optional control can be removed later using <code>removeControl</code>, and can be omitted when calling <code>reset</code>. Optional controls must be declared optional in the group's type.</p> <pre data-language="ts">const c = new FormGroup&lt;{one?: FormControl&lt;string&gt;}&gt;({
  one: new FormControl('')
});</pre>
<p>Notice that <code>c.value.one</code> has type <code>string|null|undefined</code>. This is because calling <code>c.reset({})</code> without providing the optional key <code>one</code> will cause it to become <code>null</code>.</p> </div>
</div>
</div></main></adev-reference-page></adev-main><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/api/forms/FormGroup" class="_attribution-link">https://angular.dev/api/forms/FormGroup</a>
  </p>
</div>
