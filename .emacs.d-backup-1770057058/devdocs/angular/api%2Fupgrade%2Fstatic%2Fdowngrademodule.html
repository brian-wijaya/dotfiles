<h1>downgradeModule</h1>
<router-outlet _ngcontent-ng-c1178817259></router-outlet><adev-main ngh="7"><router-outlet></router-outlet><adev-reference-page _nghost-ng-c972174807 ngh="6"><main _ngcontent-ng-c972174807 docsviewer class="docs-with-TOC" ngh="0"><div class="docs-api">
<header class="docs-reference-header"><section class="docs-reference-description"><p>A helper function for creating an AngularJS module that can bootstrap an Angular module "on-demand" (possibly lazily) when a <a href="downgradecomponent"><code>downgraded component</code></a> needs to be instantiated.</p></section></header><div class="docs-reference-section docs-reference-api-section">
<h2 id="api" class="docs-reference-section-heading">API</h2>
<pre data-language="ts">function downgradeModule&lt;T&gt;(
  moduleOrBootstrapFn:
    | Type&lt;T&gt;
    | ((extraProviders: StaticProvider[]) =&gt; Promise&lt;NgModuleRef&lt;T&gt;&gt;),
): string;
function downgradeModule&lt;T&gt;(moduleOrBootstrapFn: NgModuleFactory&lt;T&gt;): string;</pre>
</div>
<div class="docs-reference-members">
<div id="downgradeModule_0" class="docs-reference-member-card">
<header class="docs-reference-card-header"><pre data-language="ts">function downgradeModule&lt;T&gt;(moduleOrBootstrapFn: Type&lt;T&gt; | ((extraProviders: StaticProvider[]) =&gt; Promise&lt;NgModuleRef&lt;T&gt;&gt;)): string;</pre></header><div class="docs-reference-card-body"><div class="docs-reference-card-item ">
<div class="docs-function-definition">
<p>A helper function for creating an AngularJS module that can bootstrap an Angular module "on-demand" (possibly lazily) when a <a href="downgradecomponent"><code>downgraded component</code></a> needs to be instantiated.</p> <p><em>Part of the <a href="../../../api?query=upgrade/static">upgrade/static</a> library for hybrid upgrade apps that support AOT compilation.</em></p> <p>It allows loading/bootstrapping the Angular part of a hybrid application lazily and not having to pay the cost up-front. For example, you can have an AngularJS application that uses Angular for specific routes and only instantiate the Angular modules if/when the user visits one of these routes.</p> <p>The Angular module will be bootstrapped once (when requested for the first time) and the same reference will be used from that point onwards.</p> <p><a href="downgrademodule"><code>downgradeModule()</code></a> requires either an <a href="../../core/ngmodulefactory"><code>NgModuleFactory</code></a>, <a href="../../core/ngmodule"><code>NgModule</code></a> class or a function:</p> <ul class="docs-list"> <li>
<a href="../../core/ngmodulefactory"><code>NgModuleFactory</code></a>: If you pass an <a href="../../core/ngmodulefactory"><code>NgModuleFactory</code></a>, it will be used to instantiate a module using <a href="../../platform-browser/platformbrowser"><code>platformBrowser</code></a>'s <a href="../../core/platformref#bootstrapModuleFactory"><code>bootstrapModuleFactory()</code></a>. NOTE: this type of the argument is deprecated. Please either provide an <a href="../../core/ngmodule"><code>NgModule</code></a> class or a bootstrap function instead.</li> <li>
<a href="../../core/ngmodule"><code>NgModule</code></a> class: If you pass an NgModule class, it will be used to instantiate a module using <a href="../../platform-browser/platformbrowser"><code>platformBrowser</code></a>'s <a href="../../core/platformref#bootstrapModule"><code>bootstrapModule()</code></a>.</li> <li>
<code>Function</code>: If you pass a function, it is expected to return a promise resolving to an <a href="../../core/ngmoduleref"><code>NgModuleRef</code></a>. The function is called with an array of extra <a href="../../core/staticprovider"><code>Providers</code></a> that are expected to be available from the returned <a href="../../core/ngmoduleref"><code>NgModuleRef</code></a>'s <a href="../../core/injector"><code>Injector</code></a>.</li> </ul> <p><a href="downgrademodule"><code>downgradeModule()</code></a> returns the name of the created AngularJS wrapper module. You can use it to declare a dependency in your main AngularJS module.</p> <p>{@example upgrade/static/ts/lite/module.ts region="basic-how-to"}</p> <p>For more details on how to use <a href="downgrademodule"><code>downgradeModule()</code></a> see <a href="https://angular.io/guide/upgrade" target="_blank">Upgrading for Performance</a>.</p>
</div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">moduleOrBootstrapFn</span><code><a href="../../core/type">Type</a>&lt;T&gt; | ((extraProviders: <a href="../../core/staticprovider">StaticProvider</a>[]) =&gt; Promise&lt;<a href="../../core/ngmoduleref">NgModuleRef</a>&lt;T&gt;&gt;)</code>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>string</code>
</div>
<div class="docs-usage-notes">
<span class="docs-usage-notes-heading">Usage notes</span><div>
<p>Apart from <a href="upgrademodule"><code>UpgradeModule</code></a>, you can use the rest of the <code>upgrade/static</code> helpers as usual to build a hybrid application. Note that the Angular pieces (e.g. downgraded services) will not be available until the downgraded module has been bootstrapped, i.e. by instantiating a downgraded component.</p> <div class="docs-alert docs-alert-important"> <p> You cannot use <a href="downgrademodule"><code>downgradeModule()</code></a> and <a href="upgrademodule"><code>UpgradeModule</code></a> in the same hybrid application.<br> Use one or the other.</p> </div> <h3 id="differences-with-upgrademodule"> Differences with UpgradeModule </h3> <p>Besides their different API, there are two important internal differences between <a href="downgrademodule"><code>downgradeModule()</code></a> and <a href="upgrademodule"><code>UpgradeModule</code></a> that affect the behavior of hybrid applications:</p> <ol class="docs-ordered-list"> <li>Unlike <a href="upgrademodule"><code>UpgradeModule</code></a>, <a href="downgrademodule"><code>downgradeModule()</code></a> does not bootstrap the main AngularJS module inside the <a href="../../core/ngzone"><code>Angular zone</code></a>.</li> <li>Unlike <a href="upgrademodule"><code>UpgradeModule</code></a>, <a href="downgrademodule"><code>downgradeModule()</code></a> does not automatically run a <a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest" target="_blank">$digest()</a> when changes are detected in the Angular part of the application.</li> </ol> <p>What this means is that applications using <a href="upgrademodule"><code>UpgradeModule</code></a> will run change detection more frequently in order to ensure that both frameworks are properly notified about possible changes. This will inevitably result in more change detection runs than necessary.</p> <p><a href="downgrademodule"><code>downgradeModule()</code></a>, on the other side, does not try to tie the two change detection systems as tightly, restricting the explicit change detection runs only to cases where it knows it is necessary (e.g. when the inputs of a downgraded component change). This improves performance, especially in change-detection-heavy applications, but leaves it up to the developer to manually notify each framework as needed.</p> <p>For a more detailed discussion of the differences and their implications, see <a href="https://angular.io/guide/upgrade" target="_blank">Upgrading for Performance</a>.</p> <div class="docs-alert docs-alert-helpful"> <p> You can manually trigger a change detection run in AngularJS using <a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply" target="_blank">scope.$apply(...)</a> or <a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest" target="_blank">$rootScope.$digest()</a>.</p> <p> You can manually trigger a change detection run in Angular using <a href="../../core/ngzone#run"><code>*   ngZone.run(...)</code></a>.</p> </div> <h3 id="downgrading-multiple-modules"> Downgrading multiple modules </h3> <p>It is possible to downgrade multiple modules and include them in an AngularJS application. In that case, each downgraded module will be bootstrapped when an associated downgraded component or injectable needs to be instantiated.</p> <p>Things to keep in mind, when downgrading multiple modules:</p> <ul class="docs-list"> <li>
<p>Each downgraded component/injectable needs to be explicitly associated with a downgraded module. See <a href="downgradecomponent"><code>downgradeComponent()</code></a> and <a href="downgradeinjectable"><code>downgradeInjectable()</code></a> for more details.</p> </li> <li>
<p>If you want some injectables to be shared among all downgraded modules, you can provide them as <a href="../../core/staticprovider"><code>StaticProvider</code></a>s, when creating the <a href="../../core/platformref"><code>PlatformRef</code></a> (e.g. via <a href="../../platform-browser/platformbrowser"><code>platformBrowser</code></a> or <code>platformBrowserDynamic</code>).</p> </li> <li>
<p>When using <a href="../../core/platformref#bootstrapmodule"><code><code>bootstrapModule()</code></code></a> or <a href="../../core/platformref#bootstrapmodulefactory"><code><code>bootstrapModuleFactory()</code></code></a> to bootstrap the downgraded modules, each one is considered a "root" module. As a consequence, a new instance will be created for every injectable provided in <code>"root"</code> (via <a href="../../core/injectable#providedIn"><code>providedIn</code></a> If this is not your intention, you can have a shared module (that will act as act as the "root" module) and create all downgraded modules using that module's injector:</p> <p>{@example upgrade/static/ts/lite-multi-shared/module.ts region="shared-root-module"}</p> </li> </ul> </div>
</div>
</div></div>
</div>
<div id="downgradeModule_1" class="docs-reference-member-card">
<header class="docs-reference-card-header"><pre data-language="ts">function downgradeModule&lt;T&gt;(moduleOrBootstrapFn: NgModuleFactory&lt;T&gt;): string;</pre></header><div class="docs-reference-card-body"><div class="docs-reference-card-item docs-reference-card-item-deprecated">
<div class="docs-function-definition">
<p>A helper function for creating an AngularJS module that can bootstrap an Angular module "on-demand" (possibly lazily) when a <a href="downgradecomponent"><code>downgraded component</code></a> needs to be instantiated.</p> <p><em>Part of the <a href="../../../api?query=upgrade/static">upgrade/static</a> library for hybrid upgrade apps that support AOT compilation.</em></p> <p>It allows loading/bootstrapping the Angular part of a hybrid application lazily and not having to pay the cost up-front. For example, you can have an AngularJS application that uses Angular for specific routes and only instantiate the Angular modules if/when the user visits one of these routes.</p> <p>The Angular module will be bootstrapped once (when requested for the first time) and the same reference will be used from that point onwards.</p> <p><a href="downgrademodule"><code>downgradeModule()</code></a> requires either an <a href="../../core/ngmodulefactory"><code>NgModuleFactory</code></a>, <a href="../../core/ngmodule"><code>NgModule</code></a> class or a function:</p> <ul class="docs-list"> <li>
<a href="../../core/ngmodulefactory"><code>NgModuleFactory</code></a>: If you pass an <a href="../../core/ngmodulefactory"><code>NgModuleFactory</code></a>, it will be used to instantiate a module using <a href="../../platform-browser/platformbrowser"><code>platformBrowser</code></a>'s <a href="../../core/platformref#bootstrapModuleFactory"><code>bootstrapModuleFactory()</code></a>. NOTE: this type of the argument is deprecated. Please either provide an <a href="../../core/ngmodule"><code>NgModule</code></a> class or a bootstrap function instead.</li> <li>
<a href="../../core/ngmodule"><code>NgModule</code></a> class: If you pass an NgModule class, it will be used to instantiate a module using <a href="../../platform-browser/platformbrowser"><code>platformBrowser</code></a>'s <a href="../../core/platformref#bootstrapModule"><code>bootstrapModule()</code></a>.</li> <li>
<code>Function</code>: If you pass a function, it is expected to return a promise resolving to an <a href="../../core/ngmoduleref"><code>NgModuleRef</code></a>. The function is called with an array of extra <a href="../../core/staticprovider"><code>Providers</code></a> that are expected to be available from the returned <a href="../../core/ngmoduleref"><code>NgModuleRef</code></a>'s <a href="../../core/injector"><code>Injector</code></a>.</li> </ul> <p><a href="downgrademodule"><code>downgradeModule()</code></a> returns the name of the created AngularJS wrapper module. You can use it to declare a dependency in your main AngularJS module.</p> <p>{@example upgrade/static/ts/lite/module.ts region="basic-how-to"}</p> <p>For more details on how to use <a href="downgrademodule"><code>downgradeModule()</code></a> see <a href="https://angular.io/guide/upgrade" target="_blank">Upgrading for Performance</a>.</p>
</div>
<div><div class="docs-deprecation-message">
<span class="docs-param-keyword docs-deprecated">@deprecated</span><span><p>Passing <a href="../../core/ngmodulefactory"><code>NgModuleFactory</code></a> as the <a href="downgrademodule"><code>downgradeModule</code></a> function argument is deprecated, please pass an NgModule class reference instead.</p> </span>
</div></div>
<div class="docs-param-group">
<span class="docs-param-keyword">@param</span><span class="docs-param-name">moduleOrBootstrapFn</span><code><a href="../../core/ngmodulefactory">NgModuleFactory</a>&lt;T&gt;</code>
</div>
<div class="docs-return-type">
<span class="docs-param-keyword">@returns</span><code>string</code>
</div>
<div class="docs-usage-notes">
<span class="docs-usage-notes-heading">Usage notes</span><div>
<p>Apart from <a href="upgrademodule"><code>UpgradeModule</code></a>, you can use the rest of the <code>upgrade/static</code> helpers as usual to build a hybrid application. Note that the Angular pieces (e.g. downgraded services) will not be available until the downgraded module has been bootstrapped, i.e. by instantiating a downgraded component.</p> <div class="docs-alert docs-alert-important"> <p> You cannot use <a href="downgrademodule"><code>downgradeModule()</code></a> and <a href="upgrademodule"><code>UpgradeModule</code></a> in the same hybrid application.<br> Use one or the other.</p> </div> <h3 id="differences-with-upgrademodule"> Differences with UpgradeModule </h3> <p>Besides their different API, there are two important internal differences between <a href="downgrademodule"><code>downgradeModule()</code></a> and <a href="upgrademodule"><code>UpgradeModule</code></a> that affect the behavior of hybrid applications:</p> <ol class="docs-ordered-list"> <li>Unlike <a href="upgrademodule"><code>UpgradeModule</code></a>, <a href="downgrademodule"><code>downgradeModule()</code></a> does not bootstrap the main AngularJS module inside the <a href="../../core/ngzone"><code>Angular zone</code></a>.</li> <li>Unlike <a href="upgrademodule"><code>UpgradeModule</code></a>, <a href="downgrademodule"><code>downgradeModule()</code></a> does not automatically run a <a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest" target="_blank">$digest()</a> when changes are detected in the Angular part of the application.</li> </ol> <p>What this means is that applications using <a href="upgrademodule"><code>UpgradeModule</code></a> will run change detection more frequently in order to ensure that both frameworks are properly notified about possible changes. This will inevitably result in more change detection runs than necessary.</p> <p><a href="downgrademodule"><code>downgradeModule()</code></a>, on the other side, does not try to tie the two change detection systems as tightly, restricting the explicit change detection runs only to cases where it knows it is necessary (e.g. when the inputs of a downgraded component change). This improves performance, especially in change-detection-heavy applications, but leaves it up to the developer to manually notify each framework as needed.</p> <p>For a more detailed discussion of the differences and their implications, see <a href="https://angular.io/guide/upgrade" target="_blank">Upgrading for Performance</a>.</p> <div class="docs-alert docs-alert-helpful"> <p> You can manually trigger a change detection run in AngularJS using <a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply" target="_blank">scope.$apply(...)</a> or <a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest" target="_blank">$rootScope.$digest()</a>.</p> <p> You can manually trigger a change detection run in Angular using <a href="../../core/ngzone#run"><code>*   ngZone.run(...)</code></a>.</p> </div> <h3 id="downgrading-multiple-modules"> Downgrading multiple modules </h3> <p>It is possible to downgrade multiple modules and include them in an AngularJS application. In that case, each downgraded module will be bootstrapped when an associated downgraded component or injectable needs to be instantiated.</p> <p>Things to keep in mind, when downgrading multiple modules:</p> <ul class="docs-list"> <li>
<p>Each downgraded component/injectable needs to be explicitly associated with a downgraded module. See <a href="downgradecomponent"><code>downgradeComponent()</code></a> and <a href="downgradeinjectable"><code>downgradeInjectable()</code></a> for more details.</p> </li> <li>
<p>If you want some injectables to be shared among all downgraded modules, you can provide them as <a href="../../core/staticprovider"><code>StaticProvider</code></a>s, when creating the <a href="../../core/platformref"><code>PlatformRef</code></a> (e.g. via <a href="../../platform-browser/platformbrowser"><code>platformBrowser</code></a> or <code>platformBrowserDynamic</code>).</p> </li> <li>
<p>When using <a href="../../core/platformref#bootstrapmodule"><code><code>bootstrapModule()</code></code></a> or <a href="../../core/platformref#bootstrapmodulefactory"><code><code>bootstrapModuleFactory()</code></code></a> to bootstrap the downgraded modules, each one is considered a "root" module. As a consequence, a new instance will be created for every injectable provided in <code>"root"</code> (via <a href="../../core/injectable#providedIn"><code>providedIn</code></a> If this is not your intention, you can have a shared module (that will act as act as the "root" module) and create all downgraded modules using that module's injector:</p> <p>{@example upgrade/static/ts/lite-multi-shared/module.ts region="shared-root-module"}</p> </li> </ul> </div>
</div>
</div></div>
</div>
</div>
<div class="docs-reference-section">
<h2 id="description" class="docs-reference-section-heading">Description</h2>
<div>
<p>A helper function for creating an AngularJS module that can bootstrap an Angular module "on-demand" (possibly lazily) when a <a href="downgradecomponent"><code>downgraded component</code></a> needs to be instantiated.</p> <p><em>Part of the <a href="../../../api?query=upgrade/static">upgrade/static</a> library for hybrid upgrade apps that support AOT compilation.</em></p> <p>It allows loading/bootstrapping the Angular part of a hybrid application lazily and not having to pay the cost up-front. For example, you can have an AngularJS application that uses Angular for specific routes and only instantiate the Angular modules if/when the user visits one of these routes.</p> <p>The Angular module will be bootstrapped once (when requested for the first time) and the same reference will be used from that point onwards.</p> <p><a href="downgrademodule"><code>downgradeModule()</code></a> requires either an <a href="../../core/ngmodulefactory"><code>NgModuleFactory</code></a>, <a href="../../core/ngmodule"><code>NgModule</code></a> class or a function:</p> <ul class="docs-list"> <li>
<a href="../../core/ngmodulefactory"><code>NgModuleFactory</code></a>: If you pass an <a href="../../core/ngmodulefactory"><code>NgModuleFactory</code></a>, it will be used to instantiate a module using <a href="../../platform-browser/platformbrowser"><code>platformBrowser</code></a>'s <a href="../../core/platformref#bootstrapModuleFactory"><code>bootstrapModuleFactory()</code></a>. NOTE: this type of the argument is deprecated. Please either provide an <a href="../../core/ngmodule"><code>NgModule</code></a> class or a bootstrap function instead.</li> <li>
<a href="../../core/ngmodule"><code>NgModule</code></a> class: If you pass an NgModule class, it will be used to instantiate a module using <a href="../../platform-browser/platformbrowser"><code>platformBrowser</code></a>'s <a href="../../core/platformref#bootstrapModule"><code>bootstrapModule()</code></a>.</li> <li>
<code>Function</code>: If you pass a function, it is expected to return a promise resolving to an <a href="../../core/ngmoduleref"><code>NgModuleRef</code></a>. The function is called with an array of extra <a href="../../core/staticprovider"><code>Providers</code></a> that are expected to be available from the returned <a href="../../core/ngmoduleref"><code>NgModuleRef</code></a>'s <a href="../../core/injector"><code>Injector</code></a>.</li> </ul> <p><a href="downgrademodule"><code>downgradeModule()</code></a> returns the name of the created AngularJS wrapper module. You can use it to declare a dependency in your main AngularJS module.</p> <pre data-language="ts">import {BrowserModule, platformBrowser} from '@angular/platform-browser';
import {downgradeComponent, downgradeModule, UpgradeComponent} from '@angular/upgrade/static';

// The function that will bootstrap the Angular module (when/if necessary).
// (This would be omitted if we provided an `NgModuleFactory` directly.)
const ng2BootstrapFn = (extraProviders: StaticProvider[]) =&gt;
  platformBrowser(extraProviders).bootstrapModule(MyLazyAngularModule);
// This AngularJS module represents the AngularJS pieces of the application.
const myMainAngularJsModule = angular.module('myMainAngularJsModule', [
  // We declare a dependency on the "downgraded" Angular module.
  downgradeModule(ng2BootstrapFn),
  // or
  // downgradeModule(MyLazyAngularModuleFactory)
]);</pre>
<p>For more details on how to use <a href="downgrademodule"><code>downgradeModule()</code></a> see <a href="https://angular.io/guide/upgrade" target="_blank">Upgrading for Performance</a>.</p>
</div>
</div>
<div class="docs-reference-section">
<h2 id="usage-notes" class="docs-reference-section-heading">Usage Notes</h2>
<div>
<p>Apart from <a href="upgrademodule"><code>UpgradeModule</code></a>, you can use the rest of the <code>upgrade/static</code> helpers as usual to build a hybrid application. Note that the Angular pieces (e.g. downgraded services) will not be available until the downgraded module has been bootstrapped, i.e. by instantiating a downgraded component.</p> <div class="docs-alert docs-alert-important"> <p> You cannot use <a href="downgrademodule"><code>downgradeModule()</code></a> and <a href="upgrademodule"><code>UpgradeModule</code></a> in the same hybrid application.<br> Use one or the other.</p> </div> <h3 id="differences-with-upgrademodule"> Differences with UpgradeModule </h3> <p>Besides their different API, there are two important internal differences between <a href="downgrademodule"><code>downgradeModule()</code></a> and <a href="upgrademodule"><code>UpgradeModule</code></a> that affect the behavior of hybrid applications:</p> <ol class="docs-ordered-list"> <li>Unlike <a href="upgrademodule"><code>UpgradeModule</code></a>, <a href="downgrademodule"><code>downgradeModule()</code></a> does not bootstrap the main AngularJS module inside the <a href="../../core/ngzone"><code>Angular zone</code></a>.</li> <li>Unlike <a href="upgrademodule"><code>UpgradeModule</code></a>, <a href="downgrademodule"><code>downgradeModule()</code></a> does not automatically run a <a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest" target="_blank">$digest()</a> when changes are detected in the Angular part of the application.</li> </ol> <p>What this means is that applications using <a href="upgrademodule"><code>UpgradeModule</code></a> will run change detection more frequently in order to ensure that both frameworks are properly notified about possible changes. This will inevitably result in more change detection runs than necessary.</p> <p><a href="downgrademodule"><code>downgradeModule()</code></a>, on the other side, does not try to tie the two change detection systems as tightly, restricting the explicit change detection runs only to cases where it knows it is necessary (e.g. when the inputs of a downgraded component change). This improves performance, especially in change-detection-heavy applications, but leaves it up to the developer to manually notify each framework as needed.</p> <p>For a more detailed discussion of the differences and their implications, see <a href="https://angular.io/guide/upgrade" target="_blank">Upgrading for Performance</a>.</p> <div class="docs-alert docs-alert-helpful"> <p> You can manually trigger a change detection run in AngularJS using <a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply" target="_blank">scope.$apply(...)</a> or <a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest" target="_blank">$rootScope.$digest()</a>.</p> <p> You can manually trigger a change detection run in Angular using <a href="../../core/ngzone#run"><code>*   ngZone.run(...)</code></a>.</p> </div> <h3 id="downgrading-multiple-modules"> Downgrading multiple modules </h3> <p>It is possible to downgrade multiple modules and include them in an AngularJS application. In that case, each downgraded module will be bootstrapped when an associated downgraded component or injectable needs to be instantiated.</p> <p>Things to keep in mind, when downgrading multiple modules:</p> <ul class="docs-list"> <li>
<p>Each downgraded component/injectable needs to be explicitly associated with a downgraded module. See <a href="downgradecomponent"><code>downgradeComponent()</code></a> and <a href="downgradeinjectable"><code>downgradeInjectable()</code></a> for more details.</p> </li> <li>
<p>If you want some injectables to be shared among all downgraded modules, you can provide them as <a href="../../core/staticprovider"><code>StaticProvider</code></a>s, when creating the <a href="../../core/platformref"><code>PlatformRef</code></a> (e.g. via <a href="../../platform-browser/platformbrowser"><code>platformBrowser</code></a> or <code>platformBrowserDynamic</code>).</p> </li> <li>
<p>When using <a href="../../core/platformref#bootstrapmodule"><code><code>bootstrapModule()</code></code></a> or <a href="../../core/platformref#bootstrapmodulefactory"><code><code>bootstrapModuleFactory()</code></code></a> to bootstrap the downgraded modules, each one is considered a "root" module. As a consequence, a new instance will be created for every injectable provided in <code>"root"</code> (via <a href="../../core/injectable#providedIn"><code>providedIn</code></a> If this is not your intention, you can have a shared module (that will act as act as the "root" module) and create all downgraded modules using that module's injector:</p> </li> </ul> <pre data-language="ts">let rootInjectorPromise: Promise&lt;Injector&gt; | null = null;
const getRootInjector = (extraProviders: StaticProvider[]) =&gt; {
  if (!rootInjectorPromise) {
    rootInjectorPromise = platformBrowser(extraProviders)
      .bootstrapModule(Ng2RootModule)
      .then((moduleRef) =&gt; moduleRef.injector);
  }
  return rootInjectorPromise;
};

const downgradedNg2AModule = downgradeModule(async (extraProviders: StaticProvider[]) =&gt; {
  const rootInjector = await getRootInjector(extraProviders)!;
  const moduleAFactory = await rootInjector.get(Compiler).compileModuleAsync(Ng2AModule);
  return moduleAFactory.create(rootInjector);
});
const downgradedNg2BModule = downgradeModule(async (extraProviders: StaticProvider[]) =&gt; {
  const rootInjector = await getRootInjector(extraProviders)!;
  const moduleBFactory = await rootInjector.get(Compiler).compileModuleAsync(Ng2BModule);
  return moduleBFactory.create(rootInjector);
});
const appModule = angular
  .module('exampleAppModule', [downgradedNg2AModule, downgradedNg2BModule, downgradedNg2CModule])</pre>
</div>
</div>
</div></main></adev-reference-page></adev-main><div class="_attribution">
  <p class="_attribution-p">
    Super-powered by Google &copy;2010&ndash;2025.<br />Code licensed under an MIT-style License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://angular.dev/api/upgrade/static/downgradeModule" class="_attribution-link">https://angular.dev/api/upgrade/static/downgradeModule</a>
  </p>
</div>
