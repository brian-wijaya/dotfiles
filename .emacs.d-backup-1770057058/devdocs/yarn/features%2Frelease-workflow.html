<header><h1>Release Workflow</h1></header><div class="theme-admonition theme-admonition-info admonition_w2cE alert alert--info">
<div class="admonitionHeading_zjKb">
<span class="admonitionIcon_xnvX"><svg viewbox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Experimental</div>
<div class="admonitionContent_SoUl"><p>This feature is still incubating, and we'll likely be improving it based on your feedback.</p></div>
</div> <p>When working with monorepos, a hard task often is to figure out which packages should receive a new version when starting a new release. Yarn offers a few tools that aim to make this workflow easier without the need for third-party tools (although it's possible you may prefer the workflow offered by different implementations, of course!).</p> <h2 class="anchor anchorWithStickyNavbar_hhKX" id="auto-updated-dependencies">Auto-updated dependencies<a href="#auto-updated-dependencies" class="hash-link" aria-label="Direct link to Auto-updated dependencies" title="Direct link to Auto-updated dependencies">​</a>
</h2> <p>When running the <span class="inline_hdsZ"><code><span class="token_Ye2a" data-type="binary">yarn</span> <a class="path_tCL7" data-tooltip-id="tooltip" data-tooltip-content="Apply a new version to the current package
" href="../cli/version"><span class="token_Ye2a" data-type="path">version</span></a></code></span> command to upgrade the version of a workspace, every other workspace that depend on the first one through a basic semver ranges (<code>^x.y.z</code>, <code>~x.y.z</code>, ...) will get auto-updated to reference the new version. For example, let's say we have the following workspaces:</p> <div class="codeBlockContainer_iUqV theme-code-block"><div class="codeBlockContent_Xs1n">
<pre tabindex="0" class="prism-code language-text codeBlock_hDG7 thin-scrollbar" data-language="text">/packages/common (1.0.0)
/packages/server (depends on common@^1.0.0)
/packages/client (depends on common@^1.0.0)</pre>
<div class="buttonGroup_ipu6"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_FbbJ" aria-hidden="true"><svg viewbox="0 0 24 24" class="copyButtonIcon_Nh6j"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewbox="0 0 24 24" class="copyButtonSuccessIcon_wXPl"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div>
</div></div> <p>In pre-2.0, upgrading <code>common</code> would have required you to run the command there, then go into each of <code>server</code> and <code>client</code> to manually upgrade their dependencies to reference the new version. But not anymore! If we run <span class="inline_hdsZ"><code><span class="token_Ye2a" data-type="binary">yarn</span> <a class="path_tCL7" data-tooltip-id="tooltip" data-tooltip-content="Apply a new version to the current package
" href="../cli/version"><span class="token_Ye2a" data-type="path">version</span></a> <span class="token_Ye2a" data-type="positional">1.1.1</span></code></span> into <code>common</code>, the following changes will be applied:</p> <div class="codeBlockContainer_iUqV theme-code-block"><div class="codeBlockContent_Xs1n">
<pre tabindex="0" class="prism-code language-text codeBlock_hDG7 thin-scrollbar" data-language="text">/packages/common (1.1.1)
/packages/server (depends on common@^1.1.1)
/packages/client (depends on common@^1.1.1)</pre>
<div class="buttonGroup_ipu6"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_FbbJ" aria-hidden="true"><svg viewbox="0 0 24 24" class="copyButtonIcon_Nh6j"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewbox="0 0 24 24" class="copyButtonSuccessIcon_wXPl"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div>
</div></div> <p>Of course it's not that important when the packages from the monorepo are always meant to be used as part of the monorepo, but it becomes much more interesting when you work with multiple packages meant to be published. Had you forgotten to update the range of either of your dependent packages, your users would have potentially downloaded an old version of <code>common</code> which wouldn't have been compatible with the newer one.</p> <h2 class="anchor anchorWithStickyNavbar_hhKX" id="deferred-versioning">Deferred versioning<a href="#deferred-versioning" class="hash-link" aria-label="Direct link to Deferred versioning" title="Direct link to Deferred versioning">​</a>
</h2> <p>Starting from the 2.0, the <span class="inline_hdsZ"><code><span class="token_Ye2a" data-type="binary">yarn</span> <a class="path_tCL7" data-tooltip-id="tooltip" data-tooltip-content="Apply a new version to the current package
" href="../cli/version"><span class="token_Ye2a" data-type="path">version</span></a></code></span> command now accepts a new flag: <code>--deferred</code>. When set, this flag will cause the command to not immediately change the <code data-tooltip-id="tooltip" data-tooltip-content="Version of the package."><a class="key_FEvO" href="../configuration/manifest#version">version</a></code> field of the local manifest, but to instead internally record an entry stating that the current package will need to receive an upgrade during the next release cycle. For example, the following:</p>  <p>Will not cause the <code>package.json</code> file to change! Instead, Yarn will create (or reuse, if you're inside a branch) a file within the <code>.yarn/versions</code> directory. This file will record the requested upgrade:</p> <div class="language-yaml codeBlockContainer_iUqV theme-code-block"><div class="codeBlockContent_Xs1n">
<pre tabindex="0" class="prism-code language-yaml codeBlock_hDG7 thin-scrollbar" data-language="yaml">releases:
  my-package@1.0.0: minor</pre>
<div class="buttonGroup_ipu6"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_FbbJ" aria-hidden="true"><svg viewbox="0 0 24 24" class="copyButtonIcon_Nh6j"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewbox="0 0 24 24" class="copyButtonSuccessIcon_wXPl"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div>
</div></div> <p>Then later on, once you're ready, just run <span class="inline_hdsZ"><code><span class="token_Ye2a" data-type="binary">yarn</span> <a class="path_tCL7" data-tooltip-id="tooltip" data-tooltip-content="Apply all the deferred version bumps at once
" href="../cli/version/apply"><span class="token_Ye2a" data-type="path">version</span> <span class="token_Ye2a" data-type="path">apply</span></a></code></span>. Yarn will then locate all the upgrade records it previously saved, and apply them all at once (including by taking care of upgrading inter-dependencies as we saw).</p> <h2 class="anchor anchorWithStickyNavbar_hhKX" id="checked-in-deferred-records">Checked-in deferred records<a href="#checked-in-deferred-records" class="hash-link" aria-label="Direct link to Checked-in deferred records" title="Direct link to Checked-in deferred records">​</a>
</h2> <p>We've seen in the previous section that <span class="inline_hdsZ"><code><span class="token_Ye2a" data-type="binary">yarn</span> <a class="path_tCL7" data-tooltip-id="tooltip" data-tooltip-content="Apply a new version to the current package
" href="../cli/version"><span class="token_Ye2a" data-type="path">version</span></a> <span class="token_Ye2a" data-type="positional">patch</span></code></span> could store the future versions in an internal folder, <code>.yarn/versions</code>. But why is that? What good is it? To answer this question, consider a popular open-source project developed through a monorepo. This project receives many external pull requests, but they aren't released right away - they're often released as part of a batch. Every once in a while, the lead maintainer will take all the changes, convert them into new versions, and start the deployment.</p> <p>Let's focus on the part where changes have to be converted into versions. How does that work? This isn't easy. Taking Lerna, for example (the most popular version management tool for monorepos), you have two solutions:</p> <ul> <li> <p>With the fixed mode, all your packages have a single version. As such, they get upgraded all at once.</p> </li> <li> <p>With the independent mode, you get to chose a version for each package whose sources changed.</p> </li> </ul> <p>One critical problem remains, though: even if you use the independent mode, how will you know which packages are meant to be upgraded? And, just as critical, should they be patch releases? Minor releases? Hard to know - large projects can receive dozens of PRs a week, and keeping track of which units need to be released and to which version is a pretty difficult task.</p> <p>With Yarn's workflow, however, this all becomes very easy! Since the upgrades are kept in a file, and since this file is magically bound to a Git branch, it simply becomes a matter of committing the release folder - all expected releases will then become part of the project history until comes the time of <span class="inline_hdsZ"><code><span class="token_Ye2a" data-type="binary">yarn</span> <a class="path_tCL7" data-tooltip-id="tooltip" data-tooltip-content="Apply all the deferred version bumps at once
" href="../cli/version/apply"><span class="token_Ye2a" data-type="path">version</span> <span class="token_Ye2a" data-type="path">apply</span></a></code></span> - then Yarn will consume all the individual records, merge them (so that a PR requiring a minor will have higher precedence than the PR requiring a patch), and apply them simultaneously.</p> <p>As an added bonus, you'll even be able to review the package upgrades as part of the typical PR review! This will have the effect of delegating more power to your community while being able to ensure that everyone follows rules.</p> <h2 class="anchor anchorWithStickyNavbar_hhKX" id="ensuring-that-versions-are-bumped-ci">Ensuring that versions are bumped (CI)<a href="#ensuring-that-versions-are-bumped-ci" class="hash-link" aria-label="Direct link to Ensuring that versions are bumped (CI)" title="Direct link to Ensuring that versions are bumped (CI)">​</a>
</h2> <p>One problem with committing the deferred releases, however, is that it becomes important to make sure that the PRs you receive include the correct package release definitions. For example, you should be able to trust that the definition contains release strategies (patch, minor, major, ...) for each modified workspace.</p> <p>To solve this problem in an automated way, the <span class="inline_hdsZ"><code><span class="token_Ye2a" data-type="binary">yarn</span> <a class="path_tCL7" data-tooltip-id="tooltip" data-tooltip-content="Check that all the relevant packages have been bumped
" href="../cli/version/check"><span class="token_Ye2a" data-type="path">version</span> <span class="token_Ye2a" data-type="path">check</span></a></code></span> command appeared. When run, this command will figure out which packages changed and whether they are listed in the release definition file. If they aren't, an error will be thrown and - assuming you integrate this into a CI system such as the GitHub Actions - the PR author will be asked to fill out the release definition file.</p> <p>Writing this file can be tedious; fortunately <span class="inline_hdsZ"><code><span class="token_Ye2a" data-type="binary">yarn</span> <a class="path_tCL7" data-tooltip-id="tooltip" data-tooltip-content="Check that all the relevant packages have been bumped
" href="../cli/version/check"><span class="token_Ye2a" data-type="path">version</span> <span class="token_Ye2a" data-type="path">check</span></a></code></span> implements a very handy flag named <code>--interactive</code>. When set (<span class="inline_hdsZ"><code><span class="token_Ye2a" data-type="binary">yarn</span> <a class="path_tCL7" data-tooltip-id="tooltip" data-tooltip-content="Check that all the relevant packages have been bumped
" href="../cli/version/check"><span class="token_Ye2a" data-type="path">version</span> <span class="token_Ye2a" data-type="path">check</span></a> <span class="token_Ye2a" data-type="dash">--</span><span class="token_Ye2a" data-type="option" data-tooltip-id="tooltip" data-tooltip-content="Open an interactive interface used to set version bumps">interactive</span></code></span>), Yarn will print a terminal interface that will summarize all the changed files, all the changed workspaces, all relevant dependent workspaces, and checkboxes for each entry allowing you to pick the release strategies you want to set for each workspace.</p> <p>The <a href="../configuration/yarnrc#changesetIgnorePatterns"><code data-tooltip-id="tooltip" data-tooltip-content="Array of file glob patterns that will be excluded from change detection."><span class="key_FEvO">changesetIgnorePatterns</span></code></a> configuration option can be used to ignore files when checking which files have changed. It is useful for excluding files that don't affect the release process (e.g. test files).</p> <h3 class="anchor anchorWithStickyNavbar_hhKX" id="caveat">Caveat<a href="#caveat" class="hash-link" aria-label="Direct link to Caveat" title="Direct link to Caveat">​</a>
</h3> <h4 class="anchor anchorWithStickyNavbar_hhKX" id="commit-history">Commit history<a href="#commit-history" class="hash-link" aria-label="Direct link to Commit history" title="Direct link to Commit history">​</a>
</h4> <p>The <a href="https://github.com/yarnpkg/berry/tree/master/packages/plugin-version" target="_blank" rel="noopener noreferrer">version plugin</a> requires access to the commit history in order to be able to correctly infer which packages require release specifications. In particular, when using GitHub Actions with <code>actions/checkout@v2</code> or greater the default behavior is for Git to fetch just the version being checked, which would cause problems. To correct this, you will need to override the <code>fetch-depth</code> configuration value to fetch the whole commit history:</p> <div class="language-yaml codeBlockContainer_iUqV theme-code-block"><div class="codeBlockContent_Xs1n">
<pre tabindex="0" class="prism-code language-yaml codeBlock_hDG7 thin-scrollbar" data-language="yaml">- uses: actions/checkout@v2
  with:
    fetch-depth: 0</pre>
<div class="buttonGroup_ipu6"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_FbbJ" aria-hidden="true"><svg viewbox="0 0 24 24" class="copyButtonIcon_Nh6j"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewbox="0 0 24 24" class="copyButtonSuccessIcon_wXPl"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div>
</div></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016&ndash;present Yarn Contributors<br>Licensed under the BSD License.<br>
    <a href="https://yarnpkg.com/features/release-workflow" class="_attribution-link">https://yarnpkg.com/features/release-workflow</a>
  </p>
</div>
