<h1>gitsubmodules</h1>  <h2 id="_name">Name</h2> <div class="sectionbody">  <p>gitsubmodules - Mounting one repository inside another</p>  </div>   <h2 id="_synopsis">Synopsis</h2> <div class="sectionbody"> <div class="literalblock"> <div class="content"> <pre>.gitmodules, $GIT_DIR/config</pre> </div> </div> <div class="listingblock"> <div class="content"> <pre data-language="shell">git submodule
git &lt;command&gt; --recurse-submodules</pre> </div> </div> </div>   <h2 id="_description">Description</h2> <div class="sectionbody">  <p>A submodule is a repository embedded inside another repository. The submodule has its own history; the repository it is embedded in is called a superproject.</p>   <p>On the filesystem, a submodule usually (but not always - see FORMS below) consists of (i) a Git directory located under the <span class="synopsis"><code>$GIT_DIR/modules/</code></span> directory of its superproject, (ii) a working directory inside the superproject’s working directory, and a <span class="synopsis"><code>.git</code></span> file at the root of the submodule’s working directory pointing to (i).</p>   <p>Assuming the submodule has a Git directory at <span class="synopsis"><code>$GIT_DIR/modules/foo/</code></span> and a working directory at <span class="synopsis"><code>path/to/bar/</code></span>, the superproject tracks the submodule via a <span class="synopsis"><code>gitlink</code></span> entry in the tree at <span class="synopsis"><code>path/to/bar</code></span> and an entry in its <span class="synopsis"><code>.gitmodules</code></span> file (see <a href="gitmodules">gitmodules[5]</a>) of the form <span class="synopsis"><code>submodule.foo.path</code> <code>=</code> <code>path/to/bar</code></span>.</p>   <p>The <span class="synopsis"><code>gitlink</code></span> entry contains the object name of the commit that the superproject expects the submodule’s working directory to be at.</p>   <p>The section <span class="synopsis"><code>submodule.foo.*</code></span> in the <span class="synopsis"><code>.gitmodules</code></span> file gives additional hints to Git’s porcelain layer. For example, the <span class="synopsis"><code>submodule.foo.url</code></span> setting specifies where to obtain the submodule.</p>   <p>Submodules can be used for at least two different use cases:</p>  <div class="olist arabic"> <ol class="arabic"> <li> <p>Using another project while maintaining independent history. Submodules allow you to contain the working tree of another project within your own working tree while keeping the history of both projects separate. Also, since submodules are fixed to an arbitrary version, the other project can be independently developed without affecting the superproject, allowing the superproject project to fix itself to new versions only when desired.</p> </li> <li> <p>Splitting a (logically single) project into multiple repositories and tying them back together. This can be used to overcome current limitations of Git’s implementation to have finer grained access:</p> <div class="ulist"> <ul> <li> <p>Size of the Git repository: In its current form Git scales up poorly for large repositories containing content that is not compressed by delta computation between trees. For example, you can use submodules to hold large binary assets and these repositories can be shallowly cloned such that you do not have a large history locally.</p> </li> <li> <p>Transfer size: In its current form Git requires the whole working tree present. It does not allow partial trees to be transferred in fetch or clone. If the project you work on consists of multiple repositories tied together as submodules in a superproject, you can avoid fetching the working trees of the repositories you are not interested in.</p> </li> <li> <p>Access control: By restricting user access to submodules, this can be used to implement read/write policies for different users.</p> </li> </ul> </div> </li> </ol> </div> </div>   <h2 id="_the_configuration_of_submodules">The configuration of submodules</h2> <div class="sectionbody">  <p>Submodule operations can be configured using the following mechanisms (from highest to lowest precedence):</p>  <div class="ulist"> <ul> <li> <p>The command line for those commands that support taking submodules as part of their pathspecs. Most commands have a boolean flag <span class="synopsis"><code>--recurse-submodules</code></span> which specifies whether to recurse into submodules. Examples are <span class="synopsis"><code>grep</code></span> and <span class="synopsis"><code>checkout</code></span>. Some commands take enums, such as <span class="synopsis"><code>fetch</code></span> and <span class="synopsis"><code>push</code></span>, where you can specify how submodules are affected.</p> </li> <li> <p>The configuration inside the submodule. This includes <span class="synopsis"><code>$GIT_DIR/config</code></span> in the submodule, but also settings in the tree such as a <span class="synopsis"><code>.gitattributes</code></span> or <span class="synopsis"><code>.gitignore</code></span> files that specify behavior of commands inside the submodule.</p>  <p>For example an effect from the submodule’s <span class="synopsis"><code>.gitignore</code></span> file would be observed when you run <span class="synopsis"><code>git</code> <code>status</code> <code>--ignore-submodules=none</code></span> in the superproject. This collects information from the submodule’s working directory by running <span class="synopsis"><code>status</code></span> in the submodule while paying attention to the <span class="synopsis"><code>.gitignore</code></span> file of the submodule.</p>   <p>The submodule’s <span class="synopsis"><code>$GIT_DIR/config</code></span> file would come into play when running <span class="synopsis"><code>git</code> <code>push</code> <code>--recurse-submodules=check</code></span> in the superproject, as this would check if the submodule has any changes not published to any remote. The remotes are configured in the submodule as usual in the <span class="synopsis"><code>$GIT_DIR/config</code></span> file.</p>  </li> <li> <p>The configuration file <span class="synopsis"><code>$GIT_DIR/config</code></span> in the superproject. Git only recurses into active submodules (see "ACTIVE SUBMODULES" section below).</p>  <p>If the submodule is not yet initialized, then the configuration inside the submodule does not exist yet, so where to obtain the submodule from is configured here for example.</p>  </li> <li> <p>The <span class="synopsis"><code>.gitmodules</code></span> file inside the superproject. A project usually uses this file to suggest defaults for the upstream collection of repositories for the mapping that is required between a submodule’s name and its path.</p>  <p>This file mainly serves as the mapping between the name and path of submodules in the superproject, such that the submodule’s Git directory can be located.</p>   <p>If the submodule has never been initialized, this is the only place where submodule configuration is found. It serves as the last fallback to specify where to obtain the submodule from.</p>  </li> </ul> </div> </div>   <h2 id="_forms">Forms</h2> <div class="sectionbody">  <p>Submodules can take the following forms:</p>  <div class="ulist"> <ul> <li> <p>The basic form described in DESCRIPTION with a Git directory, a working directory, a <span class="synopsis"><code>gitlink</code></span>, and a <span class="synopsis"><code>.gitmodules</code></span> entry.</p> </li> <li> <p>"Old-form" submodule: A working directory with an embedded <span class="synopsis"><code>.git</code></span> directory, and the tracking <span class="synopsis"><code>gitlink</code></span> and <span class="synopsis"><code>.gitmodules</code></span> entry in the superproject. This is typically found in repositories generated using older versions of Git.</p>  <p>It is possible to construct these old form repositories manually.</p>   <p>When deinitialized or deleted (see below), the submodule’s Git directory is automatically moved to <span class="synopsis"><code>$GIT_DIR/modules/</code><em>&lt;name&gt;</em><code>/</code></span> of the superproject.</p>  </li> <li> <p>Deinitialized submodule: A <span class="synopsis"><code>gitlink</code></span>, and a <span class="synopsis"><code>.gitmodules</code></span> entry, but no submodule working directory. The submodule’s Git directory may be there as after deinitializing the Git directory is kept around. The directory which is supposed to be the working directory is empty instead.</p>  <p>A submodule can be deinitialized by running <span class="synopsis"><code>git</code> <code>submodule</code> <code>deinit</code></span>. Besides emptying the working directory, this command only modifies the superproject’s <span class="synopsis"><code>$GIT_DIR/config</code></span> file, so the superproject’s history is not affected. This can be undone using <span class="synopsis"><code>git</code> <code>submodule</code> <code>init</code></span>.</p>  </li> <li> <p>Deleted submodule: A submodule can be deleted by running <span class="synopsis"><em>git rm &lt;submodule-path&gt; &amp;&amp; git commit</em></span>. This can be undone using <span class="synopsis"><code>git</code> <code>revert</code></span>.</p>  <p>The deletion removes the superproject’s tracking data, which are both the <span class="synopsis"><code>gitlink</code></span> entry and the section in the <span class="synopsis"><code>.gitmodules</code></span> file. The submodule’s working directory is removed from the file system, but the Git directory is kept around as it to make it possible to checkout past commits without requiring fetching from another repository.</p>   <p>To completely remove a submodule, manually delete <span class="synopsis"><code>$GIT_DIR/modules/</code><em>&lt;name&gt;</em><code>/</code></span>.</p>  </li> </ul> </div> </div>   <h2 id="_active_submodules">Active submodules</h2> <div class="sectionbody">  <p>A submodule is considered active,</p>  <div class="olist arabic"> <ol class="arabic"> <li> <p>if <span class="synopsis"><code>submodule.</code><em>&lt;name&gt;</em><code>.active</code></span> is set to <span class="synopsis"><code>true</code></span></p>  <p>or</p>  </li> <li> <p>if the submodule’s path matches the pathspec in <span class="synopsis"><code>submodule.active</code></span></p>  <p>or</p>  </li> <li> <p>if <span class="synopsis"><code>submodule.</code><em>&lt;name&gt;</em><code>.url</code></span> is set.</p> </li> </ol> </div>  <p>and these are evaluated in this order.</p>   <p>For example:</p>  <div class="literalblock"> <div class="content"> <pre>[submodule "foo"]
  active = false
  url = https://example.org/foo
[submodule "bar"]
  active = true
  url = https://example.org/bar
[submodule "baz"]
  url = https://example.org/baz</pre> </div> </div>  <p>In the above config only the submodules <code>bar</code> and <code>baz</code> are active, <code>bar</code> due to (1) and <code>baz</code> due to (3). <code>foo</code> is inactive because (1) takes precedence over (3)</p>   <p>Note that (3) is a historical artefact and will be ignored if the (1) and (2) specify that the submodule is not active. In other words, if we have a <span class="synopsis"><code>submodule.</code><em>&lt;name&gt;</em><code>.active</code></span> set to <span class="synopsis"><code>false</code></span> or if the submodule’s path is excluded in the pathspec in <span class="synopsis"><code>submodule.active</code></span>, the url doesn’t matter whether it is present or not. This is illustrated in the example that follows.</p>  <div class="literalblock"> <div class="content"> <pre>[submodule "foo"]
  active = true
  url = https://example.org/foo
[submodule "bar"]
  url = https://example.org/bar
[submodule "baz"]
  url = https://example.org/baz
[submodule "bob"]
  ignore = true
[submodule]
  active = b*
  active = :(exclude) baz</pre> </div> </div>  <p>In here all submodules except <code>baz</code> (foo, bar, bob) are active. <code>foo</code> due to its own active flag and all the others due to the submodule active pathspec, which specifies that any submodule starting with <code>b</code> except <code>baz</code> are also active, regardless of the presence of the .url field.</p>  </div>   <h2 id="_workflow_for_a_third_party_library">Workflow for a third party library</h2> <div class="sectionbody"> <div class="literalblock"> <div class="content"> <pre># Add a submodule
git submodule add &lt;URL&gt; &lt;path&gt;</pre> </div> </div> <div class="literalblock"> <div class="content"> <pre># Occasionally update the submodule to a new version:
git -C &lt;path&gt; checkout &lt;new-version&gt;
git add &lt;path&gt;
git commit -m "update submodule to new version"</pre> </div> </div> <div class="literalblock"> <div class="content"> <pre># See the list of submodules in a superproject
git submodule status</pre> </div> </div> <div class="literalblock"> <div class="content"> <pre># See FORMS on removing submodules</pre> </div> </div> </div>   <h2 id="_workflow_for_an_artificially_split_repo">Workflow for an artificially split repo</h2> <div class="sectionbody"> <div class="literalblock"> <div class="content"> <pre># Enable recursion for relevant commands, such that
# regular commands recurse into submodules by default
git config --global submodule.recurse true</pre> </div> </div> <div class="literalblock"> <div class="content"> <pre># Unlike most other commands below, clone still needs
# its own recurse flag:
git clone --recurse &lt;URL&gt; &lt;directory&gt;
cd &lt;directory&gt;</pre> </div> </div> <div class="literalblock"> <div class="content"> <pre># Get to know the code:
git grep foo
git ls-files --recurse-submodules</pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon"> <div class="title">Note</div> </td> <td class="content"> <span class="synopsis"><code>git</code> <code>ls-files</code></span> also requires its own <span class="synopsis"><code>--recurse-submodules</code></span> flag. </td> </tr> </table> </div> <div class="literalblock"> <div class="content"> <pre># Get new code
git fetch
git pull --rebase</pre> </div> </div> <div class="literalblock"> <div class="content"> <pre># Change worktree
git checkout
git reset</pre> </div> </div> </div>   <h2 id="_implementation_details">Implementation details</h2> <div class="sectionbody">  <p>When cloning or pulling a repository containing submodules the submodules will not be checked out by default; you can instruct <span class="synopsis"><code>clone</code></span> to recurse into submodules. The <span class="synopsis"><code>init</code></span> and <span class="synopsis"><code>update</code></span> subcommands of <span class="synopsis"><code>git</code> <code>submodule</code></span> will maintain submodules checked out and at an appropriate revision in your working tree. Alternatively you can set <span class="synopsis"><code>submodule.recurse</code></span> to have <span class="synopsis"><code>checkout</code></span> recurse into submodules (note that <span class="synopsis"><code>submodule.recurse</code></span> also affects other Git commands, see <a href="git-config">git-config[1]</a> for a complete list).</p>  </div>   <h2 id="_see_also">See also</h2> <div class="sectionbody">  <p><a href="git-submodule">git-submodule[1]</a>, <a href="gitmodules">gitmodules[5]</a>.</p>  </div>      <h3 hidden="true" data-pagefind-weight="10">gitsubmodules</h3><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2025 Linus Torvalds and others<br>Licensed under the GNU General Public License version 2.<br>
    <a href="https://git-scm.com/docs/gitsubmodules" class="_attribution-link">https://git-scm.com/docs/gitsubmodules</a>
  </p>
</div>
