<h1> Command jsontext  </h1>     <p>Package jsontext implements syntactic processing of JSON as specified in RFC 4627, RFC 7159, RFC 7493, RFC 8259, and RFC 8785. JSON is a simple data interchange format that can represent primitive data types such as booleans, strings, and numbers, in addition to structured data types such as objects and arrays. </p>
<p>This package (encoding/json/jsontext) is experimental, and not subject to the Go 1 compatibility promise. It only exists when building with the GOEXPERIMENT=jsonv2 environment variable set. Most users should use <span>encoding/json</span>. </p>
<p>The <a href="#Encoder">Encoder</a> and <a href="#Decoder">Decoder</a> types are used to encode or decode a stream of JSON tokens or values. </p>
<h3 id="hdr-Tokens_and_Values">Tokens and Values</h3> <p>A JSON token refers to the basic structural elements of JSON: </p>
<ul> <li>a JSON literal (i.e., null, true, or false) </li>
<li>a JSON string (e.g., "hello, world!") </li>
<li>a JSON number (e.g., 123.456) </li>
<li>a begin or end delimiter for a JSON object (i.e., '{' or '}') </li>
<li>a begin or end delimiter for a JSON array (i.e., '[' or ']') </li>
</ul> <p>A JSON token is represented by the <a href="#Token">Token</a> type in Go. Technically, there are two additional structural characters (i.e., ':' and ','), but there is no <a href="#Token">Token</a> representation for them since their presence can be inferred by the structure of the JSON grammar itself. For example, there must always be an implicit colon between the name and value of a JSON object member. </p>
<p>A JSON value refers to a complete unit of JSON data: </p>
<ul> <li>a JSON literal, string, or number </li>
<li>a JSON object (e.g., `{"name":"value"}`) </li>
<li>a JSON array (e.g., `[1,2,3,]`) </li>
</ul> <p>A JSON value is represented by the <a href="#Value">Value</a> type in Go and is a []byte containing the raw textual representation of the value. There is some overlap between tokens and values as both contain literals, strings, and numbers. However, only a value can represent the entirety of a JSON object or array. </p>
<p>The <a href="#Encoder">Encoder</a> and <a href="#Decoder">Decoder</a> types contain methods to read or write the next <a href="#Token">Token</a> or <a href="#Value">Value</a> in a sequence. They maintain a state machine to validate whether the sequence of JSON tokens and/or values produces a valid JSON. <a href="#Options">Options</a> may be passed to the <a href="#NewEncoder">NewEncoder</a> or <a href="#NewDecoder">NewDecoder</a> constructors to configure the syntactic behavior of encoding and decoding. </p>
<h3 id="hdr-Terminology">Terminology</h3> <p>The terms "encode" and "decode" are used for syntactic functionality that is concerned with processing JSON based on its grammar, and the terms "marshal" and "unmarshal" are used for semantic functionality that determines the meaning of JSON values as Go values and vice-versa. This package (i.e., <span>jsontext</span>) deals with JSON at a syntactic layer, while <span>encoding/json/v2</span> deals with JSON at a semantic layer. The goal is to provide a clear distinction between functionality that is purely concerned with encoding versus that of marshaling. For example, one can directly encode a stream of JSON tokens without needing to marshal a concrete Go value representing them. Similarly, one can decode a stream of JSON tokens without needing to unmarshal them into a concrete Go value. </p>
<p>This package uses JSON terminology when discussing JSON, which may differ from related concepts in Go or elsewhere in computing literature. </p>
<ul> <li>a JSON "object" refers to an unordered collection of name/value members. </li>
<li>a JSON "array" refers to an ordered sequence of elements. </li>
<li>a JSON "value" refers to either a literal (i.e., null, false, or true), string, number, object, or array. </li>
</ul> <p>See RFC 8259 for more information. </p>
<h3 id="hdr-Specifications">Specifications</h3> <p>Relevant specifications include RFC 4627, RFC 7159, RFC 7493, RFC 8259, and RFC 8785. Each RFC is generally a stricter subset of another RFC. In increasing order of strictness: </p>
<ul> <li>RFC 4627 and RFC 7159 do not require (but recommend) the use of UTF-8 and also do not require (but recommend) that object names be unique. </li>
<li>RFC 8259 requires the use of UTF-8, but does not require (but recommends) that object names be unique. </li>
<li>RFC 7493 requires the use of UTF-8 and also requires that object names be unique. </li>
<li>RFC 8785 defines a canonical representation. It requires the use of UTF-8 and also requires that object names be unique and in a specific ordering. It specifies exactly how strings and numbers must be formatted. </li>
</ul> <p>The primary difference between RFC 4627 and RFC 7159 is that the former restricted top-level values to only JSON objects and arrays, while RFC 7159 and subsequent RFCs permit top-level values to additionally be JSON nulls, booleans, strings, or numbers. </p>
<p>By default, this package operates on RFC 7493, but can be configured to operate according to the other RFC specifications. RFC 7493 is a stricter subset of RFC 8259 and fully compliant with it. In particular, it makes specific choices about behavior that RFC 8259 leaves as undefined in order to ensure greater interoperability. </p>
<h3 id="hdr-Security_Considerations">Security Considerations</h3> <p>See the "Security Considerations" section in <span>encoding/json/v2</span>. </p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="http://golang.org/pkg/encoding/json/jsontext/" class="_attribution-link">http://golang.org/pkg/encoding/json/jsontext/</a>
  </p>
</div>
