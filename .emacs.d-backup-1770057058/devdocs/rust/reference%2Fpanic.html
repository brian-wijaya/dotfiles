 <h1 id="panic">Panic</h1>  <p>Rust provides a mechanism to prevent a function from returning normally, and instead “panic,” which is a response to an error condition that is typically not expected to be recoverable within the context in which the error is encountered.</p>  <p>Some language constructs, such as out-of-bounds <a href="expressions/array-expr#array-and-slice-indexing-expressions">array indexing</a>, panic automatically.</p>  <p>There are also language features that provide a level of control over panic behavior:</p> <ul> <li>A <a href="#the-panic_handler-attribute"><em>panic handler</em></a> defines the behavior of a panic.</li> <li>
<a href="items/functions#unwinding">FFI ABIs</a> may alter how panics behave.</li> </ul> <div class="alert alert-note"> <blockquote> <p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p> <p>The standard library provides the capability to explicitly panic via the <a href="../std/macro.panic"><code>panic!</code> macro</a>.</p> </blockquote> </div>  <h2 id="the-panic_handler-attribute">The <code id="">panic_handler</code> attribute</h2>  <p>The <em><code>panic_handler</code> attribute</em> can be applied to a function to define the behavior of panics.</p>  <p>The <code>panic_handler</code> attribute can only be applied to a function with signature <code>fn(&amp;PanicInfo) -&gt; !</code>.</p> <div class="alert alert-note"> <blockquote> <p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p> <p>The <a href="https://doc.rust-lang.org/core/panic/panic_info/struct.PanicInfo.html"><code>PanicInfo</code></a> struct contains information about the location of the panic.</p> </blockquote> </div>  <p>There must be a single <code>panic_handler</code> function in the dependency graph.</p> <p>Below is shown a <code>panic_handler</code> function that logs the panic message and then halts the thread.</p>  <pre data-language="rust">#![no_std]

use core::fmt::{self, Write};
use core::panic::PanicInfo;

struct Sink {
    // ..
   _0: (),
}

impl Sink {
    fn new() -&gt; Sink { Sink { _0: () }}
}

impl fmt::Write for Sink {
    fn write_str(&amp;mut self, _: &amp;str) -&gt; fmt::Result { Ok(()) }
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    let mut sink = Sink::new();

    // logs "panicked at '$reason', src/main.rs:27:4" to some `sink`
    let _ = writeln!(sink, "{}", info);

    loop {}
}</pre>  <h3 id="standard-behavior">Standard behavior</h3>  <p><code>std</code> provides two different panic handlers:</p> <ul> <li>
<code>unwind</code> — unwinds the stack and is potentially recoverable.</li> <li>
<code>abort</code> –– aborts the process and is non-recoverable.</li> </ul> <p>Not all targets may provide the <code>unwind</code> handler.</p> <div class="alert alert-note"> <blockquote> <p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p> <p>The panic handler used when linking with <code>std</code> can be set with the <a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#panic"><code>-C panic</code></a> CLI flag. The default for most targets is <code>unwind</code>.</p> <p>The standard library’s panic behavior can be modified at runtime with the <a href="../std/panicking/fn.set_hook"><code>std::panic::set_hook</code></a> function.</p> </blockquote> </div>  <p>Linking a <a href="names/preludes#the-no_std-attribute"><code>no_std</code></a> binary, dylib, cdylib, or staticlib will require specifying your own panic handler.</p>  <h2 id="panic-strategy">Panic strategy</h2>  <p>The <em>panic strategy</em> defines the kind of panic behavior that a crate is built to support.</p> <div class="alert alert-note"> <blockquote> <p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p> <p>The panic strategy can be chosen in <code>rustc</code> with the <a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#panic"><code>-C panic</code></a> CLI flag.</p> <p>When generating a binary, dylib, cdylib, or staticlib and linking with <code>std</code>, the <code>-C panic</code> CLI flag also influences which <a href="#the-panic_handler-attribute">panic handler</a> is used.</p> </blockquote> </div> <div class="alert alert-note"> <blockquote> <p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p> <p>When compiling code with the <code>abort</code> panic strategy, the optimizer may assume that unwinding across Rust frames is impossible, which can result in both code-size and runtime speed improvements.</p> </blockquote> </div> <div class="alert alert-note"> <blockquote> <p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p> <p>See <a href="linkage#r-link.unwinding">link.unwinding</a> for restrictions on linking crates with different panic strategies. An implication is that crates built with the <code>unwind</code> strategy can use the <code>abort</code> panic handler, but the <code>abort</code> strategy cannot use the <code>unwind</code> panic handler.</p> </blockquote> </div>  <h2 id="unwinding">Unwinding</h2>  <p>Panicking may either be recoverable or non-recoverable, though it can be configured (by choosing a non-unwinding panic handler) to always be non-recoverable. (The converse is not true: the <code>unwind</code> handler does not guarantee that all panics are recoverable, only that panicking via the <code>panic!</code> macro and similar standard library mechanisms is recoverable.)</p>  <p>When a panic occurs, the <code>unwind</code> handler “unwinds” Rust frames, just as C++’s <code>throw</code> unwinds C++ frames, until the panic reaches the point of recovery (for instance at a thread boundary). This means that as the panic traverses Rust frames, live objects in those frames that <a href="destructors">implement <code>Drop</code></a> will have their <code>drop</code> methods called. Thus, when normal execution resumes, no-longer-accessible objects will have been “cleaned up” just as if they had gone out of scope normally.</p> <div class="alert alert-note"> <blockquote> <p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p> <p>As long as this guarantee of resource-cleanup is preserved, “unwinding” may be implemented without actually using the mechanism used by C++ for the target platform.</p> </blockquote> </div> <div class="alert alert-note"> <blockquote> <p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p> <p>The standard library provides two mechanisms for recovering from a panic, <a href="../std/panic/fn.catch_unwind"><code>std::panic::catch_unwind</code></a> (which enables recovery within the panicking thread) and <a href="../std/thread/fn.spawn"><code>std::thread::spawn</code></a> (which automatically sets up panic recovery for the spawned thread so that other threads may continue running).</p> </blockquote> </div>  <h3 id="unwinding-across-ffi-boundaries">Unwinding across FFI boundaries</h3>  <p>It is possible to unwind across FFI boundaries using an <a href="items/functions#unwinding">appropriate ABI declaration</a>. While useful in certain cases, this creates unique opportunities for undefined behavior, especially when multiple language runtimes are involved.</p>  <p>Unwinding with the wrong ABI is undefined behavior:</p> <ul> <li>Causing an unwind into Rust code from a foreign function that was called via a function declaration or pointer declared with a non-unwinding ABI, such as <code>"C"</code>, <code>"system"</code>, etc. (For example, this case occurs when such a function written in C++ throws an exception that is uncaught and propagates to Rust.)</li> <li>Calling a Rust <code>extern</code> function that unwinds (with <code>extern "C-unwind"</code> or another ABI that permits unwinding) from code that does not support unwinding, such as code compiled with GCC or Clang using <code>-fno-exceptions</code>
</li> </ul>  <p>Catching a foreign unwinding operation (such as a C++ exception) using <a href="../std/panic/fn.catch_unwind"><code>std::panic::catch_unwind</code></a>, <a href="../std/thread/struct.joinhandle#method.join"><code>std::thread::JoinHandle::join</code></a>, or by letting it propagate beyond the Rust <code>main()</code> function or thread root will have one of two behaviors, and it is unspecified which will occur:</p> <ul> <li>The process aborts.</li> <li>The function returns a <a href="https://doc.rust-lang.org/core/result/enum.Result.html#variant.Err"><code>Result::Err</code></a> containing an opaque type.</li> </ul> <div class="alert alert-note"> <blockquote> <p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p> <p>Rust code compiled or linked with a different instance of the Rust standard library counts as a “foreign exception” for the purpose of this guarantee. Thus, a library that uses <code>panic!</code> and is linked against one version of the Rust standard library, invoked from an application that uses a different version of the standard library, may cause the entire application to abort even if the library is only used within a child thread.</p> </blockquote> </div>  <p>There are currently no guarantees about the behavior that occurs when a foreign runtime attempts to dispose of, or rethrow, a Rust <code>panic</code> payload. In other words, an unwind originated from a Rust runtime must either lead to termination of the process or be caught by the same runtime.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/panic.html" class="_attribution-link">https://doc.rust-lang.org/reference/panic.html</a>
  </p>
</div>
