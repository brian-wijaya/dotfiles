<h1 id="error-code-e0309">Error code E0309</h1> <p>A parameter type is missing an explicit lifetime bound and may not live long enough.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
// This won't compile because the applicable impl of
// `SomeTrait` (below) requires that `T: 'a`, but the struct does
// not have a matching where-clause.
struct Foo&lt;'a, T&gt; {
    foo: &lt;T as SomeTrait&lt;'a&gt;&gt;::Output,
}

trait SomeTrait&lt;'a&gt; {
    type Output;
}

impl&lt;'a, T&gt; SomeTrait&lt;'a&gt; for T
where
    T: 'a,
{
    type Output = u32;
}
}</pre> <p>The type definition contains some field whose type requires an outlives annotation. Outlives annotations (e.g., <code>T: 'a</code>) are used to guarantee that all the data in <code>T</code> is valid for at least the lifetime <code>'a</code>. This scenario most commonly arises when the type contains an associated type reference like <code>&lt;T as SomeTrait&lt;'a&gt;&gt;::Output</code>, as shown in the previous code.</p> <p>There, the where clause <code>T: 'a</code> that appears on the impl is not known to be satisfied on the struct. To make this example compile, you have to add a where-clause like <code>T: 'a</code> to the struct definition:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct Foo&lt;'a, T&gt;
where
    T: 'a,
{
    foo: &lt;T as SomeTrait&lt;'a&gt;&gt;::Output
}

trait SomeTrait&lt;'a&gt; {
    type Output;
}

impl&lt;'a, T&gt; SomeTrait&lt;'a&gt; for T
where
    T: 'a,
{
    type Output = u32;
}
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0309.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0309.html</a>
  </p>
</div>
