<h1 id="error-code-e0055">Error code E0055</h1> <p>During a method call, a value is automatically dereferenced as many times as needed to make the value's type match the method's receiver. The catch is that the compiler will only attempt to dereference a number of times up to the recursion limit (which can be set via the <code>recursion_limit</code> attribute).</p> <p>For a somewhat artificial example:</p> <pre data-language="rust">#![recursion_limit="4"]

struct Foo;

impl Foo {
    fn foo(&amp;self) {}
}

fn main() {
    let foo = Foo;
    let ref_foo = &amp;&amp;&amp;&amp;&amp;Foo;

    // error, reached the recursion limit while auto-dereferencing `&amp;&amp;&amp;&amp;&amp;Foo`
    ref_foo.foo();
}</pre> <p>One fix may be to increase the recursion limit. Note that it is possible to create an infinite recursion of dereferencing, in which case the only fix is to somehow break the recursion.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0055.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0055.html</a>
  </p>
</div>
