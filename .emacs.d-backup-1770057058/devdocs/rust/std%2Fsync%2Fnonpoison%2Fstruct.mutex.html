<h1 class="main-heading">Struct Mutex </h1>
<pre class="rust item-decl" data-language="rust">pub struct Mutex&lt;T: ?Sized&gt; { /* private fields */ }</pre>
<span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>nonpoison_mutex</code> <a href="https://github.com/rust-lang/rust/issues/134645">#134645</a>)</span>
</div></span><p>A mutual exclusion primitive useful for protecting shared data that does not keep track of lock poisoning.</p> <p>For more information about mutexes, check out the documentation for the poisoning variant of this lock at <a href="../struct.mutex" title="struct std::sync::Mutex"><code>poison::Mutex</code></a>.</p> <h2 id="examples">Examples</h2> <p>Note that this <code>Mutex</code> does <strong>not</strong> propagate threads that panic while holding the lock via poisoning. If you need this functionality, see <a href="../struct.mutex" title="struct std::sync::Mutex"><code>poison::Mutex</code></a>.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(nonpoison_mutex)]

use std::thread;
use std::sync::{Arc, nonpoison::Mutex};

let mutex = Arc::new(Mutex::new(0u32));
let mut handles = Vec::new();

for n in 0..10 {
    let m = Arc::clone(&amp;mutex);
    let handle = thread::spawn(move || {
        let mut guard = m.lock();
        *guard += 1;
        panic!("panic from thread {n} {guard}")
    });
    handles.push(handle);
}

for h in handles {
    let _ = h.join();
}

println!("Finished, locked {} times", mutex.lock());</pre></div>
<h3 id="implementations" class="section-header">Implementations</h3>
<div id="implementations-list">
<summary><section id="impl-Mutex%3CT%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/nonpoison/mutex.rs.html#158-248">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Mutex&lt;T&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.new" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/nonpoison/mutex.rs.html#172-174">Source</a><pre class="code-header" data-language="rust">pub const fn new(t: T) -&gt; Mutex&lt;T&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>nonpoison_mutex</code> <a href="https://github.com/rust-lang/rust/issues/134645">#134645</a>)</span>
</div></span></summary><div class="docblock">
<p>Creates a new mutex in an unlocked state ready for use.</p> <h5 id="examples-1">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(nonpoison_mutex)]

use std::sync::nonpoison::Mutex;

let mutex = Mutex::new(0);</pre></div>
</div>
<summary><section id="method.get_cloned" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/nonpoison/mutex.rs.html#192-197">Source</a><pre class="code-header" data-language="rust">pub fn get_cloned(&amp;self) -&gt; Twhere
    T: Clone,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>lock_value_accessors</code> <a href="https://github.com/rust-lang/rust/issues/133407">#133407</a>)</span>
</div></span></summary><div class="docblock">
<p>Returns the contained value by cloning it.</p> <h5 id="examples-2">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(nonpoison_mutex)]
#![feature(lock_value_accessors)]

use std::sync::nonpoison::Mutex;

let mut mutex = Mutex::new(7);

assert_eq!(mutex.get_cloned(), 7);</pre></div>
</div>
<summary><section id="method.set" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/nonpoison/mutex.rs.html#217-225">Source</a><pre class="code-header" data-language="rust">pub fn set(&amp;self, value: T)</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>lock_value_accessors</code> <a href="https://github.com/rust-lang/rust/issues/133407">#133407</a>)</span>
</div></span></summary><div class="docblock">
<p>Sets the contained value.</p> <h5 id="examples-3">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(nonpoison_mutex)]
#![feature(lock_value_accessors)]

use std::sync::nonpoison::Mutex;

let mut mutex = Mutex::new(7);

assert_eq!(mutex.get_cloned(), 7);
mutex.set(11);
assert_eq!(mutex.get_cloned(), 11);</pre></div>
</div>
<summary><section id="method.replace" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/nonpoison/mutex.rs.html#244-247">Source</a><pre class="code-header" data-language="rust">pub fn replace(&amp;self, value: T) -&gt; T</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>lock_value_accessors</code> <a href="https://github.com/rust-lang/rust/issues/133407">#133407</a>)</span>
</div></span></summary><div class="docblock">
<p>Replaces the contained value with <code>value</code>, and returns the old contained value.</p> <h5 id="examples-4">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(nonpoison_mutex)]
#![feature(lock_value_accessors)]

use std::sync::nonpoison::Mutex;

let mut mutex = Mutex::new(7);

assert_eq!(mutex.replace(11), 7);
assert_eq!(mutex.get_cloned(), 11);</pre></div>
</div>
</div>
<summary><section id="impl-Mutex%3CT%3E-1" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/nonpoison/mutex.rs.html#250-379">Source</a><pre class="code-header" data-language="rust">impl&lt;T: ?Sized&gt; Mutex&lt;T&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.lock" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/nonpoison/mutex.rs.html#284-289">Source</a><pre class="code-header" data-language="rust">pub fn lock(&amp;self) -&gt; MutexGuard&lt;'_, T&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>nonpoison_mutex</code> <a href="https://github.com/rust-lang/rust/issues/134645">#134645</a>)</span>
</div></span></summary><div class="docblock">
<p>Acquires a mutex, blocking the current thread until it is able to do so.</p> <p>This function will block the local thread until it is available to acquire the mutex. Upon returning, the thread is the only thread with the lock held. An RAII guard is returned to allow scoped unlock of the lock. When the guard goes out of scope, the mutex will be unlocked.</p> <p>The exact behavior on locking a mutex in the thread which already holds the lock is left unspecified. However, this function will not return on the second call (it might panic or deadlock, for example).</p> <h5 id="panics">Panics</h5> <p>This function might panic when called if the lock is already held by the current thread.</p> <h5 id="examples-5">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(nonpoison_mutex)]

use std::sync::{Arc, nonpoison::Mutex};
use std::thread;

let mutex = Arc::new(Mutex::new(0));
let c_mutex = Arc::clone(&amp;mutex);

thread::spawn(move || {
    *c_mutex.lock() = 10;
}).join().expect("thread::spawn failed");
assert_eq!(*mutex.lock(), 10);</pre></div>
</div>
<summary><section id="method.try_lock" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/nonpoison/mutex.rs.html#323-325">Source</a><pre class="code-header" data-language="rust">pub fn try_lock(&amp;self) -&gt; TryLockResult&lt;MutexGuard&lt;'_, T&gt;&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>nonpoison_mutex</code> <a href="https://github.com/rust-lang/rust/issues/134645">#134645</a>)</span>
</div></span></summary><div class="docblock">
<p>Attempts to acquire this lock.</p> <p>This function does not block. If the lock could not be acquired at this time, then <a href="struct.wouldblock" title="struct std::sync::nonpoison::WouldBlock"><code>WouldBlock</code></a> is returned. Otherwise, an RAII guard is returned.</p> <p>The lock will be unlocked when the guard is dropped.</p> <h5 id="errors">Errors</h5> <p>If the mutex could not be acquired because it is already locked, then this call will return the <a href="struct.wouldblock" title="struct std::sync::nonpoison::WouldBlock"><code>WouldBlock</code></a> error.</p> <h5 id="examples-6">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::{Arc, Mutex};
use std::thread;

let mutex = Arc::new(Mutex::new(0));
let c_mutex = Arc::clone(&amp;mutex);

thread::spawn(move || {
    let mut lock = c_mutex.try_lock();
    if let Ok(ref mut mutex) = lock {
        **mutex = 10;
    } else {
        println!("try_lock failed");
    }
}).join().expect("thread::spawn failed");
assert_eq!(*mutex.lock().unwrap(), 10);</pre></div>
</div>
<summary><section id="method.into_inner" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/nonpoison/mutex.rs.html#340-345">Source</a><pre class="code-header" data-language="rust">pub fn into_inner(self) -&gt; Twhere
    T: Sized,</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>nonpoison_mutex</code> <a href="https://github.com/rust-lang/rust/issues/134645">#134645</a>)</span>
</div></span></summary><div class="docblock">
<p>Consumes this mutex, returning the underlying data.</p> <h5 id="examples-7">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(nonpoison_mutex)]

use std::sync::nonpoison::Mutex;

let mutex = Mutex::new(0);
assert_eq!(mutex.into_inner(), 0);</pre></div>
</div>
<summary><section id="method.get_mut" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/nonpoison/mutex.rs.html#364-366">Source</a><pre class="code-header" data-language="rust">pub fn get_mut(&amp;mut self) -&gt; &amp;mut T</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>nonpoison_mutex</code> <a href="https://github.com/rust-lang/rust/issues/134645">#134645</a>)</span>
</div></span></summary><div class="docblock">
<p>Returns a mutable reference to the underlying data.</p> <p>Since this call borrows the <code>Mutex</code> mutably, no actual locking needs to take place â€“ the mutable borrow statically guarantees no locks exist.</p> <h5 id="examples-8">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(nonpoison_mutex)]

use std::sync::nonpoison::Mutex;

let mut mutex = Mutex::new(0);
*mutex.get_mut() = 10;
assert_eq!(*mutex.lock(), 10);</pre></div>
</div>
<summary><section id="method.data_ptr" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/nonpoison/mutex.rs.html#376-378">Source</a><pre class="code-header" data-language="rust">pub fn data_ptr(&amp;self) -&gt; *mut T</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>mutex_data_ptr</code> <a href="https://github.com/rust-lang/rust/issues/140368">#140368</a>)</span>
</div></span></summary><div class="docblock">
<p>Returns a raw pointer to the underlying data.</p> <p>The returned pointer is always non-null and properly aligned, but it is the userâ€™s responsibility to ensure that any reads and writes through it are properly synchronized to avoid data races, and that it is not read or written through after the mutex is dropped.</p> </div>
</div>
</div>
<h3 id="trait-implementations" class="section-header">Trait Implementations</h3>
<div id="trait-implementations-list">
<summary><section id="impl-Debug-for-Mutex%3CT%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/nonpoison/mutex.rs.html#399-412">Source</a><pre class="code-header" data-language="rust">impl&lt;T: ?Sized + Debug&gt; Debug for Mutex&lt;T&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/nonpoison/mutex.rs.html#400-411">Source</a><pre class="code-header" data-language="rust">fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result</pre></section></summary><div class="docblock">Formats the value using the given formatter. <a href="../../fmt/trait.debug#tymethod.fmt">Read more</a>
</div>
</div>
<summary><section id="impl-Default-for-Mutex%3CT%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/nonpoison/mutex.rs.html#391-396">Source</a><pre class="code-header" data-language="rust">impl&lt;T: ?Sized + Default&gt; Default for Mutex&lt;T&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/nonpoison/mutex.rs.html#393-395">Source</a><pre class="code-header" data-language="rust">fn default() -&gt; Mutex&lt;T&gt;</pre></section></summary><div class="docblock">
<p>Creates a <code>Mutex&lt;T&gt;</code>, with the <code>Default</code> value for T.</p> </div>
</div>
<summary><section id="impl-From%3CT%3E-for-Mutex%3CT%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/nonpoison/mutex.rs.html#382-388">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; From&lt;T&gt; for Mutex&lt;T&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/nonpoison/mutex.rs.html#385-387">Source</a><pre class="code-header" data-language="rust">fn from(t: T) -&gt; Self</pre></section></summary><div class="docblock">
<p>Creates a new mutex in an unlocked state ready for use. This is equivalent to <a href="struct.mutex#method.new" title="associated function std::sync::nonpoison::Mutex::new"><code>Mutex::new</code></a>.</p> </div>
</div>
<section id="impl-Send-for-Mutex%3CT%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/nonpoison/mutex.rs.html#60">Source</a><pre class="code-header" data-language="rust">impl&lt;T: ?Sized + Send&gt; Send for Mutex&lt;T&gt;T must be Send for a Mutex to be Send because it is possible to acquire
the owned T from the Mutex via into_inner.
</pre></section><section id="impl-Sync-for-Mutex%3CT%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/sync/nonpoison/mutex.rs.html#79">Source</a><pre class="code-header" data-language="rust">impl&lt;T: ?Sized + Send&gt; Sync for Mutex&lt;T&gt;T must be Send for Mutex to be Sync.
This ensures that the protected data can be accessed safely from multiple threads
without causing data races or other unsafe behavior.
</pre></section><div class="docblock">
<p><a href="struct.mutex" title="struct std::sync::nonpoison::Mutex"><code>Mutex&lt;T&gt;</code></a> provides mutable access to <code>T</code> to one thread at a time. However, itâ€™s essential for <code>T</code> to be <code>Send</code> because itâ€™s not safe for non-<code>Send</code> structures to be accessed in this manner. For instance, consider <a href="../../rc/struct.rc" title="struct std::rc::Rc"><code>Rc</code></a>, a non-atomic reference counted smart pointer, which is not <code>Send</code>. With <code>Rc</code>, we can have multiple copies pointing to the same heap allocation with a non-atomic reference count. If we were to use <code>Mutex&lt;Rc&lt;_&gt;&gt;</code>, it would only protect one instance of <code>Rc</code> from shared access, leaving other copies vulnerable to potential data races.</p> <p>Also note that it is not necessary for <code>T</code> to be <code>Sync</code> as <code>&amp;T</code> is only made available to one thread at a time if <code>T</code> is not <code>Sync</code>.</p> </div>
</div>
<h3 id="synthetic-implementations" class="section-header">Auto Trait Implementations</h3>
<div id="synthetic-implementations-list">
<section id="impl-Freeze-for-Mutex%3CT%3E" class="impl"><pre class="code-header" data-language="rust">impl&lt;T&gt; !Freeze for Mutex&lt;T&gt;</pre></section><section id="impl-RefUnwindSafe-for-Mutex%3CT%3E" class="impl"><pre class="code-header" data-language="rust">impl&lt;T&gt; !RefUnwindSafe for Mutex&lt;T&gt;</pre></section><section id="impl-Unpin-for-Mutex%3CT%3E" class="impl"><pre class="code-header" data-language="rust">impl&lt;T&gt; Unpin for Mutex&lt;T&gt;where
    T: Unpin + ?Sized,</pre></section><section id="impl-UnwindSafe-for-Mutex%3CT%3E" class="impl"><pre class="code-header" data-language="rust">impl&lt;T&gt; UnwindSafe for Mutex&lt;T&gt;where
    T: UnwindSafe + ?Sized,</pre></section>
</div>
<h3 id="blanket-implementations" class="section-header">Blanket Implementations</h3>
<div id="blanket-implementations-list">
<summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/any.rs.html#138">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Any for Twhere
    T: 'static + ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/any.rs.html#139">Source</a><pre class="code-header" data-language="rust">fn type_id(&amp;self) -&gt; TypeId</pre></section></summary><div class="docblock">Gets the <code>TypeId</code> of <code>self</code>. <a href="../../any/trait.any#tymethod.type_id">Read more</a>
</div>
</div>
<summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#212">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Borrow&lt;T&gt; for Twhere
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#214">Source</a><pre class="code-header" data-language="rust">fn borrow(&amp;self) -&gt; &amp;T</pre></section></summary><div class="docblock">Immutably borrows from an owned value. <a href="../../borrow/trait.borrow#tymethod.borrow">Read more</a>
</div>
</div>
<summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#221">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; BorrowMut&lt;T&gt; for Twhere
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#222">Source</a><pre class="code-header" data-language="rust">fn borrow_mut(&amp;mut self) -&gt; &amp;mut T</pre></section></summary><div class="docblock">Mutably borrows from an owned value. <a href="../../borrow/trait.borrowmut#tymethod.borrow_mut">Read more</a>
</div>
</div>
<summary><section id="impl-From%3C!%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#802">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; From&lt;!&gt; for T</pre></section></summary><div class="impl-items">
<summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#803">Source</a><pre class="code-header" data-language="rust">fn from(t: !) -&gt; T</pre></section></summary><div class="docblock">Converts to this type from the input type.</div>
</div>
<summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#785">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; From&lt;T&gt; for T</pre></section></summary><div class="impl-items">
<summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#788">Source</a><pre class="code-header" data-language="rust">fn from(t: T) -&gt; T</pre></section></summary><div class="docblock">
<p>Returns the argument unchanged.</p> </div>
</div>
<summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#767-769">Source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; Into&lt;U&gt; for Twhere
    U: From&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#777">Source</a><pre class="code-header" data-language="rust">fn into(self) -&gt; U</pre></section></summary><div class="docblock">
<p>Calls <code>U::from(self)</code>.</p> <p>That is, this conversion is whatever the implementation of <code><a href="../../convert/trait.from" title="trait std::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p> </div>
</div>
<summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#827-829">Source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; TryFrom&lt;U&gt; for Twhere
    U: Into&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#831">Source</a><pre class="code-header" data-language="rust">type Error = Infallible</pre></section></summary><div class="docblock">The type returned in the event of a conversion error.</div>
<summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#834">Source</a><pre class="code-header" data-language="rust">fn try_from(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</pre></section></summary><div class="docblock">Performs the conversion.</div>
</div>
<summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#811-813">Source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; TryInto&lt;U&gt; for Twhere
    U: TryFrom&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#815">Source</a><pre class="code-header" data-language="rust">type Error = &lt;U as TryFrom&lt;T&gt;&gt;::Error</pre></section></summary><div class="docblock">The type returned in the event of a conversion error.</div>
<summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#818">Source</a><pre class="code-header" data-language="rust">fn try_into(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</pre></section></summary><div class="docblock">Performs the conversion.</div>
</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/sync/nonpoison/struct.Mutex.html" class="_attribution-link">https://doc.rust-lang.org/std/sync/nonpoison/struct.Mutex.html</a>
  </p>
</div>
