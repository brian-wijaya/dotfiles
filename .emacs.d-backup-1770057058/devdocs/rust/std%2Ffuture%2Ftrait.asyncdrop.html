<h1 class="main-heading">Trait AsyncDrop </h1>
<pre class="rust item-decl" data-language="rust">pub trait AsyncDrop {
    // Required method
    async fn drop(self: Pin&lt;&amp;mut Self&gt;);
}</pre>
<span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>async_drop</code> <a href="https://github.com/rust-lang/rust/issues/126482">#126482</a>)</span>
</div></span><p>Async version of Drop trait.</p> <p>When a value is no longer needed, Rust will run a ‚Äúdestructor‚Äù on that value. The most common way that a value is no longer needed is when it goes out of scope. Destructors may still run in other circumstances, but we‚Äôre going to focus on scope for the examples here. To learn about some of those other cases, please see <a href="../../reference/destructors">the reference</a> section on destructors.</p> <h3 id="copy-and-dropasyncdrop-are-exclusive">
<code>Copy</code> and (<code>Drop</code>|<code>AsyncDrop</code>) are exclusive</h3> <p>You cannot implement both <a href="../marker/trait.copy" title="trait std::marker::Copy"><code>Copy</code></a> and (<a href="../ops/trait.drop" title="trait std::ops::Drop"><code>Drop</code></a>|<code>AsyncDrop</code>) on the same type. Types that are <code>Copy</code> get implicitly duplicated by the compiler, making it very hard to predict when, and how often destructors will be executed. As such, these types cannot have destructors.</p> <h3 id="required-methods" class="section-header">Required Methods</h3>
<div class="methods">
<summary><section id="tymethod.drop" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/core/future/async_drop.rs.html#40">Source</a><pre class="code-header" data-language="rust">async fn drop(self: Pin&lt;&amp;mut Self&gt;)</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>async_drop</code> <a href="https://github.com/rust-lang/rust/issues/126482">#126482</a>)</span>
</div></span></summary><div class="docblock">
<p>Executes the async destructor for this type.</p> <p>This method is called implicitly when the value goes out of scope, and cannot be called explicitly.</p> <p>When this method has been called, <code>self</code> has not yet been deallocated. That only happens after the method is over.</p> <h5 id="panics">Panics</h5>
</div>
</div>
<h3 id="dyn-compatibility" class="section-header">Dyn Compatibility</h3>
<div class="dyn-compatibility-info">
<p>This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.91.1/reference/items/traits.html#dyn-compatibility">dyn compatible</a>.</p>
<p><i>In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.</i></p>
</div>
<h3 id="implementors" class="section-header">Implementors</h3>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/future/trait.AsyncDrop.html" class="_attribution-link">https://doc.rust-lang.org/std/future/trait.AsyncDrop.html</a>
  </p>
</div>
