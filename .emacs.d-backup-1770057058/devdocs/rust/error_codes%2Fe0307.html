<h1 id="error-code-e0307">Error code E0307</h1> <p>The <code>self</code> parameter in a method has an invalid "receiver type".</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct Foo;
struct Bar;

trait Trait {
    fn foo(&amp;self);
}

impl Trait for Foo {
    fn foo(self: &amp;Bar) {}
}
}</pre> <p>Methods take a special first parameter, of which there are three variants: <code>self</code>, <code>&amp;self</code>, and <code>&amp;mut self</code>. These are syntactic sugar for <code>self: Self</code>, <code>self: &amp;Self</code>, and <code>self: &amp;mut Self</code> respectively.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct Foo;
trait Trait {
    fn foo(&amp;self);
//         ^^^^^ `self` here is a reference to the receiver object
}

impl Trait for Foo {
    fn foo(&amp;self) {}
//         ^^^^^ the receiver type is `&amp;Foo`
}
}</pre> <p>The type <code>Self</code> acts as an alias to the type of the current trait implementer, or "receiver type". Besides the already mentioned <code>Self</code>, <code>&amp;Self</code> and <code>&amp;mut Self</code> valid receiver types, the following are also valid: <code>self: Box&lt;Self&gt;</code>, <code>self: Rc&lt;Self&gt;</code>, <code>self: Arc&lt;Self&gt;</code>, and <code>self: Pin&lt;P&gt;</code> (where P is one of the previous types except <code>Self</code>). Note that <code>Self</code> can also be the underlying implementing type, like <code>Foo</code> in the following example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct Foo;
trait Trait {
    fn foo(&amp;self);
}
impl Trait for Foo {
    fn foo(self: &amp;Foo) {}
}
}</pre> <p>This error will be emitted by the compiler when using an invalid receiver type, like in the following example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct Foo;
struct Bar;
trait Trait {
    fn foo(&amp;self);
}
impl Trait for Foo {
    fn foo(self: &amp;Bar) {}
}
}</pre> <p>The nightly feature <a href="https://doc.rust-lang.org/unstable-book/language-features/arbitrary-self-types.html">Arbitrary self types</a> extends the accepted set of receiver types to also include any type that implements the <code>Receiver</code> trait and can follow its chain of <code>Target</code> types to <code>Self</code>. There's a blanket implementation of <code>Receiver</code> for <code>T: Deref</code>, so any type which dereferences to <code>Self</code> can be used.</p> <pre data-language="rust">#![allow(unused)]
#![feature(arbitrary_self_types)]

fn main() {
struct Foo;
struct Bar;

// Because you can dereference `Bar` into `Foo`...
impl std::ops::Deref for Bar {
    type Target = Foo;

    fn deref(&amp;self) -&gt; &amp;Foo {
        &amp;Foo
    }
}

impl Foo {
    fn foo(self: Bar) {}
//         ^^^^^^^^^ ...it can be used as the receiver type
}
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0307.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0307.html</a>
  </p>
</div>
