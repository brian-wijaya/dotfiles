<h1 id="error-code-e0772">Error code E0772</h1> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler">Note: this error code is no longer emitted by the compiler.</h4> <p>A trait object has some specific lifetime <code>'1</code>, but it was used in a way that requires it to have a <code>'static</code> lifetime.</p> <p>Example of erroneous code:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait BooleanLike {}
trait Person {}

impl BooleanLike for bool {}

impl dyn Person {
    fn is_cool(&amp;self) -&gt; bool {
        // hey you, you're pretty cool
        true
    }
}

fn get_is_cool&lt;'p&gt;(person: &amp;'p dyn Person) -&gt; impl BooleanLike {
    // error: `person` has an anonymous lifetime `'p` but calling
    //        `print_cool_fn` introduces an implicit `'static` lifetime
    //        requirement
    person.is_cool()
}
}</pre> <p>The trait object <code>person</code> in the function <code>get_is_cool</code>, while already being behind a reference with lifetime <code>'p</code>, also has it's own implicit lifetime, <code>'2</code>.</p> <p>Lifetime <code>'2</code> represents the data the trait object might hold inside, for example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait MyTrait {}

struct MyStruct&lt;'a&gt;(&amp;'a i32);

impl&lt;'a&gt; MyTrait for MyStruct&lt;'a&gt; {}
}</pre> <p>With this scenario, if a trait object of <code>dyn MyTrait + '2</code> was made from <code>MyStruct&lt;'a&gt;</code>, <code>'a</code> must live as long, if not longer than <code>'2</code>. This allows the trait object's internal data to be accessed safely from any trait methods. This rule also goes for any lifetime any struct made into a trait object may have.</p> <p>In the implementation for <code>dyn Person</code>, the <code>'2</code> lifetime representing the internal data was omitted, meaning that the compiler inferred the lifetime <code>'static</code>. As a result, the implementation's <code>is_cool</code> is inferred by the compiler to look like this:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait Person {}

impl dyn Person {
fn is_cool&lt;'a&gt;(self: &amp;'a (dyn Person + 'static)) -&gt; bool {unimplemented!()}
}
}</pre> <p>While the <code>get_is_cool</code> function is inferred to look like this:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait Person {}
trait BooleanLike {}

fn get_is_cool&lt;'p, R: BooleanLike&gt;(person: &amp;'p (dyn Person + 'p)) -&gt; R {
    unimplemented!()
}
}</pre> <p>Which brings us to the core of the problem; the assignment of type <code>&amp;'_ (dyn Person + '_)</code> to type <code>&amp;'_ (dyn Person + 'static)</code> is impossible.</p> <p>Fixing it is as simple as being generic over lifetime <code>'2</code>, as to prevent the compiler from inferring it as <code>'static</code>:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait Person {}

impl&lt;'d&gt; dyn Person + 'd {/* ... */}

// This works too, and is more elegant:
//impl dyn Person + '_ {/* ... */}
}</pre> <p>See the [Rust Reference on Trait Object Lifetime Bounds][trait-objects] for more information on trait object lifetimes.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0772.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0772.html</a>
  </p>
</div>
