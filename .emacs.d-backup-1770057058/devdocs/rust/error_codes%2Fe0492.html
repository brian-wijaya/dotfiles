<h1 id="error-code-e0492">Error code E0492</h1> <p>A borrow of a constant containing interior mutability was attempted.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
use std::sync::atomic::AtomicUsize;

const A: AtomicUsize = AtomicUsize::new(0);
const B: &amp;'static AtomicUsize = &amp;A;
// error: cannot borrow a constant which may contain interior mutability,
//        create a static instead
}</pre> <p>A <code>const</code> represents a constant value that should never change. If one takes a <code>&amp;</code> reference to the constant, then one is taking a pointer to some memory location containing the value. Normally this is perfectly fine: most values can't be changed via a shared <code>&amp;</code> pointer, but interior mutability would allow it. That is, a constant value could be mutated. On the other hand, a <code>static</code> is explicitly a single memory location, which can be mutated at will.</p> <p>So, in order to solve this error, use statics which are <code>Sync</code>:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
use std::sync::atomic::AtomicUsize;

static A: AtomicUsize = AtomicUsize::new(0);
static B: &amp;'static AtomicUsize = &amp;A; // ok!
}</pre> <p>You can also have this error while using a cell type:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
use std::cell::Cell;

const A: Cell&lt;usize&gt; = Cell::new(1);
const B: &amp;Cell&lt;usize&gt; = &amp;A;
// error: cannot borrow a constant which may contain interior mutability,
//        create a static instead

// or:
struct C { a: Cell&lt;usize&gt; }

const D: C = C { a: Cell::new(1) };
const E: &amp;Cell&lt;usize&gt; = &amp;D.a; // error

// or:
const F: &amp;C = &amp;D; // error
}</pre> <p>This is because cell types do operations that are not thread-safe. Due to this, they don't implement Sync and thus can't be placed in statics.</p> <p>However, if you still wish to use these types, you can achieve this by an unsafe wrapper:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
use std::cell::Cell;

struct NotThreadSafe&lt;T&gt; {
    value: Cell&lt;T&gt;,
}

unsafe impl&lt;T&gt; Sync for NotThreadSafe&lt;T&gt; {}

static A: NotThreadSafe&lt;usize&gt; = NotThreadSafe { value : Cell::new(1) };
static B: &amp;'static NotThreadSafe&lt;usize&gt; = &amp;A; // ok!
}</pre> <p>Remember this solution is unsafe! You will have to ensure that accesses to the cell are synchronized.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0492.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0492.html</a>
  </p>
</div>
