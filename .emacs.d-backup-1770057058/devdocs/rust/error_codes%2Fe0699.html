<h1 id="error-code-e0699">Error code E0699</h1> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler">Note: this error code is no longer emitted by the compiler.</h4> <p>A method was called on a raw pointer whose inner type wasn't completely known.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![deny(warnings)]
fn main() {
let foo = &amp;1;
let bar = foo as *const _;
if bar.is_null() {
    // ...
}
}</pre> <p>Here, the type of <code>bar</code> isn't known; it could be a pointer to anything. Instead, specify a type for the pointer (preferably something that makes sense for the thing you're pointing to):</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let foo = &amp;1;
let bar = foo as *const i32;
if bar.is_null() {
    // ...
}
}</pre> <p>Even though <code>is_null()</code> exists as a method on any raw pointer, Rust shows this error because Rust allows for <code>self</code> to have arbitrary types (behind the arbitrary_self_types feature flag).</p> <p>This means that someone can specify such a function:</p> <pre data-language="rust">impl Foo {
    fn is_null(self: *const Self) -&gt; bool {
        // do something else
    }
}</pre> <p>and now when you call <code>.is_null()</code> on a raw pointer to <code>Foo</code>, there's ambiguity.</p> <p>Given that we don't know what type the pointer is, and there's potential ambiguity for some types, we disallow calling methods on raw pointers when the type is unknown.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0699.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0699.html</a>
  </p>
</div>
