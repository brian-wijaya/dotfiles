<h1 id="error-code-e0591">Error code E0591</h1> <p>Per <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md">RFC 401</a>, if you have a function declaration <code>foo</code>:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct S;

// For the purposes of this explanation, all of these
// different kinds of `fn` declarations are equivalent:

fn foo(x: S) { /* ... */ }
#[cfg(for_demonstration_only)]
extern "C" {
    fn foo(x: S);
}
#[cfg(for_demonstration_only)]
impl S {
    fn foo(self) { /* ... */ }
}
}</pre> <p>the type of <code>foo</code> is <strong>not</strong> <code>fn(S)</code>, as one might expect. Rather, it is a unique, zero-sized marker type written here as <code>typeof(foo)</code>. However, <code>typeof(foo)</code> can be <em>coerced</em> to a function pointer <code>fn(S)</code>, so you rarely notice this:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct S;
fn foo(_: S) {}
let x: fn(S) = foo; // OK, coerces
}</pre> <p>The reason that this matter is that the type <code>fn(S)</code> is not specific to any particular function: it's a function <em>pointer</em>. So calling <code>x()</code> results in a virtual call, whereas <code>foo()</code> is statically dispatched, because the type of <code>foo</code> tells us precisely what function is being called.</p> <p>As noted above, coercions mean that most code doesn't have to be concerned with this distinction. However, you can tell the difference when using <strong>transmute</strong> to convert a fn item into a fn pointer.</p> <p>This is sometimes done as part of an FFI:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
extern "C" fn foo(userdata: Box&lt;i32&gt;) {
    /* ... */
}

fn callback(_: extern "C" fn(*mut i32)) {}
use std::mem::transmute;
unsafe {
    let f: extern "C" fn(*mut i32) = transmute(foo);
    callback(f);
}
}</pre> <p>Here, transmute is being used to convert the types of the fn arguments. This pattern is incorrect because the type of <code>foo</code> is a function <strong>item</strong> (<code>typeof(foo)</code>), which is zero-sized, and the target type (<code>fn()</code>) is a function pointer, which is not zero-sized. This pattern should be rewritten. There are a few possible ways to do this:</p> <ul> <li> <p>change the original fn declaration to match the expected signature, and do the cast in the fn body (the preferred option)</p> </li> <li> <p>cast the fn item of a fn pointer before calling transmute, as shown here:</p> <pre># extern "C" fn foo(_: Box&lt;i32&gt;) {}
# use std::mem::transmute;
# unsafe {
let f: extern "C" fn(*mut i32) = transmute(foo as extern "C" fn(_));
let f: extern "C" fn(*mut i32) = transmute(foo as usize); // works too
# }
</pre> </li> </ul> <p>The same applies to transmutes to <code>*mut fn()</code>, which were observed in practice. Note though that use of this type is generally incorrect. The intention is typically to describe a function pointer, but just <code>fn()</code> alone suffices for that. <code>*mut fn()</code> is a pointer to a fn pointer. (Since these values are typically just passed to C code, however, this rarely makes a difference in practice.)</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0591.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0591.html</a>
  </p>
</div>
