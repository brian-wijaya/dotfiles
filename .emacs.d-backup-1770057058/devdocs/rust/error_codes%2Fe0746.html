<h1 id="error-code-e0746">Error code E0746</h1> <p>An unboxed trait object was used as a return value.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait T {
    fn bar(&amp;self);
}
struct S(usize);
impl T for S {
    fn bar(&amp;self) {}
}

// Having the trait `T` as return type is invalid because
// unboxed trait objects do not have a statically known size:
fn foo() -&gt; dyn T { // error!
    S(42)
}
}</pre> <p>Return types cannot be <code>dyn Trait</code>s as they must be <code>Sized</code>.</p> <p>To avoid the error there are a couple of options.</p> <p>If there is a single type involved, you can use <a href="../book/ch10-02-traits#returning-types-that-implement-traits"><code>impl Trait</code></a>:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait T {
    fn bar(&amp;self);
}
struct S(usize);
impl T for S {
    fn bar(&amp;self) {}
}
// The compiler will select `S(usize)` as the materialized return type of this
// function, but callers will only know that the return type implements `T`.
fn foo() -&gt; impl T { // ok!
    S(42)
}
}</pre> <p>If there are multiple types involved, the only way you care to interact with them is through the trait's interface, and having to rely on dynamic dispatch is acceptable, then you can use <a href="../book/ch17-02-trait-objects#using-trait-objects-that-allow-for-values-of-different-types">trait objects</a> with <code>Box</code>, or other container types like <code>Rc</code> or <code>Arc</code>:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait T {
    fn bar(&amp;self);
}
struct S(usize);
impl T for S {
    fn bar(&amp;self) {}
}
struct O(&amp;'static str);
impl T for O {
    fn bar(&amp;self) {}
}

// This now returns a "trait object" and callers are only be able to access
// associated items from `T`.
fn foo(x: bool) -&gt; Box&lt;dyn T&gt; { // ok!
    if x {
        Box::new(S(42))
    } else {
        Box::new(O("val"))
    }
}
}</pre> <p>Finally, if you wish to still be able to access the original type, you can create a new <code>enum</code> with a variant for each type:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait T {
    fn bar(&amp;self);
}
struct S(usize);
impl T for S {
    fn bar(&amp;self) {}
}
struct O(&amp;'static str);
impl T for O {
    fn bar(&amp;self) {}
}
enum E {
    S(S),
    O(O),
}

// The caller can access the original types directly, but it needs to match on
// the returned `enum E`.
fn foo(x: bool) -&gt; E {
    if x {
        E::S(S(42))
    } else {
        E::O(O("val"))
    }
}
}</pre> <p>You can even implement the <code>trait</code> on the returned <code>enum</code> so the callers <em>don't</em> have to match on the returned value to invoke the associated items:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait T {
    fn bar(&amp;self);
}
struct S(usize);
impl T for S {
    fn bar(&amp;self) {}
}
struct O(&amp;'static str);
impl T for O {
    fn bar(&amp;self) {}
}
enum E {
    S(S),
    O(O),
}
impl T for E {
    fn bar(&amp;self) {
        match self {
            E::S(s) =&gt; s.bar(),
            E::O(o) =&gt; o.bar(),
        }
    }
}
}</pre> <p>If you decide to use trait objects, be aware that these rely on <a href="../book/ch17-02-trait-objects#trait-objects-perform-dynamic-dispatch">dynamic dispatch</a>, which has performance implications, as the compiler needs to emit code that will figure out which method to call <em>at runtime</em> instead of during compilation. Using trait objects we are trading flexibility for performance.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0746.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0746.html</a>
  </p>
</div>
