<h1 id="error-code-e0401">Error code E0401</h1> <p>Inner items do not inherit the generic parameters from the items they are embedded in.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo&lt;T&gt;(x: T) {
    fn bar(y: T) { // T is defined in the "outer" function
        // ..
    }
    bar(x);
}
}</pre> <p>Nor will this:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo&lt;T&gt;(x: T) {
    type MaybeT = Option&lt;T&gt;;
    // ...
}
}</pre> <p>Or this:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo&lt;T&gt;(x: T) {
    struct Foo {
        x: T,
    }
    // ...
}
}</pre> <p>Items nested inside other items are basically just like top-level items, except that they can only be used from the item they are in.</p> <p>There are a couple of solutions for this.</p> <p>If the item is a function, you may use a closure:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo&lt;T&gt;(x: T) {
    let bar = |y: T| { // explicit type annotation may not be necessary
        // ..
    };
    bar(x);
}
}</pre> <p>For a generic item, you can copy over the parameters:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo&lt;T&gt;(x: T) {
    fn bar&lt;T&gt;(y: T) {
        // ..
    }
    bar(x);
}
}</pre> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo&lt;T&gt;(x: T) {
    type MaybeT&lt;T&gt; = Option&lt;T&gt;;
}
}</pre> <p>Be sure to copy over any bounds as well:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo&lt;T: Copy&gt;(x: T) {
    fn bar&lt;T: Copy&gt;(y: T) {
        // ..
    }
    bar(x);
}
}</pre> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo&lt;T: Copy&gt;(x: T) {
    struct Foo&lt;T: Copy&gt; {
        x: T,
    }
}
}</pre> <p>This may require additional type hints in the function body.</p> <p>In case the item is a function inside an <code>impl</code>, defining a private helper function might be easier:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct Foo&lt;T&gt;(T);
impl&lt;T&gt; Foo&lt;T&gt; {
    pub fn foo(&amp;self, x: T) {
        self.bar(x);
    }

    fn bar(&amp;self, y: T) {
        // ..
    }
}
}</pre> <p>For default impls in traits, the private helper solution won't work, however closures or copying the parameters should still work.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0401.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0401.html</a>
  </p>
</div>
