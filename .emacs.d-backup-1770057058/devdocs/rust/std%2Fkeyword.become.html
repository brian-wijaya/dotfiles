<h1 class="main-heading">Keyword become </h1>
<p>Perform a tail-call of a function.</p> <div class="warning"> <p><code>feature(explicit_tail_calls)</code> is currently incomplete and may not work properly.</p> </div> <p>When tail calling a function, instead of its stack frame being added to the stack, the stack frame of the caller is directly replaced with the callee’s. This means that as long as a loop in a call graph only uses tail calls, the stack growth will be bounded.</p> <p>This is useful for writing functional-style code (since it prevents recursion from exhausting resources) or for code optimization (since a tail call <em>might</em> be cheaper than a normal call, tail calls can be used in a similar manner to computed goto).</p> <p>Example of using <code>become</code> to implement functional-style <code>fold</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(explicit_tail_calls)]
#![expect(incomplete_features)]

fn fold&lt;T: Copy, S&gt;(slice: &amp;[T], init: S, f: impl Fn(S, T) -&gt; S) -&gt; S {
    match slice {
        // without `become`, on big inputs this could easily overflow the
        // stack. using a tail call guarantees that the stack will not grow unboundedly
        [first, rest @ ..] =&gt; become fold(rest, f(init, *first), f),
        [] =&gt; init,
    }
}</pre></div> <p>Compilers can already perform “tail call optimization” – they can replace normal calls with tail calls, although there are no guarantees that this will be done. However, to perform TCO, the call needs to be the last thing that happens in the functions and be returned from it. This requirement is often broken by drop code for locals, which is run after computing the return expression:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">fn example() {
    let string = "meow".to_owned();
    println!("{string}");
    return help(); // this is *not* the last thing that happens in `example`...
}

// ... because it is desugared to this:
fn example_desugared() {
    let string = "meow".to_owned();
    println!("{string}");
    let tmp = help();
    drop(string);
    return tmp;
}

fn help() {}</pre></div> <p>For this reason, <code>become</code> also changes the drop order, such that locals are dropped <em>before</em> evaluating the call.</p> <p>In order to guarantee that the compiler can perform a tail call, <code>become</code> currently has these requirements:</p> <ol> <li>callee and caller must have the same ABI, arguments, and return type</li> <li>callee and caller must not have varargs</li> <li>caller must not be marked with <code>#[track_caller]</code> <ul> <li>callee is allowed to be marked with <code>#[track_caller]</code> as otherwise adding <code>#[track_caller]</code> would be a breaking change. if callee is marked with <code>#[track_caller]</code> a tail call is not guaranteed.</li> </ul> </li> <li>callee and caller cannot be a closure (unless it’s coerced to a function pointer)</li> </ol> <p>It is possible to tail-call a function pointer:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(explicit_tail_calls)]
#![expect(incomplete_features)]

#[derive(Copy, Clone)]
enum Inst { Inc, Dec }

fn dispatch(stream: &amp;[Inst], state: u32) -&gt; u32 {
    const TABLE: &amp;[fn(&amp;[Inst], u32) -&gt; u32] = &amp;[increment, decrement];
    match stream {
        [inst, rest @ ..] =&gt; become TABLE[*inst as usize](rest, state),
        [] =&gt; state,
    }
}

fn increment(stream: &amp;[Inst], state: u32) -&gt; u32 {
    become dispatch(stream, state + 1)
}

fn decrement(stream: &amp;[Inst], state: u32) -&gt; u32 {
    become dispatch(stream, state - 1)
}

let program = &amp;[Inst::Inc, Inst::Inc, Inst::Dec, Inst::Inc];
assert_eq!(dispatch(program, 0), 2);</pre></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/keyword.become.html" class="_attribution-link">https://doc.rust-lang.org/std/keyword.become.html</a>
  </p>
</div>
