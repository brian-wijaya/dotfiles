<h1 id="error-code-e0139">Error code E0139</h1> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler">Note: this error code is no longer emitted by the compiler.</h4> <p>There are various restrictions on transmuting between types in Rust; for example types being transmuted must have the same size. To apply all these restrictions, the compiler must know the exact types that may be transmuted. When type parameters are involved, this cannot always be done.</p> <p>So, for example, the following is not allowed:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
use std::mem::transmute;

struct Foo&lt;T&gt;(Vec&lt;T&gt;);

fn foo&lt;T&gt;(x: Vec&lt;T&gt;) {
    // we are transmuting between Vec&lt;T&gt; and Foo&lt;F&gt; here
    let y: Foo&lt;T&gt; = unsafe { transmute(x) };
    // do something with y
}
}</pre> <p>In this specific case there's a good chance that the transmute is harmless (but this is not guaranteed by Rust). However, when alignment and enum optimizations come into the picture, it's quite likely that the sizes may or may not match with different type parameter instantiations. It's not possible to check this for <em>all</em> possible types, so <code>transmute()</code> simply only accepts types without any uninstantiated type parameters.</p> <p>If you need this, there's a good chance you're doing something wrong. Keep in mind that Rust doesn't guarantee much about the layout of different structs (even two structs with identical declarations may have different layouts). If there is a solution that avoids the transmute entirely, try it instead.</p> <p>If it's possible, hand-monomorphize the code by writing the function for each possible type instantiation. It's possible to use traits to do this cleanly, for example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
use std::mem::transmute;

struct Foo&lt;T&gt;(Vec&lt;T&gt;);

trait MyTransmutableType: Sized {
    fn transmute(_: Vec&lt;Self&gt;) -&gt; Foo&lt;Self&gt;;
}

impl MyTransmutableType for u8 {
    fn transmute(x: Vec&lt;u8&gt;) -&gt; Foo&lt;u8&gt; {
        unsafe { transmute(x) }
    }
}

impl MyTransmutableType for String {
    fn transmute(x: Vec&lt;String&gt;) -&gt; Foo&lt;String&gt; {
        unsafe { transmute(x) }
    }
}

// ... more impls for the types you intend to transmute

fn foo&lt;T: MyTransmutableType&gt;(x: Vec&lt;T&gt;) {
    let y: Foo&lt;T&gt; = &lt;T as MyTransmutableType&gt;::transmute(x);
    // do something with y
}
}</pre> <p>Each impl will be checked for a size match in the transmute as usual, and since there are no unbound type parameters involved, this should compile unless there is a size mismatch in one of the impls.</p> <p>It is also possible to manually transmute:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
use std::ptr;
let v = Some("value");
type SomeType = &amp;'static [u8];
unsafe {
    ptr::read(&amp;v as *const _ as *const SomeType) // `v` transmuted to `SomeType`
}
;
}</pre> <p>Note that this does not move <code>v</code> (unlike <code>transmute</code>), and may need a call to <code>mem::forget(v)</code> in case you want to avoid destructors being called.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0139.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0139.html</a>
  </p>
</div>
