<h1 id="error-code-e0619">Error code E0619</h1> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler">Note: this error code is no longer emitted by the compiler.</h4> <p>The type-checker needed to know the type of an expression, but that type had not yet been inferred.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let mut x = vec![];
match x.pop() {
    Some(v) =&gt; {
        // Here, the type of `v` is not (yet) known, so we
        // cannot resolve this method call:
        v.to_uppercase(); // error: the type of this value must be known in
                          //        this context
    }
    None =&gt; {}
}
}</pre> <p>Type inference typically proceeds from the top of the function to the bottom, figuring out types as it goes. In some cases -- notably method calls and overloadable operators like <code>*</code> -- the type checker may not have enough information <em>yet</em> to make progress. This can be true even if the rest of the function provides enough context (because the type-checker hasn't looked that far ahead yet). In this case, type annotations can be used to help it along.</p> <p>To fix this error, just specify the type of the variable. Example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let mut x: Vec&lt;String&gt; = vec![]; // We precise the type of the vec elements.
match x.pop() {
    Some(v) =&gt; {
        v.to_uppercase(); // Since rustc now knows the type of the vec elements,
                          // we can use `v`'s methods.
    }
    None =&gt; {}
}
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0619.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0619.html</a>
  </p>
</div>
