<h1 class="main-heading">Function var </h1>
<pre class="rust item-decl" data-language="rust">pub fn var&lt;K: AsRef&lt;OsStr&gt;&gt;(key: K) -&gt; Result&lt;String, VarError&gt;</pre>
<p>Fetches the environment variable <code>key</code> from the current process.</p> <h2 id="errors">Errors</h2> <p>Returns <a href="enum.varerror#variant.NotPresent" title="variant std::env::VarError::NotPresent"><code>VarError::NotPresent</code></a> if:</p> <ul> <li>The variable is not set.</li> <li>The variable’s name contains an equal sign or NUL (<code>'='</code> or <code>'\0'</code>).</li> </ul> <p>Returns <a href="enum.varerror#variant.NotUnicode" title="variant std::env::VarError::NotUnicode"><code>VarError::NotUnicode</code></a> if the variable’s value is not valid Unicode. If this is not desired, consider using <a href="fn.var_os" title="fn std::env::var_os"><code>var_os</code></a>.</p> <p>Use <a href="../macro.env" title="macro std::env"><code>env!</code></a> or <a href="../macro.option_env" title="macro std::option_env"><code>option_env!</code></a> instead if you want to check environment variables at compile time.</p> <h2 id="examples">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::env;

let key = "HOME";
match env::var(key) {
    Ok(val) =&gt; println!("{key}: {val:?}"),
    Err(e) =&gt; println!("couldn't interpret {key}: {e}"),
}</pre></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/env/fn.var.html" class="_attribution-link">https://doc.rust-lang.org/std/env/fn.var.html</a>
  </p>
</div>
