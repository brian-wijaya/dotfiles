<h1 id="error-code-e0794">Error code E0794</h1> <p>A lifetime parameter of a function definition is called <em>late-bound</em> if it both:</p> <ol> <li>appears in an argument type</li> <li>does not appear in a generic type constraint</li> </ol> <p>You cannot specify lifetime arguments for late-bound lifetime parameters.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo&lt;'a&gt;(x: &amp;'a str) -&gt; &amp;'a str { x }
let _ = foo::&lt;'static&gt;;
}</pre> <p>The type of a concrete instance of a generic function is universally quantified over late-bound lifetime parameters. This is because we want the function to work for any lifetime instantiated for the late-bound lifetime parameter, no matter where the function is called. Consequently, it doesn't make sense to specify arguments for late-bound lifetime parameters, since they are not resolved until the function's call site(s).</p> <p>To fix the issue, remove the specified lifetime:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo&lt;'a&gt;(x: &amp;'a str) -&gt; &amp;'a str { x }
let _ = foo;
}</pre> <h3 id="additional-information">Additional information</h3> <p>Lifetime parameters that are not late-bound are called <em>early-bound</em>. Confusion may arise from the fact that late-bound and early-bound lifetime parameters are declared the same way in function definitions. When referring to a function pointer type, universal quantification over late-bound lifetime parameters can be made explicit:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait BarTrait&lt;'a&gt; {}

struct Bar&lt;'a&gt; {
    s: &amp;'a str
}

impl&lt;'a&gt; BarTrait&lt;'a&gt; for Bar&lt;'a&gt; {}

fn bar&lt;'a, 'b, T&gt;(x: &amp;'a str, _t: T) -&gt; &amp;'a str
where T: BarTrait&lt;'b&gt;
{
    x
}

let bar_fn: for&lt;'a&gt; fn(&amp;'a str, Bar&lt;'static&gt;) -&gt; &amp;'a str = bar; // OK
let bar_fn2 = bar::&lt;'static, Bar&gt;; // Not allowed
let bar_fn3 = bar::&lt;Bar&gt;; // OK
}</pre> <p>In the definition of <code>bar</code>, the lifetime parameter <code>'a</code> is late-bound, while <code>'b</code> is early-bound. This is reflected in the type annotation for <code>bar_fn</code>, where <code>'a</code> is universally quantified and <code>'b</code> is instantiated with a specific lifetime. It is not allowed to explicitly specify early-bound lifetime arguments when late-bound lifetime parameters are present (as for <code>bar_fn2</code>, see <a href="https://github.com/rust-lang/rust/issues/42868">issue #42868</a>), although the types that are constrained by early-bound parameters can be specified (as for <code>bar_fn3</code>).</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0794.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0794.html</a>
  </p>
</div>
