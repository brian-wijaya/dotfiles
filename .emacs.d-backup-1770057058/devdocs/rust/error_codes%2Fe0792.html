<h1 id="error-code-e0792">Error code E0792</h1> <p>A type alias impl trait can only have its hidden type assigned when used fully generically (and within their defining scope). This means</p> <pre data-language="rust">#![allow(unused)]
#![feature(type_alias_impl_trait)]

fn main() {
type Foo&lt;T&gt; = impl std::fmt::Debug;

#[define_opaque(Foo)]
fn foo() -&gt; Foo&lt;u32&gt; {
    5u32
}
}</pre> <p>is not accepted. If it were accepted, one could create unsound situations like</p> <pre data-language="rust">#![feature(type_alias_impl_trait)]

type Foo&lt;T&gt; = impl Default;

#[define_opaque(Foo)]
fn foo() -&gt; Foo&lt;u32&gt; {
    5u32
}

fn main() {
    let x = Foo::&lt;&amp;'static mut String&gt;::default();
}</pre> <p>Instead you need to make the function generic:</p> <pre data-language="rust">#![feature(type_alias_impl_trait)]

type Foo&lt;T&gt; = impl std::fmt::Debug;

#[define_opaque(Foo)]
fn foo&lt;U&gt;() -&gt; Foo&lt;U&gt; {
    5u32
}

fn main() {}</pre> <p>This means that no matter the generic parameter to <code>foo</code>, the hidden type will always be <code>u32</code>. If you want to link the generic parameter to the hidden type, you can do that, too:</p> <pre data-language="rust">#![feature(type_alias_impl_trait)]

use std::fmt::Debug;

type Foo&lt;T: Debug&gt; = impl Debug;

#[define_opaque(Foo)]
fn foo&lt;U: Debug&gt;() -&gt; Foo&lt;U&gt; {
    Vec::&lt;U&gt;::new()
}

fn main() {}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0792.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0792.html</a>
  </p>
</div>
