<h1 class="main-heading">Function slice_get_unchecked </h1>
<pre class="rust item-decl" data-language="rust">pub const unsafe fn slice_get_unchecked&lt;ItemPtr, SlicePtr, T&gt;(
    slice_ptr: SlicePtr,
    index: usize,
) -&gt; ItemPtrwhere
    ItemPtr: ChangePointee&lt;[T], Pointee = T, Output = SlicePtr&gt;,</pre>
<span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>core_intrinsics</code>)</span>
</div></span><p>Projects to the <code>index</code>-th element of <code>slice_ptr</code>, as the same kind of pointer as the slice was provided â€“ so <code>&amp;mut [T] â†’ &amp;mut T</code>, <code>&amp;[T] â†’ &amp;T</code>, <code>*mut [T] â†’ *mut T</code>, or <code>*const [T] â†’ *const T</code> â€“ without a bounds check.</p> <p>This is exposed via <code>&lt;usize as SliceIndex&gt;::get(_unchecked)(_mut)</code>, and isnâ€™t intended to be used elsewhere.</p> <p>Expands in MIR to <code>{&amp;, &amp;mut, &amp;raw const, &amp;raw mut} (*slice_ptr)[index]</code>, depending on the types involved, so no backend support is needed.</p> <h2 id="safety">Safety</h2> <ul> <li>
<code>index &lt; PtrMetadata(slice_ptr)</code>, so the indexing is in-bounds for the slice</li> <li>the resulting offsetting is in-bounds of the allocation, which is always the case for references, but needs to be upheld manually for pointers</li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/intrinsics/fn.slice_get_unchecked.html" class="_attribution-link">https://doc.rust-lang.org/std/intrinsics/fn.slice_get_unchecked.html</a>
  </p>
</div>
