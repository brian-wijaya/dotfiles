<h1 id="error-code-e0282">Error code E0282</h1> <p>The compiler could not infer a type and asked for a type annotation.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let x = Vec::new();
}</pre> <p>This error indicates that type inference did not result in one unique possible type, and extra information is required. In most cases this can be provided by adding a type annotation. Sometimes you need to specify a generic type parameter manually.</p> <p>In the example above, type <code>Vec</code> has a type parameter <code>T</code>. When calling <code>Vec::new</code>, barring any other later usage of the variable <code>x</code> that allows the compiler to infer what type <code>T</code> is, the compiler needs to be told what it is.</p> <p>The type can be specified on the variable:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let x: Vec&lt;i32&gt; = Vec::new();
}</pre> <p>The type can also be specified in the path of the expression:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let x = Vec::&lt;i32&gt;::new();
}</pre> <p>In cases with more complex types, it is not necessary to annotate the full type. Once the ambiguity is resolved, the compiler can infer the rest:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let x: Vec&lt;_&gt; = "hello".chars().rev().collect();
}</pre> <p>Another way to provide the compiler with enough information, is to specify the generic type parameter:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let x = "hello".chars().rev().collect::&lt;Vec&lt;char&gt;&gt;();
}</pre> <p>Again, you need not specify the full type if the compiler can infer it:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let x = "hello".chars().rev().collect::&lt;Vec&lt;_&gt;&gt;();
}</pre> <p>Apart from a method or function with a generic type parameter, this error can occur when a type parameter of a struct or trait cannot be inferred. In that case it is not always possible to use a type annotation, because all candidates have the same return type. For instance:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct Foo&lt;T&gt; {
    num: T,
}

impl&lt;T&gt; Foo&lt;T&gt; {
    fn bar() -&gt; i32 {
        0
    }

    fn baz() {
        let number = Foo::bar();
    }
}
}</pre> <p>This will fail because the compiler does not know which instance of <code>Foo</code> to call <code>bar</code> on. Change <code>Foo::bar()</code> to <code>Foo::&lt;T&gt;::bar()</code> to resolve the error.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0282.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0282.html</a>
  </p>
</div>
