 <h1 id="associated-items">Associated Items</h1>  <div class="grammar-container">
<p><strong><sup>Syntax</sup></strong>
<br>
<span class="grammar-text grammar-production" id="grammar-AssociatedItem"><a href="associated-items#railroad-AssociatedItem">AssociatedItem</a></span> → <br>
    <span class="grammar-text"><a href="../attributes#grammar-OuterAttribute">OuterAttribute</a></span><sup>*</sup> ( <br>
        <span class="grammar-text"><a href="../macros#grammar-MacroInvocationSemi">MacroInvocationSemi</a></span> <br>
      | ( <span class="grammar-text"><a href="../visibility-and-privacy#grammar-Visibility">Visibility</a></span><sup>?</sup> ( <span class="grammar-text"><a href="type-aliases#grammar-TypeAlias">TypeAlias</a></span> | <span class="grammar-text"><a href="constant-items#grammar-ConstantItem">ConstantItem</a></span> | <span class="grammar-text"><a href="functions#grammar-Function">Function</a></span> ) ) <br>
    )</p>

<details class="grammar-railroad grammar-hidden"><summary>Syntax diagram</summary> <div style="width: 654px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-AssociatedItem">
<svg class="railroad" viewbox="0 0 654 198" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="associated-items#grammar-AssociatedItem"> <text class="comment" x="64" y="25"> AssociatedItem</text> </a> <g class="sequence"> <path d=" M 10 66 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <g class="sequence"> <g class="optional"> <path d=" M 35 66 h 24 m -24 0 a 12 12 0 0 0 12 -12 v 0 a 12 12 0 0 1 12 -12 h 156 m -75 0 l -5 -5 m 0 10 l 5 -5 m 75 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 0 12 12 h -24"></path> <g class="repeat"> <path d=" M 59 66 h 12 m 132 0 h 12 m -12 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 1 -12 12 m 0 0 h -132 m 69 0 l 5 -5 m 0 10 l -5 -5 m -69 0 a 12 12 0 0 1 -12 -12 v 0 a 12 12 0 0 1 12 -12"></path>  <a class="link" xlink:href="../attributes#railroad-OuterAttribute"> <g class="nonterminal"> <rect height="22" width="132" x="71" y="55"></rect> <text x="137" y="71"> OuterAttribute</text> </g> </a> </g> </g> <g class="choice"> <path d=" M 249 66 h 24 m 172 0 h 174 m -84 0 l -5 -5 m 0 10 l 5 -5 m 84 0"></path> <g class="sequence"> <a class="link" xlink:href="../macros#railroad-MacroInvocationSemi"> <g class="nonterminal"> <rect height="22" width="172" x="273" y="55"></rect> <text x="359" y="71"> MacroInvocationSemi</text> </g> </a> </g> <path d=" M 249 66 a 12 12 0 0 1 12 12 v 9 m 346 0 v -9 a 12 12 0 0 1 12 -12"></path> <path d=" M 261 87 v 12 a 12 12 0 0 0 12 12 m 322 0 h 0 a 12 12 0 0 0 12 -12 v -12"></path> <g class="sequence"> <g class="sequence"> <g class="optional"> <path d=" M 273 111 h 24 m -24 0 a 12 12 0 0 0 12 -12 v 0 a 12 12 0 0 1 12 -12 h 100 m -47 0 l -5 -5 m 0 10 l 5 -5 m 47 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 0 12 12 h -24"></path> <a class="link" xlink:href="../visibility-and-privacy#railroad-Visibility"> <g class="nonterminal"> <rect height="22" width="100" x="297" y="100"></rect> <text x="347" y="116"> Visibility</text> </g> </a> </g> <g class="choice"> <path d=" M 431 111 h 24 m 92 0 h 48"></path> <a class="link" xlink:href="type-aliases#railroad-TypeAlias"> <g class="nonterminal"> <rect height="22" width="92" x="455" y="100"></rect> <text x="501" y="116"> TypeAlias</text> </g> </a> <path d=" M 431 111 a 12 12 0 0 1 12 12 v 9 m 140 0 v -9 a 12 12 0 0 1 12 -12"></path> <path d=" M 443 132 v 33 m 140 0 v -33"></path> <path d=" M 443 132 v 0 a 12 12 0 0 0 12 12 m 116 0 h 0 a 12 12 0 0 0 12 -12 v 0"></path> <a class="link" xlink:href="constant-items#railroad-ConstantItem"> <g class="nonterminal"> <rect height="22" width="116" x="455" y="133"></rect> <text x="513" y="149"> ConstantItem</text> </g> </a> <path d=" M 443 165 v 0 a 12 12 0 0 0 12 12 m 84 0 h 32 a 12 12 0 0 0 12 -12 v 0"></path> <a class="link" xlink:href="functions#railroad-Function"> <g class="nonterminal"> <rect height="22" width="84" x="455" y="166"></rect> <text x="497" y="182"> Function</text> </g> </a> </g> <path d=" M 421 111 h 10"></path> </g> </g> </g> <path d=" M 239 66 h 10"></path> </g> <path d=" M 629 66 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 66 h 10"></path> <path d=" M 619 66 h 10"></path> </g> </g> </svg> </div> </details>
</div>   <p><em>Associated Items</em> are the items declared in <a href="traits">traits</a> or defined in <a href="implementations">implementations</a>. They are called this because they are defined on an associate type — the type in the implementation.</p>  <p>They are a subset of the kinds of items you can declare in a module. Specifically, there are <a href="#associated-functions-and-methods">associated functions</a> (including methods), <a href="#associated-types">associated types</a>, and <a href="#associated-constants">associated constants</a>.</p>  <p>Associated items are useful when the associated item is logically related to the associating item. For example, the <code>is_some</code> method on <code>Option</code> is intrinsically related to Options, so should be associated.</p>  <p>Every associated item kind comes in two varieties: definitions that contain the actual implementation and declarations that declare signatures for definitions.</p>  <p>It is the declarations that make up the contract of traits and what is available on generic types.</p>  <h2 id="associated-functions-and-methods">Associated functions and methods</h2>  <p><em>Associated functions</em> are <a href="functions">functions</a> associated with a type.</p>  <p>An <em>associated function declaration</em> declares a signature for an associated function definition. It is written as a function item, except the function body is replaced with a <code>;</code>.</p>  <p>The identifier is the name of the function.</p>  <p>The generics, parameter list, return type, and where clause of the associated function must be the same as the associated function declarations’s.</p>  <p>An <em>associated function definition</em> defines a function associated with another type. It is written the same as a <a href="../types/function-item">function item</a>.</p> <div class="alert alert-note"> <blockquote> <p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p> <p>A common example is an associated function named <code>new</code> that returns a value of the type with which it is associated.</p> </blockquote> </div> <pre data-language="rust">struct Struct {
    field: i32
}

impl Struct {
    fn new() -&gt; Struct {
        Struct {
            field: 0i32
        }
    }
}

fn main () {
    let _struct = Struct::new();
}</pre>  <p>When the associated function is declared on a trait, the function can also be called with a <a href="../paths">path</a> that is a path to the trait appended by the name of the trait. When this happens, it is substituted for <code>&lt;_ as Trait&gt;::function_name</code>.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait Num {
    fn from_i32(n: i32) -&gt; Self;
}

impl Num for f64 {
    fn from_i32(n: i32) -&gt; f64 { n as f64 }
}

// These 4 are all equivalent in this case.
let _: f64 = Num::from_i32(42);
let _: f64 = &lt;_ as Num&gt;::from_i32(42);
let _: f64 = &lt;f64 as Num&gt;::from_i32(42);
let _: f64 = f64::from_i32(42);
}</pre>  <h3 id="methods">Methods</h3>  <p>Associated functions whose first parameter is named <code>self</code> are called <em>methods</em> and may be invoked using the <a href="../expressions/method-call-expr">method call operator</a>, for example, <code>x.foo()</code>, as well as the usual function call notation.</p>  <p>If the type of the <code>self</code> parameter is specified, it is limited to types resolving to one generated by the following grammar (where <code>'lt</code> denotes some arbitrary lifetime):</p> <pre>P = &amp;'lt S | &amp;'lt mut S | Box&lt;S&gt; | Rc&lt;S&gt; | Arc&lt;S&gt; | Pin&lt;P&gt;
S = Self | P
</pre> <p>The <code>Self</code> terminal in this grammar denotes a type resolving to the implementing type. This can also include the contextual type alias <code>Self</code>, other type aliases, or associated type projections resolving to the implementing type.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
use std::rc::Rc;
use std::sync::Arc;
use std::pin::Pin;
// Examples of methods implemented on struct `Example`.
struct Example;
type Alias = Example;
trait Trait { type Output; }
impl Trait for Example { type Output = Example; }
impl Example {
    fn by_value(self: Self) {}
    fn by_ref(self: &amp;Self) {}
    fn by_ref_mut(self: &amp;mut Self) {}
    fn by_box(self: Box&lt;Self&gt;) {}
    fn by_rc(self: Rc&lt;Self&gt;) {}
    fn by_arc(self: Arc&lt;Self&gt;) {}
    fn by_pin(self: Pin&lt;&amp;Self&gt;) {}
    fn explicit_type(self: Arc&lt;Example&gt;) {}
    fn with_lifetime&lt;'a&gt;(self: &amp;'a Self) {}
    fn nested&lt;'a&gt;(self: &amp;mut &amp;'a Arc&lt;Rc&lt;Box&lt;Alias&gt;&gt;&gt;) {}
    fn via_projection(self: &lt;Example as Trait&gt;::Output) {}
}
}</pre>  <p>Shorthand syntax can be used without specifying a type, which have the following equivalents:</p> <div class="table-wrapper">
<table>
<thead><tr>
<th>Shorthand</th>
<th>Equivalent</th>
</tr></thead>
<tbody> <tr>
<td><code>self</code></td>
<td><code>self: Self</code></td>
</tr> <tr>
<td><code>&amp;'lifetime self</code></td>
<td><code>self: &amp;'lifetime Self</code></td>
</tr> <tr>
<td><code>&amp;'lifetime mut self</code></td>
<td><code>self: &amp;'lifetime mut Self</code></td>
</tr> </tbody>
</table> </div>
<div class="alert alert-note"> <blockquote> <p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p> <p>Lifetimes can be, and usually are, elided with this shorthand.</p> </blockquote> </div>  <p>If the <code>self</code> parameter is prefixed with <code>mut</code>, it becomes a mutable variable, similar to regular parameters using a <code>mut</code> <a href="../patterns#identifier-patterns">identifier pattern</a>. For example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait Changer: Sized {
    fn change(mut self) {}
    fn modify(mut self: Box&lt;Self&gt;) {}
}
}</pre> <p>As an example of methods on a trait, consider the following:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
type Surface = i32;
type BoundingBox = i32;
trait Shape {
    fn draw(&amp;self, surface: Surface);
    fn bounding_box(&amp;self) -&gt; BoundingBox;
}
}</pre> <p>This defines a trait with two methods. All values that have <a href="implementations">implementations</a> of this trait while the trait is in scope can have their <code>draw</code> and <code>bounding_box</code> methods called.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
type Surface = i32;
type BoundingBox = i32;
trait Shape {
    fn draw(&amp;self, surface: Surface);
    fn bounding_box(&amp;self) -&gt; BoundingBox;
}

struct Circle {
    // ...
}

impl Shape for Circle {
    // ...
  fn draw(&amp;self, _: Surface) {}
  fn bounding_box(&amp;self) -&gt; BoundingBox { 0i32 }
}

impl Circle {
    fn new() -&gt; Circle { Circle{} }
}

let circle_shape = Circle::new();
let bounding_box = circle_shape.bounding_box();
}</pre>  <div class="alert alert-edition"> <blockquote> <p class="alert-title"><span class="alert-title-edition">2018</span> Edition differences</p> <p>In the 2015 edition, it is possible to declare trait methods with anonymous parameters (e.g. <code>fn foo(u8)</code>). This is deprecated and an error as of the 2018 edition. All parameters must have an argument name.</p> </blockquote> </div>  <h4 id="attributes-on-method-parameters">Attributes on method parameters</h4> <p>Attributes on method parameters follow the same rules and restrictions as <a href="functions#attributes-on-function-parameters">regular function parameters</a>.</p>  <h2 id="associated-types">Associated Types</h2>  <p><em>Associated types</em> are <a href="type-aliases">type aliases</a> associated with another type.</p>  <p>Associated types cannot be defined in <a href="implementations#inherent-implementations">inherent implementations</a> nor can they be given a default implementation in traits.</p>  <p>An <em>associated type declaration</em> declares a signature for associated type definitions. It is written in one of the following forms, where <code>Assoc</code> is the name of the associated type, <code>Params</code> is a comma-separated list of type, lifetime or const parameters, <code>Bounds</code> is a plus-separated list of trait bounds that the associated type must meet, and <code>WhereBounds</code> is a comma-separated list of bounds that the parameters must meet:</p>  <pre data-language="rust">type Assoc;
type Assoc: Bounds;
type Assoc&lt;Params&gt;;
type Assoc&lt;Params&gt;: Bounds;
type Assoc&lt;Params&gt; where WhereBounds;
type Assoc&lt;Params&gt;: Bounds where WhereBounds;</pre>  <p>The identifier is the name of the declared type alias.</p>  <p>The optional trait bounds must be fulfilled by the implementations of the type alias.</p>  <p>There is an implicit <a href="../special-types-and-traits#sized"><code>Sized</code></a> bound on associated types that can be relaxed using the special <code>?Sized</code> bound.</p>  <p>An <em>associated type definition</em> defines a type alias for the implementation of a trait on a type</p>  <p>They are written similarly to an <em>associated type declaration</em>, but cannot contain <code>Bounds</code>, but instead must contain a <code>Type</code>:</p>  <pre data-language="rust">type Assoc = Type;
type Assoc&lt;Params&gt; = Type; // the type `Type` here may reference `Params`
type Assoc&lt;Params&gt; = Type where WhereBounds;
type Assoc&lt;Params&gt; where WhereBounds = Type; // deprecated, prefer the form above</pre>  <p>If a type <code>Item</code> has an associated type <code>Assoc</code> from a trait <code>Trait</code>, then <code>&lt;Item as Trait&gt;::Assoc</code> is a type that is an alias of the type specified in the associated type definition</p>  <p>Furthermore, if <code>Item</code> is a type parameter, then <code>Item::Assoc</code> can be used in type parameters.</p>  <p>Associated types may include <a href="generics">generic parameters</a> and <a href="generics#where-clauses">where clauses</a>; these are often referred to as <em>generic associated types</em>, or <em>GATs</em>. If the type <code>Thing</code> has an associated type <code>Item</code> from a trait <code>Trait</code> with the generics <code>&lt;'a&gt;</code> , the type can be named like <code>&lt;Thing as Trait&gt;::Item&lt;'x&gt;</code>, where <code>'x</code> is some lifetime in scope. In this case, <code>'x</code> will be used wherever <code>'a</code> appears in the associated type definitions on impls.</p> <pre data-language="rust">trait AssociatedType {
    // Associated type declaration
    type Assoc;
}

struct Struct;

struct OtherStruct;

impl AssociatedType for Struct {
    // Associated type definition
    type Assoc = OtherStruct;
}

impl OtherStruct {
    fn new() -&gt; OtherStruct {
        OtherStruct
    }
}

fn main() {
    // Usage of the associated type to refer to OtherStruct as &lt;Struct as AssociatedType&gt;::Assoc
    let _other_struct: OtherStruct = &lt;Struct as AssociatedType&gt;::Assoc::new();
}</pre> <p>An example of associated types with generics and where clauses:</p> <pre data-language="rust">struct ArrayLender&lt;'a, T&gt;(&amp;'a mut [T; 16]);

trait Lend {
    // Generic associated type declaration
    type Lender&lt;'a&gt; where Self: 'a;
    fn lend&lt;'a&gt;(&amp;'a mut self) -&gt; Self::Lender&lt;'a&gt;;
}

impl&lt;T&gt; Lend for [T; 16] {
    // Generic associated type definition
    type Lender&lt;'a&gt; = ArrayLender&lt;'a, T&gt; where Self: 'a;

    fn lend&lt;'a&gt;(&amp;'a mut self) -&gt; Self::Lender&lt;'a&gt; {
        ArrayLender(self)
    }
}

fn borrow&lt;'a, T: Lend&gt;(array: &amp;'a mut T) -&gt; &lt;T as Lend&gt;::Lender&lt;'a&gt; {
    array.lend()
}

fn main() {
    let mut array = [0usize; 16];
    let lender = borrow(&amp;mut array);
}</pre> <h3 id="associated-types-container-example">Associated Types Container Example</h3> <p>Consider the following example of a <code>Container</code> trait. Notice that the type is available for use in the method signatures:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait Container {
    type E;
    fn empty() -&gt; Self;
    fn insert(&amp;mut self, elem: Self::E);
}
}</pre> <p>In order for a type to implement this trait, it must not only provide implementations for every method, but it must specify the type <code>E</code>. Here’s an implementation of <code>Container</code> for the standard library type <code>Vec</code>:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait Container {
    type E;
    fn empty() -&gt; Self;
    fn insert(&amp;mut self, elem: Self::E);
}
impl&lt;T&gt; Container for Vec&lt;T&gt; {
    type E = T;
    fn empty() -&gt; Vec&lt;T&gt; { Vec::new() }
    fn insert(&amp;mut self, x: T) { self.push(x); }
}
}</pre> <h3 id="relationship-between-bounds-and-wherebounds">Relationship between <code id="">Bounds</code> and <code>WhereBounds</code>
</h3> <p>In this example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
use std::fmt::Debug;
trait Example {
    type Output&lt;T&gt;: Ord where T: Debug;
}
}</pre> <p>Given a reference to the associated type like <code>&lt;X as Example&gt;::Output&lt;Y&gt;</code>, the associated type itself must be <code>Ord</code>, and the type <code>Y</code> must be <code>Debug</code>.</p>  <h3 id="required-where-clauses-on-generic-associated-types">Required where clauses on generic associated types</h3>  <p>Generic associated type declarations on traits currently may require a list of where clauses, dependent on functions in the trait and how the GAT is used. These rules may be loosened in the future; updates can be found <a href="https://rust-lang.github.io/generic-associated-types-initiative/explainer/required_bounds.html">on the generic associated types initiative repository</a>.</p>  <p>In a few words, these where clauses are required in order to maximize the allowed definitions of the associated type in impls. To do this, any clauses that <em>can be proven to hold</em> on functions (using the parameters of the function or trait) where a GAT appears as an input or output must also be written on the GAT itself.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait LendingIterator {
    type Item&lt;'x&gt; where Self: 'x;
    fn next&lt;'a&gt;(&amp;'a mut self) -&gt; Self::Item&lt;'a&gt;;
}
}</pre> <p>In the above, on the <code>next</code> function, we can prove that <code>Self: 'a</code>, because of the implied bounds from <code>&amp;'a mut self</code>; therefore, we must write the equivalent bound on the GAT itself: <code>where Self: 'x</code>.</p>  <p>When there are multiple functions in a trait that use the GAT, then the <em>intersection</em> of the bounds from the different functions are used, rather than the union.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait Check&lt;T&gt; {
    type Checker&lt;'x&gt;;
    fn create_checker&lt;'a&gt;(item: &amp;'a T) -&gt; Self::Checker&lt;'a&gt;;
    fn do_check(checker: Self::Checker&lt;'_&gt;);
}
}</pre> <p>In this example, no bounds are required on the <code>type Checker&lt;'a&gt;;</code>. While we know that <code>T: 'a</code> on <code>create_checker</code>, we do not know that on <code>do_check</code>. However, if <code>do_check</code> was commented out, then the <code>where T: 'x</code> bound would be required on <code>Checker</code>.</p>  <p>The bounds on associated types also propagate required where clauses.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait Iterable {
    type Item&lt;'a&gt; where Self: 'a;
    type Iterator&lt;'a&gt;: Iterator&lt;Item = Self::Item&lt;'a&gt;&gt; where Self: 'a;
    fn iter&lt;'a&gt;(&amp;'a self) -&gt; Self::Iterator&lt;'a&gt;;
}
}</pre> <p>Here, <code>where Self: 'a</code> is required on <code>Item</code> because of <code>iter</code>. However, <code>Item</code> is used in the bounds of <code>Iterator</code>, the <code>where Self: 'a</code> clause is also required there.</p>  <p>Finally, any explicit uses of <code>'static</code> on GATs in the trait do not count towards the required bounds.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait StaticReturn {
    type Y&lt;'a&gt;;
    fn foo(&amp;self) -&gt; Self::Y&lt;'static&gt;;
}
}</pre>  <h2 id="associated-constants">Associated Constants</h2>  <p><em>Associated constants</em> are <a href="constant-items">constants</a> associated with a type.</p>  <p>An <em>associated constant declaration</em> declares a signature for associated constant definitions. It is written as <code>const</code>, then an identifier, then <code>:</code>, then a type, finished by a <code>;</code>.</p>  <p>The identifier is the name of the constant used in the path. The type is the type that the definition has to implement.</p>  <p>An <em>associated constant definition</em> defines a constant associated with a type. It is written the same as a <a href="constant-items">constant item</a>.</p>  <p>Associated constant definitions undergo <a href="../const_eval">constant evaluation</a> only when referenced. Further, definitions that include <a href="generics">generic parameters</a> are evaluated after monomorphization.</p> <pre data-language="rust">struct Struct;
struct GenericStruct&lt;const ID: i32&gt;;

impl Struct {
    // Definition not immediately evaluated
    const PANIC: () = panic!("compile-time panic");
}

impl&lt;const ID: i32&gt; GenericStruct&lt;ID&gt; {
    // Definition not immediately evaluated
    const NON_ZERO: () = if ID == 0 {
        panic!("contradiction")
    };
}

fn main() {
    // Referencing Struct::PANIC causes compilation error
    let _ = Struct::PANIC;

    // Fine, ID is not 0
    let _ = GenericStruct::&lt;1&gt;::NON_ZERO;

    // Compilation error from evaluating NON_ZERO with ID=0
    let _ = GenericStruct::&lt;0&gt;::NON_ZERO;
}</pre> <h3 id="associated-constants-examples">Associated Constants Examples</h3> <p>A basic example:</p> <pre data-language="rust">trait ConstantId {
    const ID: i32;
}

struct Struct;

impl ConstantId for Struct {
    const ID: i32 = 1;
}

fn main() {
    assert_eq!(1, Struct::ID);
}</pre> <p>Using default values:</p> <pre data-language="rust">trait ConstantIdDefault {
    const ID: i32 = 1;
}

struct Struct;
struct OtherStruct;

impl ConstantIdDefault for Struct {}

impl ConstantIdDefault for OtherStruct {
    const ID: i32 = 5;
}

fn main() {
    assert_eq!(1, Struct::ID);
    assert_eq!(5, OtherStruct::ID);
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/items/associated-items.html" class="_attribution-link">https://doc.rust-lang.org/reference/items/associated-items.html</a>
  </p>
</div>
