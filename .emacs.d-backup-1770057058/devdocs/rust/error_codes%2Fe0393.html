<h1 id="error-code-e0393">Error code E0393</h1> <p>A type parameter which references <code>Self</code> in its default value was not specified.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait A&lt;T = Self&gt; {}

fn together_we_will_rule_the_galaxy(son: &amp;dyn A) {}
// error: the type parameter `T` must be explicitly specified
}</pre> <p>A trait object is defined over a single, fully-defined trait. With a regular default parameter, this parameter can just be instantiated in. However, if the default parameter is <code>Self</code>, the trait changes for each concrete type; i.e. <code>i32</code> will be expected to implement <code>A&lt;i32&gt;</code>, <code>bool</code> will be expected to implement <code>A&lt;bool&gt;</code>, etc... These types will not share an implementation of a fully-defined trait; instead they share implementations of a trait with different parameters instantiated in for each implementation. This is irreconcilable with what we need to make a trait object work, and is thus disallowed. Making the trait concrete by explicitly specifying the value of the defaulted parameter will fix this issue. Fixed example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait A&lt;T = Self&gt; {}

fn together_we_will_rule_the_galaxy(son: &amp;dyn A&lt;i32&gt;) {} // Ok!
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0393.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0393.html</a>
  </p>
</div>
