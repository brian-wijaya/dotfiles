<h1 id="error-code-e0573">Error code E0573</h1> <p>Something other than a type has been used when one was expected.</p> <p>Erroneous code examples:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
enum Dragon {
    Born,
}

fn oblivion() -&gt; Dragon::Born { // error!
    Dragon::Born
}

const HOBBIT: u32 = 2;
impl HOBBIT {} // error!

enum Wizard {
    Gandalf,
    Saruman,
}

trait Isengard {
    fn wizard(_: Wizard::Saruman); // error!
}
}</pre> <p>In all these errors, a type was expected. For example, in the first error, if we want to return the <code>Born</code> variant from the <code>Dragon</code> enum, we must set the function to return the enum and not its variant:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
enum Dragon {
    Born,
}

fn oblivion() -&gt; Dragon { // ok!
    Dragon::Born
}
}</pre> <p>In the second error, you can't implement something on an item, only on types. We would need to create a new type if we wanted to do something similar:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct Hobbit(u32); // we create a new type

const HOBBIT: Hobbit = Hobbit(2);
impl Hobbit {} // ok!
}</pre> <p>In the third case, we tried to only expect one variant of the <code>Wizard</code> enum, which is not possible. To make this work, we need to using pattern matching over the <code>Wizard</code> enum:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
enum Wizard {
    Gandalf,
    Saruman,
}

trait Isengard {
    fn wizard(w: Wizard) { // ok!
        match w {
            Wizard::Saruman =&gt; {
                // do something
            }
            _ =&gt; {} // ignore everything else
        }
    }
}
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0573.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0573.html</a>
  </p>
</div>
