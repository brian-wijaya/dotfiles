 <h1 id="call-expressions">Call expressions</h1>  <div class="grammar-container">
<p><strong><sup>Syntax</sup></strong>
<br>
<span class="grammar-text grammar-production" id="grammar-CallExpression"><a href="call-expr#railroad-CallExpression">CallExpression</a></span> → <span class="grammar-text"><a href="../expressions#grammar-Expression">Expression</a></span> <code class="grammar-literal">(</code> <span class="grammar-text"><a href="call-expr#grammar-CallParams">CallParams</a></span><sup>?</sup> <code class="grammar-literal">)</code></p>
<p><span class="grammar-text grammar-production" id="grammar-CallParams"><a href="call-expr#railroad-CallParams">CallParams</a></span> → <span class="grammar-text"><a href="../expressions#grammar-Expression">Expression</a></span> ( <code class="grammar-literal">,</code> <span class="grammar-text"><a href="../expressions#grammar-Expression">Expression</a></span> )<sup>*</sup> <code class="grammar-literal">,</code><sup>?</sup></p>

<details class="grammar-railroad grammar-hidden"><summary>Syntax diagram</summary> <div style="width: 404px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-CallExpression">
<svg class="railroad" viewbox="0 0 404 87" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="call-expr#grammar-CallExpression"> <text class="comment" x="64" y="25"> CallExpression</text> </a> <g class="sequence"> <path d=" M 10 66 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <g class="sequence"> <a class="link" xlink:href="../expressions#railroad-Expression"> <g class="nonterminal"> <rect height="22" width="100" x="35" y="55"></rect> <text x="85" y="71"> Expression</text> </g> </a> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="145" y="55"></rect> <text x="159" y="71"> (</text> </g> <g class="optional"> <path d=" M 183 66 h 24 m -24 0 a 12 12 0 0 0 12 -12 v 0 a 12 12 0 0 1 12 -12 h 100 m -47 0 l -5 -5 m 0 10 l 5 -5 m 47 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 0 12 12 h -24"></path> <a class="link" xlink:href="call-expr#railroad-CallParams"> <g class="nonterminal"> <rect height="22" width="100" x="207" y="55"></rect> <text x="257" y="71"> CallParams</text> </g> </a> </g> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="341" y="55"></rect> <text x="355" y="71"> )</text> </g> <path d=" M 135 66 h 10"></path> <path d=" M 173 66 h 10"></path> <path d=" M 331 66 h 10"></path> </g> <path d=" M 379 66 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 66 h 10"></path> <path d=" M 369 66 h 10"></path> </g> </g> </svg> </div> <div style="width: 476px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-CallParams">
<svg class="railroad" viewbox="0 0 476 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="call-expr#grammar-CallParams"> <text class="comment" x="50" y="25"> CallParams</text> </a> <g class="sequence"> <path d=" M 10 66 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <g class="sequence"> <a class="link" xlink:href="../expressions#railroad-Expression"> <g class="nonterminal"> <rect height="22" width="100" x="35" y="55"></rect> <text x="85" y="71"> Expression</text> </g> </a> <g class="optional"> <path d=" M 145 66 h 24 m -24 0 a 12 12 0 0 0 12 -12 v 0 a 12 12 0 0 1 12 -12 h 162 m -78 0 l -5 -5 m 0 10 l 5 -5 m 78 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 0 12 12 h -24"></path> <g class="repeat"> <path d=" M 169 66 h 12 m 138 0 h 12 m -12 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 1 -12 12 m 0 0 h -138 m 72 0 l 5 -5 m 0 10 l -5 -5 m -72 0 a 12 12 0 0 1 -12 -12 v 0 a 12 12 0 0 1 12 -12"></path>  <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="181" y="55"></rect> <text x="195" y="71"> ,</text> </g> <a class="link" xlink:href="../expressions#railroad-Expression"> <g class="nonterminal"> <rect height="22" width="100" x="219" y="55"></rect> <text x="269" y="71"> Expression</text> </g> </a> <path d=" M 209 66 h 10"></path> </g> </g> </g> <g class="optional"> <path d=" M 365 66 h 24 m -24 0 a 12 12 0 0 0 12 -12 v 0 a 12 12 0 0 1 12 -12 h 28 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 0 12 12 h -24"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="389" y="55"></rect> <text x="403" y="71"> ,</text> </g> </g> <path d=" M 135 66 h 10"></path> <path d=" M 355 66 h 10"></path> </g> <path d=" M 451 66 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 66 h 10"></path> <path d=" M 441 66 h 10"></path> </g> </g> </svg> </div> </details>
</div>   <p>A <em>call expression</em> calls a function. The syntax of a call expression is an expression, called the <em>function operand</em>, followed by a parenthesized comma-separated list of expression, called the <em>argument operands</em>.</p>  <p>If the function eventually returns, then the expression completes.</p>  <p>For <a href="../types/function-item">non-function types</a>, the expression <code>f(...)</code> uses the method on one of the following traits based on the function operand:</p> <ul> <li>
<a href="https://doc.rust-lang.org/core/ops/function/trait.Fn.html"><code>Fn</code></a> or <a href="https://doc.rust-lang.org/core/ops/async_function/trait.AsyncFn.html"><code>AsyncFn</code></a> — shared reference.</li> <li>
<a href="https://doc.rust-lang.org/core/ops/function/trait.FnMut.html"><code>FnMut</code></a> or <a href="https://doc.rust-lang.org/core/ops/async_function/trait.AsyncFnMut.html"><code>AsyncFnMut</code></a> — mutable reference.</li> <li>
<a href="https://doc.rust-lang.org/core/ops/function/trait.FnOnce.html"><code>FnOnce</code></a> or <a href="https://doc.rust-lang.org/core/ops/async_function/trait.AsyncFnOnce.html"><code>AsyncFnOnce</code></a> — value.</li> </ul>  <p>An automatic borrow will be taken if needed. The function operand will also be <a href="field-expr#automatic-dereferencing">automatically dereferenced</a> as required.</p> <p>Some examples of call expressions:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn add(x: i32, y: i32) -&gt; i32 { 0 }
let three: i32 = add(1i32, 2i32);
let name: &amp;'static str = (|| "Rust")();
}</pre>  <h2 id="disambiguating-function-calls">Disambiguating Function Calls</h2>  <p>All function calls are sugar for a more explicit <a href="../paths#qualified-paths">fully-qualified syntax</a>.</p>  <p>Function calls may need to be fully qualified, depending on the ambiguity of a call in light of in-scope items.</p> <div class="alert alert-note"> <blockquote> <p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p> <p>In the past, the terms “Unambiguous Function Call Syntax”, “Universal Function Call Syntax”, or “UFCS”, have been used in documentation, issues, RFCs, and other community writings. However, these terms lack descriptive power and potentially confuse the issue at hand. We mention them here for searchability’s sake.</p> </blockquote> </div>  <p>Several situations often occur which result in ambiguities about the receiver or referent of method or associated function calls. These situations may include:</p> <ul> <li>Multiple in-scope traits define methods with the same name for the same types</li> <li>Auto-<code>deref</code> is undesirable; for example, distinguishing between methods on a smart pointer itself and the pointer’s referent</li> <li>Methods which take no arguments, like <a href="https://doc.rust-lang.org/core/default/trait.Default.html#tymethod.default"><code>default()</code></a>, and return properties of a type, like <a href="https://doc.rust-lang.org/core/mem/fn.size_of.html"><code>size_of()</code></a>
</li> </ul>  <p>To resolve the ambiguity, the programmer may refer to their desired method or function using more specific paths, types, or traits.</p> <p>For example,</p> <pre data-language="rust">trait Pretty {
    fn print(&amp;self);
}

trait Ugly {
    fn print(&amp;self);
}

struct Foo;
impl Pretty for Foo {
    fn print(&amp;self) {}
}

struct Bar;
impl Pretty for Bar {
    fn print(&amp;self) {}
}
impl Ugly for Bar {
    fn print(&amp;self) {}
}

fn main() {
    let f = Foo;
    let b = Bar;

    // we can do this because we only have one item called `print` for `Foo`s
    f.print();
    // more explicit, and, in the case of `Foo`, not necessary
    Foo::print(&amp;f);
    // if you're not into the whole brevity thing
    &lt;Foo as Pretty&gt;::print(&amp;f);

    // b.print(); // Error: multiple 'print' found
    // Bar::print(&amp;b); // Still an error: multiple `print` found

    // necessary because of in-scope items defining `print`
    &lt;Bar as Pretty&gt;::print(&amp;b);
}</pre> <p>Refer to <a href="https://github.com/rust-lang/rfcs/blob/master/text/0132-ufcs.md">RFC 132</a> for further details and motivations.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/expressions/call-expr.html" class="_attribution-link">https://doc.rust-lang.org/reference/expressions/call-expr.html</a>
  </p>
</div>
