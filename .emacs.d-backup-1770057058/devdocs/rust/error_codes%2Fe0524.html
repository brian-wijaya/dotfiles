<h1 id="error-code-e0524">Error code E0524</h1> <p>A variable which requires unique access is being used in more than one closure at the same time.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn set(x: &amp;mut isize) {
    *x += 4;
}

fn dragoooon(x: &amp;mut isize) {
    let mut c1 = || set(x);
    let mut c2 = || set(x); // error!

    c2();
    c1();
}
}</pre> <p>To solve this issue, multiple solutions are available. First, is it required for this variable to be used in more than one closure at a time? If it is the case, use reference counted types such as <code>Rc</code> (or <code>Arc</code> if it runs concurrently):</p> <pre data-language="rust">#![allow(unused)]
fn main() {
use std::rc::Rc;
use std::cell::RefCell;

fn set(x: &amp;mut isize) {
    *x += 4;
}

fn dragoooon(x: &amp;mut isize) {
    let x = Rc::new(RefCell::new(x));
    let y = Rc::clone(&amp;x);
    let mut c1 = || { let mut x2 = x.borrow_mut(); set(&amp;mut x2); };
    let mut c2 = || { let mut x2 = y.borrow_mut(); set(&amp;mut x2); }; // ok!

    c2();
    c1();
}
}</pre> <p>If not, just run closures one at a time:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn set(x: &amp;mut isize) {
    *x += 4;
}

fn dragoooon(x: &amp;mut isize) {
    { // This block isn't necessary since non-lexical lifetimes, it's just to
      // make it more clear.
        let mut c1 = || set(&amp;mut *x);
        c1();
    } // `c1` has been dropped here so we're free to use `x` again!
    let mut c2 = || set(&amp;mut *x);
    c2();
}
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0524.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0524.html</a>
  </p>
</div>
