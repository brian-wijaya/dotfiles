<h1 id="error-code-e0802">Error code E0802</h1> <p>The target of <code>derive(CoercePointee)</code> macro has inadmissible specification for a meaningful use.</p> <p>Erroneous code examples:</p> <p>The target data is not a <code>struct</code>.</p> <pre data-language="rust">#![allow(unused)]
#![feature(coerce_pointee)]
fn main() {
use std::marker::CoercePointee;
#[derive(CoercePointee)]
enum NotStruct&lt;'a, T: ?Sized&gt; {
    Variant(&amp;'a T),
}
}</pre> <p>The target data has a layout that is not transparent, or <code>repr(transparent)</code> in other words.</p> <pre data-language="rust">#![allow(unused)]
#![feature(coerce_pointee)]
fn main() {
use std::marker::CoercePointee;
#[derive(CoercePointee)]
struct NotTransparent&lt;'a, #[pointee] T: ?Sized&gt; {
    ptr: &amp;'a T,
}
}</pre> <p>The target data has no data field.</p> <pre data-language="rust">#![allow(unused)]
#![feature(coerce_pointee)]
fn main() {
use std::marker::CoercePointee;
#[derive(CoercePointee)]
#[repr(transparent)]
struct NoField&lt;'a, #[pointee] T: ?Sized&gt; {}
}</pre> <p>The target data is not generic over any data, or has no generic type parameter.</p> <pre data-language="rust">#![allow(unused)]
#![feature(coerce_pointee)]
fn main() {
use std::marker::CoercePointee;
#[derive(CoercePointee)]
#[repr(transparent)]
struct NoGeneric&lt;'a&gt;(&amp;'a u8);
}</pre> <p>The target data has multiple generic type parameters, but none is designated as a pointee for coercion.</p> <pre data-language="rust">#![allow(unused)]
#![feature(coerce_pointee)]
fn main() {
use std::marker::CoercePointee;
#[derive(CoercePointee)]
#[repr(transparent)]
struct AmbiguousPointee&lt;'a, T1: ?Sized, T2: ?Sized&gt; {
    a: (&amp;'a T1, &amp;'a T2),
}
}</pre> <p>The target data has multiple generic type parameters that are designated as pointees for coercion.</p> <pre data-language="rust">#![allow(unused)]
#![feature(coerce_pointee)]
fn main() {
use std::marker::CoercePointee;
#[derive(CoercePointee)]
#[repr(transparent)]
struct TooManyPointees&lt;
    'a,
    #[pointee] A: ?Sized,
    #[pointee] B: ?Sized&gt;
((&amp;'a A, &amp;'a B));
}</pre> <p>The type parameter that is designated as a pointee is not marked <code>?Sized</code>.</p> <pre data-language="rust">#![allow(unused)]
#![feature(coerce_pointee)]
fn main() {
use std::marker::CoercePointee;
#[derive(CoercePointee)]
#[repr(transparent)]
struct NoMaybeSized&lt;'a, #[pointee] T&gt; {
    ptr: &amp;'a T,
}
}</pre> <p>In summary, the <code>CoercePointee</code> macro demands the type to be a <code>struct</code> that is generic over at least one type or over more types, one of which is marked with <code>#[pointee]</code>, and has at least one data field and adopts a <code>repr(transparent)</code> layout. The only generic type or the type marked with <code>#[pointee]</code> has to be also marked as <code>?Sized</code>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0802.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0802.html</a>
  </p>
</div>
