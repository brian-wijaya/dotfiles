 <h1 id="array-and-array-index-expressions">Array and array index expressions</h1> <h2 id="array-expressions">Array expressions</h2>  <div class="grammar-container">
<p><strong><sup>Syntax</sup></strong>
<br>
<span class="grammar-text grammar-production" id="grammar-ArrayExpression"><a href="array-expr#railroad-ArrayExpression">ArrayExpression</a></span> → <code class="grammar-literal">[</code> <span class="grammar-text"><a href="array-expr#grammar-ArrayElements">ArrayElements</a></span><sup>?</sup> <code class="grammar-literal">]</code></p>
<p><span class="grammar-text grammar-production" id="grammar-ArrayElements"><a href="array-expr#railroad-ArrayElements">ArrayElements</a></span> → <br>
      <span class="grammar-text"><a href="../expressions#grammar-Expression">Expression</a></span> ( <code class="grammar-literal">,</code> <span class="grammar-text"><a href="../expressions#grammar-Expression">Expression</a></span> )<sup>*</sup> <code class="grammar-literal">,</code><sup>?</sup> <br>
    | <span class="grammar-text"><a href="../expressions#grammar-Expression">Expression</a></span> <code class="grammar-literal">;</code> <span class="grammar-text"><a href="../expressions#grammar-Expression">Expression</a></span></p>

<details class="grammar-railroad grammar-hidden"><summary>Syntax diagram</summary> <div style="width: 318px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-ArrayExpression">
<svg class="railroad" viewbox="0 0 318 87" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="array-expr#grammar-ArrayExpression"> <text class="comment" x="67" y="25"> ArrayExpression</text> </a> <g class="sequence"> <path d=" M 10 66 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="35" y="55"></rect> <text x="49" y="71"> [</text> </g> <g class="optional"> <path d=" M 73 66 h 24 m -24 0 a 12 12 0 0 0 12 -12 v 0 a 12 12 0 0 1 12 -12 h 124 m -59 0 l -5 -5 m 0 10 l 5 -5 m 59 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 0 12 12 h -24"></path> <a class="link" xlink:href="array-expr#railroad-ArrayElements"> <g class="nonterminal"> <rect height="22" width="124" x="97" y="55"></rect> <text x="159" y="71"> ArrayElements</text> </g> </a> </g> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="255" y="55"></rect> <text x="269" y="71"> ]</text> </g> <path d=" M 63 66 h 10"></path> <path d=" M 245 66 h 10"></path> </g> <path d=" M 293 66 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 66 h 10"></path> <path d=" M 283 66 h 10"></path> </g> </g> </svg> </div> <div style="width: 524px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-ArrayElements">
<svg class="railroad" viewbox="0 0 524 133" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="array-expr#grammar-ArrayElements"> <text class="comment" x="60" y="25"> ArrayElements</text> </a> <g class="sequence"> <path d=" M 10 66 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <g class="choice"> <path d=" M 35 66 h 24 m 406 0 h 24"></path> <g class="sequence"> <a class="link" xlink:href="../expressions#railroad-Expression"> <g class="nonterminal"> <rect height="22" width="100" x="59" y="55"></rect> <text x="109" y="71"> Expression</text> </g> </a> <g class="optional"> <path d=" M 169 66 h 24 m -24 0 a 12 12 0 0 0 12 -12 v 0 a 12 12 0 0 1 12 -12 h 162 m -78 0 l -5 -5 m 0 10 l 5 -5 m 78 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 0 12 12 h -24"></path> <g class="repeat"> <path d=" M 193 66 h 12 m 138 0 h 12 m -12 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 1 -12 12 m 0 0 h -138 m 72 0 l 5 -5 m 0 10 l -5 -5 m -72 0 a 12 12 0 0 1 -12 -12 v 0 a 12 12 0 0 1 12 -12"></path>  <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="205" y="55"></rect> <text x="219" y="71"> ,</text> </g> <a class="link" xlink:href="../expressions#railroad-Expression"> <g class="nonterminal"> <rect height="22" width="100" x="243" y="55"></rect> <text x="293" y="71"> Expression</text> </g> </a> <path d=" M 233 66 h 10"></path> </g> </g> </g> <g class="optional"> <path d=" M 389 66 h 24 m -24 0 a 12 12 0 0 0 12 -12 v 0 a 12 12 0 0 1 12 -12 h 28 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 0 12 12 h -24"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="413" y="55"></rect> <text x="427" y="71"> ,</text> </g> </g> <path d=" M 159 66 h 10"></path> <path d=" M 379 66 h 10"></path> </g> <path d=" M 35 66 a 12 12 0 0 1 12 12 v 22 m 430 0 v -22 a 12 12 0 0 1 12 -12"></path> <path d=" M 47 100 v 0 a 12 12 0 0 0 12 12 m 248 0 h 158 m -76 0 l -5 -5 m 0 10 l 5 -5 m 76 0 a 12 12 0 0 0 12 -12 v 0"></path> <g class="sequence"> <a class="link" xlink:href="../expressions#railroad-Expression"> <g class="nonterminal"> <rect height="22" width="100" x="59" y="101"></rect> <text x="109" y="117"> Expression</text> </g> </a> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="169" y="101"></rect> <text x="183" y="117"> ;</text> </g> <a class="link" xlink:href="../expressions#railroad-Expression"> <g class="nonterminal"> <rect height="22" width="100" x="207" y="101"></rect> <text x="257" y="117"> Expression</text> </g> </a> <path d=" M 159 112 h 10"></path> <path d=" M 197 112 h 10"></path> </g> </g> <path d=" M 499 66 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 66 h 10"></path> <path d=" M 489 66 h 10"></path> </g> </g> </svg> </div> </details>
</div>   <p><em>Array expressions</em> construct <a href="../types/array">arrays</a>. Array expressions come in two forms.</p>  <p>The first form lists out every value in the array.</p>  <p>The syntax for this form is a comma-separated list of expressions of uniform type enclosed in square brackets.</p>  <p>This produces an array containing each of these values in the order they are written.</p>  <p>The syntax for the second form is two expressions separated by a semicolon (<code>;</code>) enclosed in square brackets.</p>  <p>The expression before the <code>;</code> is called the <em>repeat operand</em>.</p>  <p>The expression after the <code>;</code> is called the <em>length operand</em>.</p>  <p>The length operand must either be an <a href="../items/generics#r-items.generics.const.inferred">inferred const</a> or be a <a href="../const_eval#constant-expressions">constant expression</a> of type <code>usize</code> (e.g. a <a href="../tokens#literals">literal</a> or a <a href="../items/constant-items">constant item</a>).</p> <pre data-language="rust">#![allow(unused)]
fn main() {
const C: usize = 1;
let _: [u8; C] = [0; 1]; // Literal.
let _: [u8; C] = [0; C]; // Constant item.
let _: [u8; C] = [0; _]; // Inferred const.
let _: [u8; C] = [0; (((_)))]; // Inferred const.
}</pre> <div class="alert alert-note"> <blockquote> <p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p> <p>In an array expression, an <a href="../items/generics#r-items.generics.const.inferred">inferred const</a> is parsed as an <a href="../expressions#grammar-Expression">expression</a> but then semantically treated as a separate kind of <a href="../items/generics#r-items.generics.const.argument">const generic argument</a>.</p> </blockquote> </div>  <p>An array expression of this form creates an array with the length of the value of the length operand with each element being a copy of the repeat operand. That is, <code>[a; b]</code> creates an array containing <code>b</code> copies of the value of <code>a</code>.</p>  <p>If the length operand has a value greater than 1 then this requires the repeat operand to have a type that implements <a href="../special-types-and-traits#copy"><code>Copy</code></a>, to be a <a href="block-expr#r-expr.block.const">const block expression</a>, or to be a <a href="path-expr">path</a> to a constant item.</p>  <p>When the repeat operand is a const block or a path to a constant item, it is evaluated the number of times specified in the length operand.</p>  <p>If that value is <code>0</code>, then the const block or constant item is not evaluated at all.</p>  <p>For expressions that are neither a const block nor a path to a constant item, it is evaluated exactly once, and then the result is copied the length operand’s value times.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
[1, 2, 3, 4];
["a", "b", "c", "d"];
[0; 128];              // array with 128 zeros
[0u8, 0u8, 0u8, 0u8,];
[[1, 0, 0], [0, 1, 0], [0, 0, 1]]; // 2D array
const EMPTY: Vec&lt;i32&gt; = Vec::new();
[EMPTY; 2];
}</pre>  <h2 id="array-and-slice-indexing-expressions">Array and slice indexing expressions</h2>  <div class="grammar-container">
<p><strong><sup>Syntax</sup></strong>
<br>
<span class="grammar-text grammar-production" id="grammar-IndexExpression"><a href="array-expr#railroad-IndexExpression">IndexExpression</a></span> → <span class="grammar-text"><a href="../expressions#grammar-Expression">Expression</a></span> <code class="grammar-literal">[</code> <span class="grammar-text"><a href="../expressions#grammar-Expression">Expression</a></span> <code class="grammar-literal">]</code></p>

<details class="grammar-railroad grammar-hidden"><summary>Syntax diagram</summary> <div style="width: 356px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-IndexExpression">
<svg class="railroad" viewbox="0 0 356 74" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="array-expr#grammar-IndexExpression"> <text class="comment" x="67" y="25"> IndexExpression</text> </a> <g class="sequence"> <path d=" M 10 53 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <g class="sequence"> <a class="link" xlink:href="../expressions#railroad-Expression"> <g class="nonterminal"> <rect height="22" width="100" x="35" y="42"></rect> <text x="85" y="58"> Expression</text> </g> </a> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="145" y="42"></rect> <text x="159" y="58"> [</text> </g> <a class="link" xlink:href="../expressions#railroad-Expression"> <g class="nonterminal"> <rect height="22" width="100" x="183" y="42"></rect> <text x="233" y="58"> Expression</text> </g> </a> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="293" y="42"></rect> <text x="307" y="58"> ]</text> </g> <path d=" M 135 53 h 10"></path> <path d=" M 173 53 h 10"></path> <path d=" M 283 53 h 10"></path> </g> <path d=" M 331 53 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 53 h 10"></path> <path d=" M 321 53 h 10"></path> </g> </g> </svg> </div> </details>
</div>   <p><a href="../types/array">Array</a> and <a href="../types/slice">slice</a>-typed values can be indexed by writing a square-bracket-enclosed expression of type <code>usize</code> (the index) after them. When the array is mutable, the resulting <a href="../expressions#place-expressions-and-value-expressions">memory location</a> can be assigned to.</p>  <p>For other types an index expression <code>a[b]</code> is equivalent to <code>*std::ops::Index::index(&amp;a, b)</code>, or <code>*std::ops::IndexMut::index_mut(&amp;mut a, b)</code> in a mutable place expression context. Just as with methods, Rust will also insert dereference operations on <code>a</code> repeatedly to find an implementation.</p>  <p>Indices are zero-based for arrays and slices.</p>  <p>Array access is a <a href="../const_eval#constant-expressions">constant expression</a>, so bounds can be checked at compile-time with a constant index value. Otherwise a check will be performed at run-time that will put the thread in a <a href="../panic"><em>panicked state</em></a> if it fails.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
// lint is deny by default.
#![warn(unconditional_panic)]

([1, 2, 3, 4])[2];        // Evaluates to 3

let b = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
b[1][2];                  // multidimensional array indexing

let x = (["a", "b"])[10]; // warning: index out of bounds

let n = 10;
let y = (["a", "b"])[n];  // panics

let arr = ["a", "b"];
arr[10];                  // warning: index out of bounds
}</pre>  <p>The array index expression can be implemented for types other than arrays and slices by implementing the <a href="https://doc.rust-lang.org/core/ops/index/trait.Index.html">Index</a> and <a href="https://doc.rust-lang.org/core/ops/index/trait.IndexMut.html">IndexMut</a> traits.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/expressions/array-expr.html" class="_attribution-link">https://doc.rust-lang.org/reference/expressions/array-expr.html</a>
  </p>
</div>
