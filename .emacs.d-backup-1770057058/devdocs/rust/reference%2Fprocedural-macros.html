 <h1 id="procedural-macros">Procedural Macros</h1>  <p><em>Procedural macros</em> allow creating syntax extensions as execution of a function. Procedural macros come in one of three flavors:</p> <ul> <li>
<a href="#function-like-procedural-macros">Function-like macros</a> - <code>custom!(...)</code>
</li> <li>
<a href="procedural-macros#r-macro.proc.derive">Derive macros</a> - <code>#[derive(CustomDerive)]</code>
</li> <li>
<a href="#attribute-macros">Attribute macros</a> - <code>#[CustomAttribute]</code>
</li> </ul> <p>Procedural macros allow you to run code at compile time that operates over Rust syntax, both consuming and producing Rust syntax. You can sort of think of procedural macros as functions from an AST to another AST.</p>  <p>Procedural macros must be defined in the root of a crate with the <a href="linkage">crate type</a> of <code>proc-macro</code>. The macros may not be used from the crate where they are defined, and can only be used when imported in another crate.</p> <div class="alert alert-note"> <blockquote> <p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p> <p>When using Cargo, Procedural macro crates are defined with the <code>proc-macro</code> key in your manifest:</p> <pre>[lib]
proc-macro = true
</pre> </blockquote> </div>  <p>As functions, they must either return syntax, panic, or loop endlessly. Returned syntax either replaces or adds the syntax depending on the kind of procedural macro. Panics are caught by the compiler and are turned into a compiler error. Endless loops are not caught by the compiler which hangs the compiler.</p> <p>Procedural macros run during compilation, and thus have the same resources that the compiler has. For example, standard input, error, and output are the same that the compiler has access to. Similarly, file access is the same. Because of this, procedural macros have the same security concerns that <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">Cargo’s build scripts</a> have.</p>  <p>Procedural macros have two ways of reporting errors. The first is to panic. The second is to emit a <a href="https://doc.rust-lang.org/core/macro.compile_error.html"><code>compile_error</code></a> macro invocation.</p>  <h2 id="the-proc_macro-crate">The <code id="">proc_macro</code> crate</h2>  <p>Procedural macro crates almost always will link to the compiler-provided <a href="https://doc.rust-lang.org/proc_macro/index.html"><code>proc_macro</code> crate</a>. The <code>proc_macro</code> crate provides types required for writing procedural macros and facilities to make it easier.</p>  <p>This crate primarily contains a <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> type. Procedural macros operate over <em>token streams</em> instead of AST nodes, which is a far more stable interface over time for both the compiler and for procedural macros to target. A <em>token stream</em> is roughly equivalent to <code>Vec&lt;TokenTree&gt;</code> where a <code>TokenTree</code> can roughly be thought of as lexical token. For example <code>foo</code> is an <code>Ident</code> token, <code>.</code> is a <code>Punct</code> token, and <code>1.2</code> is a <code>Literal</code> token. The <code>TokenStream</code> type, unlike <code>Vec&lt;TokenTree&gt;</code>, is cheap to clone.</p>  <p>All tokens have an associated <code>Span</code>. A <code>Span</code> is an opaque value that cannot be modified but can be manufactured. <code>Span</code>s represent an extent of source code within a program and are primarily used for error reporting. While you cannot modify a <code>Span</code> itself, you can always change the <code>Span</code> <em>associated</em> with any token, such as through getting a <code>Span</code> from another token.</p>  <h2 id="procedural-macro-hygiene">Procedural macro hygiene</h2> <p>Procedural macros are <em>unhygienic</em>. This means they behave as if the output token stream was simply written inline to the code it’s next to. This means that it’s affected by external items and also affects external imports.</p> <p>Macro authors need to be careful to ensure their macros work in as many contexts as possible given this limitation. This often includes using absolute paths to items in libraries (for example, <code>::std::option::Option</code> instead of <code>Option</code>) or by ensuring that generated functions have names that are unlikely to clash with other functions (like <code>__internal_foo</code> instead of <code>foo</code>).</p>  <h2 id="function-like-procedural-macros">Function-like procedural macros</h2>  <p><em>Function-like procedural macros</em> are procedural macros that are invoked using the macro invocation operator (<code>!</code>).</p>  <p>These macros are defined by a <a href="visibility-and-privacy">public</a> <a href="items/functions">function</a> with the <code>proc_macro</code> <a href="attributes">attribute</a> and a signature of <code>(TokenStream) -&gt; TokenStream</code>. The input <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> is what is inside the delimiters of the macro invocation and the output <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> replaces the entire macro invocation.</p>  <p>The <code>proc_macro</code> attribute defines the macro in the <a href="names/namespaces">macro namespace</a> in the root of the crate.</p> <p>For example, the following macro definition ignores its input and outputs a function <code>answer</code> into its scope.</p>  <pre data-language="rust">#![crate_type = "proc-macro"]
extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro]
pub fn make_answer(_item: TokenStream) -&gt; TokenStream {
    "fn answer() -&gt; u32 { 42 }".parse().unwrap()
}</pre> <p>And then we use it in a binary crate to print “42” to standard output.</p>  <pre data-language="rust">extern crate proc_macro_examples;
use proc_macro_examples::make_answer;

make_answer!();

fn main() {
    println!("{}", answer());
}</pre>  <p>Function-like procedural macros may be invoked in any macro invocation position, which includes <a href="statements">statements</a>, <a href="expressions">expressions</a>, <a href="patterns">patterns</a>, <a href="types#type-expressions">type expressions</a>, <a href="items">item</a> positions, including items in <a href="items/external-blocks"><code>extern</code> blocks</a>, inherent and trait <a href="items/implementations">implementations</a>, and <a href="items/traits">trait definitions</a>.</p>   <h2 id="the-proc_macro_derive-attribute">The <code id="">proc_macro_derive</code> attribute</h2>  <p>Applying the <em><code>proc_macro_derive</code> <a href="attributes">attribute</a></em> to a function defines a <em>derive macro</em> that can be invoked by the <a href="attributes/derive"><code>derive</code> attribute</a>. These macros are given the token stream of a <a href="items/structs">struct</a>, <a href="items/enumerations">enum</a>, or <a href="items/unions">union</a> definition and can emit new <a href="items">items</a> after it. They can also declare and use <a href="#derive-macro-helper-attributes">derive macro helper attributes</a>.</p> <div class="alert alert-example"> <blockquote> <p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0ZM1.5 8a6.5 6.5 0 1 0 13 0 6.5 6.5 0 0 0-13 0Zm4.879-2.773 4.264 2.559a.25.25 0 0 1 0 .428l-4.264 2.559A.25.25 0 0 1 6 10.559V5.442a.25.25 0 0 1 .379-.215Z"></path></svg>Example</p> <p>This derive macro ignores its input and appends tokens that define a function.</p>  <pre data-language="rust">#![crate_type = "proc-macro"]
extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro_derive(AnswerFn)]
pub fn derive_answer_fn(_item: TokenStream) -&gt; TokenStream {
    "fn answer() -&gt; u32 { 42 }".parse().unwrap()
}</pre> <p>To use it, we might write:</p>  <pre data-language="rust">extern crate proc_macro_examples;
use proc_macro_examples::AnswerFn;

#[derive(AnswerFn)]
struct Struct;

fn main() {
    assert_eq!(42, answer());
}</pre> </blockquote> </div>  <p>The syntax for the <code>proc_macro_derive</code> attribute is:</p> <div class="grammar-container">
<p><strong><sup>Syntax</sup></strong>
<br>
<span class="grammar-text grammar-production" id="grammar-ProcMacroDeriveAttribute"><a href="procedural-macros#railroad-ProcMacroDeriveAttribute">ProcMacroDeriveAttribute</a></span> → <br>
    <code class="grammar-literal">proc_macro_derive</code> <code class="grammar-literal">(</code> <span class="grammar-text"><a href="procedural-macros#grammar-DeriveMacroName">DeriveMacroName</a></span> ( <code class="grammar-literal">,</code> <span class="grammar-text"><a href="procedural-macros#grammar-DeriveMacroAttributes">DeriveMacroAttributes</a></span> )<sup>?</sup> <code class="grammar-literal">,</code><sup>?</sup> <code class="grammar-literal">)</code></p>
<p><span class="grammar-text grammar-production" id="grammar-DeriveMacroName"><a href="procedural-macros#railroad-DeriveMacroName">DeriveMacroName</a></span> → <span class="grammar-text"><a href="identifiers#grammar-IDENTIFIER">IDENTIFIER</a></span></p>
<p><span class="grammar-text grammar-production" id="grammar-DeriveMacroAttributes"><a href="procedural-macros#railroad-DeriveMacroAttributes">DeriveMacroAttributes</a></span> → <br>
    <code class="grammar-literal">attributes</code> <code class="grammar-literal">(</code> ( <span class="grammar-text"><a href="identifiers#grammar-IDENTIFIER">IDENTIFIER</a></span> ( <code class="grammar-literal">,</code> <span class="grammar-text"><a href="identifiers#grammar-IDENTIFIER">IDENTIFIER</a></span> )<sup>*</sup> <code class="grammar-literal">,</code><sup>?</sup> )<sup>?</sup> <code class="grammar-literal">)</code></p>

<details class="grammar-railroad grammar-hidden"><summary>Syntax diagram</summary> <div style="width: 830px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-ProcMacroDeriveAttribute">
<svg class="railroad" viewbox="0 0 830 87" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="procedural-macros#grammar-ProcMacroDeriveAttribute"> <text class="comment" x="102" y="25"> ProcMacroDeriveAttribute</text> </a> <g class="sequence"> <path d=" M 10 66 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="156" x="35" y="55"></rect> <text x="113" y="71"> proc_macro_derive</text> </g> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="201" y="55"></rect> <text x="215" y="71"> (</text> </g> <a class="link" xlink:href="procedural-macros#railroad-DeriveMacroName"> <g class="nonterminal"> <rect height="22" width="140" x="239" y="55"></rect> <text x="309" y="71"> DeriveMacroName</text> </g> </a> <g class="optional"> <path d=" M 389 66 h 24 m -24 0 a 12 12 0 0 0 12 -12 v 0 a 12 12 0 0 1 12 -12 h 234 m -114 0 l -5 -5 m 0 10 l 5 -5 m 114 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 0 12 12 h -24"></path> <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="413" y="55"></rect> <text x="427" y="71"> ,</text> </g> <a class="link" xlink:href="procedural-macros#railroad-DeriveMacroAttributes"> <g class="nonterminal"> <rect height="22" width="196" x="451" y="55"></rect> <text x="549" y="71"> DeriveMacroAttributes</text> </g> </a> <path d=" M 441 66 h 10"></path> </g> </g> <g class="optional"> <path d=" M 681 66 h 24 m -24 0 a 12 12 0 0 0 12 -12 v 0 a 12 12 0 0 1 12 -12 h 28 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 0 12 12 h -24"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="705" y="55"></rect> <text x="719" y="71"> ,</text> </g> </g> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="767" y="55"></rect> <text x="781" y="71"> )</text> </g> <path d=" M 191 66 h 10"></path> <path d=" M 229 66 h 10"></path> <path d=" M 379 66 h 10"></path> <path d=" M 671 66 h 10"></path> <path d=" M 757 66 h 10"></path> </g> <path d=" M 805 66 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 66 h 10"></path> <path d=" M 795 66 h 10"></path> </g> </g> </svg> </div> <div style="width: 170px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-DeriveMacroName">
<svg class="railroad" viewbox="0 0 170 74" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="procedural-macros#grammar-DeriveMacroName"> <text class="comment" x="67" y="25"> DeriveMacroName</text> </a> <g class="sequence"> <path d=" M 10 53 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <a class="link" xlink:href="identifiers#railroad-IDENTIFIER"> <g class="nonterminal"> <rect height="22" width="100" x="35" y="42"></rect> <text x="85" y="58"> IDENTIFIER</text> </g> </a> <path d=" M 145 53 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 53 h 10"></path> <path d=" M 135 53 h 10"></path> </g> </g> </svg> </div> <div style="width: 710px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-DeriveMacroAttributes">
<svg class="railroad" viewbox="0 0 710 112" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="procedural-macros#grammar-DeriveMacroAttributes"> <text class="comment" x="92" y="25"> DeriveMacroAttributes</text> </a> <g class="sequence"> <path d=" M 10 78 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="100" x="35" y="67"></rect> <text x="85" y="83"> attributes</text> </g> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="145" y="67"></rect> <text x="159" y="83"> (</text> </g> <g class="optional"> <path d=" M 183 78 h 24 m -24 0 a 12 12 0 0 0 12 -12 v -12 a 12 12 0 0 1 12 -12 h 406 m -200 0 l -5 -5 m 0 10 l 5 -5 m 200 0 a 12 12 0 0 1 12 12 v 12 a 12 12 0 0 0 12 12 h -24"></path> <g class="sequence"> <a class="link" xlink:href="identifiers#railroad-IDENTIFIER"> <g class="nonterminal"> <rect height="22" width="100" x="207" y="67"></rect> <text x="257" y="83"> IDENTIFIER</text> </g> </a> <g class="optional"> <path d=" M 317 78 h 24 m -24 0 a 12 12 0 0 0 12 -12 v 0 a 12 12 0 0 1 12 -12 h 162 m -78 0 l -5 -5 m 0 10 l 5 -5 m 78 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 0 12 12 h -24"></path> <g class="repeat"> <path d=" M 341 78 h 12 m 138 0 h 12 m -12 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 1 -12 12 m 0 0 h -138 m 72 0 l 5 -5 m 0 10 l -5 -5 m -72 0 a 12 12 0 0 1 -12 -12 v 0 a 12 12 0 0 1 12 -12"></path>  <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="353" y="67"></rect> <text x="367" y="83"> ,</text> </g> <a class="link" xlink:href="identifiers#railroad-IDENTIFIER"> <g class="nonterminal"> <rect height="22" width="100" x="391" y="67"></rect> <text x="441" y="83"> IDENTIFIER</text> </g> </a> <path d=" M 381 78 h 10"></path> </g> </g> </g> <g class="optional"> <path d=" M 537 78 h 24 m -24 0 a 12 12 0 0 0 12 -12 v 0 a 12 12 0 0 1 12 -12 h 28 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 0 12 12 h -24"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="561" y="67"></rect> <text x="575" y="83"> ,</text> </g> </g> <path d=" M 307 78 h 10"></path> <path d=" M 527 78 h 10"></path> </g> </g> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="647" y="67"></rect> <text x="661" y="83"> )</text> </g> <path d=" M 135 78 h 10"></path> <path d=" M 173 78 h 10"></path> <path d=" M 637 78 h 10"></path> </g> <path d=" M 685 78 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 78 h 10"></path> <path d=" M 675 78 h 10"></path> </g> </g> </svg> </div> </details>
</div>  <p>The name of the derive macro is given by <a href="procedural-macros#grammar-DeriveMacroName">DeriveMacroName</a>. The optional <code>attributes</code> argument is described in <a href="procedural-macros#r-macro.proc.derive.attributes">macro.proc.derive.attributes</a>.</p>  <p>The <code>proc_macro_derive</code> attribute may only be applied to a <code>pub</code> function with the <a href="items/functions#r-items.fn.extern">Rust ABI</a> defined in the root of the crate with a type of <code>fn(TokenStream) -&gt; TokenStream</code> where <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> comes from the <a href="https://doc.rust-lang.org/proc_macro/index.html"><code>proc_macro</code> crate</a>. The function may be <code>const</code> and may use <code>extern</code> to explicitly specify the Rust ABI, but it may not use any other <a href="items/functions#grammar-FunctionQualifiers">qualifiers</a> (e.g. it may not be <code>async</code> or <code>unsafe</code>).</p>  <p>The <code>proc_macro_derive</code> attribute may be used only once on a function.</p>  <p>The <code>proc_macro_derive</code> attribute publicly defines the derive macro in the <a href="names/namespaces">macro namespace</a> in the root of the crate.</p>  <p>The input <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> is the token stream of the item to which the <code>derive</code> attribute is applied. The output <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> must be a (possibly empty) set of items. These items are appended following the input item within the same <a href="items/modules">module</a> or <a href="expressions/block-expr">block</a>.</p>  <h3 id="derive-macro-helper-attributes">Derive macro helper attributes</h3>  <p>Derive macros can declare <em>derive macro helper attributes</em> to be used within the scope of the <a href="items">item</a> to which the derive macro is applied. These <a href="attributes">attributes</a> are <a href="attributes#active-and-inert-attributes">inert</a>. While their purpose is to be used by the macro that declared them, they can be seen by any macro.</p>  <p>A helper attribute for a derive macro is declared by adding its identifier to the <code>attributes</code> list in the <code>proc_macro_derive</code> attribute.</p> <div class="alert alert-example"> <blockquote> <p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0ZM1.5 8a6.5 6.5 0 1 0 13 0 6.5 6.5 0 0 0-13 0Zm4.879-2.773 4.264 2.559a.25.25 0 0 1 0 .428l-4.264 2.559A.25.25 0 0 1 6 10.559V5.442a.25.25 0 0 1 .379-.215Z"></path></svg>Example</p> <p>This declares a helper attribute and then ignores it.</p>  <pre data-language="rust">#![crate_type="proc-macro"]
extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro_derive(WithHelperAttr, attributes(helper))]
pub fn derive_with_helper_attr(_item: TokenStream) -&gt; TokenStream {
    TokenStream::new()
}</pre> <p>To use it, we might write:</p>  <pre data-language="rust">#[derive(WithHelperAttr)]
struct Struct {
    #[helper] field: (),
}</pre> </blockquote> </div>  <h2 id="attribute-macros">Attribute macros</h2>  <p><em>Attribute macros</em> define new <a href="attributes">outer attributes</a> which can be attached to <a href="items">items</a>, including items in <a href="items/external-blocks"><code>extern</code> blocks</a>, inherent and trait <a href="items/implementations">implementations</a>, and <a href="items/traits">trait definitions</a>.</p>  <p>Attribute macros are defined by a <a href="visibility-and-privacy">public</a> <a href="items/functions">function</a> with the <code>proc_macro_attribute</code> <a href="attributes">attribute</a> that has a signature of <code>(TokenStream, TokenStream) -&gt; TokenStream</code>. The first <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> is the delimited token tree following the attribute’s name, not including the outer delimiters. If the attribute is written as a bare attribute name, the attribute <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> is empty. The second <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> is the rest of the <a href="items">item</a> including other <a href="attributes">attributes</a> on the <a href="items">item</a>. The returned <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>TokenStream</code></a> replaces the <a href="items">item</a> with an arbitrary number of <a href="items">items</a>.</p>  <p>The <code>proc_macro_attribute</code> attribute defines the attribute in the <a href="names/namespaces">macro namespace</a> in the root of the crate.</p> <p>For example, this attribute macro takes the input stream and returns it as is, effectively being the no-op of attributes.</p>  <pre data-language="rust">#![crate_type = "proc-macro"]
extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn return_as_is(_attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    item
}</pre> <p>This following example shows the stringified <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>TokenStream</code>s</a> that the attribute macros see. The output will show in the output of the compiler. The output is shown in the comments after the function prefixed with “out:”.</p>  <pre data-language="rust">// my-macro/src/lib.rs
extern crate proc_macro;
use proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn show_streams(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
    println!("attr: \"{attr}\"");
    println!("item: \"{item}\"");
    item
}</pre>  <pre data-language="rust">// src/lib.rs
extern crate my_macro;

use my_macro::show_streams;

// Example: Basic function
#[show_streams]
fn invoke1() {}
// out: attr: ""
// out: item: "fn invoke1() {}"

// Example: Attribute with input
#[show_streams(bar)]
fn invoke2() {}
// out: attr: "bar"
// out: item: "fn invoke2() {}"

// Example: Multiple tokens in the input
#[show_streams(multiple =&gt; tokens)]
fn invoke3() {}
// out: attr: "multiple =&gt; tokens"
// out: item: "fn invoke3() {}"

// Example:
#[show_streams { delimiters }]
fn invoke4() {}
// out: attr: "delimiters"
// out: item: "fn invoke4() {}"</pre>  <h2 id="declarative-macro-tokens-and-procedural-macro-tokens">Declarative macro tokens and procedural macro tokens</h2>  <p>Declarative <code>macro_rules</code> macros and procedural macros use similar, but different definitions for tokens (or rather <a href="https://doc.rust-lang.org/proc_macro/enum.TokenTree.html"><code>TokenTree</code>s</a>.)</p>  <p>Token trees in <code>macro_rules</code> (corresponding to <code>tt</code> matchers) are defined as</p> <ul> <li>Delimited groups (<code>(...)</code>, <code>{...}</code>, etc)</li> <li>All operators supported by the language, both single-character and multi-character ones (<code>+</code>, <code>+=</code>). <ul> <li>Note that this set doesn’t include the single quote <code>'</code>.</li> </ul> </li> <li>Literals (<code>"string"</code>, <code>1</code>, etc) <ul> <li>Note that negation (e.g. <code>-1</code>) is never a part of such literal tokens, but a separate operator token.</li> </ul> </li> <li>Identifiers, including keywords (<code>ident</code>, <code>r#ident</code>, <code>fn</code>)</li> <li>Lifetimes (<code>'ident</code>)</li> <li>Metavariable substitutions in <code>macro_rules</code> (e.g. <code>$my_expr</code> in <code>macro_rules! mac { ($my_expr: expr) =&gt; { $my_expr } }</code> after the <code>mac</code>’s expansion, which will be considered a single token tree regardless of the passed expression)</li> </ul>  <p>Token trees in procedural macros are defined as</p> <ul> <li>Delimited groups (<code>(...)</code>, <code>{...}</code>, etc)</li> <li>All punctuation characters used in operators supported by the language (<code>+</code>, but not <code>+=</code>), and also the single quote <code>'</code> character (typically used in lifetimes, see below for lifetime splitting and joining behavior)</li> <li>Literals (<code>"string"</code>, <code>1</code>, etc) <ul> <li>Negation (e.g. <code>-1</code>) is supported as a part of integer and floating point literals.</li> </ul> </li> <li>Identifiers, including keywords (<code>ident</code>, <code>r#ident</code>, <code>fn</code>)</li> </ul>  <p>Mismatches between these two definitions are accounted for when token streams are passed to and from procedural macros. <br> Note that the conversions below may happen lazily, so they might not happen if the tokens are not actually inspected.</p>  <p>When passed to a proc-macro</p> <ul> <li>All multi-character operators are broken into single characters.</li> <li>Lifetimes are broken into a <code>'</code> character and an identifier.</li> <li>The keyword metavariable <a href="macros-by-example#r-macro.decl.hygiene.crate"><code>$crate</code></a> is passed as a single identifier.</li> <li>All other metavariable substitutions are represented as their underlying token streams. <ul> <li>Such token streams may be wrapped into delimited groups (<a href="https://doc.rust-lang.org/proc_macro/struct.Group.html"><code>Group</code></a>) with implicit delimiters (<a href="https://doc.rust-lang.org/proc_macro/enum.Delimiter.html#variant.None"><code>Delimiter::None</code></a>) when it’s necessary for preserving parsing priorities.</li> <li>
<code>tt</code> and <code>ident</code> substitutions are never wrapped into such groups and always represented as their underlying token trees.</li> </ul> </li> </ul>  <p>When emitted from a proc macro</p> <ul> <li>Punctuation characters are glued into multi-character operators when applicable.</li> <li>Single quotes <code>'</code> joined with identifiers are glued into lifetimes.</li> <li>Negative literals are converted into two tokens (the <code>-</code> and the literal) possibly wrapped into a delimited group (<a href="https://doc.rust-lang.org/proc_macro/struct.Group.html"><code>Group</code></a>) with implicit delimiters (<a href="https://doc.rust-lang.org/proc_macro/enum.Delimiter.html#variant.None"><code>Delimiter::None</code></a>) when it’s necessary for preserving parsing priorities.</li> </ul>  <p>Note that neither declarative nor procedural macros support doc comment tokens (e.g. <code>/// Doc</code>), so they are always converted to token streams representing their equivalent <code>#[doc = r"str"]</code> attributes when passed to macros.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/procedural-macros.html" class="_attribution-link">https://doc.rust-lang.org/reference/procedural-macros.html</a>
  </p>
</div>
