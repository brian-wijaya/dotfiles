<h1 id="error-code-e0072">Error code E0072</h1> <p>A recursive type has infinite size because it doesn't have an indirection.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct ListNode {
    head: u8,
    tail: Option&lt;ListNode&gt;, // error: no indirection here so impossible to
                            //        compute the type's size
}
}</pre> <p>When defining a recursive struct or enum, any use of the type being defined from inside the definition must occur behind a pointer (like <code>Box</code>, <code>&amp;</code> or <code>Rc</code>). This is because structs and enums must have a well-defined size, and without the pointer, the size of the type would need to be unbounded.</p> <p>In the example, the type cannot have a well-defined size, because it needs to be arbitrarily large (since we would be able to nest <code>ListNode</code>s to any depth). Specifically,</p> <pre>size of `ListNode` = 1 byte for `head`
                   + 1 byte for the discriminant of the `Option`
                   + size of `ListNode`
</pre> <p>One way to fix this is by wrapping <code>ListNode</code> in a <code>Box</code>, like so:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct ListNode {
    head: u8,
    tail: Option&lt;Box&lt;ListNode&gt;&gt;,
}
}</pre> <p>This works because <code>Box</code> is a pointer, so its size is well-known.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0072.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0072.html</a>
  </p>
</div>
