<h1 id="error-code-e0716">Error code E0716</h1> <p>A temporary value is being dropped while a borrow is still in active use.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo() -&gt; i32 { 22 }
fn bar(x: &amp;i32) -&gt; &amp;i32 { x }
let p = bar(&amp;foo());
         // ------ creates a temporary
let q = *p;
}</pre> <p>Here, the expression <code>&amp;foo()</code> is borrowing the expression <code>foo()</code>. As <code>foo()</code> is a call to a function, and not the name of a variable, this creates a <strong>temporary</strong> -- that temporary stores the return value from <code>foo()</code> so that it can be borrowed. You could imagine that <code>let p = bar(&amp;foo());</code> is equivalent to the following, which uses an explicit temporary variable.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo() -&gt; i32 { 22 }
fn bar(x: &amp;i32) -&gt; &amp;i32 { x }
let p = {
  let tmp = foo(); // the temporary
  bar(&amp;tmp) // error: `tmp` does not live long enough
}; // &lt;-- tmp is freed as we exit this block
let q = p;
}</pre> <p>Whenever a temporary is created, it is automatically dropped (freed) according to fixed rules. Ordinarily, the temporary is dropped at the end of the enclosing statement -- in this case, after the <code>let p</code>. This is illustrated in the example above by showing that <code>tmp</code> would be freed as we exit the block.</p> <p>To fix this problem, you need to create a local variable to store the value in rather than relying on a temporary. For example, you might change the original program to the following:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo() -&gt; i32 { 22 }
fn bar(x: &amp;i32) -&gt; &amp;i32 { x }
let value = foo(); // dropped at the end of the enclosing block
let p = bar(&amp;value);
let q = *p;
}</pre> <p>By introducing the explicit <code>let value</code>, we allocate storage that will last until the end of the enclosing block (when <code>value</code> goes out of scope). When we borrow <code>&amp;value</code>, we are borrowing a local variable that already exists, and hence no temporary is created.</p> <p>Temporaries are not always dropped at the end of the enclosing statement. In simple cases where the <code>&amp;</code> expression is immediately stored into a variable, the compiler will automatically extend the lifetime of the temporary until the end of the enclosing block. Therefore, an alternative way to fix the original program is to write <code>let tmp = &amp;foo()</code> and not <code>let tmp = foo()</code>:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo() -&gt; i32 { 22 }
fn bar(x: &amp;i32) -&gt; &amp;i32 { x }
let value = &amp;foo();
let p = bar(value);
let q = *p;
}</pre> <p>Here, we are still borrowing <code>foo()</code>, but as the borrow is assigned directly into a variable, the temporary will not be dropped until the end of the enclosing block. Similar rules apply when temporaries are stored into aggregate structures like a tuple or struct:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
// Here, two temporaries are created, but
// as they are stored directly into `value`,
// they are not dropped until the end of the
// enclosing block.
fn foo() -&gt; i32 { 22 }
let value = (&amp;foo(), &amp;foo());
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0716.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0716.html</a>
  </p>
</div>
