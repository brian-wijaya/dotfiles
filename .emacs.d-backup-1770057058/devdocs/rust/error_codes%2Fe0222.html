<h1 id="error-code-e0222">Error code E0222</h1> <p>An attempt was made to constrain an associated type.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
pub trait Vehicle {
    type Color;
}

pub trait Box {
    type Color;
}

pub trait BoxCar : Box + Vehicle {}

fn dent_object&lt;COLOR&gt;(c: dyn BoxCar&lt;Color=COLOR&gt;) {} // Invalid constraint
}</pre> <p>In this example, <code>BoxCar</code> has two supertraits: <code>Vehicle</code> and <code>Box</code>. Both of these traits define an associated type <code>Color</code>. <code>BoxCar</code> inherits two types with that name from both supertraits. Because of this, we need to use the fully qualified path syntax to refer to the appropriate <code>Color</code> associated type, either <code>&lt;BoxCar as Vehicle&gt;::Color</code> or <code>&lt;BoxCar as Box&gt;::Color</code>, but this syntax is not allowed to be used in a function signature.</p> <p>In order to encode this kind of constraint, a <code>where</code> clause and a new type parameter are needed:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
pub trait Vehicle {
    type Color;
}

pub trait Box {
    type Color;
}

pub trait BoxCar : Box + Vehicle {}

// Introduce a new `CAR` type parameter
fn foo&lt;CAR, COLOR&gt;(
    c: CAR,
) where
    // Bind the type parameter `CAR` to the trait `BoxCar`
    CAR: BoxCar,
    // Further restrict `&lt;BoxCar as Vehicle&gt;::Color` to be the same as the
    // type parameter `COLOR`
    CAR: Vehicle&lt;Color = COLOR&gt;,
    // We can also simultaneously restrict the other trait's associated type
    CAR: Box&lt;Color = COLOR&gt;
{}
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0222.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0222.html</a>
  </p>
</div>
