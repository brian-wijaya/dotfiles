 <h1 id="constant-items">Constant items</h1>  <div class="grammar-container">
<p><strong><sup>Syntax</sup></strong>
<br>
<span class="grammar-text grammar-production" id="grammar-ConstantItem"><a href="constant-items#railroad-ConstantItem">ConstantItem</a></span> → <br>
    <code class="grammar-literal">const</code> ( <span class="grammar-text"><a href="../identifiers#grammar-IDENTIFIER">IDENTIFIER</a></span> | <code class="grammar-literal">_</code> ) <code class="grammar-literal">:</code> <span class="grammar-text"><a href="../types#grammar-Type">Type</a></span> ( <code class="grammar-literal">=</code> <span class="grammar-text"><a href="../expressions#grammar-Expression">Expression</a></span> )<sup>?</sup> <code class="grammar-literal">;</code></p>

<details class="grammar-railroad grammar-hidden"><summary>Syntax diagram</summary> <div style="width: 622px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-ConstantItem">
<svg class="railroad" viewbox="0 0 622 120" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="constant-items#grammar-ConstantItem"> <text class="comment" x="57" y="25"> ConstantItem</text> </a> <g class="sequence"> <path d=" M 10 66 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="60" x="35" y="55"></rect> <text x="65" y="71"> const</text> </g> <g class="choice"> <path d=" M 105 66 h 24 m 100 0 h 24"></path> <a class="link" xlink:href="../identifiers#railroad-IDENTIFIER"> <g class="nonterminal"> <rect height="22" width="100" x="129" y="55"></rect> <text x="179" y="71"> IDENTIFIER</text> </g> </a> <path d=" M 105 66 a 12 12 0 0 1 12 12 v 9 m 124 0 v -9 a 12 12 0 0 1 12 -12"></path> <path d=" M 117 87 v 0 a 12 12 0 0 0 12 12 m 28 0 h 72 m -33 0 l -5 -5 m 0 10 l 5 -5 m 33 0 a 12 12 0 0 0 12 -12 v 0"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="129" y="88"></rect> <text x="143" y="104"> _</text> </g> </g> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="263" y="55"></rect> <text x="277" y="71"> :</text> </g> <a class="link" xlink:href="../types#railroad-Type"> <g class="nonterminal"> <rect height="22" width="52" x="301" y="55"></rect> <text x="327" y="71"> Type</text> </g> </a> <g class="optional"> <path d=" M 363 66 h 24 m -24 0 a 12 12 0 0 0 12 -12 v 0 a 12 12 0 0 1 12 -12 h 138 m -66 0 l -5 -5 m 0 10 l 5 -5 m 66 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 0 12 12 h -24"></path> <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="387" y="55"></rect> <text x="401" y="71"> =</text> </g> <a class="link" xlink:href="../expressions#railroad-Expression"> <g class="nonterminal"> <rect height="22" width="100" x="425" y="55"></rect> <text x="475" y="71"> Expression</text> </g> </a> <path d=" M 415 66 h 10"></path> </g> </g> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="559" y="55"></rect> <text x="573" y="71"> ;</text> </g> <path d=" M 95 66 h 10"></path> <path d=" M 253 66 h 10"></path> <path d=" M 291 66 h 10"></path> <path d=" M 353 66 h 10"></path> <path d=" M 549 66 h 10"></path> </g> <path d=" M 597 66 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 66 h 10"></path> <path d=" M 587 66 h 10"></path> </g> </g> </svg> </div> </details>
</div>   <p>A <em>constant item</em> is an optionally named <em><a href="../const_eval#constant-expressions">constant value</a></em> which is not associated with a specific memory location in the program.</p>  <p>Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. This includes usage of constants from external crates, and non-<a href="../special-types-and-traits#copy"><code>Copy</code></a> types. References to the same constant are not necessarily guaranteed to refer to the same memory address.</p>  <p>The constant declaration defines the constant value in the <a href="../names/namespaces">value namespace</a> of the module or block where it is located.</p>  <p>Constants must be explicitly typed. The type must have a <code>'static</code> lifetime: any references in the initializer must have <code>'static</code> lifetimes. References in the type of a constant default to <code>'static</code> lifetime; see <a href="../lifetime-elision#const-and-static-elision">static lifetime elision</a>.</p>  <p>A reference to a constant will have <code>'static</code> lifetime if the constant value is eligible for <a href="../destructors#constant-promotion">promotion</a>; otherwise, a temporary will be created.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
const BIT1: u32 = 1 &lt;&lt; 0;
const BIT2: u32 = 1 &lt;&lt; 1;

const BITS: [u32; 2] = [BIT1, BIT2];
const STRING: &amp;'static str = "bitstring";

struct BitsNStrings&lt;'a&gt; {
    mybits: [u32; 2],
    mystring: &amp;'a str,
}

const BITS_N_STRINGS: BitsNStrings&lt;'static&gt; = BitsNStrings {
    mybits: BITS,
    mystring: STRING,
};
}</pre>  <p>The final value of a <code>const</code> item cannot contain any mutable references.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#![allow(static_mut_refs)]
static mut S: u8 = 0;
const C: &amp;u8 = unsafe { &amp;mut S }; // OK
}</pre> <pre data-language="rust">#![allow(unused)]
fn main() {
use core::sync::atomic::AtomicU8;
static S: AtomicU8 = AtomicU8::new(0);
const C: &amp;AtomicU8 = &amp;S; // OK
}</pre> <pre data-language="rust">#![allow(unused)]
fn main() {
#![allow(static_mut_refs)]
static mut S: u8 = 0;
const C: &amp;mut u8 = unsafe { &amp;mut S }; // ERROR not allowed
}</pre> <div class="alert alert-note"> <blockquote> <p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p> <p>We also disallow, in the final value, shared references to mutable statics created in the initializer for a separate reason. Consider:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
use core::sync::atomic::AtomicU8;
const C: &amp;AtomicU8 = &amp;AtomicU8::new(0); // ERROR
}</pre> <p>Here, the <code>AtomicU8</code> is a temporary that is lifetime extended to <code>'static</code> (see <a href="../destructors#r-destructors.scope.lifetime-extension.static">destructors.scope.lifetime-extension.static</a>), and references to lifetime-extended temporaries with interior mutability are not allowed in the final value of a constant expression (see <a href="../const_eval#r-const-eval.const-expr.borrows">const-eval.const-expr.borrows</a>).</p> </blockquote> </div>  <p>The constant expression may only be omitted in a <a href="traits">trait definition</a>.</p>  <h2 id="constants-with-destructors">Constants with Destructors</h2> <p>Constants can contain destructors. Destructors are run when the value goes out of scope.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct TypeWithDestructor(i32);

impl Drop for TypeWithDestructor {
    fn drop(&amp;mut self) {
        println!("Dropped. Held {}.", self.0);
    }
}

const ZERO_WITH_DESTRUCTOR: TypeWithDestructor = TypeWithDestructor(0);

fn create_and_drop_zero_with_destructor() {
    let x = ZERO_WITH_DESTRUCTOR;
    // x gets dropped at end of function, calling drop.
    // prints "Dropped. Held 0.".
}
}</pre>  <h2 id="unnamed-constant">Unnamed constant</h2>  <p>Unlike an <a href="associated-items#associated-constants">associated constant</a>, a <a href="../glossary#free-item">free</a> constant may be unnamed by using an underscore instead of the name. For example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
const _: () =  { struct _SameNameTwice; };

// OK although it is the same name as above:
const _: () =  { struct _SameNameTwice; };
}</pre>  <p>As with <a href="use-declarations#underscore-imports">underscore imports</a>, macros may safely emit the same unnamed constant in the same scope more than once. For example, the following should not produce an error:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
macro_rules! m {
    ($item: item) =&gt; { $item $item }
}

m!(const _: () = (););
// This expands to:
// const _: () = ();
// const _: () = ();
}</pre>  <h2 id="evaluation">Evaluation</h2> <p><a href="../glossary#free-item">Free</a> constants are always <a href="../const_eval">evaluated</a> at compile-time to surface panics. This happens even within an unused function:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
// Compile-time panic
const PANIC: () = std::unimplemented!();

fn unused_generic_function&lt;T&gt;() {
    // A failing compile-time assertion
    const _: () = assert!(usize::BITS == 0);
}
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/items/constant-items.html" class="_attribution-link">https://doc.rust-lang.org/reference/items/constant-items.html</a>
  </p>
</div>
