<h1 id="error-code-e0482">Error code E0482</h1> <h4 id="note-this-error-code-is-no-longer-emitted-by-the-compiler">Note: this error code is no longer emitted by the compiler.</h4> <p>A lifetime of a returned value does not outlive the function call.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn prefix&lt;'a&gt;(
    words: impl Iterator&lt;Item = &amp;'a str&gt;
) -&gt; impl Iterator&lt;Item = String&gt; { // error!
    words.map(|v| format!("foo-{}", v))
}
}</pre> <p>To fix this error, make the lifetime of the returned value explicit:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn prefix&lt;'a&gt;(
    words: impl Iterator&lt;Item = &amp;'a str&gt; + 'a
) -&gt; impl Iterator&lt;Item = String&gt; + 'a { // ok!
    words.map(|v| format!("foo-{}", v))
}
}</pre> <p>The <a href="../reference/types/impl-trait"><code>impl Trait</code></a> feature in this example uses an implicit <code>'static</code> lifetime restriction in the returned type. However the type implementing the <code>Iterator</code> passed to the function lives just as long as <code>'a</code>, which is not long enough.</p> <p>The solution involves adding lifetime bound to both function argument and the return value to make sure that the values inside the iterator are not dropped when the function goes out of the scope.</p> <p>An alternative solution would be to guarantee that the <code>Item</code> references in the iterator are alive for the whole lifetime of the program.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn prefix(
    words: impl Iterator&lt;Item = &amp;'static str&gt;
) -&gt; impl Iterator&lt;Item = String&gt; {  // ok!
    words.map(|v| format!("foo-{}", v))
}
}</pre> <p>A similar lifetime problem might arise when returning closures:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo(
    x: &amp;mut Vec&lt;i32&gt;
) -&gt; impl FnMut(&amp;mut Vec&lt;i32&gt;) -&gt; &amp;[i32] { // error!
    |y| {
        y.append(x);
        y
    }
}
}</pre> <p>Analogically, a solution here is to use explicit return lifetime and move the ownership of the variable to the closure.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo&lt;'a&gt;(
    x: &amp;'a mut Vec&lt;i32&gt;
) -&gt; impl FnMut(&amp;mut Vec&lt;i32&gt;) -&gt; &amp;[i32] + 'a { // ok!
    move |y| {
        y.append(x);
        y
    }
}
}</pre> <p>To better understand the lifetime treatment in the <a href="../reference/types/impl-trait"><code>impl Trait</code></a>, please see the <a href="https://rust-lang.github.io/rfcs/1951-expand-impl-trait.html">RFC 1951</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0482.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0482.html</a>
  </p>
</div>
