<h1 id="error-code-e0373">Error code E0373</h1> <p>A captured variable in a closure may not live long enough.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo() -&gt; Box&lt;dyn Fn(u32) -&gt; u32&gt; {
    let x = 0u32;
    Box::new(|y| x + y)
}
}</pre> <p>This error occurs when an attempt is made to use data captured by a closure, when that data may no longer exist. It's most commonly seen when attempting to return a closure as shown in the previous code example.</p> <p>Notice that <code>x</code> is stack-allocated by <code>foo()</code>. By default, Rust captures closed-over data by reference. This means that once <code>foo()</code> returns, <code>x</code> no longer exists. An attempt to access <code>x</code> within the closure would thus be unsafe.</p> <p>Another situation where this might be encountered is when spawning threads:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo() {
    let x = 0u32;
    let y = 1u32;

    let thr = std::thread::spawn(|| {
        x + y
    });
}
}</pre> <p>Since our new thread runs in parallel, the stack frame containing <code>x</code> and <code>y</code> may well have disappeared by the time we try to use them. Even if we call <code>thr.join()</code> within foo (which blocks until <code>thr</code> has completed, ensuring the stack frame won't disappear), we will not succeed: the compiler cannot prove that this behavior is safe, and so won't let us do it.</p> <p>The solution to this problem is usually to switch to using a <code>move</code> closure. This approach moves (or copies, where possible) data into the closure, rather than taking references to it. For example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo() -&gt; Box&lt;dyn Fn(u32) -&gt; u32&gt; {
    let x = 0u32;
    Box::new(move |y| x + y)
}
}</pre> <p>Now that the closure has its own copy of the data, there's no need to worry about safety.</p> <p>This error may also be encountered while using <code>async</code> blocks:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
use std::future::Future;

async fn f() {
    let v = vec![1, 2, 3i32];
    spawn(async { //~ ERROR E0373
        println!("{:?}", v)
    });
}

fn spawn&lt;F: Future + Send + 'static&gt;(future: F) {
    unimplemented!()
}
}</pre> <p>Similarly to closures, <code>async</code> blocks are not executed immediately and may capture closed-over data by reference. For more information, see <a href="https://rust-lang.github.io/async-book/03_async_await/01_chapter.html">https://rust-lang.github.io/async-book/03_async_await/01_chapter.html</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0373.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0373.html</a>
  </p>
</div>
