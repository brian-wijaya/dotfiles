<h1 class="main-heading">Function successors </h1>
<pre class="rust item-decl" data-language="rust">pub fn successors&lt;T, F&gt;(first: Option&lt;T&gt;, succ: F) -&gt; Successors&lt;T, F&gt; ⓘwhere
    F: FnMut(&amp;T) -&gt; Option&lt;T&gt;,</pre>
<p>Creates an iterator which, starting from an initial item, computes each successive item from the preceding one.</p> <p>This iterator stores an optional item (<code>Option&lt;T&gt;</code>) and a successor closure (<code>impl FnMut(&amp;T) -&gt; Option&lt;T&gt;</code>). Its <code>next</code> method returns the stored optional item and if it is <code>Some(val)</code> calls the stored closure on <code>&amp;val</code> to compute and store its successor. The iterator will apply the closure successively to the stored option’s value until the option is <code>None</code>. This also means that once the stored option is <code>None</code> it will remain <code>None</code>, as the closure will not be called again, so the created iterator is a <a href="trait.fusediterator" title="trait std::iter::FusedIterator"><code>FusedIterator</code></a>. The iterator’s items will be the initial item and all of its successors as calculated by the successor closure.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::iter::successors;

let powers_of_10 = successors(Some(1_u16), |n| n.checked_mul(10));
assert_eq!(powers_of_10.collect::&lt;Vec&lt;_&gt;&gt;(), &amp;[1, 10, 100, 1_000, 10_000]);</pre></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/iter/fn.successors.html" class="_attribution-link">https://doc.rust-lang.org/std/iter/fn.successors.html</a>
  </p>
</div>
