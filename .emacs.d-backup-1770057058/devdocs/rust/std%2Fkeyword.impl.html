<h1 class="main-heading">Keyword impl </h1>
<p>Implementations of functionality for a type, or a type implementing some functionality.</p> <p>There are two uses of the keyword <code>impl</code>:</p> <ul> <li>An <code>impl</code> block is an item that is used to implement some functionality for a type.</li> <li>An <code>impl Trait</code> in a type-position can be used to designate a type that implements a trait called <code>Trait</code>.</li> </ul> <h2 id="implementing-functionality-for-a-type">Implementing Functionality for a Type</h2> <p>The <code>impl</code> keyword is primarily used to define implementations on types. Inherent implementations are standalone, while trait implementations are used to implement traits for types, or other traits.</p> <p>An implementation consists of definitions of functions and consts. A function defined in an <code>impl</code> block can be standalone, meaning it would be called like <code>Vec::new()</code>. If the function takes <code>self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code> as its first argument, it can also be called using method-call syntax, a familiar feature to any object-oriented programmer, like <code>vec.len()</code>.</p> <h3 id="inherent-implementations">Inherent Implementations</h3> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">struct Example {
    number: i32,
}

impl Example {
    fn boo() {
        println!("boo! Example::boo() was called!");
    }

    fn answer(&amp;mut self) {
        self.number += 42;
    }

    fn get_number(&amp;self) -&gt; i32 {
        self.number
    }
}</pre></div> <p>It matters little where an inherent implementation is defined; its functionality is in scope wherever its implementing type is.</p> <h3 id="trait-implementations-1">Trait Implementations</h3> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">struct Example {
    number: i32,
}

trait Thingy {
    fn do_thingy(&amp;self);
}

impl Thingy for Example {
    fn do_thingy(&amp;self) {
        println!("doing a thing! also, number is {}!", self.number);
    }
}</pre></div> <p>It matters little where a trait implementation is defined; its functionality can be brought into scope by importing the trait it implements.</p> <p>For more information on implementations, see the <a href="../book/ch05-03-method-syntax">Rust book</a> or the <a href="../reference/items/implementations">Reference</a>.</p> <h2 id="designating-a-type-that-implements-some-functionality">Designating a Type that Implements Some Functionality</h2> <p>The other use of the <code>impl</code> keyword is in <code>impl Trait</code> syntax, which can be understood to mean “any (or some) concrete type that implements Trait”. It can be used as the type of a variable declaration, in <a href="https://rust-lang.github.io/rfcs/1951-expand-impl-trait.html">argument position</a> or in <a href="https://rust-lang.github.io/rfcs/3425-return-position-impl-trait-in-traits.html">return position</a>. One pertinent use case is in working with closures, which have unnameable types.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">fn thing_returning_closure() -&gt; impl Fn(i32) -&gt; bool {
    println!("here's a closure for you!");
    |x: i32| x % 3 == 0
}</pre></div> <p>For more information on <code>impl Trait</code> syntax, see the <a href="../book/ch10-02-traits#returning-types-that-implement-traits">Rust book</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/keyword.impl.html" class="_attribution-link">https://doc.rust-lang.org/std/keyword.impl.html</a>
  </p>
</div>
