<h1 id="error-code-e0500">Error code E0500</h1> <p>A borrowed variable was used by a closure.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn you_know_nothing(jon_snow: &amp;mut i32) {
    let nights_watch = &amp;jon_snow;
    let starks = || {
        *jon_snow = 3; // error: closure requires unique access to `jon_snow`
                       //        but it is already borrowed
    };
    println!("{}", nights_watch);
}
}</pre> <p>In here, <code>jon_snow</code> is already borrowed by the <code>nights_watch</code> reference, so it cannot be borrowed by the <code>starks</code> closure at the same time. To fix this issue, you can create the closure after the borrow has ended:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn you_know_nothing(jon_snow: &amp;mut i32) {
    let nights_watch = &amp;jon_snow;
    println!("{}", nights_watch);
    let starks = || {
        *jon_snow = 3;
    };
}
}</pre> <p>Or, if the type implements the <code>Clone</code> trait, you can clone it between closures:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn you_know_nothing(jon_snow: &amp;mut i32) {
    let mut jon_copy = jon_snow.clone();
    let starks = || {
        *jon_snow = 3;
    };
    println!("{}", jon_copy);
}
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0500.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0500.html</a>
  </p>
</div>
