<h1 class="main-heading">Function park </h1>
<pre class="rust item-decl" data-language="rust">pub fn park()</pre>
<p>Blocks unless or until the current thread’s token is made available.</p> <p>A call to <code>park</code> does not guarantee that the thread will remain parked forever, and callers should be prepared for this possibility. However, it is guaranteed that this function will not panic (it may abort the process if the implementation encounters some rare errors).</p> <h2 id="park-and-unpark">
<code>park</code> and <code>unpark</code>
</h2> <p>Every thread is equipped with some basic low-level blocking support, via the <a href="fn.park" title="fn std::thread::park"><code>thread::park</code></a> function and <a href="struct.thread#method.unpark" title="method std::thread::Thread::unpark"><code>thread::Thread::unpark</code></a> method. <a href="fn.park" title="fn std::thread::park"><code>park</code></a> blocks the current thread, which can then be resumed from another thread by calling the <a href="struct.thread#method.unpark" title="method std::thread::Thread::unpark"><code>unpark</code></a> method on the blocked thread’s handle.</p> <p>Conceptually, each <a href="struct.thread" title="struct std::thread::Thread"><code>Thread</code></a> handle has an associated token, which is initially not present:</p> <ul> <li> <p>The <a href="fn.park" title="fn std::thread::park"><code>thread::park</code></a> function blocks the current thread unless or until the token is available for its thread handle, at which point it atomically consumes the token. It may also return <em>spuriously</em>, without consuming the token. <a href="fn.park_timeout" title="fn std::thread::park_timeout"><code>thread::park_timeout</code></a> does the same, but allows specifying a maximum time to block the thread for.</p> </li> <li> <p>The <a href="struct.thread#method.unpark" title="method std::thread::Thread::unpark"><code>unpark</code></a> method on a <a href="struct.thread" title="struct std::thread::Thread"><code>Thread</code></a> atomically makes the token available if it wasn’t already. Because the token can be held by a thread even if it is currently not parked, <a href="struct.thread#method.unpark" title="method std::thread::Thread::unpark"><code>unpark</code></a> followed by <a href="fn.park" title="fn std::thread::park"><code>park</code></a> will result in the second call returning immediately. However, note that to rely on this guarantee, you need to make sure that your <code>unpark</code> happens after all <code>park</code> that may be done by other data structures!</p> </li> </ul> <p>The API is typically used by acquiring a handle to the current thread, placing that handle in a shared data structure so that other threads can find it, and then <code>park</code>ing in a loop. When some desired condition is met, another thread calls <a href="struct.thread#method.unpark" title="method std::thread::Thread::unpark"><code>unpark</code></a> on the handle. The last bullet point above guarantees that even if the <code>unpark</code> occurs before the thread is finished <code>park</code>ing, it will be woken up properly.</p> <p>Note that the coordination via the shared data structure is crucial: If you <code>unpark</code> a thread without first establishing that it is about to be <code>park</code>ing within your code, that <code>unpark</code> may get consumed by a <em>different</em> <code>park</code> in the same thread, leading to a deadlock. This also means you must not call unknown code between setting up for parking and calling <code>park</code>; for instance, if you invoke <code>println!</code>, that may itself call <code>park</code> and thus consume your <code>unpark</code> and cause a deadlock.</p> <p>The motivation for this design is twofold:</p> <ul> <li> <p>It avoids the need to allocate mutexes and condvars when building new synchronization primitives; the threads already provide basic blocking/signaling.</p> </li> <li> <p>It can be implemented very efficiently on many platforms.</p> </li> </ul> <h2 id="memory-ordering">Memory Ordering</h2> <p>Calls to <code>unpark</code> <em>synchronize-with</em> calls to <code>park</code>, meaning that memory operations performed before a call to <code>unpark</code> are made visible to the thread that consumes the token and returns from <code>park</code>. Note that all <code>park</code> and <code>unpark</code> operations for a given thread form a total order and <em>all</em> prior <code>unpark</code> operations synchronize-with <code>park</code>.</p> <p>In atomic ordering terms, <code>unpark</code> performs a <code>Release</code> operation and <code>park</code> performs the corresponding <code>Acquire</code> operation. Calls to <code>unpark</code> for the same thread form a <a href="https://en.cppreference.com/w/cpp/atomic/memory_order#Release_sequence">release sequence</a>.</p> <p>Note that being unblocked does not imply a call was made to <code>unpark</code>, because wakeups can also be spurious. For example, a valid, but inefficient, implementation could have <code>park</code> and <code>unpark</code> return immediately without doing anything, making <em>all</em> wakeups spurious.</p> <h2 id="examples">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::thread;
use std::sync::atomic::{Ordering, AtomicBool};
use std::time::Duration;

static QUEUED: AtomicBool = AtomicBool::new(false);
static FLAG: AtomicBool = AtomicBool::new(false);

let parked_thread = thread::spawn(move || {
    println!("Thread spawned");
    // Signal that we are going to `park`. Between this store and our `park`, there may
    // be no other `park`, or else that `park` could consume our `unpark` token!
    QUEUED.store(true, Ordering::Release);
    // We want to wait until the flag is set. We *could* just spin, but using
    // park/unpark is more efficient.
    while !FLAG.load(Ordering::Acquire) {
        // We can *not* use `println!` here since that could use thread parking internally.
        thread::park();
        // We *could* get here spuriously, i.e., way before the 10ms below are over!
        // But that is no problem, we are in a loop until the flag is set anyway.
    }
    println!("Flag received");
});

// Let some time pass for the thread to be spawned.
thread::sleep(Duration::from_millis(10));

// Ensure the thread is about to park.
// This is crucial! It guarantees that the `unpark` below is not consumed
// by some other code in the parked thread (e.g. inside `println!`).
while !QUEUED.load(Ordering::Acquire) {
    // Spinning is of course inefficient; in practice, this would more likely be
    // a dequeue where we have no work to do if there's nobody queued.
    std::hint::spin_loop();
}

// Set the flag, and let the thread wake up.
// There is no race condition here: if `unpark`
// happens first, `park` will return immediately.
// There is also no other `park` that could consume this token,
// since we waited until the other thread got queued.
// Hence there is no risk of a deadlock.
FLAG.store(true, Ordering::Release);
println!("Unpark the thread");
parked_thread.thread().unpark();

parked_thread.join().unwrap();</pre></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/thread/fn.park.html" class="_attribution-link">https://doc.rust-lang.org/std/thread/fn.park.html</a>
  </p>
</div>
