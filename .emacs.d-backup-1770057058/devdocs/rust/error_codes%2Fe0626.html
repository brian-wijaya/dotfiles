<h1 id="error-code-e0626">Error code E0626</h1> <p>This error occurs because a borrow in a movable coroutine persists across a yield point.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#![feature(coroutines, coroutine_trait, stmt_expr_attributes)]
use std::ops::Coroutine;
use std::pin::Pin;
let mut b = #[coroutine] || {
    let a = &amp;String::new(); // &lt;-- This borrow...
    yield (); // ...is still in scope here, when the yield occurs.
    println!("{}", a);
};
Pin::new(&amp;mut b).resume(());
}</pre> <p>Coroutines may be either unmarked, or marked with <code>static</code>. If it is unmarked, then the coroutine is considered "movable". At present, it is not permitted to have a yield in a movable coroutine that occurs while a borrow is still in scope. To resolve this error, the coroutine may be marked <code>static</code>:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#![feature(coroutines, coroutine_trait, stmt_expr_attributes)]
use std::ops::Coroutine;
use std::pin::Pin;
let mut b = #[coroutine] static || { // &lt;-- note the static keyword
    let a = &amp;String::from("hello, world");
    yield ();
    println!("{}", a);
};
let mut b = std::pin::pin!(b);
b.as_mut().resume(());
}</pre> <p>If the coroutine must remain movable, for example to be used as <code>Unpin</code> without pinning it on the stack or in an allocation, we can alternatively resolve the previous example by removing the borrow and just storing the type by value:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#![feature(coroutines, coroutine_trait, stmt_expr_attributes)]
use std::ops::Coroutine;
use std::pin::Pin;
let mut b = #[coroutine] || {
    let a = String::from("hello, world");
    yield ();
    println!("{}", a);
};
Pin::new(&amp;mut b).resume(());
}</pre> <p>This is a very simple case, of course. In more complex cases, we may wish to have more than one reference to the value that was borrowed -- in those cases, something like the <code>Rc</code> or <code>Arc</code> types may be useful.</p> <p>This error also frequently arises with iteration:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#![feature(coroutines, coroutine_trait, stmt_expr_attributes)]
use std::ops::Coroutine;
use std::pin::Pin;
let mut b = #[coroutine] || {
  let v = vec![1,2,3];
  for &amp;x in &amp;v { // &lt;-- borrow of `v` is still in scope...
    yield x; // ...when this yield occurs.
  }
};
Pin::new(&amp;mut b).resume(());
}</pre> <p>Such cases can sometimes be resolved by iterating "by value" (or using <code>into_iter()</code>) to avoid borrowing:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#![feature(coroutines, coroutine_trait, stmt_expr_attributes)]
use std::ops::Coroutine;
use std::pin::Pin;
let mut b = #[coroutine] || {
  let v = vec![1,2,3];
  for x in v { // &lt;-- Take ownership of the values instead!
    yield x; // &lt;-- Now yield is OK.
  }
};
Pin::new(&amp;mut b).resume(());
}</pre> <p>If taking ownership is not an option, using indices can work too:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#![feature(coroutines, coroutine_trait, stmt_expr_attributes)]
use std::ops::Coroutine;
use std::pin::Pin;
let mut b = #[coroutine] || {
  let v = vec![1,2,3];
  let len = v.len(); // (*)
  for i in 0..len {
    let x = v[i]; // (*)
    yield x; // &lt;-- Now yield is OK.
  }
};
Pin::new(&amp;mut b).resume(());

// (*) -- Unfortunately, these temporaries are currently required.
// See &lt;https://github.com/rust-lang/rust/issues/43122&gt;.
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0626.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0626.html</a>
  </p>
</div>
