<h1 id="error-code-e0507">Error code E0507</h1> <p>A borrowed value was moved out.</p> <p>Erroneous code example:</p> <pre data-language="rust">use std::cell::RefCell;

struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

fn main() {
    let x = RefCell::new(TheDarkKnight);

    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content
}</pre> <p>Here, the <code>nothing_is_true</code> method takes the ownership of <code>self</code>. However, <code>self</code> cannot be moved because <code>.borrow()</code> only provides an <code>&amp;TheDarkKnight</code>, which is a borrow of the content owned by the <code>RefCell</code>. To fix this error, you have three choices:</p> <ul> <li>Try to avoid moving the variable.</li> <li>Somehow reclaim the ownership.</li> <li>Implement the <code>Copy</code> trait on the type.</li> </ul> <p>This can also happen when using a type implementing <code>Fn</code> or <code>FnMut</code>, as neither allows moving out of them (they usually represent closures which can be called more than once). Much of the text following applies equally well to non-<code>FnOnce</code> closure bodies.</p> <p>Examples:</p> <pre data-language="rust">use std::cell::RefCell;

struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(&amp;self) {} // First case, we don't take ownership
}

fn main() {
    let x = RefCell::new(TheDarkKnight);

    x.borrow().nothing_is_true(); // ok!
}</pre> <p>Or:</p> <pre data-language="rust">use std::cell::RefCell;

struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

fn main() {
    let x = RefCell::new(TheDarkKnight);
    let x = x.into_inner(); // we get back ownership

    x.nothing_is_true(); // ok!
}</pre> <p>Or:</p> <pre data-language="rust">use std::cell::RefCell;

#[derive(Clone, Copy)] // we implement the Copy trait
struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

fn main() {
    let x = RefCell::new(TheDarkKnight);

    x.borrow().nothing_is_true(); // ok!
}</pre> <p>Moving a member out of a mutably borrowed struct will also cause E0507 error:</p> <pre data-language="rust">struct TheDarkKnight;

impl TheDarkKnight {
    fn nothing_is_true(self) {}
}

struct Batcave {
    knight: TheDarkKnight
}

fn main() {
    let mut cave = Batcave {
        knight: TheDarkKnight
    };
    let borrowed = &amp;mut cave;

    borrowed.knight.nothing_is_true(); // E0507
}</pre> <p>It is fine only if you put something back. <code>mem::replace</code> can be used for that:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct TheDarkKnight;
impl TheDarkKnight { fn nothing_is_true(self) {} }
struct Batcave { knight: TheDarkKnight }
use std::mem;

let mut cave = Batcave {
    knight: TheDarkKnight
};
let borrowed = &amp;mut cave;

mem::replace(&amp;mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!
}</pre> <p>For more information on Rust's ownership system, take a look at the <a href="../book/ch04-02-references-and-borrowing">References &amp; Borrowing</a> section of the Book.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0507.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0507.html</a>
  </p>
</div>
