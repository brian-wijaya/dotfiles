<h1 id="error-code-e0283">Error code E0283</h1> <p>The compiler could not infer a type and asked for a type annotation.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let x = "hello".chars().rev().collect();
}</pre> <p>This error indicates that type inference did not result in one unique possible type, and extra information is required. In most cases this can be provided by adding a type annotation. Sometimes you need to specify a generic type parameter manually.</p> <p>A common example is the <code>collect</code> method on <code>Iterator</code>. It has a generic type parameter with a <code>FromIterator</code> bound, which for a <code>char</code> iterator is implemented by <code>Vec</code> and <code>String</code> among others. Consider the following snippet that reverses the characters of a string:</p> <p>In the first code example, the compiler cannot infer what the type of <code>x</code> should be: <code>Vec&lt;char&gt;</code> and <code>String</code> are both suitable candidates. To specify which type to use, you can use a type annotation on <code>x</code>:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let x: Vec&lt;char&gt; = "hello".chars().rev().collect();
}</pre> <p>It is not necessary to annotate the full type. Once the ambiguity is resolved, the compiler can infer the rest:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let x: Vec&lt;_&gt; = "hello".chars().rev().collect();
}</pre> <p>Another way to provide the compiler with enough information, is to specify the generic type parameter:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let x = "hello".chars().rev().collect::&lt;Vec&lt;char&gt;&gt;();
}</pre> <p>Again, you need not specify the full type if the compiler can infer it:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let x = "hello".chars().rev().collect::&lt;Vec&lt;_&gt;&gt;();
}</pre> <p>We can see a self-contained example below:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct Foo;

impl Into&lt;u32&gt; for Foo {
    fn into(self) -&gt; u32 { 1 }
}

let foo = Foo;
let bar: u32 = foo.into() * 1u32;
}</pre> <p>This error can be solved by adding type annotations that provide the missing information to the compiler. In this case, the solution is to specify the trait's type parameter:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct Foo;

impl Into&lt;u32&gt; for Foo {
    fn into(self) -&gt; u32 { 1 }
}

let foo = Foo;
let bar: u32 = Into::&lt;u32&gt;::into(foo) * 1u32;
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0283.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0283.html</a>
  </p>
</div>
