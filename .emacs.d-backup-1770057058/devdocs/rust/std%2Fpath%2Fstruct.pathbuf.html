<h1 class="main-heading">Struct PathBuf </h1>
<pre class="rust item-decl" data-language="rust">pub struct PathBuf { /* private fields */ }</pre>
<p>An owned, mutable path (akin to <a href="../string/struct.string" title="struct std::string::String"><code>String</code></a>).</p> <p>This type provides methods like <a href="struct.pathbuf#method.push" title="method std::path::PathBuf::push"><code>push</code></a> and <a href="struct.pathbuf#method.set_extension" title="method std::path::PathBuf::set_extension"><code>set_extension</code></a> that mutate the path in place. It also implements <a href="../ops/trait.deref" title="trait std::ops::Deref"><code>Deref</code></a> to <a href="struct.path" title="struct std::path::Path"><code>Path</code></a>, meaning that all methods on <a href="struct.path" title="struct std::path::Path"><code>Path</code></a> slices are available on <code>PathBuf</code> values as well.</p> <p>More details about the overall approach can be found in the <a href="index" title="mod std::path">module documentation</a>.</p> <h2 id="examples">Examples</h2> <p>You can use <a href="struct.pathbuf#method.push" title="method std::path::PathBuf::push"><code>push</code></a> to build up a <code>PathBuf</code> from components:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::PathBuf;

let mut path = PathBuf::new();

path.push(r"C:\");
path.push("windows");
path.push("system32");

path.set_extension("dll");</pre></div> <p>However, <a href="struct.pathbuf#method.push" title="method std::path::PathBuf::push"><code>push</code></a> is best used for dynamic situations. This is a better way to do this when you know all of the components ahead of time:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::PathBuf;

let path: PathBuf = [r"C:\", "windows", "system32.dll"].iter().collect();</pre></div> <p>We can still do better than this! Since these are all strings, we can use <code>From::from</code>:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::PathBuf;

let path = PathBuf::from(r"C:\windows\system32.dll");</pre></div> <p>Which method works best depends on what kind of situation you’re in.</p> <p>Note that <code>PathBuf</code> does not always sanitize arguments, for example <a href="struct.pathbuf#method.push" title="method std::path::PathBuf::push"><code>push</code></a> allows paths built from strings which include separators:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::PathBuf;

let mut path = PathBuf::new();

path.push(r"C:\");
path.push("windows");
path.push(r"..\otherdir");
path.push("system32");</pre></div> <p>The behavior of <code>PathBuf</code> may be changed to a panic on such inputs in the future. <a href="../iter/trait.extend#tymethod.extend" title="method std::iter::Extend::extend"><code>Extend::extend</code></a> should be used to add multi-part paths.</p> <h3 id="implementations" class="section-header">Implementations</h3>
<div id="implementations-list">
<summary><section id="impl-PathBuf" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1181-1750">Source</a><pre class="code-header" data-language="rust">impl PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.new" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.91.0">1.0.0 (const: 1.91.0)</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1195-1197">Source</a></span><pre class="code-header" data-language="rust">pub const fn new() -&gt; PathBuf</pre></section></summary><div class="docblock">
<p>Allocates an empty <code>PathBuf</code>.</p> <h5 id="examples-1">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::PathBuf;

let path = PathBuf::new();</pre></div>
</div>
<summary><section id="method.with_capacity" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.44.0">1.44.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1220-1222">Source</a></span><pre class="code-header" data-language="rust">pub fn with_capacity(capacity: usize) -&gt; PathBuf</pre></section></summary><div class="docblock">
<p>Creates a new <code>PathBuf</code> with a given capacity used to create the internal <a href="../ffi/struct.osstring" title="struct std::ffi::OsString"><code>OsString</code></a>. See <a href="../ffi/struct.osstring#method.with_capacity" title="associated function std::ffi::OsString::with_capacity"><code>with_capacity</code></a> defined on <a href="../ffi/struct.osstring" title="struct std::ffi::OsString"><code>OsString</code></a>.</p> <h5 id="examples-2">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::PathBuf;

let mut path = PathBuf::with_capacity(10);
let capacity = path.capacity();

// This push is done without reallocating
path.push(r"C:\");

assert_eq!(capacity, path.capacity());</pre></div>
</div>
<summary><section id="method.as_path" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1238-1240">Source</a></span><pre class="code-header" data-language="rust">pub fn as_path(&amp;self) -&gt; &amp;Path</pre></section></summary><div class="docblock">
<p>Coerces to a <a href="struct.path" title="struct std::path::Path"><code>Path</code></a> slice.</p> <h5 id="examples-3">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::{Path, PathBuf};

let p = PathBuf::from("/test");
assert_eq!(Path::new("/test"), p.as_path());</pre></div>
</div>
<summary><section id="method.leak" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.89.0">1.89.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1257-1259">Source</a></span><pre class="code-header" data-language="rust">pub fn leak&lt;'a&gt;(self) -&gt; &amp;'a mut Path</pre></section></summary><div class="docblock">
<p>Consumes and leaks the <code>PathBuf</code>, returning a mutable reference to the contents, <code>&amp;'a mut Path</code>.</p> <p>The caller has free choice over the returned lifetime, including ’static. Indeed, this function is ideally used for data that lives for the remainder of the program’s life, as dropping the returned reference will cause a memory leak.</p> <p>It does not reallocate or shrink the <code>PathBuf</code>, so the leaked allocation may include unused capacity that is not part of the returned slice. If you want to discard excess capacity, call <a href="struct.pathbuf#method.into_boxed_path" title="method std::path::PathBuf::into_boxed_path"><code>into_boxed_path</code></a>, and then <a href="../boxed/struct.box#method.leak" title="associated function std::boxed::Box::leak"><code>Box::leak</code></a> instead. However, keep in mind that trimming the capacity may result in a reallocation and copy.</p> </div>
<summary><section id="method.push" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1300-1302">Source</a></span><pre class="code-header" data-language="rust">pub fn push&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P)</pre></section></summary><div class="docblock">
<p>Extends <code>self</code> with <code>path</code>.</p> <p>If <code>path</code> is absolute, it replaces the current path.</p> <p>On Windows:</p> <ul> <li>if <code>path</code> has a root but no prefix (e.g., <code>\windows</code>), it replaces everything except for the prefix (if any) of <code>self</code>.</li> <li>if <code>path</code> has a prefix but no root, it replaces <code>self</code>.</li> <li>if <code>self</code> has a verbatim prefix (e.g. <code>\\?\C:\windows</code>) and <code>path</code> is not empty, the new path is normalized: all references to <code>.</code> and <code>..</code> are removed.</li> </ul> <p>Consider using <a href="struct.path#method.join" title="method std::path::Path::join"><code>Path::join</code></a> if you need a new <code>PathBuf</code> instead of using this function on a cloned <code>PathBuf</code>.</p> <h5 id="examples-4">Examples</h5> <p>Pushing a relative path extends the existing path:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::PathBuf;

let mut path = PathBuf::from("/tmp");
path.push("file.bk");
assert_eq!(path, PathBuf::from("/tmp/file.bk"));</pre></div> <p>Pushing an absolute path replaces the existing path:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::PathBuf;

let mut path = PathBuf::from("/tmp");
path.push("/etc");
assert_eq!(path, PathBuf::from("/etc"));</pre></div>
</div>
<summary><section id="method.pop" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1405-1413">Source</a></span><pre class="code-header" data-language="rust">pub fn pop(&amp;mut self) -&gt; bool</pre></section></summary><div class="docblock">
<p>Truncates <code>self</code> to <a href="struct.path#method.parent" title="method std::path::Path::parent"><code>self.parent</code></a>.</p> <p>Returns <code>false</code> and does nothing if <a href="struct.path#method.parent" title="method std::path::Path::parent"><code>self.parent</code></a> is <a href="../option/enum.option#variant.None" title="variant std::option::Option::None"><code>None</code></a>. Otherwise, returns <code>true</code>.</p> <h5 id="examples-5">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::{Path, PathBuf};

let mut p = PathBuf::from("/spirited/away.rs");

p.pop();
assert_eq!(Path::new("/spirited"), p);
p.pop();
assert_eq!(Path::new("/"), p);</pre></div>
</div>
<summary><section id="method.set_file_name" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1455-1457">Source</a></span><pre class="code-header" data-language="rust">pub fn set_file_name&lt;S: AsRef&lt;OsStr&gt;&gt;(&amp;mut self, file_name: S)</pre></section></summary><div class="docblock">
<p>Updates <a href="struct.path#method.file_name" title="method std::path::Path::file_name"><code>self.file_name</code></a> to <code>file_name</code>.</p> <p>If <a href="struct.path#method.file_name" title="method std::path::Path::file_name"><code>self.file_name</code></a> was <a href="../option/enum.option#variant.None" title="variant std::option::Option::None"><code>None</code></a>, this is equivalent to pushing <code>file_name</code>.</p> <p>Otherwise it is equivalent to calling <a href="struct.pathbuf#method.pop" title="method std::path::PathBuf::pop"><code>pop</code></a> and then pushing <code>file_name</code>. The new path will be a sibling of the original path. (That is, it will have the same parent.)</p> <p>The argument is not sanitized, so can include separators. This behavior may be changed to a panic in the future.</p> <h5 id="examples-6">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::PathBuf;

let mut buf = PathBuf::from("/");
assert!(buf.file_name() == None);

buf.set_file_name("foo.txt");
assert!(buf == PathBuf::from("/foo.txt"));
assert!(buf.file_name().is_some());

buf.set_file_name("bar.txt");
assert!(buf == PathBuf::from("/bar.txt"));

buf.set_file_name("baz");
assert!(buf == PathBuf::from("/baz"));

buf.set_file_name("../b/c.txt");
assert!(buf == PathBuf::from("/../b/c.txt"));

buf.set_file_name("baz");
assert!(buf == PathBuf::from("/../b/baz"));</pre></div>
</div>
<summary><section id="method.set_extension" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1524-1526">Source</a></span><pre class="code-header" data-language="rust">pub fn set_extension&lt;S: AsRef&lt;OsStr&gt;&gt;(&amp;mut self, extension: S) -&gt; bool</pre></section></summary><div class="docblock">
<p>Updates <a href="struct.path#method.extension" title="method std::path::Path::extension"><code>self.extension</code></a> to <code>Some(extension)</code> or to <code>None</code> if <code>extension</code> is empty.</p> <p>Returns <code>false</code> and does nothing if <a href="struct.path#method.file_name" title="method std::path::Path::file_name"><code>self.file_name</code></a> is <a href="../option/enum.option#variant.None" title="variant std::option::Option::None"><code>None</code></a>, returns <code>true</code> and updates the extension otherwise.</p> <p>If <a href="struct.path#method.extension" title="method std::path::Path::extension"><code>self.extension</code></a> is <a href="../option/enum.option#variant.None" title="variant std::option::Option::None"><code>None</code></a>, the extension is added; otherwise it is replaced.</p> <p>If <code>extension</code> is the empty string, <a href="struct.path#method.extension" title="method std::path::Path::extension"><code>self.extension</code></a> will be <a href="../option/enum.option#variant.None" title="variant std::option::Option::None"><code>None</code></a> afterwards, not <code>Some("")</code>.</p> <h5 id="panics">Panics</h5> <p>Panics if the passed extension contains a path separator (see <a href="fn.is_separator" title="fn std::path::is_separator"><code>is_separator</code></a>).</p> <h5 id="caveats">Caveats</h5> <p>The new <code>extension</code> may contain dots and will be used in its entirety, but only the part after the final dot will be reflected in <a href="struct.path#method.extension" title="method std::path::Path::extension"><code>self.extension</code></a>.</p> <p>If the file stem contains internal dots and <code>extension</code> is empty, part of the old file stem will be considered the new <a href="struct.path#method.extension" title="method std::path::Path::extension"><code>self.extension</code></a>.</p> <p>See the examples below.</p> <h5 id="examples-7">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::{Path, PathBuf};

let mut p = PathBuf::from("/feel/the");

p.set_extension("force");
assert_eq!(Path::new("/feel/the.force"), p.as_path());

p.set_extension("dark.side");
assert_eq!(Path::new("/feel/the.dark.side"), p.as_path());

p.set_extension("cookie");
assert_eq!(Path::new("/feel/the.dark.cookie"), p.as_path());

p.set_extension("");
assert_eq!(Path::new("/feel/the.dark"), p.as_path());

p.set_extension("");
assert_eq!(Path::new("/feel/the"), p.as_path());

p.set_extension("");
assert_eq!(Path::new("/feel/the"), p.as_path());</pre></div>
</div>
<summary><section id="method.add_extension" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.91.0">1.91.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1598-1600">Source</a></span><pre class="code-header" data-language="rust">pub fn add_extension&lt;S: AsRef&lt;OsStr&gt;&gt;(&amp;mut self, extension: S) -&gt; bool</pre></section></summary><div class="docblock">
<p>Append <a href="struct.path#method.extension" title="method std::path::Path::extension"><code>self.extension</code></a> with <code>extension</code>.</p> <p>Returns <code>false</code> and does nothing if <a href="struct.path#method.file_name" title="method std::path::Path::file_name"><code>self.file_name</code></a> is <a href="../option/enum.option#variant.None" title="variant std::option::Option::None"><code>None</code></a>, returns <code>true</code> and updates the extension otherwise.</p> <h5 id="panics-1">Panics</h5> <p>Panics if the passed extension contains a path separator (see <a href="fn.is_separator" title="fn std::path::is_separator"><code>is_separator</code></a>).</p> <h5 id="caveats-1">Caveats</h5> <p>The appended <code>extension</code> may contain dots and will be used in its entirety, but only the part after the final dot will be reflected in <a href="struct.path#method.extension" title="method std::path::Path::extension"><code>self.extension</code></a>.</p> <p>See the examples below.</p> <h5 id="examples-8">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::{Path, PathBuf};

let mut p = PathBuf::from("/feel/the");

p.add_extension("formatted");
assert_eq!(Path::new("/feel/the.formatted"), p.as_path());

p.add_extension("dark.side");
assert_eq!(Path::new("/feel/the.formatted.dark.side"), p.as_path());

p.set_extension("cookie");
assert_eq!(Path::new("/feel/the.formatted.dark.cookie"), p.as_path());

p.set_extension("");
assert_eq!(Path::new("/feel/the.formatted.dark"), p.as_path());

p.add_extension("");
assert_eq!(Path::new("/feel/the.formatted.dark"), p.as_path());</pre></div>
</div>
<summary><section id="method.as_mut_os_string" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.70.0">1.70.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1648-1650">Source</a></span><pre class="code-header" data-language="rust">pub fn as_mut_os_string(&amp;mut self) -&gt; &amp;mut OsString</pre></section></summary><div class="docblock">
<p>Yields a mutable reference to the underlying <a href="../ffi/struct.osstring" title="struct std::ffi::OsString"><code>OsString</code></a> instance.</p> <h5 id="examples-9">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::{Path, PathBuf};

let mut path = PathBuf::from("/foo");

path.push("bar");
assert_eq!(path, Path::new("/foo/bar"));

// OsString's `push` does not add a separator.
path.as_mut_os_string().push("baz");
assert_eq!(path, Path::new("/foo/barbaz"));</pre></div>
</div>
<summary><section id="method.into_os_string" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1665-1667">Source</a></span><pre class="code-header" data-language="rust">pub fn into_os_string(self) -&gt; OsString</pre></section></summary><div class="docblock">
<p>Consumes the <code>PathBuf</code>, yielding its internal <a href="../ffi/struct.osstring" title="struct std::ffi::OsString"><code>OsString</code></a> storage.</p> <h5 id="examples-10">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::PathBuf;

let p = PathBuf::from("/the/head");
let os_str = p.into_os_string();</pre></div>
</div>
<summary><section id="method.into_boxed_path" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1673-1676">Source</a></span><pre class="code-header" data-language="rust">pub fn into_boxed_path(self) -&gt; Box&lt;Path&gt;</pre></section></summary><div class="docblock">
<p>Converts this <code>PathBuf</code> into a <a href="../boxed/struct.box" title="struct std::boxed::Box">boxed</a> <a href="struct.path" title="struct std::path::Path"><code>Path</code></a>.</p> </div>
<summary><section id="method.capacity" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.44.0">1.44.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1684-1686">Source</a></span><pre class="code-header" data-language="rust">pub fn capacity(&amp;self) -&gt; usize</pre></section></summary><div class="docblock">
<p>Invokes <a href="../ffi/struct.osstring#method.capacity" title="method std::ffi::OsString::capacity"><code>capacity</code></a> on the underlying instance of <a href="../ffi/struct.osstring" title="struct std::ffi::OsString"><code>OsString</code></a>.</p> </div>
<summary><section id="method.clear" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.44.0">1.44.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1693-1695">Source</a></span><pre class="code-header" data-language="rust">pub fn clear(&amp;mut self)</pre></section></summary><div class="docblock">
<p>Invokes <a href="../ffi/struct.osstring#method.clear" title="method std::ffi::OsString::clear"><code>clear</code></a> on the underlying instance of <a href="../ffi/struct.osstring" title="struct std::ffi::OsString"><code>OsString</code></a>.</p> </div>
<summary><section id="method.reserve" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.44.0">1.44.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1702-1704">Source</a></span><pre class="code-header" data-language="rust">pub fn reserve(&amp;mut self, additional: usize)</pre></section></summary><div class="docblock">
<p>Invokes <a href="../ffi/struct.osstring#method.reserve" title="method std::ffi::OsString::reserve"><code>reserve</code></a> on the underlying instance of <a href="../ffi/struct.osstring" title="struct std::ffi::OsString"><code>OsString</code></a>.</p> </div>
<summary><section id="method.try_reserve" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.63.0">1.63.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1711-1713">Source</a></span><pre class="code-header" data-language="rust">pub fn try_reserve(&amp;mut self, additional: usize) -&gt; Result&lt;(), TryReserveError&gt;</pre></section></summary><div class="docblock">
<p>Invokes <a href="../ffi/struct.osstring#method.try_reserve" title="method std::ffi::OsString::try_reserve"><code>try_reserve</code></a> on the underlying instance of <a href="../ffi/struct.osstring" title="struct std::ffi::OsString"><code>OsString</code></a>.</p> </div>
<summary><section id="method.reserve_exact" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.44.0">1.44.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1720-1722">Source</a></span><pre class="code-header" data-language="rust">pub fn reserve_exact(&amp;mut self, additional: usize)</pre></section></summary><div class="docblock">
<p>Invokes <a href="../ffi/struct.osstring#method.reserve_exact" title="method std::ffi::OsString::reserve_exact"><code>reserve_exact</code></a> on the underlying instance of <a href="../ffi/struct.osstring" title="struct std::ffi::OsString"><code>OsString</code></a>.</p> </div>
<summary><section id="method.try_reserve_exact" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.63.0">1.63.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1729-1731">Source</a></span><pre class="code-header" data-language="rust">pub fn try_reserve_exact(
    &amp;mut self,
    additional: usize,
) -&gt; Result&lt;(), TryReserveError&gt;</pre></section></summary><div class="docblock">
<p>Invokes <a href="../ffi/struct.osstring#method.try_reserve_exact" title="method std::ffi::OsString::try_reserve_exact"><code>try_reserve_exact</code></a> on the underlying instance of <a href="../ffi/struct.osstring" title="struct std::ffi::OsString"><code>OsString</code></a>.</p> </div>
<summary><section id="method.shrink_to_fit" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.44.0">1.44.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1738-1740">Source</a></span><pre class="code-header" data-language="rust">pub fn shrink_to_fit(&amp;mut self)</pre></section></summary><div class="docblock">
<p>Invokes <a href="../ffi/struct.osstring#method.shrink_to_fit" title="method std::ffi::OsString::shrink_to_fit"><code>shrink_to_fit</code></a> on the underlying instance of <a href="../ffi/struct.osstring" title="struct std::ffi::OsString"><code>OsString</code></a>.</p> </div>
<summary><section id="method.shrink_to" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.56.0">1.56.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1747-1749">Source</a></span><pre class="code-header" data-language="rust">pub fn shrink_to(&amp;mut self, min_capacity: usize)</pre></section></summary><div class="docblock">
<p>Invokes <a href="../ffi/struct.osstring#method.shrink_to" title="method std::ffi::OsString::shrink_to"><code>shrink_to</code></a> on the underlying instance of <a href="../ffi/struct.osstring" title="struct std::ffi::OsString"><code>OsString</code></a>.</p> </div>
</div>
</div>
<summary><h3 id="deref-methods-Path" class="section-header"><span>Methods from <a class="trait" href="../ops/trait.deref" title="trait std::ops::Deref">Deref</a>&lt;Target = <a class="struct" href="struct.path" title="struct std::path::Path">Path</a>&gt;</span></h3></summary><summary><section id="method.as_os_str" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2290-2292">Source</a></span><pre class="code-header" data-language="rust">pub fn as_os_str(&amp;self) -&gt; &amp;OsStr</pre></section></summary><div class="docblock">
<p>Yields the underlying <a href="../ffi/struct.osstr" title="struct std::ffi::OsStr"><code>OsStr</code></a> slice.</p> <h5 id="examples-11">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

let os_str = Path::new("foo.txt").as_os_str();
assert_eq!(os_str, std::ffi::OsStr::new("foo.txt"));</pre></div>
</div>
<summary><section id="method.as_mut_os_str" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.70.0">1.70.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2311-2313">Source</a></span><pre class="code-header" data-language="rust">pub fn as_mut_os_str(&amp;mut self) -&gt; &amp;mut OsStr</pre></section></summary><div class="docblock">
<p>Yields a mutable reference to the underlying <a href="../ffi/struct.osstr" title="struct std::ffi::OsStr"><code>OsStr</code></a> slice.</p> <h5 id="examples-12">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::{Path, PathBuf};

let mut path = PathBuf::from("Foo.TXT");

assert_ne!(path, Path::new("foo.txt"));

path.as_mut_os_str().make_ascii_lowercase();
assert_eq!(path, Path::new("foo.txt"));</pre></div>
</div>
<summary><section id="method.to_str" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2335-2337">Source</a></span><pre class="code-header" data-language="rust">pub fn to_str(&amp;self) -&gt; Option&lt;&amp;str&gt;</pre></section></summary><div class="docblock">
<p>Yields a <a href="../primitive.str" title="primitive str"><code>&amp;str</code></a> slice if the <code>Path</code> is valid unicode.</p> <p>This conversion may entail doing a check for UTF-8 validity. Note that validation is performed because non-UTF-8 strings are perfectly valid for some OS.</p> <h5 id="examples-13">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

let path = Path::new("foo.txt");
assert_eq!(path.to_str(), Some("foo.txt"));</pre></div>
</div>
<summary><section id="method.to_string_lossy" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2363-2365">Source</a></span><pre class="code-header" data-language="rust">pub fn to_string_lossy(&amp;self) -&gt; Cow&lt;'_, str&gt;</pre></section></summary><div class="docblock">
<p>Converts a <code>Path</code> to a <a href="../borrow/enum.cow" title="enum std::borrow::Cow"><code>Cow&lt;str&gt;</code></a>.</p> <p>Any non-UTF-8 sequences are replaced with <a href="../char/constant.replacement_character" title="constant std::char::REPLACEMENT_CHARACTER"><code>U+FFFD REPLACEMENT CHARACTER</code></a>.</p> <h5 id="examples-14">Examples</h5> <p>Calling <code>to_string_lossy</code> on a <code>Path</code> with valid unicode:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

let path = Path::new("foo.txt");
assert_eq!(path.to_string_lossy(), "foo.txt");</pre></div> <p>Had <code>path</code> contained invalid unicode, the <code>to_string_lossy</code> call might have returned <code>"fo�.txt"</code>.</p> </div>
<summary><section id="method.to_path_buf" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2382-2384">Source</a></span><pre class="code-header" data-language="rust">pub fn to_path_buf(&amp;self) -&gt; PathBuf</pre></section></summary><div class="docblock">
<p>Converts a <code>Path</code> to an owned <a href="struct.pathbuf" title="struct std::path::PathBuf"><code>PathBuf</code></a>.</p> <h5 id="examples-15">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::{Path, PathBuf};

let path_buf = Path::new("foo.txt").to_path_buf();
assert_eq!(path_buf, PathBuf::from("foo.txt"));</pre></div>
</div>
<summary><section id="method.is_absolute" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2407-2409">Source</a></span><pre class="code-header" data-language="rust">pub fn is_absolute(&amp;self) -&gt; bool</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if the <code>Path</code> is absolute, i.e., if it is independent of the current directory.</p> <ul> <li> <p>On Unix, a path is absolute if it starts with the root, so <code>is_absolute</code> and <a href="struct.path#method.has_root" title="method std::path::Path::has_root"><code>has_root</code></a> are equivalent.</p> </li> <li> <p>On Windows, a path is absolute if it has a prefix and starts with the root: <code>c:\windows</code> is absolute, while <code>c:temp</code> and <code>\temp</code> are not.</p> </li> </ul> <h5 id="examples-16">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

assert!(!Path::new("foo.txt").is_absolute());</pre></div>
</div>
<summary><section id="method.is_relative" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2427-2429">Source</a></span><pre class="code-header" data-language="rust">pub fn is_relative(&amp;self) -&gt; bool</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if the <code>Path</code> is relative, i.e., not absolute.</p> <p>See <a href="struct.path#method.is_absolute" title="method std::path::Path::is_absolute"><code>is_absolute</code></a>’s documentation for more details.</p> <h5 id="examples-17">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

assert!(Path::new("foo.txt").is_relative());</pre></div>
</div>
<summary><section id="method.has_root" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2454-2456">Source</a></span><pre class="code-header" data-language="rust">pub fn has_root(&amp;self) -&gt; bool</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if the <code>Path</code> has a root.</p> <ul> <li> <p>On Unix, a path has a root if it begins with <code>/</code>.</p> </li> <li> <p>On Windows, a path has a root if it:</p> <ul> <li>has no prefix and begins with a separator, e.g., <code>\windows</code>
</li> <li>has a prefix followed by a separator, e.g., <code>c:\windows</code> but not <code>c:windows</code>
</li> <li>has any non-disk prefix, e.g., <code>\\server\share</code>
</li> </ul> </li> </ul> <h5 id="examples-18">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

assert!(Path::new("/etc/passwd").has_root());</pre></div>
</div>
<summary><section id="method.parent" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2489-2498">Source</a></span><pre class="code-header" data-language="rust">pub fn parent(&amp;self) -&gt; Option&lt;&amp;Path&gt;</pre></section></summary><div class="docblock">
<p>Returns the <code>Path</code> without its final component, if there is one.</p> <p>This means it returns <code>Some("")</code> for relative paths with one component.</p> <p>Returns <a href="../option/enum.option#variant.None" title="variant std::option::Option::None"><code>None</code></a> if the path terminates in a root or prefix, or if it’s the empty string.</p> <h5 id="examples-19">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

let path = Path::new("/foo/bar");
let parent = path.parent().unwrap();
assert_eq!(parent, Path::new("/foo"));

let grand_parent = parent.parent().unwrap();
assert_eq!(grand_parent, Path::new("/"));
assert_eq!(grand_parent.parent(), None);

let relative_path = Path::new("foo/bar");
let parent = relative_path.parent();
assert_eq!(parent, Some(Path::new("foo")));
let grand_parent = parent.and_then(Path::parent);
assert_eq!(grand_parent, Some(Path::new("")));
let great_grand_parent = grand_parent.and_then(Path::parent);
assert_eq!(great_grand_parent, None);</pre></div>
</div>
<summary><section id="method.ancestors" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.28.0">1.28.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2529-2531">Source</a></span><pre class="code-header" data-language="rust">pub fn ancestors(&amp;self) -&gt; Ancestors&lt;'_&gt; ⓘ</pre></section></summary><div class="docblock">
<p>Produces an iterator over <code>Path</code> and its ancestors.</p> <p>The iterator will yield the <code>Path</code> that is returned if the <a href="struct.path#method.parent" title="method std::path::Path::parent"><code>parent</code></a> method is used zero or more times. If the <a href="struct.path#method.parent" title="method std::path::Path::parent"><code>parent</code></a> method returns <a href="../option/enum.option#variant.None" title="variant std::option::Option::None"><code>None</code></a>, the iterator will do likewise. The iterator will always yield at least one value, namely <code>Some(&amp;self)</code>. Next it will yield <code>&amp;self.parent()</code>, <code>&amp;self.parent().and_then(Path::parent)</code> and so on.</p> <h5 id="examples-20">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

let mut ancestors = Path::new("/foo/bar").ancestors();
assert_eq!(ancestors.next(), Some(Path::new("/foo/bar")));
assert_eq!(ancestors.next(), Some(Path::new("/foo")));
assert_eq!(ancestors.next(), Some(Path::new("/")));
assert_eq!(ancestors.next(), None);

let mut ancestors = Path::new("../foo/bar").ancestors();
assert_eq!(ancestors.next(), Some(Path::new("../foo/bar")));
assert_eq!(ancestors.next(), Some(Path::new("../foo")));
assert_eq!(ancestors.next(), Some(Path::new("..")));
assert_eq!(ancestors.next(), Some(Path::new("")));
assert_eq!(ancestors.next(), None);</pre></div>
</div>
<summary><section id="method.file_name" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2556-2561">Source</a></span><pre class="code-header" data-language="rust">pub fn file_name(&amp;self) -&gt; Option&lt;&amp;OsStr&gt;</pre></section></summary><div class="docblock">
<p>Returns the final component of the <code>Path</code>, if there is one.</p> <p>If the path is a normal file, this is the file name. If it’s the path of a directory, this is the directory name.</p> <p>Returns <a href="../option/enum.option#variant.None" title="variant std::option::Option::None"><code>None</code></a> if the path terminates in <code>..</code>.</p> <h5 id="examples-21">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;
use std::ffi::OsStr;

assert_eq!(Some(OsStr::new("bin")), Path::new("/usr/bin/").file_name());
assert_eq!(Some(OsStr::new("foo.txt")), Path::new("tmp/foo.txt").file_name());
assert_eq!(Some(OsStr::new("foo.txt")), Path::new("foo.txt/.").file_name());
assert_eq!(Some(OsStr::new("foo.txt")), Path::new("foo.txt/.//").file_name());
assert_eq!(None, Path::new("foo.txt/..").file_name());
assert_eq!(None, Path::new("/").file_name());</pre></div>
</div>
<summary><section id="method.strip_prefix" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.7.0">1.7.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2593-2598">Source</a></span><pre class="code-header" data-language="rust">pub fn strip_prefix&lt;P&gt;(&amp;self, base: P) -&gt; Result&lt;&amp;Path, StripPrefixError&gt;where
    P: AsRef&lt;Path&gt;,</pre></section></summary><div class="docblock">
<p>Returns a path that, when joined onto <code>base</code>, yields <code>self</code>.</p> <h5 id="errors">Errors</h5> <p>If <code>base</code> is not a prefix of <code>self</code> (i.e., <a href="struct.path#method.starts_with" title="method std::path::Path::starts_with"><code>starts_with</code></a> returns <code>false</code>), returns <a href="../result/enum.result#variant.Err" title="variant std::result::Result::Err"><code>Err</code></a>.</p> <h5 id="examples-22">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::{Path, PathBuf};

let path = Path::new("/test/haha/foo.txt");

assert_eq!(path.strip_prefix("/"), Ok(Path::new("test/haha/foo.txt")));
assert_eq!(path.strip_prefix("/test"), Ok(Path::new("haha/foo.txt")));
assert_eq!(path.strip_prefix("/test/"), Ok(Path::new("haha/foo.txt")));
assert_eq!(path.strip_prefix("/test/haha/foo.txt"), Ok(Path::new("")));
assert_eq!(path.strip_prefix("/test/haha/foo.txt/"), Ok(Path::new("")));

assert!(path.strip_prefix("test").is_err());
assert!(path.strip_prefix("/te").is_err());
assert!(path.strip_prefix("/haha").is_err());

let prefix = PathBuf::from("/test/");
assert_eq!(path.strip_prefix(prefix), Ok(Path::new("haha/foo.txt")));</pre></div>
</div>
<summary><section id="method.starts_with" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2630-2632">Source</a></span><pre class="code-header" data-language="rust">pub fn starts_with&lt;P: AsRef&lt;Path&gt;&gt;(&amp;self, base: P) -&gt; bool</pre></section></summary><div class="docblock">
<p>Determines whether <code>base</code> is a prefix of <code>self</code>.</p> <p>Only considers whole path components to match.</p> <h5 id="examples-23">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

let path = Path::new("/etc/passwd");

assert!(path.starts_with("/etc"));
assert!(path.starts_with("/etc/"));
assert!(path.starts_with("/etc/passwd"));
assert!(path.starts_with("/etc/passwd/")); // extra slash is okay
assert!(path.starts_with("/etc/passwd///")); // multiple extra slashes are okay

assert!(!path.starts_with("/e"));
assert!(!path.starts_with("/etc/passwd.txt"));

assert!(!Path::new("/etc/foo.rs").starts_with("/etc/foo"));</pre></div>
</div>
<summary><section id="method.ends_with" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2658-2660">Source</a></span><pre class="code-header" data-language="rust">pub fn ends_with&lt;P: AsRef&lt;Path&gt;&gt;(&amp;self, child: P) -&gt; bool</pre></section></summary><div class="docblock">
<p>Determines whether <code>child</code> is a suffix of <code>self</code>.</p> <p>Only considers whole path components to match.</p> <h5 id="examples-24">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

let path = Path::new("/etc/resolv.conf");

assert!(path.ends_with("resolv.conf"));
assert!(path.ends_with("etc/resolv.conf"));
assert!(path.ends_with("/etc/resolv.conf"));

assert!(!path.ends_with("/resolv.conf"));
assert!(!path.ends_with("conf")); // use .extension() instead</pre></div>
</div>
<summary><section id="method.file_stem" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2694-2696">Source</a></span><pre class="code-header" data-language="rust">pub fn file_stem(&amp;self) -&gt; Option&lt;&amp;OsStr&gt;</pre></section></summary><div class="docblock">
<p>Extracts the stem (non-extension) portion of <a href="struct.path#method.file_name" title="method std::path::Path::file_name"><code>self.file_name</code></a>.</p> <p>The stem is:</p> <ul> <li>
<a href="../option/enum.option#variant.None" title="variant std::option::Option::None"><code>None</code></a>, if there is no file name;</li> <li>The entire file name if there is no embedded <code>.</code>;</li> <li>The entire file name if the file name begins with <code>.</code> and has no other <code>.</code>s within;</li> <li>Otherwise, the portion of the file name before the final <code>.</code>
</li> </ul> <h5 id="examples-25">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

assert_eq!("foo", Path::new("foo.rs").file_stem().unwrap());
assert_eq!("foo.tar", Path::new("foo.tar.gz").file_stem().unwrap());</pre></div>
<h5 id="see-also">See Also</h5> <p>This method is similar to <a href="struct.path#method.file_prefix" title="method std::path::Path::file_prefix"><code>Path::file_prefix</code></a>, which extracts the portion of the file name before the <em>first</em> <code>.</code></p> </div>
<summary><section id="method.file_prefix" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.91.0">1.91.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2729-2731">Source</a></span><pre class="code-header" data-language="rust">pub fn file_prefix(&amp;self) -&gt; Option&lt;&amp;OsStr&gt;</pre></section></summary><div class="docblock">
<p>Extracts the prefix of <a href="struct.path#method.file_name" title="method std::path::Path::file_name"><code>self.file_name</code></a>.</p> <p>The prefix is:</p> <ul> <li>
<a href="../option/enum.option#variant.None" title="variant std::option::Option::None"><code>None</code></a>, if there is no file name;</li> <li>The entire file name if there is no embedded <code>.</code>;</li> <li>The portion of the file name before the first non-beginning <code>.</code>;</li> <li>The entire file name if the file name begins with <code>.</code> and has no other <code>.</code>s within;</li> <li>The portion of the file name before the second <code>.</code> if the file name begins with <code>.</code>
</li> </ul> <h5 id="examples-26">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

assert_eq!("foo", Path::new("foo.rs").file_prefix().unwrap());
assert_eq!("foo", Path::new("foo.tar.gz").file_prefix().unwrap());
assert_eq!(".config", Path::new(".config").file_prefix().unwrap());
assert_eq!(".config", Path::new(".config.toml").file_prefix().unwrap());</pre></div>
<h5 id="see-also-1">See Also</h5> <p>This method is similar to <a href="struct.path#method.file_stem" title="method std::path::Path::file_stem"><code>Path::file_stem</code></a>, which extracts the portion of the file name before the <em>last</em> <code>.</code></p> </div>
<summary><section id="method.extension" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2754-2756">Source</a></span><pre class="code-header" data-language="rust">pub fn extension(&amp;self) -&gt; Option&lt;&amp;OsStr&gt;</pre></section></summary><div class="docblock">
<p>Extracts the extension (without the leading dot) of <a href="struct.path#method.file_name" title="method std::path::Path::file_name"><code>self.file_name</code></a>, if possible.</p> <p>The extension is:</p> <ul> <li>
<a href="../option/enum.option#variant.None" title="variant std::option::Option::None"><code>None</code></a>, if there is no file name;</li> <li>
<a href="../option/enum.option#variant.None" title="variant std::option::Option::None"><code>None</code></a>, if there is no embedded <code>.</code>;</li> <li>
<a href="../option/enum.option#variant.None" title="variant std::option::Option::None"><code>None</code></a>, if the file name begins with <code>.</code> and has no other <code>.</code>s within;</li> <li>Otherwise, the portion of the file name after the final <code>.</code>
</li> </ul> <h5 id="examples-27">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

assert_eq!("rs", Path::new("foo.rs").extension().unwrap());
assert_eq!("gz", Path::new("foo.tar.gz").extension().unwrap());</pre></div>
</div>
<summary><section id="method.join" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2774-2776">Source</a></span><pre class="code-header" data-language="rust">pub fn join&lt;P: AsRef&lt;Path&gt;&gt;(&amp;self, path: P) -&gt; PathBuf</pre></section></summary><div class="docblock">
<p>Creates an owned <a href="struct.pathbuf" title="struct std::path::PathBuf"><code>PathBuf</code></a> with <code>path</code> adjoined to <code>self</code>.</p> <p>If <code>path</code> is absolute, it replaces the current path.</p> <p>See <a href="struct.pathbuf#method.push" title="method std::path::PathBuf::push"><code>PathBuf::push</code></a> for more details on what it means to adjoin a path.</p> <h5 id="examples-28">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::{Path, PathBuf};

assert_eq!(Path::new("/etc").join("passwd"), PathBuf::from("/etc/passwd"));
assert_eq!(Path::new("/etc").join("/bin/sh"), PathBuf::from("/bin/sh"));</pre></div>
</div>
<summary><section id="method.with_file_name" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2802-2804">Source</a></span><pre class="code-header" data-language="rust">pub fn with_file_name&lt;S: AsRef&lt;OsStr&gt;&gt;(&amp;self, file_name: S) -&gt; PathBuf</pre></section></summary><div class="docblock">
<p>Creates an owned <a href="struct.pathbuf" title="struct std::path::PathBuf"><code>PathBuf</code></a> like <code>self</code> but with the given file name.</p> <p>See <a href="struct.pathbuf#method.set_file_name" title="method std::path::PathBuf::set_file_name"><code>PathBuf::set_file_name</code></a> for more details.</p> <h5 id="examples-29">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::{Path, PathBuf};

let path = Path::new("/tmp/foo.png");
assert_eq!(path.with_file_name("bar"), PathBuf::from("/tmp/bar"));
assert_eq!(path.with_file_name("bar.txt"), PathBuf::from("/tmp/bar.txt"));

let path = Path::new("/tmp");
assert_eq!(path.with_file_name("var"), PathBuf::from("/var"));</pre></div>
</div>
<summary><section id="method.with_extension" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2845-2847">Source</a></span><pre class="code-header" data-language="rust">pub fn with_extension&lt;S: AsRef&lt;OsStr&gt;&gt;(&amp;self, extension: S) -&gt; PathBuf</pre></section></summary><div class="docblock">
<p>Creates an owned <a href="struct.pathbuf" title="struct std::path::PathBuf"><code>PathBuf</code></a> like <code>self</code> but with the given extension.</p> <p>See <a href="struct.pathbuf#method.set_extension" title="method std::path::PathBuf::set_extension"><code>PathBuf::set_extension</code></a> for more details.</p> <h5 id="examples-30">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

let path = Path::new("foo.rs");
assert_eq!(path.with_extension("txt"), Path::new("foo.txt"));
assert_eq!(path.with_extension(""), Path::new("foo"));</pre></div> <p>Handling multiple extensions:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

let path = Path::new("foo.tar.gz");
assert_eq!(path.with_extension("xz"), Path::new("foo.tar.xz"));
assert_eq!(path.with_extension("").with_extension("txt"), Path::new("foo.txt"));</pre></div> <p>Adding an extension where one did not exist:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

let path = Path::new("foo");
assert_eq!(path.with_extension("rs"), Path::new("foo.rs"));</pre></div>
</div>
<summary><section id="method.with_added_extension" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.91.0">1.91.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2892-2896">Source</a></span><pre class="code-header" data-language="rust">pub fn with_added_extension&lt;S: AsRef&lt;OsStr&gt;&gt;(&amp;self, extension: S) -&gt; PathBuf</pre></section></summary><div class="docblock">
<p>Creates an owned <a href="struct.pathbuf" title="struct std::path::PathBuf"><code>PathBuf</code></a> like <code>self</code> but with the extension added.</p> <p>See <a href="struct.pathbuf#method.add_extension" title="method std::path::PathBuf::add_extension"><code>PathBuf::add_extension</code></a> for more details.</p> <h5 id="examples-31">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::{Path, PathBuf};

let path = Path::new("foo.rs");
assert_eq!(path.with_added_extension("txt"), PathBuf::from("foo.rs.txt"));

let path = Path::new("foo.tar.gz");
assert_eq!(path.with_added_extension(""), PathBuf::from("foo.tar.gz"));
assert_eq!(path.with_added_extension("xz"), PathBuf::from("foo.tar.gz.xz"));
assert_eq!(path.with_added_extension("").with_added_extension("txt"), PathBuf::from("foo.tar.gz.txt"));</pre></div>
</div>
<summary><section id="method.components" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2932-2941">Source</a></span><pre class="code-header" data-language="rust">pub fn components(&amp;self) -&gt; Components&lt;'_&gt; ⓘ</pre></section></summary><div class="docblock">
<p>Produces an iterator over the <a href="enum.component" title="enum std::path::Component"><code>Component</code></a>s of the path.</p> <p>When parsing the path, there is a small amount of normalization:</p> <ul> <li> <p>Repeated separators are ignored, so <code>a/b</code> and <code>a//b</code> both have <code>a</code> and <code>b</code> as components.</p> </li> <li> <p>Occurrences of <code>.</code> are normalized away, except if they are at the beginning of the path. For example, <code>a/./b</code>, <code>a/b/</code>, <code>a/b/.</code> and <code>a/b</code> all have <code>a</code> and <code>b</code> as components, but <code>./a/b</code> starts with an additional <a href="enum.component#variant.CurDir" title="variant std::path::Component::CurDir"><code>CurDir</code></a> component.</p> </li> <li> <p>A trailing slash is normalized away, <code>/a/b</code> and <code>/a/b/</code> are equivalent.</p> </li> </ul> <p>Note that no other normalization takes place; in particular, <code>a/c</code> and <code>a/b/../c</code> are distinct, to account for the possibility that <code>b</code> is a symbolic link (so its parent isn’t <code>a</code>).</p> <h5 id="examples-32">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::{Path, Component};
use std::ffi::OsStr;

let mut components = Path::new("/tmp/foo.txt").components();

assert_eq!(components.next(), Some(Component::RootDir));
assert_eq!(components.next(), Some(Component::Normal(OsStr::new("tmp"))));
assert_eq!(components.next(), Some(Component::Normal(OsStr::new("foo.txt"))));
assert_eq!(components.next(), None)</pre></div>
</div>
<summary><section id="method.iter" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2965-2967">Source</a></span><pre class="code-header" data-language="rust">pub fn iter(&amp;self) -&gt; Iter&lt;'_&gt; ⓘ</pre></section></summary><div class="docblock">
<p>Produces an iterator over the path’s components viewed as <a href="../ffi/struct.osstr" title="struct std::ffi::OsStr"><code>OsStr</code></a> slices.</p> <p>For more information about the particulars of how the path is separated into components, see <a href="struct.path#method.components" title="method std::path::Path::components"><code>components</code></a>.</p> <h5 id="examples-33">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::{self, Path};
use std::ffi::OsStr;

let mut it = Path::new("/tmp/foo.txt").iter();
assert_eq!(it.next(), Some(OsStr::new(&amp;path::MAIN_SEPARATOR.to_string())));
assert_eq!(it.next(), Some(OsStr::new("tmp")));
assert_eq!(it.next(), Some(OsStr::new("foo.txt")));
assert_eq!(it.next(), None)</pre></div>
</div>
<summary><section id="method.display" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2990-2992">Source</a></span><pre class="code-header" data-language="rust">pub fn display(&amp;self) -&gt; Display&lt;'_&gt;</pre></section></summary><div class="docblock">
<p>Returns an object that implements <a href="../fmt/trait.display" title="trait std::fmt::Display"><code>Display</code></a> for safely printing paths that may contain non-Unicode data. This may perform lossy conversion, depending on the platform. If you would like an implementation which escapes the path please use <a href="../fmt/trait.debug" title="trait std::fmt::Debug"><code>Debug</code></a> instead.</p> <h5 id="examples-34">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

let path = Path::new("/tmp/foo.rs");

println!("{}", path.display());</pre></div>
</div>
<summary><section id="method.metadata" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3012-3014">Source</a></span><pre class="code-header" data-language="rust">pub fn metadata(&amp;self) -&gt; Result&lt;Metadata&gt;</pre></section></summary><div class="docblock">
<p>Queries the file system to get information about a file, directory, etc.</p> <p>This function will traverse symbolic links to query information about the destination file.</p> <p>This is an alias to <a href="../fs/fn.metadata" title="fn std::fs::metadata"><code>fs::metadata</code></a>.</p> <h5 id="examples-35">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

let path = Path::new("/Minas/tirith");
let metadata = path.metadata().expect("metadata call failed");
println!("{:?}", metadata.file_type());</pre></div>
</div>
<summary><section id="method.symlink_metadata" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3031-3033">Source</a></span><pre class="code-header" data-language="rust">pub fn symlink_metadata(&amp;self) -&gt; Result&lt;Metadata&gt;</pre></section></summary><div class="docblock">
<p>Queries the metadata about a file without following symlinks.</p> <p>This is an alias to <a href="../fs/fn.symlink_metadata" title="fn std::fs::symlink_metadata"><code>fs::symlink_metadata</code></a>.</p> <h5 id="examples-36">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

let path = Path::new("/Minas/tirith");
let metadata = path.symlink_metadata().expect("symlink_metadata call failed");
println!("{:?}", metadata.file_type());</pre></div>
</div>
<summary><section id="method.canonicalize" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3058-3060">Source</a></span><pre class="code-header" data-language="rust">pub fn canonicalize(&amp;self) -&gt; Result&lt;PathBuf&gt;</pre></section></summary><div class="docblock">
<p>Returns the canonical, absolute form of the path with all intermediate components normalized and symbolic links resolved.</p> <p>This is an alias to <a href="../fs/fn.canonicalize" title="fn std::fs::canonicalize"><code>fs::canonicalize</code></a>.</p> <h5 id="errors-1">Errors</h5> <p>This method will return an error in the following situations, but is not limited to just these cases:</p> <ul> <li>
<code>path</code> does not exist.</li> <li>A non-final component in path is not a directory.</li> </ul> <h5 id="examples-37">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::{Path, PathBuf};

let path = Path::new("/foo/test/../test/bar.rs");
assert_eq!(path.canonicalize().unwrap(), PathBuf::from("/foo/test/bar.rs"));</pre></div>
</div>
<summary><section id="method.normalize_lexically" class="method"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3077-3121">Source</a><pre class="code-header" data-language="rust">pub fn normalize_lexically(&amp;self) -&gt; Result&lt;PathBuf, NormalizeError&gt;</pre></section><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>normalize_lexically</code> <a href="https://github.com/rust-lang/rust/issues/134694">#134694</a>)</span>
</div></span></summary><div class="docblock">
<p>Normalize a path, including <code>..</code> without traversing the filesystem.</p> <p>Returns an error if normalization would leave leading <code>..</code> components.</p> <div class="warning"> <p>This function always resolves <code>..</code> to the “lexical” parent. That is “a/b/../c” will always resolve to <code>a/c</code> which can change the meaning of the path. In particular, <code>a/c</code> and <code>a/b/../c</code> are distinct on many systems because <code>b</code> may be a symbolic link, so its parent isn’t <code>a</code>.</p> </div> <p><a href="fn.absolute" title="fn std::path::absolute"><code>path::absolute</code></a> is an alternative that preserves <code>..</code>. Or <a href="struct.path#method.canonicalize" title="method std::path::Path::canonicalize"><code>Path::canonicalize</code></a> can be used to resolve any <code>..</code> by querying the filesystem.</p> </div>
<summary><section id="method.read_link" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3137-3139">Source</a></span><pre class="code-header" data-language="rust">pub fn read_link(&amp;self) -&gt; Result&lt;PathBuf&gt;</pre></section></summary><div class="docblock">
<p>Reads a symbolic link, returning the file that the link points to.</p> <p>This is an alias to <a href="../fs/fn.read_link" title="fn std::fs::read_link"><code>fs::read_link</code></a>.</p> <h5 id="examples-38">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

let path = Path::new("/laputa/sky_castle.rs");
let path_link = path.read_link().expect("read_link call failed");</pre></div>
</div>
<summary><section id="method.read_dir" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3162-3164">Source</a></span><pre class="code-header" data-language="rust">pub fn read_dir(&amp;self) -&gt; Result&lt;ReadDir&gt;</pre></section></summary><div class="docblock">
<p>Returns an iterator over the entries within a directory.</p> <p>The iterator will yield instances of <code><a href="../io/type.result" title="type std::io::Result">io::Result</a>&lt;<a href="../fs/struct.direntry" title="struct std::fs::DirEntry">fs::DirEntry</a>&gt;</code>. New errors may be encountered after an iterator is initially constructed.</p> <p>This is an alias to <a href="../fs/fn.read_dir" title="fn std::fs::read_dir"><code>fs::read_dir</code></a>.</p> <h5 id="examples-39">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;

let path = Path::new("/laputa");
for entry in path.read_dir().expect("read_dir call failed") {
    if let Ok(entry) = entry {
        println!("{:?}", entry.path());
    }
}</pre></div>
</div>
<summary><section id="method.exists" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3194-3196">Source</a></span><pre class="code-header" data-language="rust">pub fn exists(&amp;self) -&gt; bool</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if the path points at an existing entity.</p> <p>Warning: this method may be error-prone, consider using <a href="struct.path#method.try_exists" title="method std::path::Path::try_exists"><code>try_exists()</code></a> instead! It also has a risk of introducing time-of-check to time-of-use (<a href="../fs/index#time-of-check-to-time-of-use-toctou" title="mod std::fs">TOCTOU</a>) bugs.</p> <p>This function will traverse symbolic links to query information about the destination file.</p> <p>If you cannot access the metadata of the file, e.g. because of a permission error or broken symbolic links, this will return <code>false</code>.</p> <h5 id="examples-40">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;
assert!(!Path::new("does_not_exist.txt").exists());</pre></div>
<h5 id="see-also-2">See Also</h5> <p>This is a convenience function that coerces errors to false. If you want to check errors, call <a href="struct.path#method.try_exists" title="method std::path::Path::try_exists"><code>Path::try_exists</code></a>.</p> </div>
<summary><section id="method.try_exists" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.63.0">1.63.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3227-3229">Source</a></span><pre class="code-header" data-language="rust">pub fn try_exists(&amp;self) -&gt; Result&lt;bool&gt;</pre></section></summary><div class="docblock">
<p>Returns <code>Ok(true)</code> if the path points at an existing entity.</p> <p>This function will traverse symbolic links to query information about the destination file. In case of broken symbolic links this will return <code>Ok(false)</code>.</p> <p><a href="struct.path#method.exists" title="method std::path::Path::exists"><code>Path::exists()</code></a> only checks whether or not a path was both found and readable. By contrast, <code>try_exists</code> will return <code>Ok(true)</code> or <code>Ok(false)</code>, respectively, if the path was <em>verified</em> to exist or not exist. If its existence can neither be confirmed nor denied, it will propagate an <code>Err(_)</code> instead. This can be the case if e.g. listing permission is denied on one of the parent directories.</p> <p>Note that while this avoids some pitfalls of the <code>exists()</code> method, it still can not prevent time-of-check to time-of-use (<a href="../fs/index#time-of-check-to-time-of-use-toctou" title="mod std::fs">TOCTOU</a>) bugs. You should only use it in scenarios where those bugs are not an issue.</p> <p>This is an alias for <a href="../fs/fn.exists" title="fn std::fs::exists"><code>std::fs::exists</code></a>.</p> <h5 id="examples-41">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;
assert!(!Path::new("does_not_exist.txt").try_exists().expect("Can't check existence of file does_not_exist.txt"));
assert!(Path::new("/root/secret_file.txt").try_exists().is_err());</pre></div>
</div>
<summary><section id="method.is_file" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3260-3262">Source</a></span><pre class="code-header" data-language="rust">pub fn is_file(&amp;self) -&gt; bool</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if the path exists on disk and is pointing at a regular file.</p> <p>This function will traverse symbolic links to query information about the destination file.</p> <p>If you cannot access the metadata of the file, e.g. because of a permission error or broken symbolic links, this will return <code>false</code>.</p> <h5 id="examples-42">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;
assert_eq!(Path::new("./is_a_directory/").is_file(), false);
assert_eq!(Path::new("a_file.txt").is_file(), true);</pre></div>
<h5 id="see-also-3">See Also</h5> <p>This is a convenience function that coerces errors to false. If you want to check errors, call <a href="../fs/fn.metadata" title="fn std::fs::metadata"><code>fs::metadata</code></a> and handle its <a href="../result/enum.result" title="enum std::result::Result"><code>Result</code></a>. Then call <a href="../fs/struct.metadata#method.is_file" title="method std::fs::Metadata::is_file"><code>fs::Metadata::is_file</code></a> if it was <a href="../result/enum.result#variant.Ok" title="variant std::result::Result::Ok"><code>Ok</code></a>.</p> <p>When the goal is simply to read from (or write to) the source, the most reliable way to test the source can be read (or written to) is to open it. Only using <code>is_file</code> can break workflows like <code>diff &lt;( prog_a )</code> on a Unix-like system for example. See <a href="../fs/struct.file#method.open" title="associated function std::fs::File::open"><code>fs::File::open</code></a> or <a href="../fs/struct.openoptions#method.open" title="method std::fs::OpenOptions::open"><code>fs::OpenOptions::open</code></a> for more information.</p> </div>
<summary><section id="method.is_dir" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3287-3289">Source</a></span><pre class="code-header" data-language="rust">pub fn is_dir(&amp;self) -&gt; bool</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if the path exists on disk and is pointing at a directory.</p> <p>This function will traverse symbolic links to query information about the destination file.</p> <p>If you cannot access the metadata of the file, e.g. because of a permission error or broken symbolic links, this will return <code>false</code>.</p> <h5 id="examples-43">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;
assert_eq!(Path::new("./is_a_directory/").is_dir(), true);
assert_eq!(Path::new("a_file.txt").is_dir(), false);</pre></div>
<h5 id="see-also-4">See Also</h5> <p>This is a convenience function that coerces errors to false. If you want to check errors, call <a href="../fs/fn.metadata" title="fn std::fs::metadata"><code>fs::metadata</code></a> and handle its <a href="../result/enum.result" title="enum std::result::Result"><code>Result</code></a>. Then call <a href="../fs/struct.metadata#method.is_dir" title="method std::fs::Metadata::is_dir"><code>fs::Metadata::is_dir</code></a> if it was <a href="../result/enum.result#variant.Ok" title="variant std::result::Result::Ok"><code>Ok</code></a>.</p> </div>
<summary><section id="method.is_symlink" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.58.0">1.58.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3320-3322">Source</a></span><pre class="code-header" data-language="rust">pub fn is_symlink(&amp;self) -&gt; bool</pre></section></summary><div class="docblock">
<p>Returns <code>true</code> if the path exists on disk and is pointing at a symbolic link.</p> <p>This function will not traverse symbolic links. In case of a broken symbolic link this will also return true.</p> <p>If you cannot access the directory containing the file, e.g., because of a permission error, this will return false.</p> <h5 id="examples-44">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::path::Path;
use std::os::unix::fs::symlink;

let link_path = Path::new("link");
symlink("/origin_does_not_exist/", link_path).unwrap();
assert_eq!(link_path.is_symlink(), true);
assert_eq!(link_path.exists(), false);</pre></div>
<h5 id="see-also-5">See Also</h5> <p>This is a convenience function that coerces errors to false. If you want to check errors, call <a href="../fs/fn.symlink_metadata" title="fn std::fs::symlink_metadata"><code>fs::symlink_metadata</code></a> and handle its <a href="../result/enum.result" title="enum std::result::Result"><code>Result</code></a>. Then call <a href="../fs/struct.metadata#method.is_symlink" title="method std::fs::Metadata::is_symlink"><code>fs::Metadata::is_symlink</code></a> if it was <a href="../result/enum.result#variant.Ok" title="variant std::result::Result::Ok"><code>Ok</code></a>.</p> </div>
<h3 id="trait-implementations" class="section-header">Trait Implementations</h3>
<div id="trait-implementations-list">
<summary><section id="impl-AsRef%3COsStr%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2165-2170">Source</a></span><pre class="code-header" data-language="rust">impl AsRef&lt;OsStr&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.as_ref" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#2167-2169">Source</a><pre class="code-header" data-language="rust">fn as_ref(&amp;self) -&gt; &amp;OsStr</pre></section></summary><div class="docblock">Converts this type into a shared reference of the (usually inferred) input type.</div>
</div>
<summary><section id="impl-AsRef%3CPath%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3567-3572">Source</a></span><pre class="code-header" data-language="rust">impl AsRef&lt;Path&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.as_ref-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3569-3571">Source</a><pre class="code-header" data-language="rust">fn as_ref(&amp;self) -&gt; &amp;Path</pre></section></summary><div class="docblock">Converts this type into a shared reference of the (usually inferred) input type.</div>
</div>
<summary><section id="impl-Borrow%3CPath%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1963-1968">Source</a></span><pre class="code-header" data-language="rust">impl Borrow&lt;Path&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1965-1967">Source</a><pre class="code-header" data-language="rust">fn borrow(&amp;self) -&gt; &amp;Path</pre></section></summary><div class="docblock">Immutably borrows from an owned value. <a href="../borrow/trait.borrow#tymethod.borrow">Read more</a>
</div>
</div>
<summary><section id="impl-Clone-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1753-1767">Source</a></span><pre class="code-header" data-language="rust">impl Clone for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.clone_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1764-1766">Source</a><pre class="code-header" data-language="rust">fn clone_from(&amp;mut self, source: &amp;Self)</pre></section></summary><div class="docblock">
<p>Clones the contents of <code>source</code> into <code>self</code>.</p> <p>This method is preferred over simply assigning <code>source.clone()</code> to <code>self</code>, as it avoids reallocation if possible.</p> </div>
<summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1755-1757">Source</a><pre class="code-header" data-language="rust">fn clone(&amp;self) -&gt; Self</pre></section></summary><div class="docblock">Returns a duplicate of the value. <a href="../clone/trait.clone#tymethod.clone">Read more</a>
</div>
</div>
<summary><section id="impl-Debug-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1939-1943">Source</a></span><pre class="code-header" data-language="rust">impl Debug for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1940-1942">Source</a><pre class="code-header" data-language="rust">fn fmt(&amp;self, formatter: &amp;mut Formatter&lt;'_&gt;) -&gt; Result</pre></section></summary><div class="docblock">Formats the value using the given formatter. <a href="../fmt/trait.debug#tymethod.fmt">Read more</a>
</div>
</div>
<summary><section id="impl-Default-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1971-1976">Source</a></span><pre class="code-header" data-language="rust">impl Default for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1973-1975">Source</a><pre class="code-header" data-language="rust">fn default() -&gt; Self</pre></section></summary><div class="docblock">Returns the “default value” for a type. <a href="../default/trait.default#tymethod.default">Read more</a>
</div>
</div>
<summary><section id="impl-Deref-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1946-1952">Source</a></span><pre class="code-header" data-language="rust">impl Deref for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Target" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1947">Source</a><pre class="code-header" data-language="rust">type Target = Path</pre></section></summary><div class="docblock">The resulting type after dereferencing.</div>
<summary><section id="method.deref" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1949-1951">Source</a><pre class="code-header" data-language="rust">fn deref(&amp;self) -&gt; &amp;Path</pre></section></summary><div class="docblock">Dereferences the value.</div>
</div>
<summary><section id="impl-DerefMut-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.68.0">1.68.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1955-1960">Source</a></span><pre class="code-header" data-language="rust">impl DerefMut for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.deref_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1957-1959">Source</a><pre class="code-header" data-language="rust">fn deref_mut(&amp;mut self) -&gt; &amp;mut Path</pre></section></summary><div class="docblock">Mutably dereferences the value.</div>
</div>
<summary><section id="impl-Extend%3CP%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1913-1936">Source</a></span><pre class="code-header" data-language="rust">impl&lt;P: AsRef&lt;Path&gt;&gt; Extend&lt;P&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.extend" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1928-1930">Source</a><pre class="code-header" data-language="rust">fn extend&lt;I: IntoIterator&lt;Item = P&gt;&gt;(&amp;mut self, iter: I)</pre></section></summary><div class="docblock">
<p>Extends <code>self</code> with <a href="struct.path" title="struct std::path::Path"><code>Path</code></a> elements from <code>iter</code>.</p> <p>This uses <a href="struct.pathbuf#method.push" title="method std::path::PathBuf::push"><code>push</code></a> to add each element, so can be used to adjoin multiple path <a href="struct.components" title="struct std::path::Components">components</a>.</p> <h5 id="examples-46">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let mut path = PathBuf::from("/tmp");
path.extend(["foo", "bar", "file.txt"]);
assert_eq!(path, PathBuf::from("/tmp/foo/bar/file.txt"));</pre></div> <p>See documentation for <a href="struct.pathbuf#method.push" title="method std::path::PathBuf::push"><code>push</code></a> for more details on how the path is constructed.</p> </div>
<summary><section id="method.extend_one" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1933-1935">Source</a><pre class="code-header" data-language="rust">fn extend_one(&amp;mut self, p: P)</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code> <a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</span>
</div></span><div class="docblock">Extends a collection with exactly one element.</div>
<summary><section id="method.extend_reserve" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/iter/traits/collect.rs.html#425">Source</a><pre class="code-header" data-language="rust">fn extend_reserve(&amp;mut self, additional: usize)</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>extend_one</code> <a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</span>
</div></span><div class="docblock">Reserves capacity in a collection for the given number of additional elements. <a href="../iter/trait.extend#method.extend_reserve">Read more</a>
</div>
</div>
<summary><section id="impl-From%3C%26PathBuf%3E-for-Cow%3C'a,+Path%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.28.0">1.28.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2003-2012">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; From&lt;&amp;'a PathBuf&gt; for Cow&lt;'a, Path&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#2009-2011">Source</a><pre class="code-header" data-language="rust">fn from(p: &amp;'a PathBuf) -&gt; Cow&lt;'a, Path&gt;</pre></section></summary><div class="docblock">
<p>Creates a clone-on-write pointer from a reference to <a href="struct.pathbuf" title="struct std::path::PathBuf"><code>PathBuf</code></a>.</p> <p>This conversion does not clone or allocate.</p> </div>
</div>
<summary><section id="impl-From%3C%26T%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1837-1845">Source</a></span><pre class="code-header" data-language="rust">impl&lt;T: ?Sized + AsRef&lt;OsStr&gt;&gt; From&lt;&amp;T&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1842-1844">Source</a><pre class="code-header" data-language="rust">fn from(s: &amp;T) -&gt; PathBuf</pre></section></summary><div class="docblock">
<p>Converts a borrowed <a href="../ffi/struct.osstr" title="struct std::ffi::OsStr"><code>OsStr</code></a> to a <a href="struct.pathbuf" title="struct std::path::PathBuf"><code>PathBuf</code></a>.</p> <p>Allocates a <a href="struct.pathbuf" title="struct std::path::PathBuf"><code>PathBuf</code></a> and copies the data into it.</p> </div>
</div>
<summary><section id="impl-From%3CBox%3CPath%3E%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.18.0">1.18.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1806-1814">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;Box&lt;Path&gt;&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1811-1813">Source</a><pre class="code-header" data-language="rust">fn from(boxed: Box&lt;Path&gt;) -&gt; PathBuf</pre></section></summary><div class="docblock">
<p>Converts a <code><a href="../boxed/struct.box" title="struct std::boxed::Box">Box</a>&lt;<a href="struct.path" title="struct std::path::Path">Path</a>&gt;</code> into a <a href="struct.pathbuf" title="struct std::path::PathBuf"><code>PathBuf</code></a>.</p> <p>This conversion does not allocate or copy memory.</p> </div>
</div>
<summary><section id="impl-From%3CCow%3C'a,+Path%3E%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.28.0">1.28.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2015-2023">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; From&lt;Cow&lt;'a, Path&gt;&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.from-8" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#2020-2022">Source</a><pre class="code-header" data-language="rust">fn from(p: Cow&lt;'a, Path&gt;) -&gt; Self</pre></section></summary><div class="docblock">
<p>Converts a clone-on-write pointer to an owned path.</p> <p>Converting from a <code>Cow::Owned</code> does not clone or allocate.</p> </div>
</div>
<summary><section id="impl-From%3COsString%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1848-1856">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;OsString&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.from-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1853-1855">Source</a><pre class="code-header" data-language="rust">fn from(s: OsString) -&gt; PathBuf</pre></section></summary><div class="docblock">
<p>Converts an <a href="../ffi/struct.osstring" title="struct std::ffi::OsString"><code>OsString</code></a> into a <a href="struct.pathbuf" title="struct std::path::PathBuf"><code>PathBuf</code></a>.</p> <p>This conversion does not allocate or copy memory.</p> </div>
</div>
<summary><section id="impl-From%3CPathBuf%3E-for-Arc%3CPath%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.24.0">1.24.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2026-2034">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;PathBuf&gt; for Arc&lt;Path&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-9" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#2030-2033">Source</a><pre class="code-header" data-language="rust">fn from(s: PathBuf) -&gt; Arc&lt;Path&gt;</pre></section></summary><div class="docblock">
<p>Converts a <a href="struct.pathbuf" title="struct std::path::PathBuf"><code>PathBuf</code></a> into an <code><a href="../sync/struct.arc" title="struct std::sync::Arc">Arc</a>&lt;<a href="struct.path" title="struct std::path::Path">Path</a>&gt;</code> by moving the <a href="struct.pathbuf" title="struct std::path::PathBuf"><code>PathBuf</code></a> data into a new <a href="../sync/struct.arc" title="struct std::sync::Arc"><code>Arc</code></a> buffer.</p> </div>
</div>
<summary><section id="impl-From%3CPathBuf%3E-for-Box%3CPath%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1817-1826">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;PathBuf&gt; for Box&lt;Path&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1823-1825">Source</a><pre class="code-header" data-language="rust">fn from(p: PathBuf) -&gt; Box&lt;Path&gt;</pre></section></summary><div class="docblock">
<p>Converts a <a href="struct.pathbuf" title="struct std::path::PathBuf"><code>PathBuf</code></a> into a <code><a href="../boxed/struct.box" title="struct std::boxed::Box">Box</a>&lt;<a href="struct.path" title="struct std::path::Path">Path</a>&gt;</code>.</p> <p>This conversion currently should not allocate memory, but this behavior is not guaranteed on all platforms or in all future versions.</p> </div>
</div>
<summary><section id="impl-From%3CPathBuf%3E-for-Cow%3C'a,+Path%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1991-2000">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; From&lt;PathBuf&gt; for Cow&lt;'a, Path&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1997-1999">Source</a><pre class="code-header" data-language="rust">fn from(s: PathBuf) -&gt; Cow&lt;'a, Path&gt;</pre></section></summary><div class="docblock">
<p>Creates a clone-on-write pointer from an owned instance of <a href="struct.pathbuf" title="struct std::path::PathBuf"><code>PathBuf</code></a>.</p> <p>This conversion does not clone or allocate.</p> </div>
</div>
<summary><section id="impl-From%3CPathBuf%3E-for-OsString" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.14.0">1.14.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1859-1867">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;PathBuf&gt; for OsString</pre></section></summary><div class="impl-items">
<summary><section id="method.from-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1864-1866">Source</a><pre class="code-header" data-language="rust">fn from(path_buf: PathBuf) -&gt; OsString</pre></section></summary><div class="docblock">
<p>Converts a <a href="struct.pathbuf" title="struct std::path::PathBuf"><code>PathBuf</code></a> into an <a href="../ffi/struct.osstring" title="struct std::ffi::OsString"><code>OsString</code></a></p> <p>This conversion does not allocate or copy memory.</p> </div>
</div>
<summary><section id="impl-From%3CPathBuf%3E-for-Rc%3CPath%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.24.0">1.24.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2056-2064">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;PathBuf&gt; for Rc&lt;Path&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.from-10" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#2060-2063">Source</a><pre class="code-header" data-language="rust">fn from(s: PathBuf) -&gt; Rc&lt;Path&gt;</pre></section></summary><div class="docblock">
<p>Converts a <a href="struct.pathbuf" title="struct std::path::PathBuf"><code>PathBuf</code></a> into an <code><a href="../rc/struct.rc" title="struct std::rc::Rc">Rc</a>&lt;<a href="struct.path" title="struct std::path::Path">Path</a>&gt;</code> by moving the <a href="struct.pathbuf" title="struct std::path::PathBuf"><code>PathBuf</code></a> data into a new <a href="../rc/struct.rc" title="struct std::rc::Rc"><code>Rc</code></a> buffer.</p> </div>
</div>
<summary><section id="impl-From%3CString%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1870-1878">Source</a></span><pre class="code-header" data-language="rust">impl From&lt;String&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.from-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1875-1877">Source</a><pre class="code-header" data-language="rust">fn from(s: String) -&gt; PathBuf</pre></section></summary><div class="docblock">
<p>Converts a <a href="../string/struct.string" title="struct std::string::String"><code>String</code></a> into a <a href="struct.pathbuf" title="struct std::path::PathBuf"><code>PathBuf</code></a></p> <p>This conversion does not allocate or copy memory.</p> </div>
</div>
<summary><section id="impl-FromIterator%3CP%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1891-1910">Source</a></span><pre class="code-header" data-language="rust">impl&lt;P: AsRef&lt;Path&gt;&gt; FromIterator&lt;P&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.from_iter" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1905-1909">Source</a><pre class="code-header" data-language="rust">fn from_iter&lt;I: IntoIterator&lt;Item = P&gt;&gt;(iter: I) -&gt; PathBuf</pre></section></summary><div class="docblock">
<p>Creates a new <code>PathBuf</code> from the <a href="struct.path" title="struct std::path::Path"><code>Path</code></a> elements of an iterator.</p> <p>This uses <a href="struct.pathbuf#method.push" title="method std::path::PathBuf::push"><code>push</code></a> to add each element, so can be used to adjoin multiple path <a href="struct.components" title="struct std::path::Components">components</a>.</p> <h5 id="examples-45">Examples</h5> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">let path = PathBuf::from_iter(["/tmp", "foo", "bar"]);
assert_eq!(path, PathBuf::from("/tmp/foo/bar"));</pre></div> <p>See documentation for <a href="struct.pathbuf#method.push" title="method std::path::PathBuf::push"><code>push</code></a> for more details on how the path is constructed.</p> </div>
</div>
<summary><section id="impl-FromStr-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.32.0">1.32.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#1881-1888">Source</a></span><pre class="code-header" data-language="rust">impl FromStr for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Err" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1882">Source</a><pre class="code-header" data-language="rust">type Err = Infallible</pre></section></summary><div class="docblock">The associated error which can be returned from parsing.</div>
<summary><section id="method.from_str" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#1885-1887">Source</a><pre class="code-header" data-language="rust">fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt;</pre></section></summary><div class="docblock">Parses a string <code>s</code> to return a value of this type. <a href="../str/trait.fromstr#tymethod.from_str">Read more</a>
</div>
</div>
<summary><section id="impl-Hash-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2139-2143">Source</a></span><pre class="code-header" data-language="rust">impl Hash for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.hash" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#2140-2142">Source</a><pre class="code-header" data-language="rust">fn hash&lt;H: Hasher&gt;(&amp;self, h: &amp;mut H)</pre></section></summary><div class="docblock">Feeds this value into the given <a href="../hash/trait.hasher" title="trait std::hash::Hasher"><code>Hasher</code></a>. <a href="../hash/trait.hash#tymethod.hash">Read more</a>
</div>
<summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span><a class="src" href="https://doc.rust-lang.org/src/core/hash/mod.rs.html#235-237">Source</a></span><pre class="code-header" data-language="rust">fn hash_slice&lt;H&gt;(data: &amp;[Self], state: &amp;mut H)where
    H: Hasher,
    Self: Sized,</pre></section></summary><div class="docblock">Feeds a slice of this type into the given <a href="../hash/trait.hasher" title="trait std::hash::Hasher"><code>Hasher</code></a>. <a href="../hash/trait.hash#method.hash_slice">Read more</a>
</div>
</div>
<summary><section id="impl-IntoIterator-for-%26PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3575-3582">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; IntoIterator for &amp;'a PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Item" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3576">Source</a><pre class="code-header" data-language="rust">type Item = &amp;'a OsStr</pre></section></summary><div class="docblock">The type of the elements being iterated over.</div>
<summary><section id="associatedtype.IntoIter" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3577">Source</a><pre class="code-header" data-language="rust">type IntoIter = Iter&lt;'a&gt;</pre></section></summary><div class="docblock">Which kind of iterator are we turning this into?</div>
<summary><section id="method.into_iter" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3579-3581">Source</a><pre class="code-header" data-language="rust">fn into_iter(self) -&gt; Iter&lt;'a&gt; ⓘ</pre></section></summary><div class="docblock">Creates an iterator from a value. <a href="../iter/trait.intoiterator#tymethod.into_iter">Read more</a>
</div>
</div>
<summary><section id="impl-Ord-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2157-2162">Source</a></span><pre class="code-header" data-language="rust">impl Ord for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.cmp" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#2159-2161">Source</a><pre class="code-header" data-language="rust">fn cmp(&amp;self, other: &amp;PathBuf) -&gt; Ordering</pre></section></summary><div class="docblock">This method returns an <a href="../cmp/enum.ordering" title="enum std::cmp::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="../cmp/trait.ord#tymethod.cmp">Read more</a>
</div>
<summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1023-1025">Source</a></span><pre class="code-header" data-language="rust">fn max(self, other: Self) -&gt; Selfwhere
    Self: Sized,</pre></section></summary><div class="docblock">Compares and returns the maximum of two values. <a href="../cmp/trait.ord#method.max">Read more</a>
</div>
<summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1062-1064">Source</a></span><pre class="code-header" data-language="rust">fn min(self, other: Self) -&gt; Selfwhere
    Self: Sized,</pre></section></summary><div class="docblock">Compares and returns the minimum of two values. <a href="../cmp/trait.ord#method.min">Read more</a>
</div>
<summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1088-1090">Source</a></span><pre class="code-header" data-language="rust">fn clamp(self, min: Self, max: Self) -&gt; Selfwhere
    Self: Sized,</pre></section></summary><div class="docblock">Restrict a value to a certain interval. <a href="../cmp/trait.ord#method.clamp">Read more</a>
</div>
</div>
<summary><section id="impl-PartialEq%3C%26OsStr%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3673">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; PartialEq&lt;&amp;'a OsStr&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-13" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3673">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;&amp;'a OsStr) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-13" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#264">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3C%26Path%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3631">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; PartialEq&lt;&amp;'a Path&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3631">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;&amp;'a Path) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-7" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#264">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CCow%3C'a,+OsStr%3E%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3674">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; PartialEq&lt;Cow&lt;'a, OsStr&gt;&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-15" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3674">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;Cow&lt;'a, OsStr&gt;) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-15" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#264">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CCow%3C'a,+Path%3E%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3634">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; PartialEq&lt;Cow&lt;'a, Path&gt;&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-10" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3634">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;Cow&lt;'a, Path&gt;) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-10" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#264">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3COsStr%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3672">Source</a></span><pre class="code-header" data-language="rust">impl PartialEq&lt;OsStr&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-11" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3672">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;OsStr) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-11" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#264">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3COsString%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3675">Source</a></span><pre class="code-header" data-language="rust">impl PartialEq&lt;OsString&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-17" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3675">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;OsString) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-17" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#264">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CPath%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3630">Source</a></span><pre class="code-header" data-language="rust">impl PartialEq&lt;Path&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3630">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;Path) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-5" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#264">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CPathBuf%3E-for-%26OsStr" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3673">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; PartialEq&lt;PathBuf&gt; for &amp;'a OsStr</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-14" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3673">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;PathBuf) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-14" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#264">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CPathBuf%3E-for-%26Path" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3631">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; PartialEq&lt;PathBuf&gt; for &amp;'a Path</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-8" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3631">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;PathBuf) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-8" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#264">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CPathBuf%3E-for-Cow%3C'a,+OsStr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3674">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; PartialEq&lt;PathBuf&gt; for Cow&lt;'a, OsStr&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-16" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3674">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;PathBuf) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-16" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#264">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CPathBuf%3E-for-Cow%3C'a,+Path%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3634">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; PartialEq&lt;PathBuf&gt; for Cow&lt;'a, Path&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-9" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3634">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;PathBuf) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-9" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#264">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CPathBuf%3E-for-OsStr" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3672">Source</a></span><pre class="code-header" data-language="rust">impl PartialEq&lt;PathBuf&gt; for OsStr</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-12" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3672">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;PathBuf) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-12" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#264">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CPathBuf%3E-for-OsString" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3675">Source</a></span><pre class="code-header" data-language="rust">impl PartialEq&lt;PathBuf&gt; for OsString</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-18" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3675">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;PathBuf) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-18" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#264">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CPathBuf%3E-for-Path" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3630">Source</a></span><pre class="code-header" data-language="rust">impl PartialEq&lt;PathBuf&gt; for Path</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3630">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;PathBuf) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-6" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#264">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CPathBuf%3E-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.91.0">1.91.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2131-2136">Source</a></span><pre class="code-header" data-language="rust">impl PartialEq&lt;PathBuf&gt; for String</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#2133-2135">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;PathBuf) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-4" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#264">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CPathBuf%3E-for-str" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.91.0">1.91.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2115-2120">Source</a></span><pre class="code-header" data-language="rust">impl PartialEq&lt;PathBuf&gt; for str</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#2117-2119">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;PathBuf) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#264">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3CString%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.91.0">1.91.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2123-2128">Source</a></span><pre class="code-header" data-language="rust">impl PartialEq&lt;String&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#2125-2127">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;String) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-3" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#264">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq%3Cstr%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.91.0">1.91.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2107-2112">Source</a></span><pre class="code-header" data-language="rust">impl PartialEq&lt;str&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.eq-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#2109-2111">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;str) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#264">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialEq-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2099-2104">Source</a></span><pre class="code-header" data-language="rust">impl PartialEq for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#2101-2103">Source</a><pre class="code-header" data-language="rust">fn eq(&amp;self, other: &amp;PathBuf) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div>
<summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#264">Source</a></span><pre class="code-header" data-language="rust">fn ne(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests for <code>!=</code>. The default implementation is almost always sufficient, and should not be overridden without very good reason.</div>
</div>
<summary><section id="impl-PartialOrd%3C%26OsStr%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3673">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; PartialOrd&lt;&amp;'a OsStr&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp-9" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3673">Source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;&amp;'a OsStr) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../cmp/trait.partialord#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt-9" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1399">Source</a></span><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../cmp/trait.partialord#method.lt">Read more</a>
</div>
<summary><section id="method.le-9" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1417">Source</a></span><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../cmp/trait.partialord#method.le">Read more</a>
</div>
<summary><section id="method.gt-9" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1435">Source</a></span><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../cmp/trait.partialord#method.gt">Read more</a>
</div>
<summary><section id="method.ge-9" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1453">Source</a></span><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../cmp/trait.partialord#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-PartialOrd%3C%26Path%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3631">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; PartialOrd&lt;&amp;'a Path&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp-3" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3631">Source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;&amp;'a Path) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../cmp/trait.partialord#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt-3" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1399">Source</a></span><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../cmp/trait.partialord#method.lt">Read more</a>
</div>
<summary><section id="method.le-3" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1417">Source</a></span><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../cmp/trait.partialord#method.le">Read more</a>
</div>
<summary><section id="method.gt-3" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1435">Source</a></span><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../cmp/trait.partialord#method.gt">Read more</a>
</div>
<summary><section id="method.ge-3" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1453">Source</a></span><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../cmp/trait.partialord#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-PartialOrd%3CCow%3C'a,+OsStr%3E%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3674">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; PartialOrd&lt;Cow&lt;'a, OsStr&gt;&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp-11" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3674">Source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;Cow&lt;'a, OsStr&gt;) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../cmp/trait.partialord#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt-11" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1399">Source</a></span><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../cmp/trait.partialord#method.lt">Read more</a>
</div>
<summary><section id="method.le-11" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1417">Source</a></span><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../cmp/trait.partialord#method.le">Read more</a>
</div>
<summary><section id="method.gt-11" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1435">Source</a></span><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../cmp/trait.partialord#method.gt">Read more</a>
</div>
<summary><section id="method.ge-11" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1453">Source</a></span><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../cmp/trait.partialord#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-PartialOrd%3CCow%3C'a,+Path%3E%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3634">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; PartialOrd&lt;Cow&lt;'a, Path&gt;&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3634">Source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;Cow&lt;'a, Path&gt;) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../cmp/trait.partialord#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt-6" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1399">Source</a></span><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../cmp/trait.partialord#method.lt">Read more</a>
</div>
<summary><section id="method.le-6" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1417">Source</a></span><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../cmp/trait.partialord#method.le">Read more</a>
</div>
<summary><section id="method.gt-6" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1435">Source</a></span><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../cmp/trait.partialord#method.gt">Read more</a>
</div>
<summary><section id="method.ge-6" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1453">Source</a></span><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../cmp/trait.partialord#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-PartialOrd%3COsStr%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3672">Source</a></span><pre class="code-header" data-language="rust">impl PartialOrd&lt;OsStr&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp-7" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3672">Source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;OsStr) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../cmp/trait.partialord#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt-7" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1399">Source</a></span><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../cmp/trait.partialord#method.lt">Read more</a>
</div>
<summary><section id="method.le-7" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1417">Source</a></span><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../cmp/trait.partialord#method.le">Read more</a>
</div>
<summary><section id="method.gt-7" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1435">Source</a></span><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../cmp/trait.partialord#method.gt">Read more</a>
</div>
<summary><section id="method.ge-7" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1453">Source</a></span><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../cmp/trait.partialord#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-PartialOrd%3COsString%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3675">Source</a></span><pre class="code-header" data-language="rust">impl PartialOrd&lt;OsString&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp-13" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3675">Source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;OsString) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../cmp/trait.partialord#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt-13" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1399">Source</a></span><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../cmp/trait.partialord#method.lt">Read more</a>
</div>
<summary><section id="method.le-13" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1417">Source</a></span><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../cmp/trait.partialord#method.le">Read more</a>
</div>
<summary><section id="method.gt-13" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1435">Source</a></span><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../cmp/trait.partialord#method.gt">Read more</a>
</div>
<summary><section id="method.ge-13" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1453">Source</a></span><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../cmp/trait.partialord#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-PartialOrd%3CPath%3E-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3630">Source</a></span><pre class="code-header" data-language="rust">impl PartialOrd&lt;Path&gt; for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3630">Source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;Path) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../cmp/trait.partialord#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1399">Source</a></span><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../cmp/trait.partialord#method.lt">Read more</a>
</div>
<summary><section id="method.le-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1417">Source</a></span><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../cmp/trait.partialord#method.le">Read more</a>
</div>
<summary><section id="method.gt-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1435">Source</a></span><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../cmp/trait.partialord#method.gt">Read more</a>
</div>
<summary><section id="method.ge-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1453">Source</a></span><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../cmp/trait.partialord#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-PartialOrd%3CPathBuf%3E-for-%26OsStr" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3673">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; PartialOrd&lt;PathBuf&gt; for &amp;'a OsStr</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp-10" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3673">Source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;PathBuf) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../cmp/trait.partialord#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt-10" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1399">Source</a></span><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../cmp/trait.partialord#method.lt">Read more</a>
</div>
<summary><section id="method.le-10" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1417">Source</a></span><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../cmp/trait.partialord#method.le">Read more</a>
</div>
<summary><section id="method.gt-10" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1435">Source</a></span><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../cmp/trait.partialord#method.gt">Read more</a>
</div>
<summary><section id="method.ge-10" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1453">Source</a></span><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../cmp/trait.partialord#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-PartialOrd%3CPathBuf%3E-for-%26Path" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3631">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; PartialOrd&lt;PathBuf&gt; for &amp;'a Path</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp-4" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3631">Source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;PathBuf) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../cmp/trait.partialord#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt-4" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1399">Source</a></span><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../cmp/trait.partialord#method.lt">Read more</a>
</div>
<summary><section id="method.le-4" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1417">Source</a></span><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../cmp/trait.partialord#method.le">Read more</a>
</div>
<summary><section id="method.gt-4" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1435">Source</a></span><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../cmp/trait.partialord#method.gt">Read more</a>
</div>
<summary><section id="method.ge-4" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1453">Source</a></span><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../cmp/trait.partialord#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-PartialOrd%3CPathBuf%3E-for-Cow%3C'a,+OsStr%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3674">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; PartialOrd&lt;PathBuf&gt; for Cow&lt;'a, OsStr&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp-12" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3674">Source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;PathBuf) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../cmp/trait.partialord#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt-12" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1399">Source</a></span><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../cmp/trait.partialord#method.lt">Read more</a>
</div>
<summary><section id="method.le-12" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1417">Source</a></span><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../cmp/trait.partialord#method.le">Read more</a>
</div>
<summary><section id="method.gt-12" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1435">Source</a></span><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../cmp/trait.partialord#method.gt">Read more</a>
</div>
<summary><section id="method.ge-12" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1453">Source</a></span><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../cmp/trait.partialord#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-PartialOrd%3CPathBuf%3E-for-Cow%3C'a,+Path%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3634">Source</a></span><pre class="code-header" data-language="rust">impl&lt;'a&gt; PartialOrd&lt;PathBuf&gt; for Cow&lt;'a, Path&gt;</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp-5" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3634">Source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;PathBuf) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../cmp/trait.partialord#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt-5" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1399">Source</a></span><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../cmp/trait.partialord#method.lt">Read more</a>
</div>
<summary><section id="method.le-5" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1417">Source</a></span><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../cmp/trait.partialord#method.le">Read more</a>
</div>
<summary><section id="method.gt-5" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1435">Source</a></span><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../cmp/trait.partialord#method.gt">Read more</a>
</div>
<summary><section id="method.ge-5" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1453">Source</a></span><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../cmp/trait.partialord#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-PartialOrd%3CPathBuf%3E-for-OsStr" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3672">Source</a></span><pre class="code-header" data-language="rust">impl PartialOrd&lt;PathBuf&gt; for OsStr</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp-8" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3672">Source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;PathBuf) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../cmp/trait.partialord#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt-8" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1399">Source</a></span><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../cmp/trait.partialord#method.lt">Read more</a>
</div>
<summary><section id="method.le-8" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1417">Source</a></span><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../cmp/trait.partialord#method.le">Read more</a>
</div>
<summary><section id="method.gt-8" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1435">Source</a></span><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../cmp/trait.partialord#method.gt">Read more</a>
</div>
<summary><section id="method.ge-8" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1453">Source</a></span><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../cmp/trait.partialord#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-PartialOrd%3CPathBuf%3E-for-OsString" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3675">Source</a></span><pre class="code-header" data-language="rust">impl PartialOrd&lt;PathBuf&gt; for OsString</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp-14" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3675">Source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;PathBuf) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../cmp/trait.partialord#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt-14" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1399">Source</a></span><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../cmp/trait.partialord#method.lt">Read more</a>
</div>
<summary><section id="method.le-14" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1417">Source</a></span><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../cmp/trait.partialord#method.le">Read more</a>
</div>
<summary><section id="method.gt-14" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1435">Source</a></span><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../cmp/trait.partialord#method.gt">Read more</a>
</div>
<summary><section id="method.ge-14" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1453">Source</a></span><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../cmp/trait.partialord#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-PartialOrd%3CPathBuf%3E-for-Path" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#3630">Source</a></span><pre class="code-header" data-language="rust">impl PartialOrd&lt;PathBuf&gt; for Path</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp-2" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#3630">Source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;PathBuf) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../cmp/trait.partialord#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1399">Source</a></span><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../cmp/trait.partialord#method.lt">Read more</a>
</div>
<summary><section id="method.le-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1417">Source</a></span><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../cmp/trait.partialord#method.le">Read more</a>
</div>
<summary><section id="method.gt-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1435">Source</a></span><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../cmp/trait.partialord#method.gt">Read more</a>
</div>
<summary><section id="method.ge-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1453">Source</a></span><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../cmp/trait.partialord#method.ge">Read more</a>
</div>
</div>
<summary><section id="impl-PartialOrd-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2149-2154">Source</a></span><pre class="code-header" data-language="rust">impl PartialOrd for PathBuf</pre></section></summary><div class="impl-items">
<summary><section id="method.partial_cmp" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/std/path.rs.html#2151-2153">Source</a><pre class="code-header" data-language="rust">fn partial_cmp(&amp;self, other: &amp;PathBuf) -&gt; Option&lt;Ordering&gt;</pre></section></summary><div class="docblock">This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../cmp/trait.partialord#tymethod.partial_cmp">Read more</a>
</div>
<summary><section id="method.lt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1399">Source</a></span><pre class="code-header" data-language="rust">fn lt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../cmp/trait.partialord#method.lt">Read more</a>
</div>
<summary><section id="method.le" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1417">Source</a></span><pre class="code-header" data-language="rust">fn le(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../cmp/trait.partialord#method.le">Read more</a>
</div>
<summary><section id="method.gt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1435">Source</a></span><pre class="code-header" data-language="rust">fn gt(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../cmp/trait.partialord#method.gt">Read more</a>
</div>
<summary><section id="method.ge" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/core/cmp.rs.html#1453">Source</a></span><pre class="code-header" data-language="rust">fn ge(&amp;self, other: &amp;Rhs) -&gt; bool</pre></section></summary><div class="docblock">Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../cmp/trait.partialord#method.ge">Read more</a>
</div>
</div>
<section id="impl-Eq-for-PathBuf" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a class="src" href="https://doc.rust-lang.org/src/std/path.rs.html#2146">Source</a></span><pre class="code-header" data-language="rust">impl Eq for PathBuf</pre></section>
</div>
<h3 id="synthetic-implementations" class="section-header">Auto Trait Implementations</h3>
<div id="synthetic-implementations-list">
<section id="impl-Freeze-for-PathBuf" class="impl"><pre class="code-header" data-language="rust">impl Freeze for PathBuf</pre></section><section id="impl-RefUnwindSafe-for-PathBuf" class="impl"><pre class="code-header" data-language="rust">impl RefUnwindSafe for PathBuf</pre></section><section id="impl-Send-for-PathBuf" class="impl"><pre class="code-header" data-language="rust">impl Send for PathBuf</pre></section><section id="impl-Sync-for-PathBuf" class="impl"><pre class="code-header" data-language="rust">impl Sync for PathBuf</pre></section><section id="impl-Unpin-for-PathBuf" class="impl"><pre class="code-header" data-language="rust">impl Unpin for PathBuf</pre></section><section id="impl-UnwindSafe-for-PathBuf" class="impl"><pre class="code-header" data-language="rust">impl UnwindSafe for PathBuf</pre></section>
</div>
<h3 id="blanket-implementations" class="section-header">Blanket Implementations</h3>
<div id="blanket-implementations-list">
<summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/any.rs.html#138">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Any for Twhere
    T: 'static + ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/any.rs.html#139">Source</a><pre class="code-header" data-language="rust">fn type_id(&amp;self) -&gt; TypeId</pre></section></summary><div class="docblock">Gets the <code>TypeId</code> of <code>self</code>. <a href="../any/trait.any#tymethod.type_id">Read more</a>
</div>
</div>
<summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#212">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; Borrow&lt;T&gt; for Twhere
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#214">Source</a><pre class="code-header" data-language="rust">fn borrow(&amp;self) -&gt; &amp;T</pre></section></summary><div class="docblock">Immutably borrows from an owned value. <a href="../borrow/trait.borrow#tymethod.borrow">Read more</a>
</div>
</div>
<summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#221">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; BorrowMut&lt;T&gt; for Twhere
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/borrow.rs.html#222">Source</a><pre class="code-header" data-language="rust">fn borrow_mut(&amp;mut self) -&gt; &amp;mut T</pre></section></summary><div class="docblock">Mutably borrows from an owned value. <a href="../borrow/trait.borrowmut#tymethod.borrow_mut">Read more</a>
</div>
</div>
<summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/clone.rs.html#515">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; CloneToUninit for Twhere
    T: Clone,</pre></section></summary><div class="impl-items">
<summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/clone.rs.html#517">Source</a><pre class="code-header" data-language="rust">unsafe fn clone_to_uninit(&amp;self, dest: *mut u8)</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code> <a href="https://github.com/rust-lang/rust/issues/126799">#126799</a>)</span>
</div></span><div class="docblock">Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="../clone/trait.clonetouninit#tymethod.clone_to_uninit">Read more</a>
</div>
</div>
<summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#785">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; From&lt;T&gt; for T</pre></section></summary><div class="impl-items">
<summary><section id="method.from-11" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#788">Source</a><pre class="code-header" data-language="rust">fn from(t: T) -&gt; T</pre></section></summary><div class="docblock">
<p>Returns the argument unchanged.</p> </div>
</div>
<summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#767-769">Source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; Into&lt;U&gt; for Twhere
    U: From&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#777">Source</a><pre class="code-header" data-language="rust">fn into(self) -&gt; U</pre></section></summary><div class="docblock">
<p>Calls <code>U::from(self)</code>.</p> <p>That is, this conversion is whatever the implementation of <code><a href="../convert/trait.from" title="trait std::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p> </div>
</div>
<summary><section id="impl-Receiver-for-P" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/ops/deref.rs.html#378-380">Source</a><pre class="code-header" data-language="rust">impl&lt;P, T&gt; Receiver for Pwhere
    P: Deref&lt;Target = T&gt; + ?Sized,
    T: ?Sized,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Target-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/ops/deref.rs.html#382">Source</a><pre class="code-header" data-language="rust">type Target = T</pre></section></summary><span class="item-info"><div class="stab unstable">
<span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>arbitrary_self_types</code> <a href="https://github.com/rust-lang/rust/issues/44874">#44874</a>)</span>
</div></span><div class="docblock">The target type on which the method may be called.</div>
</div>
<summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#85-87">Source</a><pre class="code-header" data-language="rust">impl&lt;T&gt; ToOwned for Twhere
    T: Clone,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#89">Source</a><pre class="code-header" data-language="rust">type Owned = T</pre></section></summary><div class="docblock">The resulting type after obtaining ownership.</div>
<summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#90">Source</a><pre class="code-header" data-language="rust">fn to_owned(&amp;self) -&gt; T</pre></section></summary><div class="docblock">Creates owned data from borrowed data, usually by cloning. <a href="../borrow/trait.toowned#tymethod.to_owned">Read more</a>
</div>
<summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/alloc/borrow.rs.html#94">Source</a><pre class="code-header" data-language="rust">fn clone_into(&amp;self, target: &amp;mut T)</pre></section></summary><div class="docblock">Uses borrowed data to replace owned data, usually by cloning. <a href="../borrow/trait.toowned#method.clone_into">Read more</a>
</div>
</div>
<summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#827-829">Source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; TryFrom&lt;U&gt; for Twhere
    U: Into&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#831">Source</a><pre class="code-header" data-language="rust">type Error = Infallible</pre></section></summary><div class="docblock">The type returned in the event of a conversion error.</div>
<summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#834">Source</a><pre class="code-header" data-language="rust">fn try_from(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</pre></section></summary><div class="docblock">Performs the conversion.</div>
</div>
<summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#811-813">Source</a><pre class="code-header" data-language="rust">impl&lt;T, U&gt; TryInto&lt;U&gt; for Twhere
    U: TryFrom&lt;T&gt;,</pre></section></summary><div class="impl-items">
<summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#815">Source</a><pre class="code-header" data-language="rust">type Error = &lt;U as TryFrom&lt;T&gt;&gt;::Error</pre></section></summary><div class="docblock">The type returned in the event of a conversion error.</div>
<summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/src/core/convert/mod.rs.html#818">Source</a><pre class="code-header" data-language="rust">fn try_into(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</pre></section></summary><div class="docblock">Performs the conversion.</div>
</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/path/struct.PathBuf.html" class="_attribution-link">https://doc.rust-lang.org/std/path/struct.PathBuf.html</a>
  </p>
</div>
