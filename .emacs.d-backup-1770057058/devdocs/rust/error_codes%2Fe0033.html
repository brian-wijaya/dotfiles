<h1 id="error-code-e0033">Error code E0033</h1> <p>A trait type has been dereferenced.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait SomeTrait { fn method_one(&amp;self){} fn method_two(&amp;self){} }
impl&lt;T&gt; SomeTrait for T {}
let trait_obj: &amp;SomeTrait = &amp;"some_value";

// This tries to implicitly dereference to create an unsized local variable.
let &amp;invalid = trait_obj;

// You can call methods without binding to the value being pointed at.
trait_obj.method_one();
trait_obj.method_two();
}</pre> <p>A pointer to a trait type cannot be implicitly dereferenced by a pattern. Every trait defines a type, but because the size of trait implementers isn't fixed, this type has no compile-time size. Therefore, all accesses to trait types must be through pointers. If you encounter this error you should try to avoid dereferencing the pointer.</p> <p>You can read more about trait objects in the <a href="../reference/types#trait-objects">Trait Objects</a> section of the Reference.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0033.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0033.html</a>
  </p>
</div>
