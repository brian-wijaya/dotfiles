<h1 id="error-code-e0207">Error code E0207</h1> <p>A type, const or lifetime parameter that is specified for <code>impl</code> is not constrained.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct Foo;

impl&lt;T: Default&gt; Foo {
    // error: the type parameter `T` is not constrained by the impl trait, self
    // type, or predicates [E0207]
    fn get(&amp;self) -&gt; T {
        &lt;T as Default&gt;::default()
    }
}
}</pre> <p>Any type or const parameter of an <code>impl</code> must meet at least one of the following criteria:</p> <ul> <li>it appears in the <em>implementing type</em> of the impl, e.g. <code>impl&lt;T&gt; Foo&lt;T&gt;</code>
</li> <li>for a trait impl, it appears in the <em>implemented trait</em>, e.g. <code>impl&lt;T&gt; SomeTrait&lt;T&gt; for Foo</code>
</li> <li>it is bound as an associated type, e.g. <code>impl&lt;T, U&gt; SomeTrait for T where T: AnotherTrait&lt;AssocType=U&gt;</code>
</li> </ul> <p>Any unconstrained lifetime parameter of an <code>impl</code> is not supported if the lifetime parameter is used by an associated type.</p> <h3 id="error-example-1">Error example 1</h3> <p>Suppose we have a struct <code>Foo</code> and we would like to define some methods for it. The previous code example has a definition which leads to a compiler error:</p> <p>The problem is that the parameter <code>T</code> does not appear in the implementing type (<code>Foo</code>) of the impl. In this case, we can fix the error by moving the type parameter from the <code>impl</code> to the method <code>get</code>:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct Foo;

// Move the type parameter from the impl to the method
impl Foo {
    fn get&lt;T: Default&gt;(&amp;self) -&gt; T {
        &lt;T as Default&gt;::default()
    }
}
}</pre> <h3 id="error-example-2">Error example 2</h3> <p>As another example, suppose we have a <code>Maker</code> trait and want to establish a type <code>FooMaker</code> that makes <code>Foo</code>s:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait Maker {
    type Item;
    fn make(&amp;mut self) -&gt; Self::Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

struct FooMaker;

impl&lt;T: Default&gt; Maker for FooMaker {
// error: the type parameter `T` is not constrained by the impl trait, self
// type, or predicates [E0207]
    type Item = Foo&lt;T&gt;;

    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo { foo: &lt;T as Default&gt;::default() }
    }
}
}</pre> <p>This fails to compile because <code>T</code> does not appear in the trait or in the implementing type.</p> <p>One way to work around this is to introduce a phantom type parameter into <code>FooMaker</code>, like so:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
use std::marker::PhantomData;

trait Maker {
    type Item;
    fn make(&amp;mut self) -&gt; Self::Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

// Add a type parameter to `FooMaker`
struct FooMaker&lt;T&gt; {
    phantom: PhantomData&lt;T&gt;,
}

impl&lt;T: Default&gt; Maker for FooMaker&lt;T&gt; {
    type Item = Foo&lt;T&gt;;

    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo {
            foo: &lt;T as Default&gt;::default(),
        }
    }
}
}</pre> <p>Another way is to do away with the associated type in <code>Maker</code> and use an input type parameter instead:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
// Use a type parameter instead of an associated type here
trait Maker&lt;Item&gt; {
    fn make(&amp;mut self) -&gt; Item;
}

struct Foo&lt;T&gt; {
    foo: T
}

struct FooMaker;

impl&lt;T: Default&gt; Maker&lt;Foo&lt;T&gt;&gt; for FooMaker {
    fn make(&amp;mut self) -&gt; Foo&lt;T&gt; {
        Foo { foo: &lt;T as Default&gt;::default() }
    }
}
}</pre> <h3 id="error-example-3">Error example 3</h3> <p>Suppose we have a struct <code>Foo</code> and we would like to define some methods for it. The following code example has a definition which leads to a compiler error:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct Foo;

impl&lt;const T: i32&gt; Foo {
    // error: the const parameter `T` is not constrained by the impl trait, self
    // type, or predicates [E0207]
    fn get(&amp;self) -&gt; i32 {
        i32::default()
    }
}
}</pre> <p>The problem is that the const parameter <code>T</code> does not appear in the implementing type (<code>Foo</code>) of the impl. In this case, we can fix the error by moving the type parameter from the <code>impl</code> to the method <code>get</code>:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct Foo;

// Move the const parameter from the impl to the method
impl Foo {
    fn get&lt;const T: i32&gt;(&amp;self) -&gt; i32 {
        i32::default()
    }
}
}</pre> <h3 id="error-example-4">Error example 4</h3> <p>Suppose we have a struct <code>Foo</code> and a struct <code>Bar</code> that uses lifetime <code>'a</code>. We would like to implement trait <code>Contains</code> for <code>Foo</code>. The trait <code>Contains</code> have the associated type <code>B</code>. The following code example has a definition which leads to a compiler error:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct Foo;
struct Bar&lt;'a&gt;;

trait Contains {
    type B;

    fn get(&amp;self) -&gt; i32;
}

impl&lt;'a&gt; Contains for Foo {
    type B = Bar&lt;'a&gt;;

    // error: the lifetime parameter `'a` is not constrained by the impl trait,
    // self type, or predicates [E0207]
    fn get(&amp;self) -&gt; i32 {
        i32::default()
    }
}
}</pre> <p>Please note that unconstrained lifetime parameters are not supported if they are being used by an associated type.</p> <p>In cases where the associated type's lifetime is meant to be tied to the self type, and none of the methods on the trait need ownership or different mutability, then an option is to implement the trait on a borrowed type:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct Foo(i32);

trait Contents {
    type Item;

    fn get(&amp;self) -&gt; Self::Item;
}

// Note the lifetime `'a` is used both for the self type...
impl&lt;'a&gt; Contents for &amp;'a Foo {
    // ...and the associated type.
    type Item = &amp;'a i32;

    fn get(&amp;self) -&gt; Self::Item {
        &amp;self.0
    }
}
}</pre> <h3 id="additional-information">Additional information</h3> <p>For more information, please see <a href="https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md">RFC 447</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0207.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0207.html</a>
  </p>
</div>
