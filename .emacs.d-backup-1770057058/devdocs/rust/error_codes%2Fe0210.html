<h1 id="error-code-e0210">Error code E0210</h1> <p>This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule concerns the use of type parameters in an implementation of a foreign trait (a trait defined in another crate), and states that type parameters must be "covered" by a local type.</p> <p>When implementing a foreign trait for a foreign type, the trait must have one or more type parameters. A type local to your crate must appear before any use of any type parameters.</p> <p>To understand what this means, it is perhaps easier to consider a few examples.</p> <p>If <code>ForeignTrait</code> is a trait defined in some external crate <code>foo</code>, then the following trait <code>impl</code> is an error:</p> <pre data-language="rust">#[cfg(for_demonstration_only)]
extern crate foo;
#[cfg(for_demonstration_only)]
use foo::ForeignTrait;
use std::panic::UnwindSafe as ForeignTrait;

impl&lt;T&gt; ForeignTrait for T { } // error
fn main() {}</pre> <p>To work around this, it can be covered with a local type, <code>MyType</code>:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
use std::panic::UnwindSafe as ForeignTrait;
struct MyType&lt;T&gt;(T);
impl&lt;T&gt; ForeignTrait for MyType&lt;T&gt; { } // Ok
}</pre> <p>Please note that a type alias is not sufficient.</p> <p>For another example of an error, suppose there's another trait defined in <code>foo</code> named <code>ForeignTrait2</code> that takes two type parameters. Then this <code>impl</code> results in the same rule violation:</p> <pre data-language="rust">struct MyType2;
impl&lt;T&gt; ForeignTrait2&lt;T, MyType&lt;T&gt;&gt; for MyType2 { } // error</pre> <p>The reason for this is that there are two appearances of type parameter <code>T</code> in the <code>impl</code> header, both as parameters for <code>ForeignTrait2</code>. The first appearance is uncovered, and so runs afoul of the orphan rule.</p> <p>Consider one more example:</p> <pre data-language="rust">impl&lt;T&gt; ForeignTrait2&lt;MyType&lt;T&gt;, T&gt; for MyType2 { } // Ok</pre> <p>This only differs from the previous <code>impl</code> in that the parameters <code>T</code> and <code>MyType&lt;T&gt;</code> for <code>ForeignTrait2</code> have been swapped. This example does <em>not</em> violate the orphan rule; it is permitted.</p> <p>To see why that last example was allowed, you need to understand the general rule. Unfortunately this rule is a bit tricky to state. Consider an <code>impl</code>:</p> <pre data-language="rust">impl&lt;P1, ..., Pm&gt; ForeignTrait&lt;T1, ..., Tn&gt; for T0 { ... }</pre> <p>where <code>P1, ..., Pm</code> are the type parameters of the <code>impl</code> and <code>T0, ..., Tn</code> are types. One of the types <code>T0, ..., Tn</code> must be a local type (this is another orphan rule, see the explanation for E0117).</p> <p>Both of the following must be true:</p> <ol> <li>At least one of the types <code>T0..=Tn</code> must be a local type. Let <code>Ti</code> be the first such type.</li> <li>No uncovered type parameters <code>P1..=Pm</code> may appear in <code>T0..Ti</code> (excluding <code>Ti</code>).</li> </ol> <p>For information on the design of the orphan rules, see <a href="https://rust-lang.github.io/rfcs/2451-re-rebalancing-coherence.html">RFC 2451</a> and <a href="https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md">RFC 1023</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0210.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0210.html</a>
  </p>
</div>
