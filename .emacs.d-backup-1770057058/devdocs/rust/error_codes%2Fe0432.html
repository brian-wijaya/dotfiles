<h1 id="error-code-e0432">Error code E0432</h1> <p>An import was unresolved.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
use something::Foo; // error: unresolved import `something::Foo`.
}</pre> <p>In Rust 2015, paths in <code>use</code> statements are relative to the crate root. To import items relative to the current and parent modules, use the <code>self::</code> and <code>super::</code> prefixes, respectively.</p> <p>In Rust 2018 or later, paths in <code>use</code> statements are relative to the current module unless they begin with the name of a crate or a literal <code>crate::</code>, in which case they start from the crate root. As in Rust 2015 code, the <code>self::</code> and <code>super::</code> prefixes refer to the current and parent modules respectively.</p> <p>Also verify that you didn't misspell the import name and that the import exists in the module from where you tried to import it. Example:</p> <pre data-language="rust">use self::something::Foo; // Ok.

mod something {
    pub struct Foo;
}
fn main() {}</pre> <p>If you tried to use a module from an external crate and are using Rust 2015, you may have missed the <code>extern crate</code> declaration (which is usually placed in the crate root):</p> <pre data-language="rust">extern crate core; // Required to use the `core` crate in Rust 2015.

use core::any;
fn main() {}</pre> <p>Since Rust 2018 the <code>extern crate</code> declaration is not required and you can instead just <code>use</code> it:</p> <pre data-language="rust">use core::any; // No extern crate required in Rust 2018.
fn main() {}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0432.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0432.html</a>
  </p>
</div>
