 <h1 id="macros-by-example">Macros By Example</h1>  <div class="grammar-container">
<p><strong><sup>Syntax</sup></strong>
<br>
<span class="grammar-text grammar-production" id="grammar-MacroRulesDefinition"><a href="macros-by-example#railroad-MacroRulesDefinition">MacroRulesDefinition</a></span> → <br>
    <code class="grammar-literal">macro_rules</code> <code class="grammar-literal">!</code> <span class="grammar-text"><a href="identifiers#grammar-IDENTIFIER">IDENTIFIER</a></span> <span class="grammar-text"><a href="macros-by-example#grammar-MacroRulesDef">MacroRulesDef</a></span></p>
<p><span class="grammar-text grammar-production" id="grammar-MacroRulesDef"><a href="macros-by-example#railroad-MacroRulesDef">MacroRulesDef</a></span> → <br>
      <code class="grammar-literal">(</code> <span class="grammar-text"><a href="macros-by-example#grammar-MacroRules">MacroRules</a></span> <code class="grammar-literal">)</code> <code class="grammar-literal">;</code> <br>
    | <code class="grammar-literal">[</code> <span class="grammar-text"><a href="macros-by-example#grammar-MacroRules">MacroRules</a></span> <code class="grammar-literal">]</code> <code class="grammar-literal">;</code> <br>
    | <code class="grammar-literal">{</code> <span class="grammar-text"><a href="macros-by-example#grammar-MacroRules">MacroRules</a></span> <code class="grammar-literal">}</code></p>
<p><span class="grammar-text grammar-production" id="grammar-MacroRules"><a href="macros-by-example#railroad-MacroRules">MacroRules</a></span> → <br>
    <span class="grammar-text"><a href="macros-by-example#grammar-MacroRule">MacroRule</a></span> ( <code class="grammar-literal">;</code> <span class="grammar-text"><a href="macros-by-example#grammar-MacroRule">MacroRule</a></span> )<sup>*</sup> <code class="grammar-literal">;</code><sup>?</sup></p>
<p><span class="grammar-text grammar-production" id="grammar-MacroRule"><a href="macros-by-example#railroad-MacroRule">MacroRule</a></span> → <br>
    <span class="grammar-text"><a href="macros-by-example#grammar-MacroMatcher">MacroMatcher</a></span> <code class="grammar-literal">=&gt;</code> <span class="grammar-text"><a href="macros-by-example#grammar-MacroTranscriber">MacroTranscriber</a></span></p>
<p><span class="grammar-text grammar-production" id="grammar-MacroMatcher"><a href="macros-by-example#railroad-MacroMatcher">MacroMatcher</a></span> → <br>
      <code class="grammar-literal">(</code> <span class="grammar-text"><a href="macros-by-example#grammar-MacroMatch">MacroMatch</a></span><sup>*</sup> <code class="grammar-literal">)</code> <br>
    | <code class="grammar-literal">[</code> <span class="grammar-text"><a href="macros-by-example#grammar-MacroMatch">MacroMatch</a></span><sup>*</sup> <code class="grammar-literal">]</code> <br>
    | <code class="grammar-literal">{</code> <span class="grammar-text"><a href="macros-by-example#grammar-MacroMatch">MacroMatch</a></span><sup>*</sup> <code class="grammar-literal">}</code></p>
<p><span class="grammar-text grammar-production" id="grammar-MacroMatch"><a href="macros-by-example#railroad-MacroMatch">MacroMatch</a></span> → <br>
      <span class="grammar-text"><a href="tokens#grammar-Token">Token</a></span><sub class="grammar-text">except <code>$</code> and <a href="tokens#r-lex.token.delim">delimiters</a></sub> <br>
    | <span class="grammar-text"><a href="macros-by-example#grammar-MacroMatcher">MacroMatcher</a></span> <br>
    | <code class="grammar-literal">$</code> ( <span class="grammar-text"><a href="identifiers#grammar-IDENTIFIER_OR_KEYWORD">IDENTIFIER_OR_KEYWORD</a></span><sub class="grammar-text">except <code>crate</code></sub> | <span class="grammar-text"><a href="identifiers#grammar-RAW_IDENTIFIER">RAW_IDENTIFIER</a></span> | <code class="grammar-literal">_</code> ) <code class="grammar-literal">:</code> <span class="grammar-text"><a href="macros-by-example#grammar-MacroFragSpec">MacroFragSpec</a></span> <br>
    | <code class="grammar-literal">$</code> <code class="grammar-literal">(</code> <span class="grammar-text"><a href="macros-by-example#grammar-MacroMatch">MacroMatch</a></span><sup>+</sup> <code class="grammar-literal">)</code> <span class="grammar-text"><a href="macros-by-example#grammar-MacroRepSep">MacroRepSep</a></span><sup>?</sup> <span class="grammar-text"><a href="macros-by-example#grammar-MacroRepOp">MacroRepOp</a></span></p>
<p><span class="grammar-text grammar-production" id="grammar-MacroFragSpec"><a href="macros-by-example#railroad-MacroFragSpec">MacroFragSpec</a></span> → <br>
      <code class="grammar-literal">block</code> | <code class="grammar-literal">expr</code> | <code class="grammar-literal">expr_2021</code> | <code class="grammar-literal">ident</code> | <code class="grammar-literal">item</code> | <code class="grammar-literal">lifetime</code> | <code class="grammar-literal">literal</code> <br>
    | <code class="grammar-literal">meta</code> | <code class="grammar-literal">pat</code> | <code class="grammar-literal">pat_param</code> | <code class="grammar-literal">path</code> | <code class="grammar-literal">stmt</code> | <code class="grammar-literal">tt</code> | <code class="grammar-literal">ty</code> | <code class="grammar-literal">vis</code></p>
<p><span class="grammar-text grammar-production" id="grammar-MacroRepSep"><a href="macros-by-example#railroad-MacroRepSep">MacroRepSep</a></span> → <span class="grammar-text"><a href="tokens#grammar-Token">Token</a></span><sub class="grammar-text">except <a href="tokens#r-lex.token.delim">delimiters</a> and <a href="macros-by-example#grammar-MacroRepOp">MacroRepOp</a></sub></p>
<p><span class="grammar-text grammar-production" id="grammar-MacroRepOp"><a href="macros-by-example#railroad-MacroRepOp">MacroRepOp</a></span> → <code class="grammar-literal">*</code> | <code class="grammar-literal">+</code> | <code class="grammar-literal">?</code></p>
<p><span class="grammar-text grammar-production" id="grammar-MacroTranscriber"><a href="macros-by-example#railroad-MacroTranscriber">MacroTranscriber</a></span> → <span class="grammar-text"><a href="macros#grammar-DelimTokenTree">DelimTokenTree</a></span></p>

<details class="grammar-railroad grammar-hidden"><summary>Syntax diagram</summary> <div style="width: 460px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-MacroRulesDefinition">
<svg class="railroad" viewbox="0 0 460 74" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="macros-by-example#grammar-MacroRulesDefinition"> <text class="comment" x="88" y="25"> MacroRulesDefinition</text> </a> <g class="sequence"> <path d=" M 10 53 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="108" x="35" y="42"></rect> <text x="89" y="58"> macro_rules</text> </g> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="153" y="42"></rect> <text x="167" y="58"> !</text> </g> <a class="link" xlink:href="identifiers#railroad-IDENTIFIER"> <g class="nonterminal"> <rect height="22" width="100" x="191" y="42"></rect> <text x="241" y="58"> IDENTIFIER</text> </g> </a> <a class="link" xlink:href="macros-by-example#railroad-MacroRulesDef"> <g class="nonterminal"> <rect height="22" width="124" x="301" y="42"></rect> <text x="363" y="58"> MacroRulesDef</text> </g> </a> <path d=" M 143 53 h 10"></path> <path d=" M 181 53 h 10"></path> <path d=" M 291 53 h 10"></path> </g> <path d=" M 435 53 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 53 h 10"></path> <path d=" M 425 53 h 10"></path> </g> </g> </svg> </div> <div style="width: 332px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-MacroRulesDef">
<svg class="railroad" viewbox="0 0 332 140" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="macros-by-example#grammar-MacroRulesDef"> <text class="comment" x="60" y="25"> MacroRulesDef</text> </a> <g class="sequence"> <path d=" M 10 53 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <g class="choice"> <path d=" M 35 53 h 24 m 214 0 h 24"></path> <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="59" y="42"></rect> <text x="73" y="58"> (</text> </g> <a class="link" xlink:href="macros-by-example#railroad-MacroRules"> <g class="nonterminal"> <rect height="22" width="100" x="97" y="42"></rect> <text x="147" y="58"> MacroRules</text> </g> </a> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="207" y="42"></rect> <text x="221" y="58"> )</text> </g> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="245" y="42"></rect> <text x="259" y="58"> ;</text> </g> <path d=" M 87 53 h 10"></path> <path d=" M 197 53 h 10"></path> <path d=" M 235 53 h 10"></path> </g> <path d=" M 35 53 a 12 12 0 0 1 12 12 v 9 m 238 0 v -9 a 12 12 0 0 1 12 -12"></path> <path d=" M 47 74 v 33 m 238 0 v -33"></path> <path d=" M 47 74 v 0 a 12 12 0 0 0 12 12 m 214 0 h 0 a 12 12 0 0 0 12 -12 v 0"></path> <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="59" y="75"></rect> <text x="73" y="91"> [</text> </g> <a class="link" xlink:href="macros-by-example#railroad-MacroRules"> <g class="nonterminal"> <rect height="22" width="100" x="97" y="75"></rect> <text x="147" y="91"> MacroRules</text> </g> </a> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="207" y="75"></rect> <text x="221" y="91"> ]</text> </g> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="245" y="75"></rect> <text x="259" y="91"> ;</text> </g> <path d=" M 87 86 h 10"></path> <path d=" M 197 86 h 10"></path> <path d=" M 235 86 h 10"></path> </g> <path d=" M 47 107 v 0 a 12 12 0 0 0 12 12 m 176 0 h 38 a 12 12 0 0 0 12 -12 v 0"></path> <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="59" y="108"></rect> <text x="73" y="124"> {</text> </g> <a class="link" xlink:href="macros-by-example#railroad-MacroRules"> <g class="nonterminal"> <rect height="22" width="100" x="97" y="108"></rect> <text x="147" y="124"> MacroRules</text> </g> </a> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="207" y="108"></rect> <text x="221" y="124"> }</text> </g> <path d=" M 87 119 h 10"></path> <path d=" M 197 119 h 10"></path> </g> </g> <path d=" M 307 53 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 53 h 10"></path> <path d=" M 297 53 h 10"></path> </g> </g> </svg> </div> <div style="width: 460px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-MacroRules">
<svg class="railroad" viewbox="0 0 460 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="macros-by-example#grammar-MacroRules"> <text class="comment" x="50" y="25"> MacroRules</text> </a> <g class="sequence"> <path d=" M 10 66 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <g class="sequence"> <a class="link" xlink:href="macros-by-example#railroad-MacroRule"> <g class="nonterminal"> <rect height="22" width="92" x="35" y="55"></rect> <text x="81" y="71"> MacroRule</text> </g> </a> <g class="optional"> <path d=" M 137 66 h 24 m -24 0 a 12 12 0 0 0 12 -12 v 0 a 12 12 0 0 1 12 -12 h 154 m -74 0 l -5 -5 m 0 10 l 5 -5 m 74 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 0 12 12 h -24"></path> <g class="repeat"> <path d=" M 161 66 h 12 m 130 0 h 12 m -12 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 1 -12 12 m 0 0 h -130 m 68 0 l 5 -5 m 0 10 l -5 -5 m -68 0 a 12 12 0 0 1 -12 -12 v 0 a 12 12 0 0 1 12 -12"></path>  <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="173" y="55"></rect> <text x="187" y="71"> ;</text> </g> <a class="link" xlink:href="macros-by-example#railroad-MacroRule"> <g class="nonterminal"> <rect height="22" width="92" x="211" y="55"></rect> <text x="257" y="71"> MacroRule</text> </g> </a> <path d=" M 201 66 h 10"></path> </g> </g> </g> <g class="optional"> <path d=" M 349 66 h 24 m -24 0 a 12 12 0 0 0 12 -12 v 0 a 12 12 0 0 1 12 -12 h 28 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 0 12 12 h -24"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="373" y="55"></rect> <text x="387" y="71"> ;</text> </g> </g> <path d=" M 127 66 h 10"></path> <path d=" M 339 66 h 10"></path> </g> <path d=" M 435 66 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 66 h 10"></path> <path d=" M 425 66 h 10"></path> </g> </g> </svg> </div> <div style="width: 390px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-MacroRule">
<svg class="railroad" viewbox="0 0 390 74" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="macros-by-example#grammar-MacroRule"> <text class="comment" x="46" y="25"> MacroRule</text> </a> <g class="sequence"> <path d=" M 10 53 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <g class="sequence"> <a class="link" xlink:href="macros-by-example#railroad-MacroMatcher"> <g class="nonterminal"> <rect height="22" width="116" x="35" y="42"></rect> <text x="93" y="58"> MacroMatcher</text> </g> </a> <g class="terminal"> <rect height="22" rx="10" ry="10" width="36" x="161" y="42"></rect> <text x="179" y="58"> =&gt;</text> </g> <a class="link" xlink:href="macros-by-example#railroad-MacroTranscriber"> <g class="nonterminal"> <rect height="22" width="148" x="207" y="42"></rect> <text x="281" y="58"> MacroTranscriber</text> </g> </a> <path d=" M 151 53 h 10"></path> <path d=" M 197 53 h 10"></path> </g> <path d=" M 365 53 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 53 h 10"></path> <path d=" M 355 53 h 10"></path> </g> </g> </svg> </div> <div style="width: 366px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-MacroMatcher">
<svg class="railroad" viewbox="0 0 366 216" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="macros-by-example#grammar-MacroMatcher"> <text class="comment" x="57" y="25"> MacroMatcher</text> </a> <g class="sequence"> <path d=" M 10 66 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <g class="choice"> <path d=" M 35 66 h 24 m 248 0 h 24"></path> <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="59" y="55"></rect> <text x="73" y="71"> (</text> </g> <g class="optional"> <path d=" M 97 66 h 24 m -24 0 a 12 12 0 0 0 12 -12 v 0 a 12 12 0 0 1 12 -12 h 124 m -59 0 l -5 -5 m 0 10 l 5 -5 m 59 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 0 12 12 h -24"></path> <g class="repeat"> <path d=" M 121 66 h 12 m 100 0 h 12 m -12 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 1 -12 12 m 0 0 h -100 m 53 0 l 5 -5 m 0 10 l -5 -5 m -53 0 a 12 12 0 0 1 -12 -12 v 0 a 12 12 0 0 1 12 -12"></path>  <a class="link" xlink:href="macros-by-example#railroad-MacroMatch"> <g class="nonterminal"> <rect height="22" width="100" x="133" y="55"></rect> <text x="183" y="71"> MacroMatch</text> </g> </a> </g> </g> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="279" y="55"></rect> <text x="293" y="71"> )</text> </g> <path d=" M 87 66 h 10"></path> <path d=" M 269 66 h 10"></path> </g> <path d=" M 35 66 a 12 12 0 0 1 12 12 v 22 m 272 0 v -22 a 12 12 0 0 1 12 -12"></path> <path d=" M 47 112 v 46 m 272 0 v -46"></path> <path d=" M 47 100 v 12 a 12 12 0 0 0 12 12 m 248 0 h 0 a 12 12 0 0 0 12 -12 v -12"></path> <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="59" y="113"></rect> <text x="73" y="129"> [</text> </g> <g class="optional"> <path d=" M 97 124 h 24 m -24 0 a 12 12 0 0 0 12 -12 v 0 a 12 12 0 0 1 12 -12 h 124 m -59 0 l -5 -5 m 0 10 l 5 -5 m 59 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 0 12 12 h -24"></path> <g class="repeat"> <path d=" M 121 124 h 12 m 100 0 h 12 m -12 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 1 -12 12 m 0 0 h -100 m 53 0 l 5 -5 m 0 10 l -5 -5 m -53 0 a 12 12 0 0 1 -12 -12 v 0 a 12 12 0 0 1 12 -12"></path>  <a class="link" xlink:href="macros-by-example#railroad-MacroMatch"> <g class="nonterminal"> <rect height="22" width="100" x="133" y="113"></rect> <text x="183" y="129"> MacroMatch</text> </g> </a> </g> </g> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="279" y="113"></rect> <text x="293" y="129"> ]</text> </g> <path d=" M 87 124 h 10"></path> <path d=" M 269 124 h 10"></path> </g> <path d=" M 47 158 v 12 a 12 12 0 0 0 12 12 m 248 0 h 0 a 12 12 0 0 0 12 -12 v -12"></path> <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="59" y="171"></rect> <text x="73" y="187"> {</text> </g> <g class="optional"> <path d=" M 97 182 h 24 m -24 0 a 12 12 0 0 0 12 -12 v 0 a 12 12 0 0 1 12 -12 h 124 m -59 0 l -5 -5 m 0 10 l 5 -5 m 59 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 0 12 12 h -24"></path> <g class="repeat"> <path d=" M 121 182 h 12 m 100 0 h 12 m -12 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 1 -12 12 m 0 0 h -100 m 53 0 l 5 -5 m 0 10 l -5 -5 m -53 0 a 12 12 0 0 1 -12 -12 v 0 a 12 12 0 0 1 12 -12"></path>  <a class="link" xlink:href="macros-by-example#railroad-MacroMatch"> <g class="nonterminal"> <rect height="22" width="100" x="133" y="171"></rect> <text x="183" y="187"> MacroMatch</text> </g> </a> </g> </g> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="279" y="171"></rect> <text x="293" y="187"> }</text> </g> <path d=" M 87 182 h 10"></path> <path d=" M 269 182 h 10"></path> </g> </g> <path d=" M 341 66 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 66 h 10"></path> <path d=" M 331 66 h 10"></path> </g> </g> </svg> </div> <div style="width: 632px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-MacroMatch">
<svg class="railroad" viewbox="0 0 632 351" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="macros-by-example#grammar-MacroMatch"> <text class="comment" x="50" y="25"> MacroMatch</text> </a> <g class="sequence"> <path d=" M 10 89 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <g class="choice"> <path d=" M 35 89 h 24 m 208 0 h 330 m -162 0 l -5 -5 m 0 10 l 5 -5 m 162 0"></path> <g class="sequence"> <g class="labeledbox"> <rect height="66" width="208" x="59" y="42"></rect> <path d=" M 59 89 h 8 m 60 0 h 140 m -67 0 l -5 -5 m 0 10 l 5 -5 m 67 0"></path> <text class="comment" x="163" y="65"> except `$` and delimiters</text> <a class="link" xlink:href="tokens#railroad-Token"> <g class="nonterminal"> <rect height="22" width="60" x="67" y="78"></rect> <text x="97" y="94"> Token</text> </g> </a> </g> </g> <path d=" M 35 89 a 12 12 0 0 1 12 12 v 17 m 538 0 v -17 a 12 12 0 0 1 12 -12"></path> <path d=" M 47 118 v 33 m 538 0 v -33"></path> <path d=" M 47 186 v 107 m 0 -50 l -5 -5 m 10 0 l -5 5 m 0 50 m 538 0 v -107 m 0 56 l -5 5 m 10 0 l -5 -5 m 0 -56"></path> <path d=" M 47 118 v 0 a 12 12 0 0 0 12 12 m 116 0 h 398 m -196 0 l -5 -5 m 0 10 l 5 -5 m 196 0 a 12 12 0 0 0 12 -12 v 0"></path> <g class="sequence"> <a class="link" xlink:href="macros-by-example#railroad-MacroMatcher"> <g class="nonterminal"> <rect height="22" width="116" x="59" y="119"></rect> <text x="117" y="135"> MacroMatcher</text> </g> </a> </g> <path d=" M 47 151 v 35 a 12 12 0 0 0 12 12 m 470 0 h 44 a 12 12 0 0 0 12 -12 v -35"></path> <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="59" y="187"></rect> <text x="73" y="203"> $</text> </g> <g class="choice"> <path d=" M 97 198 h 24 m 212 0 h 24"></path> <g class="labeledbox"> <rect height="66" width="212" x="121" y="151"></rect> <path d=" M 121 198 h 8 m 196 0 h 8"></path> <text class="comment" x="183" y="174"> except `crate`</text> <a class="link" xlink:href="identifiers#railroad-IDENTIFIER_OR_KEYWORD"> <g class="nonterminal"> <rect height="22" width="196" x="129" y="187"></rect> <text x="227" y="203"> IDENTIFIER_OR_KEYWORD</text> </g> </a> </g> <path d=" M 97 198 a 12 12 0 0 1 12 12 v 17 m 236 0 v -17 a 12 12 0 0 1 12 -12"></path> <path d=" M 109 227 v 33 m 236 0 v -33"></path> <path d=" M 109 227 v 0 a 12 12 0 0 0 12 12 m 132 0 h 80 m -37 0 l -5 -5 m 0 10 l 5 -5 m 37 0 a 12 12 0 0 0 12 -12 v 0"></path> <a class="link" xlink:href="identifiers#railroad-RAW_IDENTIFIER"> <g class="nonterminal"> <rect height="22" width="132" x="121" y="228"></rect> <text x="187" y="244"> RAW_IDENTIFIER</text> </g> </a> <path d=" M 109 260 v 0 a 12 12 0 0 0 12 12 m 28 0 h 184 m -89 0 l -5 -5 m 0 10 l 5 -5 m 89 0 a 12 12 0 0 0 12 -12 v 0"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="121" y="261"></rect> <text x="135" y="277"> _</text> </g> </g> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="367" y="187"></rect> <text x="381" y="203"> :</text> </g> <a class="link" xlink:href="macros-by-example#railroad-MacroFragSpec"> <g class="nonterminal"> <rect height="22" width="124" x="405" y="187"></rect> <text x="467" y="203"> MacroFragSpec</text> </g> </a> <path d=" M 87 198 h 10"></path> <path d=" M 357 198 h 10"></path> <path d=" M 395 198 h 10"></path> </g> <path d=" M 47 293 v 12 a 12 12 0 0 0 12 12 m 514 0 h 0 a 12 12 0 0 0 12 -12 v -12"></path> <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="59" y="306"></rect> <text x="73" y="322"> $</text> </g> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="97" y="306"></rect> <text x="111" y="322"> (</text> </g> <g class="repeat"> <path d=" M 135 317 h 12 m 100 0 h 12 m -12 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 1 -12 12 m 0 0 h -100 m 53 0 l 5 -5 m 0 10 l -5 -5 m -53 0 a 12 12 0 0 1 -12 -12 v 0 a 12 12 0 0 1 12 -12"></path>  <a class="link" xlink:href="macros-by-example#railroad-MacroMatch"> <g class="nonterminal"> <rect height="22" width="100" x="147" y="306"></rect> <text x="197" y="322"> MacroMatch</text> </g> </a> </g> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="269" y="306"></rect> <text x="283" y="322"> )</text> </g> <g class="optional"> <path d=" M 307 317 h 24 m -24 0 a 12 12 0 0 0 12 -12 v 0 a 12 12 0 0 1 12 -12 h 108 m -51 0 l -5 -5 m 0 10 l 5 -5 m 51 0 a 12 12 0 0 1 12 12 v 0 a 12 12 0 0 0 12 12 h -24"></path> <a class="link" xlink:href="macros-by-example#railroad-MacroRepSep"> <g class="nonterminal"> <rect height="22" width="108" x="331" y="306"></rect> <text x="385" y="322"> MacroRepSep</text> </g> </a> </g> <a class="link" xlink:href="macros-by-example#railroad-MacroRepOp"> <g class="nonterminal"> <rect height="22" width="100" x="473" y="306"></rect> <text x="523" y="322"> MacroRepOp</text> </g> </a> <path d=" M 87 317 h 10"></path> <path d=" M 125 317 h 10"></path> <path d=" M 259 317 h 10"></path> <path d=" M 297 317 h 10"></path> <path d=" M 463 317 h 10"></path> </g> </g> <path d=" M 607 89 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 89 h 10"></path> <path d=" M 597 89 h 10"></path> </g> </g> </svg> </div> <div style="width: 210px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-MacroFragSpec">
<svg class="railroad" viewbox="0 0 210 536" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="macros-by-example#grammar-MacroFragSpec"> <text class="comment" x="60" y="25"> MacroFragSpec</text> </a> <g class="sequence"> <path d=" M 10 53 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <g class="choice"> <path d=" M 35 53 h 24 m 60 0 h 56 m -25 0 l -5 -5 m 0 10 l 5 -5 m 25 0"></path> <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="60" x="59" y="42"></rect> <text x="89" y="58"> block</text> </g> </g> <path d=" M 35 53 a 12 12 0 0 1 12 12 v 9 m 116 0 v -9 a 12 12 0 0 1 12 -12"></path> <path d=" M 47 74 v 33 m 116 0 v -33"></path> <path d=" M 47 107 v 33 m 116 0 v -33"></path> <path d=" M 47 140 v 33 m 116 0 v -33"></path> <path d=" M 47 173 v 33 m 116 0 v -33"></path> <path d=" M 47 206 v 33 m 116 0 v -33"></path> <path d=" M 47 239 v 33 m 116 0 v -33"></path> <path d=" M 47 272 v 33 m 116 0 v -33"></path> <path d=" M 47 305 v 33 m 116 0 v -33"></path> <path d=" M 47 338 v 33 m 116 0 v -33"></path> <path d=" M 47 371 v 33 m 116 0 v -33"></path> <path d=" M 47 404 v 33 m 116 0 v -33"></path> <path d=" M 47 437 v 33 m 116 0 v -33"></path> <path d=" M 47 470 v 33 m 116 0 v -33"></path> <path d=" M 47 74 v 0 a 12 12 0 0 0 12 12 m 52 0 h 40 a 12 12 0 0 0 12 -12 v 0"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="52" x="59" y="75"></rect> <text x="85" y="91"> expr</text> </g> <path d=" M 47 107 v 0 a 12 12 0 0 0 12 12 m 92 0 h 0 a 12 12 0 0 0 12 -12 v 0"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="92" x="59" y="108"></rect> <text x="105" y="124"> expr_2021</text> </g> <path d=" M 47 140 v 0 a 12 12 0 0 0 12 12 m 60 0 h 32 a 12 12 0 0 0 12 -12 v 0"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="60" x="59" y="141"></rect> <text x="89" y="157"> ident</text> </g> <path d=" M 47 173 v 0 a 12 12 0 0 0 12 12 m 52 0 h 40 a 12 12 0 0 0 12 -12 v 0"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="52" x="59" y="174"></rect> <text x="85" y="190"> item</text> </g> <path d=" M 47 206 v 0 a 12 12 0 0 0 12 12 m 84 0 h 8 a 12 12 0 0 0 12 -12 v 0"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="84" x="59" y="207"></rect> <text x="101" y="223"> lifetime</text> </g> <path d=" M 47 239 v 0 a 12 12 0 0 0 12 12 m 76 0 h 16 a 12 12 0 0 0 12 -12 v 0"></path> <g class="sequence"> <g class="terminal"> <rect height="22" rx="10" ry="10" width="76" x="59" y="240"></rect> <text x="97" y="256"> literal</text> </g> </g> <path d=" M 47 272 v 0 a 12 12 0 0 0 12 12 m 52 0 h 40 a 12 12 0 0 0 12 -12 v 0"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="52" x="59" y="273"></rect> <text x="85" y="289"> meta</text> </g> <path d=" M 47 305 v 0 a 12 12 0 0 0 12 12 m 44 0 h 48 a 12 12 0 0 0 12 -12 v 0"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="44" x="59" y="306"></rect> <text x="81" y="322"> pat</text> </g> <path d=" M 47 338 v 0 a 12 12 0 0 0 12 12 m 92 0 h 0 a 12 12 0 0 0 12 -12 v 0"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="92" x="59" y="339"></rect> <text x="105" y="355"> pat_param</text> </g> <path d=" M 47 371 v 0 a 12 12 0 0 0 12 12 m 52 0 h 40 a 12 12 0 0 0 12 -12 v 0"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="52" x="59" y="372"></rect> <text x="85" y="388"> path</text> </g> <path d=" M 47 404 v 0 a 12 12 0 0 0 12 12 m 52 0 h 40 a 12 12 0 0 0 12 -12 v 0"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="52" x="59" y="405"></rect> <text x="85" y="421"> stmt</text> </g> <path d=" M 47 437 v 0 a 12 12 0 0 0 12 12 m 36 0 h 56 m -25 0 l -5 -5 m 0 10 l 5 -5 m 25 0 a 12 12 0 0 0 12 -12 v 0"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="36" x="59" y="438"></rect> <text x="77" y="454"> tt</text> </g> <path d=" M 47 470 v 0 a 12 12 0 0 0 12 12 m 36 0 h 56 m -25 0 l -5 -5 m 0 10 l 5 -5 m 25 0 a 12 12 0 0 0 12 -12 v 0"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="36" x="59" y="471"></rect> <text x="77" y="487"> ty</text> </g> <path d=" M 47 503 v 0 a 12 12 0 0 0 12 12 m 44 0 h 48 a 12 12 0 0 0 12 -12 v 0"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="44" x="59" y="504"></rect> <text x="81" y="520"> vis</text> </g> </g> <path d=" M 185 53 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 53 h 10"></path> <path d=" M 175 53 h 10"></path> </g> </g> </svg> </div> <div style="width: 327px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-MacroRepSep">
<svg class="railroad" viewbox="0 0 327 118" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="macros-by-example#grammar-MacroRepSep"> <text class="comment" x="53" y="25"> MacroRepSep</text> </a> <g class="sequence"> <path d=" M 10 89 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <g class="labeledbox"> <rect height="66" width="257" x="35" y="42"></rect> <path d=" M 35 89 h 8 m 60 0 h 189 m -91 0 l -5 -5 m 0 10 l 5 -5 m 91 0"></path> <text class="comment" x="163" y="65"> except delimiters and MacroRepOp</text> <a class="link" xlink:href="tokens#railroad-Token"> <g class="nonterminal"> <rect height="22" width="60" x="43" y="78"></rect> <text x="73" y="94"> Token</text> </g> </a> </g> <path d=" M 302 89 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 89 h 10"></path> <path d=" M 292 89 h 10"></path> </g> </g> </svg> </div> <div style="width: 146px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-MacroRepOp">
<svg class="railroad" viewbox="0 0 146 140" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="macros-by-example#grammar-MacroRepOp"> <text class="comment" x="50" y="25"> MacroRepOp</text> </a> <g class="sequence"> <path d=" M 10 53 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <g class="choice"> <path d=" M 35 53 h 24 m 28 0 h 24"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="59" y="42"></rect> <text x="73" y="58"> *</text> </g> <path d=" M 35 53 a 12 12 0 0 1 12 12 v 9 m 52 0 v -9 a 12 12 0 0 1 12 -12"></path> <path d=" M 47 74 v 33 m 52 0 v -33"></path> <path d=" M 47 74 v 0 a 12 12 0 0 0 12 12 m 28 0 h 0 a 12 12 0 0 0 12 -12 v 0"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="59" y="75"></rect> <text x="73" y="91"> +</text> </g> <path d=" M 47 107 v 0 a 12 12 0 0 0 12 12 m 28 0 h 0 a 12 12 0 0 0 12 -12 v 0"></path> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="59" y="108"></rect> <text x="73" y="124"> ?</text> </g> </g> <path d=" M 121 53 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 53 h 10"></path> <path d=" M 111 53 h 10"></path> </g> </g> </svg> </div> <div style="width: 202px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-MacroTranscriber">
<svg class="railroad" viewbox="0 0 202 74" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="macros-by-example#grammar-MacroTranscriber"> <text class="comment" x="71" y="25"> MacroTranscriber</text> </a> <g class="sequence"> <path d=" M 10 53 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <a class="link" xlink:href="macros#railroad-DelimTokenTree"> <g class="nonterminal"> <rect height="22" width="132" x="35" y="42"></rect> <text x="101" y="58"> DelimTokenTree</text> </g> </a> <path d=" M 177 53 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 53 h 10"></path> <path d=" M 167 53 h 10"></path> </g> </g> </svg> </div> </details>
</div>   <p><code>macro_rules</code> allows users to define syntax extension in a declarative way. We call such extensions “macros by example” or simply “macros”.</p> <p>Each macro by example has a name, and one or more <em>rules</em>. Each rule has two parts: a <em>matcher</em>, describing the syntax that it matches, and a <em>transcriber</em>, describing the syntax that will replace a successfully matched invocation. Both the matcher and the transcriber must be surrounded by delimiters. Macros can expand to expressions, statements, items (including traits, impls, and foreign items), types, or patterns.</p>  <h2 id="transcribing">Transcribing</h2>  <p>When a macro is invoked, the macro expander looks up macro invocations by name, and tries each macro rule in turn. It transcribes the first successful match; if this results in an error, then future matches are not tried.</p>  <p>When matching, no lookahead is performed; if the compiler cannot unambiguously determine how to parse the macro invocation one token at a time, then it is an error. In the following example, the compiler does not look ahead past the identifier to see if the following token is a <code>)</code>, even though that would allow it to parse the invocation unambiguously:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
macro_rules! ambiguity {
    ($($i:ident)* $j:ident) =&gt; { };
}

ambiguity!(error); // Error: local ambiguity
}</pre>  <p>In both the matcher and the transcriber, the <code>$</code> token is used to invoke special behaviours from the macro engine (described below in <a href="#metavariables">Metavariables</a> and <a href="#repetitions">Repetitions</a>). Tokens that aren’t part of such an invocation are matched and transcribed literally, with one exception. The exception is that the outer delimiters for the matcher will match any pair of delimiters. Thus, for instance, the matcher <code>(())</code> will match <code>{()}</code> but not <code>{{}}</code>. The character <code>$</code> cannot be matched or transcribed literally.</p>  <h3 id="forwarding-a-matched-fragment">Forwarding a matched fragment</h3> <p>When forwarding a matched fragment to another macro-by-example, matchers in the second macro will see an opaque AST of the fragment type. The second macro can’t use literal tokens to match the fragments in the matcher, only a fragment specifier of the same type. The <code>ident</code>, <code>lifetime</code>, and <code>tt</code> fragment types are an exception, and <em>can</em> be matched by literal tokens. The following illustrates this restriction:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
macro_rules! foo {
    ($l:expr) =&gt; { bar!($l); }
// ERROR:               ^^ no rules expected this token in macro call
}

macro_rules! bar {
    (3) =&gt; {}
}

foo!(3);
}</pre> <p>The following illustrates how tokens can be directly matched after matching a <code>tt</code> fragment:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
// compiles OK
macro_rules! foo {
    ($l:tt) =&gt; { bar!($l); }
}

macro_rules! bar {
    (3) =&gt; {}
}

foo!(3);
}</pre>  <h2 id="metavariables">Metavariables</h2>  <p>In the matcher, <code>$</code> <em>name</em> <code>:</code> <em>fragment-specifier</em> matches a Rust syntax fragment of the kind specified and binds it to the metavariable <code>$</code><em>name</em>.</p>  <p>Valid fragment specifiers are:</p> <ul> <li>
<code>block</code>: a <a href="expressions/block-expr#grammar-BlockExpression">BlockExpression</a>
</li> <li>
<code>expr</code>: an <a href="expressions#grammar-Expression">Expression</a>
</li> <li>
<code>expr_2021</code>: an <a href="expressions#grammar-Expression">Expression</a> except <a href="expressions/underscore-expr#grammar-UnderscoreExpression">UnderscoreExpression</a> and <a href="expressions/block-expr#grammar-ConstBlockExpression">ConstBlockExpression</a> (see <a href="macros-by-example#r-macro.decl.meta.edition2024">macro.decl.meta.edition2024</a>)</li> <li>
<code>ident</code>: an <a href="identifiers#grammar-IDENTIFIER_OR_KEYWORD">IDENTIFIER_OR_KEYWORD</a>, <a href="identifiers#grammar-RAW_IDENTIFIER">RAW_IDENTIFIER</a>, or <a href="macros-by-example#r-macro.decl.hygiene.crate"><code>$crate</code></a>
</li> <li>
<code>item</code>: an <a href="items#grammar-Item">Item</a>
</li> <li>
<code>lifetime</code>: a <a href="tokens#grammar-LIFETIME_TOKEN">LIFETIME_TOKEN</a>
</li> <li>
<code>literal</code>: matches <code>-</code><sup>?</sup><a href="expressions/literal-expr#grammar-LiteralExpression">LiteralExpression</a>
</li> <li>
<code>meta</code>: an <a href="attributes#grammar-Attr">Attr</a>, the contents of an attribute</li> <li>
<code>pat</code>: a <a href="patterns#grammar-Pattern">Pattern</a> (see <a href="macros-by-example#r-macro.decl.meta.edition2021">macro.decl.meta.edition2021</a>)</li> <li>
<code>pat_param</code>: a <a href="patterns#grammar-PatternNoTopAlt">PatternNoTopAlt</a>
</li> <li>
<code>path</code>: a <a href="paths#grammar-TypePath">TypePath</a> style path</li> <li>
<code>stmt</code>: a <a href="statements#grammar-Statement">Statement</a> without the trailing semicolon (except for item statements that require semicolons)</li> <li>
<code>tt</code>: a <a href="macros#grammar-TokenTree">TokenTree</a> (a single <a href="tokens">token</a> or tokens in matching delimiters <code>()</code>, <code>[]</code>, or <code>{}</code>)</li> <li>
<code>ty</code>: a <a href="types#grammar-Type">Type</a>
</li> <li>
<code>vis</code>: a possibly empty <a href="visibility-and-privacy#grammar-Visibility">Visibility</a> qualifier</li> </ul>  <p>In the transcriber, metavariables are referred to simply by <code>$</code><em>name</em>, since the fragment kind is specified in the matcher. Metavariables are replaced with the syntax element that matched them. Metavariables can be transcribed more than once or not at all.</p>  <p>The keyword metavariable <a href="macros-by-example#r-macro.decl.hygiene.crate"><code>$crate</code></a> can be used to refer to the current crate.</p>  <div class="alert alert-edition"> <blockquote> <p class="alert-title"><span class="alert-title-edition">2021</span> Edition differences</p> <p>Starting with the 2021 edition, <code>pat</code> fragment-specifiers match top-level or-patterns (that is, they accept <a href="patterns#grammar-Pattern">Pattern</a>).</p> <p>Before the 2021 edition, they match exactly the same fragments as <code>pat_param</code> (that is, they accept <a href="patterns#grammar-PatternNoTopAlt">PatternNoTopAlt</a>).</p> <p>The relevant edition is the one in effect for the <code>macro_rules!</code> definition.</p> </blockquote> </div>  <div class="alert alert-edition"> <blockquote> <p class="alert-title"><span class="alert-title-edition">2024</span> Edition differences</p> <p>Before the 2024 edition, <code>expr</code> fragment specifiers do not match <a href="expressions/underscore-expr#grammar-UnderscoreExpression">UnderscoreExpression</a> or <a href="expressions/block-expr#grammar-ConstBlockExpression">ConstBlockExpression</a> at the top level. They are allowed within subexpressions.</p> <p>The <code>expr_2021</code> fragment specifier exists to maintain backwards compatibility with editions before 2024.</p> </blockquote> </div>  <h2 id="repetitions">Repetitions</h2>  <p>In both the matcher and transcriber, repetitions are indicated by placing the tokens to be repeated inside <code>$(</code>…<code>)</code>, followed by a repetition operator, optionally with a separator token between.</p>  <p>The separator token can be any token other than a delimiter or one of the repetition operators, but <code>;</code> and <code>,</code> are the most common. For instance, <code>$( $i:ident ),*</code> represents any number of identifiers separated by commas. Nested repetitions are permitted.</p>  <p>The repetition operators are:</p> <ul> <li>
<code>*</code> — indicates any number of repetitions.</li> <li>
<code>+</code> — indicates any number but at least one.</li> <li>
<code>?</code> — indicates an optional fragment with zero or one occurrence.</li> </ul>  <p>Since <code>?</code> represents at most one occurrence, it cannot be used with a separator.</p>  <p>The repeated fragment both matches and transcribes to the specified number of the fragment, separated by the separator token. Metavariables are matched to every repetition of their corresponding fragment. For instance, the <code>$( $i:ident ),*</code> example above matches <code>$i</code> to all of the identifiers in the list.</p> <p>During transcription, additional restrictions apply to repetitions so that the compiler knows how to expand them properly:</p> <ol> <li>A metavariable must appear in exactly the same number, kind, and nesting order of repetitions in the transcriber as it did in the matcher. So for the matcher <code>$( $i:ident ),*</code>, the transcribers <code>=&gt; { $i }</code>, <code>=&gt; { $( $( $i)* )* }</code>, and <code>=&gt; { $( $i )+ }</code> are all illegal, but <code>=&gt; { $( $i );* }</code> is correct and replaces a comma-separated list of identifiers with a semicolon-separated list.</li> <li>Each repetition in the transcriber must contain at least one metavariable to decide how many times to expand it. If multiple metavariables appear in the same repetition, they must be bound to the same number of fragments. For instance, <code>( $( $i:ident ),* ; $( $j:ident ),* ) =&gt; (( $( ($i,$j) ),* ))</code> must bind the same number of <code>$i</code> fragments as <code>$j</code> fragments. This means that invoking the macro with <code>(a, b, c; d, e, f)</code> is legal and expands to <code>((a,d), (b,e), (c,f))</code>, but <code>(a, b, c; d, e)</code> is illegal because it does not have the same number. This requirement applies to every layer of nested repetitions.</li> </ol>  <h2 id="scoping-exporting-and-importing">Scoping, Exporting, and Importing</h2>  <p>For historical reasons, the scoping of macros by example does not work entirely like items. Macros have two forms of scope: textual scope, and path-based scope. Textual scope is based on the order that things appear in source files, or even across multiple files, and is the default scoping. It is explained further below. Path-based scope works exactly the same way that item scoping does. The scoping, exporting, and importing of macros is controlled largely by attributes.</p>  <p>When a macro is invoked by an unqualified identifier (not part of a multi-part path), it is first looked up in textual scoping. If this does not yield any results, then it is looked up in path-based scoping. If the macro’s name is qualified with a path, then it is only looked up in path-based scoping.</p>  <pre data-language="rust">use lazy_static::lazy_static; // Path-based import.

macro_rules! lazy_static { // Textual definition.
    (lazy) =&gt; {};
}

lazy_static!{lazy} // Textual lookup finds our macro first.
self::lazy_static!{} // Path-based lookup ignores our macro, finds imported one.</pre>  <h3 id="textual-scope">Textual Scope</h3>  <p>Textual scope is based largely on the order that things appear in source files, and works similarly to the scope of local variables declared with <code>let</code> except it also applies at the module level. When <code>macro_rules!</code> is used to define a macro, the macro enters the scope after the definition (note that it can still be used recursively, since names are looked up from the invocation site), up until its surrounding scope, typically a module, is closed. This can enter child modules and even span across multiple files:</p>  <pre data-language="rust">//// src/lib.rs
mod has_macro {
    // m!{} // Error: m is not in scope.

    macro_rules! m {
        () =&gt; {};
    }
    m!{} // OK: appears after declaration of m.

    mod uses_macro;
}

// m!{} // Error: m is not in scope.

//// src/has_macro/uses_macro.rs

m!{} // OK: appears after declaration of m in src/lib.rs</pre>  <p>It is not an error to define a macro multiple times; the most recent declaration will shadow the previous one unless it has gone out of scope.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
macro_rules! m {
    (1) =&gt; {};
}

m!(1);

mod inner {
    m!(1);

    macro_rules! m {
        (2) =&gt; {};
    }
    // m!(1); // Error: no rule matches '1'
    m!(2);

    macro_rules! m {
        (3) =&gt; {};
    }
    m!(3);
}

m!(1);
}</pre> <p>Macros can be declared and used locally inside functions as well, and work similarly:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn foo() {
    // m!(); // Error: m is not in scope.
    macro_rules! m {
        () =&gt; {};
    }
    m!();
}

// m!(); // Error: m is not in scope.
}</pre>  <h3 id="the-macro_use-attribute">The <code id="">macro_use</code> attribute</h3>  <p>The <em><code>macro_use</code> attribute</em> has two purposes. First, it can be used to make a module’s macro scope not end when the module is closed, by applying it to a module:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[macro_use]
mod inner {
    macro_rules! m {
        () =&gt; {};
    }
}

m!();
}</pre>  <p>Second, it can be used to import macros from another crate, by attaching it to an <code>extern crate</code> declaration appearing in the crate’s root module. Macros imported this way are imported into the <a href="names/preludes#macro_use-prelude"><code>macro_use</code> prelude</a>, not textually, which means that they can be shadowed by any other name. While macros imported by <code>#[macro_use]</code> can be used before the import statement, in case of a conflict, the last macro imported wins. Optionally, a list of macros to import can be specified using the <a href="attributes#grammar-MetaListIdents">MetaListIdents</a> syntax; this is not supported when <code>#[macro_use]</code> is applied to a module.</p>  <pre data-language="rust">#[macro_use(lazy_static)] // Or #[macro_use] to import all macros.
extern crate lazy_static;

lazy_static!{}
// self::lazy_static!{} // Error: lazy_static is not defined in `self`</pre>  <p>Macros to be imported with <code>#[macro_use]</code> must be exported with <code>#[macro_export]</code>, which is described below.</p>  <h3 id="path-based-scope">Path-Based Scope</h3>  <p>By default, a macro has no path-based scope. However, if it has the <code>#[macro_export]</code> attribute, then it is declared in the crate root scope and can be referred to normally as such:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
self::m!();
m!(); // OK: Path-based lookup finds m in the current module.

mod inner {
    super::m!();
    crate::m!();
}

mod mac {
    #[macro_export]
    macro_rules! m {
        () =&gt; {};
    }
}
}</pre>  <p>Macros labeled with <code>#[macro_export]</code> are always <code>pub</code> and can be referred to by other crates, either by path or by <code>#[macro_use]</code> as described above.</p>  <h2 id="hygiene">Hygiene</h2>  <p>Macros by example have <em>mixed-site hygiene</em>. This means that <a href="expressions/loop-expr#loop-labels">loop labels</a>, <a href="expressions/loop-expr#labelled-block-expressions">block labels</a>, and local variables are looked up at the macro definition site while other symbols are looked up at the macro invocation site. For example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let x = 1;
fn func() {
    unreachable!("this is never called")
}

macro_rules! check {
    () =&gt; {
        assert_eq!(x, 1); // Uses `x` from the definition site.
        func();           // Uses `func` from the invocation site.
    };
}

{
    let x = 2;
    fn func() { /* does not panic */ }
    check!();
}
}</pre> <p>Labels and local variables defined in macro expansion are not shared between invocations, so this code doesn’t compile:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
macro_rules! m {
    (define) =&gt; {
        let x = 1;
    };
    (refer) =&gt; {
        dbg!(x);
    };
}

m!(define);
m!(refer);
}</pre>  <p>A special case is the <code>$crate</code> metavariable. It refers to the crate defining the macro, and can be used at the start of the path to look up items or macros which are not in scope at the invocation site.</p>  <pre data-language="rust">//// Definitions in the `helper_macro` crate.
#[macro_export]
macro_rules! helped {
    // () =&gt; { helper!() } // This might lead to an error due to 'helper' not being in scope.
    () =&gt; { $crate::helper!() }
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}

//// Usage in another crate.
// Note that `helper_macro::helper` is not imported!
use helper_macro::helped;

fn unit() {
    helped!();
}</pre> <p>Note that, because <code>$crate</code> refers to the current crate, it must be used with a fully qualified module path when referring to non-macro items:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
pub mod inner {
    #[macro_export]
    macro_rules! call_foo {
        () =&gt; { $crate::inner::foo() };
    }

    pub fn foo() {}
}
}</pre>  <p>Additionally, even though <code>$crate</code> allows a macro to refer to items within its own crate when expanding, its use has no effect on visibility. An item or macro referred to must still be visible from the invocation site. In the following example, any attempt to invoke <code>call_foo!()</code> from outside its crate will fail because <code>foo()</code> is not public.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[macro_export]
macro_rules! call_foo {
    () =&gt; { $crate::foo() };
}

fn foo() {}
}</pre> <blockquote> <p><strong>Version differences</strong>: Prior to Rust 1.30, <code>$crate</code> and <code>local_inner_macros</code> (below) were unsupported. They were added alongside path-based imports of macros (described above), to ensure that helper macros did not need to be manually imported by users of a macro-exporting crate. Crates written for earlier versions of Rust that use helper macros need to be modified to use <code>$crate</code> or <code>local_inner_macros</code> to work well with path-based imports.</p> </blockquote>  <p>When a macro is exported, the <code>#[macro_export]</code> attribute can have the <code>local_inner_macros</code> keyword added to automatically prefix all contained macro invocations with <code>$crate::</code>. This is intended primarily as a tool to migrate code written before <code>$crate</code> was added to the language to work with Rust 2018’s path-based imports of macros. Its use is discouraged in new code.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[macro_export(local_inner_macros)]
macro_rules! helped {
    () =&gt; { helper!() } // Automatically converted to $crate::helper!().
}

#[macro_export]
macro_rules! helper {
    () =&gt; { () }
}
}</pre>  <h2 id="follow-set-ambiguity-restrictions">Follow-set Ambiguity Restrictions</h2>  <p>The parser used by the macro system is reasonably powerful, but it is limited in order to prevent ambiguity in current or future versions of the language.</p>  <p>In particular, in addition to the rule about ambiguous expansions, a nonterminal matched by a metavariable must be followed by a token which has been decided can be safely used after that kind of match.</p> <p>As an example, a macro matcher like <code>$i:expr [ , ]</code> could in theory be accepted in Rust today, since <code>[,]</code> cannot be part of a legal expression and therefore the parse would always be unambiguous. However, because <code>[</code> can start trailing expressions, <code>[</code> is not a character which can safely be ruled out as coming after an expression. If <code>[,]</code> were accepted in a later version of Rust, this matcher would become ambiguous or would misparse, breaking working code. Matchers like <code>$i:expr,</code> or <code>$i:expr;</code> would be legal, however, because <code>,</code> and <code>;</code> are legal expression separators. The specific rules are:</p>  <ul> <li>
<code>expr</code> and <code>stmt</code> may only be followed by one of: <code>=&gt;</code>, <code>,</code>, or <code>;</code>.</li> </ul>  <ul> <li>
<code>pat_param</code> may only be followed by one of: <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>if</code>, or <code>in</code>.</li> </ul>  <ul> <li>
<code>pat</code> may only be followed by one of: <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>if</code>, or <code>in</code>.</li> </ul>  <ul> <li>
<code>path</code> and <code>ty</code> may only be followed by one of: <code>=&gt;</code>, <code>,</code>, <code>=</code>, <code>|</code>, <code>;</code>, <code>:</code>, <code>&gt;</code>, <code>&gt;&gt;</code>, <code>[</code>, <code>{</code>, <code>as</code>, <code>where</code>, or a macro variable of <code>block</code> fragment specifier.</li> </ul>  <ul> <li>
<code>vis</code> may only be followed by one of: <code>,</code>, an identifier other than a non-raw <code>priv</code>, any token that can begin a type, or a metavariable with a <code>ident</code>, <code>ty</code>, or <code>path</code> fragment specifier.</li> </ul>  <ul> <li>All other fragment specifiers have no restrictions.</li> </ul>  <div class="alert alert-edition"> <blockquote> <p class="alert-title"><span class="alert-title-edition">2021</span> Edition differences</p> <p>Before the 2021 edition, <code>pat</code> may also be followed by <code>|</code>.</p> </blockquote> </div>  <p>When repetitions are involved, then the rules apply to every possible number of expansions, taking separators into account. This means:</p> <ul> <li>If the repetition includes a separator, that separator must be able to follow the contents of the repetition.</li> <li>If the repetition can repeat multiple times (<code>*</code> or <code>+</code>), then the contents must be able to follow themselves.</li> <li>The contents of the repetition must be able to follow whatever comes before, and whatever comes after must be able to follow the contents of the repetition.</li> <li>If the repetition can match zero times (<code>*</code> or <code>?</code>), then whatever comes after must be able to follow whatever comes before.</li> </ul> <p>For more detail, see the <a href="macro-ambiguity">formal specification</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/macros-by-example.html" class="_attribution-link">https://doc.rust-lang.org/reference/macros-by-example.html</a>
  </p>
</div>
