 <h1 id="await-expressions">Await expressions</h1>  <div class="grammar-container">
<p><strong><sup>Syntax</sup></strong>
<br>
<span class="grammar-text grammar-production" id="grammar-AwaitExpression"><a href="await-expr#railroad-AwaitExpression">AwaitExpression</a></span> â†’ <span class="grammar-text"><a href="../expressions#grammar-Expression">Expression</a></span> <code class="grammar-literal">.</code> <code class="grammar-literal">await</code></p>

<details class="grammar-railroad grammar-hidden"><summary>Syntax diagram</summary> <div style="width: 278px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-AwaitExpression">
<svg class="railroad" viewbox="0 0 278 74" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="await-expr#grammar-AwaitExpression"> <text class="comment" x="67" y="25"> AwaitExpression</text> </a> <g class="sequence"> <path d=" M 10 53 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <g class="sequence"> <a class="link" xlink:href="../expressions#railroad-Expression"> <g class="nonterminal"> <rect height="22" width="100" x="35" y="42"></rect> <text x="85" y="58"> Expression</text> </g> </a> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="145" y="42"></rect> <text x="159" y="58"> .</text> </g> <g class="terminal"> <rect height="22" rx="10" ry="10" width="60" x="183" y="42"></rect> <text x="213" y="58"> await</text> </g> <path d=" M 135 53 h 10"></path> <path d=" M 173 53 h 10"></path> </g> <path d=" M 253 53 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 53 h 10"></path> <path d=" M 243 53 h 10"></path> </g> </g> </svg> </div> </details>
</div>   <p>An <code>await</code> expression is a syntactic construct for suspending a computation provided by an implementation of <code>std::future::IntoFuture</code> until the given future is ready to produce a value.</p>  <p>The syntax for an await expression is an expression with a type that implements the <a href="https://doc.rust-lang.org/core/future/into_future/trait.IntoFuture.html"><code>IntoFuture</code></a> trait, called the <em>future operand</em>, then the token <code>.</code>, and then the <code>await</code> keyword.</p>  <p>Await expressions are legal only within an <a href="block-expr#async-context">async context</a>, like an <a href="../items/functions#async-functions"><code>async fn</code></a>, <a href="closure-expr#async-closures"><code>async</code> closure</a>, or <a href="block-expr#async-blocks"><code>async</code> block</a>.</p>  <p>More specifically, an await expression has the following effect.</p> <ol> <li>Create a future by calling <a href="https://doc.rust-lang.org/core/future/into_future/trait.IntoFuture.html#tymethod.into_future"><code>IntoFuture::into_future</code></a> on the future operand.</li> <li>Evaluate the future to a <a href="https://doc.rust-lang.org/core/future/future/trait.Future.html">future</a> <code>tmp</code>;</li> <li>Pin <code>tmp</code> using <a href="https://doc.rust-lang.org/core/pin/struct.Pin.html#method.new_unchecked"><code>Pin::new_unchecked</code></a>;</li> <li>This pinned future is then polled by calling the <a href="https://doc.rust-lang.org/core/future/future/trait.Future.html#tymethod.poll"><code>Future::poll</code></a> method and passing it the current <a href="#task-context">task context</a>;</li> <li>If the call to <code>poll</code> returns <a href="https://doc.rust-lang.org/core/task/poll/enum.Poll.html#variant.Pending"><code>Poll::Pending</code></a>, then the future returns <code>Poll::Pending</code>, suspending its state so that, when the surrounding async context is re-polled,execution returns to step 3;</li> <li>Otherwise the call to <code>poll</code> must have returned <a href="https://doc.rust-lang.org/core/task/poll/enum.Poll.html#variant.Ready"><code>Poll::Ready</code></a>, in which case the value contained in the <a href="https://doc.rust-lang.org/core/task/poll/enum.Poll.html#variant.Ready"><code>Poll::Ready</code></a> variant is used as the result of the <code>await</code> expression itself.</li> </ol>  <div class="alert alert-edition"> <blockquote> <p class="alert-title"><span class="alert-title-edition">2018</span> Edition differences</p> <p>Await expressions are only available beginning with Rust 2018.</p> </blockquote> </div>  <h2 id="task-context">Task context</h2> <p>The task context refers to the <a href="https://doc.rust-lang.org/core/task/wake/struct.Context.html"><code>Context</code></a> which was supplied to the current <a href="block-expr#async-context">async context</a> when the async context itself was polled. Because <code>await</code> expressions are only legal in an async context, there must be some task context available.</p>  <h2 id="approximate-desugaring">Approximate desugaring</h2> <p>Effectively, an await expression is roughly equivalent to the following non-normative desugaring:</p>  <pre data-language="rust">match operand.into_future() {
    mut pinned =&gt; loop {
        let mut pin = unsafe { Pin::new_unchecked(&amp;mut pinned) };
        match Pin::future::poll(Pin::borrow(&amp;mut pin), &amp;mut current_context) {
            Poll::Ready(r) =&gt; break r,
            Poll::Pending =&gt; yield Poll::Pending,
        }
    }
}</pre> <p>where the <code>yield</code> pseudo-code returns <code>Poll::Pending</code> and, when re-invoked, resumes execution from that point. The variable <code>current_context</code> refers to the context taken from the async environment.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/expressions/await-expr.html" class="_attribution-link">https://doc.rust-lang.org/reference/expressions/await-expr.html</a>
  </p>
</div>
