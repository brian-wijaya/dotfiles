<h1 id="error-code-e0793">Error code E0793</h1> <p>An unaligned reference to a field of a <a href="../reference/type-layout#the-alignment-modifiers">packed</a> <code>struct</code> or <code>union</code> was created.</p> <p>The <code>#[repr(packed)]</code> attribute removes padding between fields, which can cause fields to be stored at unaligned memory addresses. Creating references to such fields violates Rust's memory safety guarantees and can lead to undefined behavior in optimized code.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[repr(packed)]
pub struct Foo {
    field1: u64,
    field2: u8,
}

unsafe {
    let foo = Foo { field1: 0, field2: 0 };
    // Accessing the field directly is fine.
    let val = foo.field1;
    // A reference to a packed field causes a error.
    let val = &amp;foo.field1; // ERROR
    // An implicit `&amp;` is added in format strings, causing the same error.
    println!("{}", foo.field1); // ERROR
}
}</pre> <p>Creating a reference to an insufficiently aligned packed field is <a href="../reference/behavior-considered-undefined">undefined behavior</a> and therefore disallowed. Using an <code>unsafe</code> block does not change anything about this. Instead, the code should do a copy of the data in the packed field or use raw pointers and unaligned accesses.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[repr(packed)]
pub struct Foo {
    field1: u64,
    field2: u8,
}

unsafe {
    let foo = Foo { field1: 0, field2: 0 };

    // Instead of a reference, we can create a raw pointer...
    let ptr = std::ptr::addr_of!(foo.field1);
    // ... and then (crucially!) access it in an explicitly unaligned way.
    let val = unsafe { ptr.read_unaligned() };
    // This would *NOT* be correct:
    // let val = unsafe { *ptr }; // Undefined Behavior due to unaligned load!

    // For formatting, we can create a copy to avoid the direct reference.
    let copy = foo.field1;
    println!("{}", copy);

    // Creating a copy can be written in a single line with curly braces.
    // (This is equivalent to the two lines above.)
    println!("{}", { foo.field1 });

    // A reference to a field that will always be sufficiently aligned is safe:
    println!("{}", foo.field2);
}
}</pre> <h3 id="unions">Unions</h3> <p>Although creating a reference to a <code>union</code> field is <code>unsafe</code>, this error will still be triggered if the referenced field is not sufficiently aligned. Use <code>addr_of!</code> and raw pointers in the same way as for struct fields.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[repr(packed)]
pub union Foo {
    field1: u64,
    field2: u8,
}

unsafe {
    let foo = Foo { field1: 0 };
    // Accessing the field directly is fine.
    let val = foo.field1;

    // A reference to a packed union field causes an error.
    let val = &amp;foo.field1; // ERROR
}
}</pre> <h3 id="additional-information">Additional information</h3> <p>Note that this error is specifically about <em>references</em> to packed fields. Direct by-value access of those fields is fine, since then the compiler has enough information to generate the correct kind of access.</p> <p>See <a href="https://github.com/rust-lang/rust/issues/82523">issue #82523</a> for more information.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0793.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0793.html</a>
  </p>
</div>
