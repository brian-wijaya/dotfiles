<h1 class="main-heading">Module mem </h1>
<p>Basic functions for dealing with memory.</p> <p>This module contains functions for querying the size and alignment of types, initializing and manipulating memory.</p> <h3 id="macros" class="section-header">Macros</h3>
<dl class="item-table">
<dt><a class="macro" href="macro.offset_of" title="macro std::mem::offset_of">offset_<wbr>of</wbr></a></dt>
<dd>Expands to the offset in bytes of a field from the beginning of the given type.</dd>
</dl>
<h3 id="structs" class="section-header">Structs</h3>
<dl class="item-table">
<dt><a class="struct" href="struct.discriminant" title="struct std::mem::Discriminant">Discriminant</a></dt>
<dd>Opaque type representing the discriminant of an enum.</dd>
<dt><a class="struct" href="struct.manuallydrop" title="struct std::mem::ManuallyDrop">Manually<wbr>Drop</wbr></a></dt>
<dd>A wrapper to inhibit the compiler from automatically calling <code>T</code>’s destructor. This wrapper is 0-cost.</dd>
<dt>
<a class="struct" href="struct.assume" title="struct std::mem::Assume">Assume</a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>Configurable proof assumptions of <a href="trait.transmutefrom" title="trait std::mem::TransmuteFrom"><code>TransmuteFrom</code></a>.</dd>
<dt>
<a class="struct" href="struct.dropguard" title="struct std::mem::DropGuard">Drop<wbr>Guard</wbr></a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>Wrap a value and run a closure when dropped.</dd>
</dl>
<h3 id="traits" class="section-header">Traits</h3>
<dl class="item-table">
<dt>
<a class="trait" href="trait.transmutefrom" title="trait std::mem::TransmuteFrom">Transmute<wbr>From</wbr></a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>Marks that <code>Src</code> is transmutable into <code>Self</code>.</dd>
</dl>
<h3 id="functions" class="section-header">Functions</h3>
<dl class="item-table">
<dt><a class="fn" href="fn.align_of" title="fn std::mem::align_of">align_<wbr>of</wbr></a></dt>
<dd>Returns the <a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a>-required minimum alignment of a type in bytes.</dd>
<dt><a class="fn" href="fn.align_of_val" title="fn std::mem::align_of_val">align_<wbr>of_<wbr>val</wbr></wbr></a></dt>
<dd>Returns the <a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a>-required minimum alignment of the type of the value that <code>val</code> points to in bytes.</dd>
<dt><a class="fn" href="fn.discriminant" title="fn std::mem::discriminant">discriminant</a></dt>
<dd>Returns a value uniquely identifying the enum variant in <code>v</code>.</dd>
<dt><a class="fn" href="fn.drop" title="fn std::mem::drop">drop</a></dt>
<dd>Disposes of a value.</dd>
<dt><a class="fn" href="fn.forget" title="fn std::mem::forget">forget</a></dt>
<dd>Takes ownership and “forgets” about the value <strong>without running its destructor</strong>.</dd>
<dt>
<a class="fn" href="fn.min_align_of" title="fn std::mem::min_align_of">min_<wbr>align_<wbr>of</wbr></wbr></a><wbr><span class="stab deprecated" title="">Deprecated</span></wbr>
</dt>
<dd>Returns the <a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a>-required minimum alignment of a type in bytes.</dd>
<dt>
<a class="fn" href="fn.min_align_of_val" title="fn std::mem::min_align_of_val">min_<wbr>align_<wbr>of_<wbr>val</wbr></wbr></wbr></a><wbr><span class="stab deprecated" title="">Deprecated</span></wbr>
</dt>
<dd>Returns the <a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a>-required minimum alignment of the type of the value that <code>val</code> points to in bytes.</dd>
<dt><a class="fn" href="fn.needs_drop" title="fn std::mem::needs_drop">needs_<wbr>drop</wbr></a></dt>
<dd>Returns <code>true</code> if dropping values of type <code>T</code> matters.</dd>
<dt><a class="fn" href="fn.replace" title="fn std::mem::replace">replace</a></dt>
<dd>Moves <code>src</code> into the referenced <code>dest</code>, returning the previous <code>dest</code> value.</dd>
<dt><a class="fn" href="fn.size_of" title="fn std::mem::size_of">size_of</a></dt>
<dd>Returns the size of a type in bytes.</dd>
<dt><a class="fn" href="fn.size_of_val" title="fn std::mem::size_of_val">size_<wbr>of_<wbr>val</wbr></wbr></a></dt>
<dd>Returns the size of the pointed-to value in bytes.</dd>
<dt><a class="fn" href="fn.swap" title="fn std::mem::swap">swap</a></dt>
<dd>Swaps the values at two mutable locations, without deinitializing either one.</dd>
<dt><a class="fn" href="fn.take" title="fn std::mem::take">take</a></dt>
<dd>Replaces <code>dest</code> with the default value of <code>T</code>, returning the previous <code>dest</code> value.</dd>
<dt>
<a class="fn" href="fn.transmute" title="fn std::mem::transmute">transmute</a><sup title="unsafe function">⚠</sup>
</dt>
<dd>Reinterprets the bits of a value of one type as another type.</dd>
<dt>
<a class="fn" href="fn.transmute_copy" title="fn std::mem::transmute_copy">transmute_<wbr>copy</wbr></a><sup title="unsafe function">⚠</sup>
</dt>
<dd>Interprets <code>src</code> as having type <code>&amp;Dst</code>, and then reads <code>src</code> without moving the contained value.</dd>
<dt>
<a class="fn" href="fn.uninitialized" title="fn std::mem::uninitialized">uninitialized</a><sup title="unsafe function">⚠</sup><wbr><span class="stab deprecated" title="">Deprecated</span></wbr>
</dt>
<dd>Bypasses Rust’s normal memory-initialization checks by pretending to produce a value of type <code>T</code>, while doing nothing at all.</dd>
<dt>
<a class="fn" href="fn.zeroed" title="fn std::mem::zeroed">zeroed</a><sup title="unsafe function">⚠</sup>
</dt>
<dd>Returns the value of type <code>T</code> represented by the all-zero byte-pattern.</dd>
<dt>
<a class="fn" href="fn.align_of_val_raw" title="fn std::mem::align_of_val_raw">align_<wbr>of_<wbr>val_<wbr>raw</wbr></wbr></wbr></a><sup title="unsafe function">⚠</sup><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>Returns the <a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a>-required minimum alignment of the type of the value that <code>val</code> points to in bytes.</dd>
<dt>
<a class="fn" href="fn.copy" title="fn std::mem::copy">copy</a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>Bitwise-copies a value.</dd>
<dt>
<a class="fn" href="fn.forget_unsized" title="fn std::mem::forget_unsized">forget_<wbr>unsized</wbr></a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>Like <a href="fn.forget" title="fn std::mem::forget"><code>forget</code></a>, but also accepts unsized values.</dd>
<dt>
<a class="fn" href="fn.size_of_val_raw" title="fn std::mem::size_of_val_raw">size_<wbr>of_<wbr>val_<wbr>raw</wbr></wbr></wbr></a><sup title="unsafe function">⚠</sup><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>Returns the size of the pointed-to value in bytes.</dd>
<dt>
<a class="fn" href="fn.variant_count" title="fn std::mem::variant_count">variant_<wbr>count</wbr></a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>Returns the number of variants in the enum type <code>T</code>.</dd>
</dl>
<h3 id="unions" class="section-header">Unions</h3>
<dl class="item-table">
<dt><a class="union" href="union.maybeuninit" title="union std::mem::MaybeUninit">Maybe<wbr>Uninit</wbr></a></dt>
<dd>A wrapper type to construct uninitialized instances of <code>T</code>.</dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/mem/index.html" class="_attribution-link">https://doc.rust-lang.org/std/mem/index.html</a>
  </p>
</div>
