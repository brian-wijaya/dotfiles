<h1 id="error-code-e0034">Error code E0034</h1> <p>The compiler doesn't know what method to call because more than one method has the same prototype.</p> <p>Erroneous code example:</p> <pre data-language="rust">struct Test;

trait Trait1 {
    fn foo();
}

trait Trait2 {
    fn foo();
}

impl Trait1 for Test { fn foo() {} }
impl Trait2 for Test { fn foo() {} }

fn main() {
    Test::foo() // error, which foo() to call?
}</pre> <p>To avoid this error, you have to keep only one of them and remove the others. So let's take our example and fix it:</p> <pre data-language="rust">struct Test;

trait Trait1 {
    fn foo();
}

impl Trait1 for Test { fn foo() {} }

fn main() {
    Test::foo() // and now that's good!
}</pre> <p>However, a better solution would be using fully explicit naming of type and trait:</p> <pre data-language="rust">struct Test;

trait Trait1 {
    fn foo();
}

trait Trait2 {
    fn foo();
}

impl Trait1 for Test { fn foo() {} }
impl Trait2 for Test { fn foo() {} }

fn main() {
    &lt;Test as Trait1&gt;::foo()
}</pre> <p>One last example:</p> <pre data-language="rust">trait F {
    fn m(&amp;self);
}

trait G {
    fn m(&amp;self);
}

struct X;

impl F for X { fn m(&amp;self) { println!("I am F"); } }
impl G for X { fn m(&amp;self) { println!("I am G"); } }

fn main() {
    let f = X;

    F::m(&amp;f); // it displays "I am F"
    G::m(&amp;f); // it displays "I am G"
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0034.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0034.html</a>
  </p>
</div>
