 <h1 id="interior-mutability">Interior Mutability</h1>  <p>Sometimes a type needs to be mutated while having multiple aliases. In Rust this is achieved using a pattern called <em>interior mutability</em>.</p>  <p>A type has interior mutability if its internal state can be changed through a <a href="types/pointer#shared-references-">shared reference</a> to it.</p>  <p>This goes against the usual <a href="behavior-considered-undefined">requirement</a> that the value pointed to by a shared reference is not mutated.</p>  <p><a href="https://doc.rust-lang.org/core/cell/struct.UnsafeCell.html"><code>std::cell::UnsafeCell&lt;T&gt;</code></a> type is the only allowed way to disable this requirement. When <code>UnsafeCell&lt;T&gt;</code> is immutably aliased, it is still safe to mutate, or obtain a mutable reference to, the <code>T</code> it contains.</p>  <p>As with all other types, it is undefined behavior to have multiple <code>&amp;mut UnsafeCell&lt;T&gt;</code> aliases.</p>  <p>Other types with interior mutability can be created by using <code>UnsafeCell&lt;T&gt;</code> as a field. The standard library provides a variety of types that provide safe interior mutability APIs.</p>  <p>For example, <a href="https://doc.rust-lang.org/core/cell/struct.RefCell.html"><code>std::cell::RefCell&lt;T&gt;</code></a> uses run-time borrow checks to ensure the usual rules around multiple references.</p>  <p>The <a href="https://doc.rust-lang.org/core/sync/atomic/index.html"><code>std::sync::atomic</code></a> module contains types that wrap a value that is only accessed with atomic operations, allowing the value to be shared and mutated across threads.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/interior-mutability.html" class="_attribution-link">https://doc.rust-lang.org/reference/interior-mutability.html</a>
  </p>
</div>
