<h1 id="error-code-e0382">Error code E0382</h1> <p>A variable was used after its contents have been moved elsewhere.</p> <p>Erroneous code example:</p> <pre data-language="rust">struct MyStruct { s: u32 }

fn main() {
    let mut x = MyStruct{ s: 5u32 };
    let y = x;
    x.s = 6;
    println!("{}", x.s);
}</pre> <p>Since <code>MyStruct</code> is a type that is not marked <code>Copy</code>, the data gets moved out of <code>x</code> when we set <code>y</code>. This is fundamental to Rust's ownership system: outside of workarounds like <code>Rc</code>, a value cannot be owned by more than one variable.</p> <p>Sometimes we don't need to move the value. Using a reference, we can let another function borrow the value without changing its ownership. In the example below, we don't actually have to move our string to <code>calculate_length</code>, we can give it a reference to it with <code>&amp;</code> instead.</p> <pre data-language="rust">fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&amp;s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}</pre> <p>A mutable reference can be created with <code>&amp;mut</code>.</p> <p>Sometimes we don't want a reference, but a duplicate. All types marked <code>Clone</code> can be duplicated by calling <code>.clone()</code>. Subsequent changes to a clone do not affect the original variable.</p> <p>Most types in the standard library are marked <code>Clone</code>. The example below demonstrates using <code>clone()</code> on a string. <code>s1</code> is first set to "many", and then copied to <code>s2</code>. Then the first character of <code>s1</code> is removed, without affecting <code>s2</code>. "any many" is printed to the console.</p> <pre data-language="rust">fn main() {
    let mut s1 = String::from("many");
    let s2 = s1.clone();
    s1.remove(0);
    println!("{} {}", s1, s2);
}</pre> <p>If we control the definition of a type, we can implement <code>Clone</code> on it ourselves with <code>#[derive(Clone)]</code>.</p> <p>Some types have no ownership semantics at all and are trivial to duplicate. An example is <code>i32</code> and the other number types. We don't have to call <code>.clone()</code> to clone them, because they are marked <code>Copy</code> in addition to <code>Clone</code>. Implicit cloning is more convenient in this case. We can mark our own types <code>Copy</code> if all their members also are marked <code>Copy</code>.</p> <p>In the example below, we implement a <code>Point</code> type. Because it only stores two integers, we opt-out of ownership semantics with <code>Copy</code>. Then we can <code>let p2 = p1</code> without <code>p1</code> being moved.</p> <pre data-language="rust">#[derive(Copy, Clone)]
struct Point { x: i32, y: i32 }

fn main() {
    let mut p1 = Point{ x: -1, y: 2 };
    let p2 = p1;
    p1.x = 1;
    println!("p1: {}, {}", p1.x, p1.y);
    println!("p2: {}, {}", p2.x, p2.y);
}</pre> <p>Alternatively, if we don't control the struct's definition, or mutable shared ownership is truly required, we can use <code>Rc</code> and <code>RefCell</code>:</p> <pre data-language="rust">use std::cell::RefCell;
use std::rc::Rc;

struct MyStruct { s: u32 }

fn main() {
    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));
    let y = x.clone();
    x.borrow_mut().s = 6;
    println!("{}", x.borrow().s);
}</pre> <p>With this approach, x and y share ownership of the data via the <code>Rc</code> (reference count type). <code>RefCell</code> essentially performs runtime borrow checking: ensuring that at most one writer or multiple readers can access the data at any one time.</p> <p>If you wish to learn more about ownership in Rust, start with the <a href="../book/ch04-00-understanding-ownership">Understanding Ownership</a> chapter in the Book.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0382.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0382.html</a>
  </p>
</div>
