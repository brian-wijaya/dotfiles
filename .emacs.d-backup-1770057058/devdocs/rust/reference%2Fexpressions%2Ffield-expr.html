 <h1 id="field-access-expressions">Field access expressions</h1>  <div class="grammar-container">
<p><strong><sup>Syntax</sup></strong>
<br>
<span class="grammar-text grammar-production" id="grammar-FieldExpression"><a href="field-expr#railroad-FieldExpression">FieldExpression</a></span> â†’ <span class="grammar-text"><a href="../expressions#grammar-Expression">Expression</a></span> <code class="grammar-literal">.</code> <span class="grammar-text"><a href="../identifiers#grammar-IDENTIFIER">IDENTIFIER</a></span></p>

<details class="grammar-railroad grammar-hidden"><summary>Syntax diagram</summary> <div style="width: 318px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-FieldExpression">
<svg class="railroad" viewbox="0 0 318 74" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"> <rect class="railroad_canvas" height="100%" width="100%"></rect> <g class="verticalgrid"> <a class="link" xlink:href="field-expr#grammar-FieldExpression"> <text class="comment" x="67" y="25"> FieldExpression</text> </a> <g class="sequence"> <path d=" M 10 53 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5 m 10 0 h 5"></path> <g class="sequence"> <a class="link" xlink:href="../expressions#railroad-Expression"> <g class="nonterminal"> <rect height="22" width="100" x="35" y="42"></rect> <text x="85" y="58"> Expression</text> </g> </a> <g class="terminal"> <rect height="22" rx="10" ry="10" width="28" x="145" y="42"></rect> <text x="159" y="58"> .</text> </g> <a class="link" xlink:href="../identifiers#railroad-IDENTIFIER"> <g class="nonterminal"> <rect height="22" width="100" x="183" y="42"></rect> <text x="233" y="58"> IDENTIFIER</text> </g> </a> <path d=" M 135 53 h 10"></path> <path d=" M 173 53 h 10"></path> </g> <path d=" M 293 53 h 5 a 5 5 0 0 1 5 -5 a 5 5 0 0 1 5 5 a 5 5 0 0 1 -5 5 a 5 5 0 0 1 -5 -5"></path> <path d=" M 25 53 h 10"></path> <path d=" M 283 53 h 10"></path> </g> </g> </svg> </div> </details>
</div>   <p>A <em>field expression</em> is a <a href="../expressions#place-expressions-and-value-expressions">place expression</a> that evaluates to the location of a field of a <a href="../items/structs">struct</a> or <a href="../items/unions">union</a>.</p>  <p>When the operand is <a href="../expressions#mutability">mutable</a>, the field expression is also mutable.</p>  <p>The syntax for a field expression is an expression, called the <em>container operand</em>, then a <code>.</code>, and finally an <a href="../identifiers">identifier</a>.</p>  <p>Field expressions cannot be followed by a parenthetical comma-separated list of expressions, as that is instead parsed as a <a href="method-call-expr">method call expression</a>. That is, they cannot be the function operand of a <a href="call-expr">call expression</a>.</p> <div class="alert alert-note"> <blockquote> <p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p> <p>Wrap the field expression in a <a href="grouped-expr">parenthesized expression</a> to use it in a call expression.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct HoldsCallable&lt;F: Fn()&gt; { callable: F }
let holds_callable = HoldsCallable { callable: || () };

// Invalid: Parsed as calling the method "callable"
// holds_callable.callable();

// Valid
(holds_callable.callable)();
}</pre> </blockquote> </div> <p>Examples:</p>  <pre data-language="rust">mystruct.myfield;
foo().x;
(Struct {a: 10, b: 20}).a;
(mystruct.function_field)() // Call expression containing a field expression</pre>  <h2 id="automatic-dereferencing">Automatic dereferencing</h2> <p>If the type of the container operand implements <a href="../special-types-and-traits#deref-and-derefmut"><code>Deref</code></a> or <a href="../special-types-and-traits#deref-and-derefmut"><code>DerefMut</code></a> depending on whether the operand is <a href="../expressions#mutability">mutable</a>, it is <em>automatically dereferenced</em> as many times as necessary to make the field access possible. This process is also called <em>autoderef</em> for short.</p>  <h2 id="borrowing">Borrowing</h2> <p>The fields of a struct or a reference to a struct are treated as separate entities when borrowing. If the struct does not implement <a href="../special-types-and-traits#drop"><code>Drop</code></a> and is stored in a local variable, this also applies to moving out of each of its fields. This also does not apply if automatic dereferencing is done through user-defined types other than <a href="../special-types-and-traits#boxt"><code>Box</code></a>.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct A { f1: String, f2: String, f3: String }
let mut x: A;
x = A {
    f1: "f1".to_string(),
    f2: "f2".to_string(),
    f3: "f3".to_string()
};
let a: &amp;mut String = &amp;mut x.f1; // x.f1 borrowed mutably
let b: &amp;String = &amp;x.f2;         // x.f2 borrowed immutably
let c: &amp;String = &amp;x.f2;         // Can borrow again
let d: String = x.f3;           // Move out of x.f3
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/expressions/field-expr.html" class="_attribution-link">https://doc.rust-lang.org/reference/expressions/field-expr.html</a>
  </p>
</div>
