<h1 class="main-heading">Module range </h1>
<span class="item-info"><div class="stab unstable">
<span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>new_range_api</code> <a href="https://github.com/rust-lang/rust/issues/125687">#125687</a>)</span>
</div></span><h2 id="experimental-replacement-range-types">Experimental replacement range types</h2> <p>The types within this module are meant to replace the existing <code>Range</code>, <code>RangeInclusive</code>, and <code>RangeFrom</code> types in a future edition.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#![feature(new_range_api)]
use core::range::{Range, RangeFrom, RangeInclusive};

let arr = [0, 1, 2, 3, 4];
assert_eq!(arr[                      ..   ], [0, 1, 2, 3, 4]);
assert_eq!(arr[                      .. 3 ], [0, 1, 2      ]);
assert_eq!(arr[                      ..=3 ], [0, 1, 2, 3   ]);
assert_eq!(arr[     RangeFrom::from(1..  )], [   1, 2, 3, 4]);
assert_eq!(arr[         Range::from(1..3 )], [   1, 2      ]);
assert_eq!(arr[RangeInclusive::from(1..=3)], [   1, 2, 3   ]);</pre></div>
<h3 id="modules" class="section-header">Modules</h3>
<dl class="item-table">
<dt>
<a class="mod" href="legacy/index" title="mod std::range::legacy">legacy</a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>Legacy range types</dd>
</dl>
<h3 id="structs" class="section-header">Structs</h3>
<dl class="item-table">
<dt>
<a class="struct" href="struct.iterrange" title="struct std::range::IterRange">Iter<wbr>Range</wbr></a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>By-value <a href="struct.range" title="struct std::range::Range"><code>Range</code></a> iterator.</dd>
<dt>
<a class="struct" href="struct.iterrangefrom" title="struct std::range::IterRangeFrom">Iter<wbr>Range<wbr>From</wbr></wbr></a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>By-value <a href="struct.rangefrom" title="struct std::range::RangeFrom"><code>RangeFrom</code></a> iterator.</dd>
<dt>
<a class="struct" href="struct.iterrangeinclusive" title="struct std::range::IterRangeInclusive">Iter<wbr>Range<wbr>Inclusive</wbr></wbr></a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>By-value <a href="struct.rangeinclusive" title="struct std::range::RangeInclusive"><code>RangeInclusive</code></a> iterator.</dd>
<dt>
<a class="struct" href="struct.range" title="struct std::range::Range">Range</a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>A (half-open) range bounded inclusively below and exclusively above (<code>start..end</code> in a future edition).</dd>
<dt>
<a class="struct" href="struct.rangefrom" title="struct std::range::RangeFrom">Range<wbr>From</wbr></a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>A range only bounded inclusively below (<code>start..</code>).</dd>
<dt>
<a class="struct" href="struct.rangefull" title="struct std::range::RangeFull">Range<wbr>Full</wbr></a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>An unbounded range (<code>..</code>).</dd>
<dt>
<a class="struct" href="struct.rangeinclusive" title="struct std::range::RangeInclusive">Range<wbr>Inclusive</wbr></a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>A range bounded inclusively below and above (<code>start..=last</code>).</dd>
<dt>
<a class="struct" href="struct.rangeto" title="struct std::range::RangeTo">RangeTo</a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>A range only bounded exclusively above (<code>..end</code>).</dd>
<dt>
<a class="struct" href="struct.rangetoinclusive" title="struct std::range::RangeToInclusive">Range<wbr>ToInclusive</wbr></a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>A range only bounded inclusively above (<code>..=last</code>).</dd>
</dl>
<h3 id="enums" class="section-header">Enums</h3>
<dl class="item-table">
<dt>
<a class="enum" href="enum.bound" title="enum std::range::Bound">Bound</a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>An endpoint of a range of keys.</dd>
</dl>
<h3 id="traits" class="section-header">Traits</h3>
<dl class="item-table">
<dt>
<a class="trait" href="trait.intobounds" title="trait std::range::IntoBounds">Into<wbr>Bounds</wbr></a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>Used to convert a range into start and end bounds, consuming the range by value.</dd>
<dt>
<a class="trait" href="trait.onesidedrange" title="trait std::range::OneSidedRange">OneSided<wbr>Range</wbr></a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>
<code>OneSidedRange</code> is implemented for built-in range types that are unbounded on one side. For example, <code>a..</code>, <code>..b</code> and <code>..=c</code> implement <code>OneSidedRange</code>, but <code>..</code>, <code>d..e</code>, and <code>f..=g</code> do not.</dd>
<dt>
<a class="trait" href="trait.rangebounds" title="trait std::range::RangeBounds">Range<wbr>Bounds</wbr></a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>
<code>RangeBounds</code> is implemented by Rustâ€™s built-in range types, produced by range syntax like <code>..</code>, <code>a..</code>, <code>..b</code>, <code>..=c</code>, <code>d..e</code>, or <code>f..=g</code>.</dd>
<dt>
<a class="trait" href="trait.step" title="trait std::range::Step">Step</a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>Objects that have a notion of <em>successor</em> and <em>predecessor</em> operations.</dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/range/index.html" class="_attribution-link">https://doc.rust-lang.org/std/range/index.html</a>
  </p>
</div>
