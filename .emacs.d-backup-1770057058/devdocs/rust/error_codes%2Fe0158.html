<h1 id="error-code-e0158">Error code E0158</h1> <p>A generic parameter or <code>static</code> has been referenced in a pattern.</p> <p>Erroneous code example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
enum Foo {
    One,
    Two
}

trait Bar {
    const X: Foo;
}

fn test&lt;A: Bar&gt;(arg: Foo) {
    match arg {
        A::X =&gt; println!("A::X"), // error: E0158: constant pattern depends
                                  //        on a generic parameter
        Foo::Two =&gt; println!("Two")
    }
}
}</pre> <p>Generic parameters cannot be referenced in patterns because it is impossible for the compiler to prove exhaustiveness (that some pattern will always match). Take the above example, because Rust does type checking in the <em>generic</em> method, not the <em>monomorphized</em> specific instance. So because <code>Bar</code> could have theoretically arbitrary implementations, there's no way to always be sure that <code>A::X</code> is <code>Foo::One</code>. So this code must be rejected. Even if code can be proven exhaustive by a programmer, the compiler cannot currently prove this.</p> <p>The same holds true of <code>static</code>s.</p> <p>If you want to match against a <code>const</code> that depends on a generic parameter or a <code>static</code>, consider using a guard instead:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait Trait {
    const X: char;
}

static FOO: char = 'j';

fn test&lt;A: Trait, const Y: char&gt;(arg: char) {
    match arg {
        c if c == A::X =&gt; println!("A::X"),
        c if c == Y =&gt; println!("Y"),
        c if c == FOO =&gt; println!("FOO"),
        _ =&gt; ()
    }
}
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/error_codes/E0158.html" class="_attribution-link">https://doc.rust-lang.org/error_codes/E0158.html</a>
  </p>
</div>
