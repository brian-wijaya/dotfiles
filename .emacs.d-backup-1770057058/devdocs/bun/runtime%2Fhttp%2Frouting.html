<h1 id="header">Routing</h1>
<div data-page-title="Routing" data-page-href="/runtime/http/routing" id="content">
<span data-as="p">You can add routes to <code>Bun.serve()</code> by using the <code>routes</code> property (for static paths, parameters, and wildcards) or by handling unmatched requests with the <a href="#fetch"><code>fetch</code></a> method.</span> <span data-as="p"><code>Bun.serve()</code>’s router builds on top uWebSocket’s <a href="https://github.com/oven-sh/bun/blob/0d1a00fa0f7830f8ecd99c027fce8096c9d459b6/packages/bun-uws/src/HttpRouter.h#L57-L64" target="_blank" rel="noreferrer">tree-based approach</a> to add <a href="https://github.com/oven-sh/bun/blob/main/src/bun.js/bindings/decodeURIComponentSIMD.cpp#L21-L271" target="_blank" rel="noreferrer">SIMD-accelerated route parameter decoding</a> and <a href="https://github.com/oven-sh/bun/blob/main/src/bun.js/bindings/ServerRouteList.cpp#L100-L101" target="_blank" rel="noreferrer">JavaScriptCore structure caching</a> to push the performance limits of what modern hardware allows.</span> <h2 id="basic-setup"><span>Basic Setup</span></h2> <pre numberoflines="10" language="typescript" data-language="typescript">Bun.serve({
  routes: {
    "/": () =&gt; new Response("Home"),
    "/api": () =&gt; Response.json({ success: true }),
    "/users": async () =&gt; Response.json({ users: [] }),
  },
  fetch() {
    return new Response("Unmatched route");
  },
});
</pre> <span data-as="p">Routes in <code>Bun.serve()</code> receive a <code>BunRequest</code> (which extends <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request" target="_blank" rel="noreferrer"><code>Request</code></a>) and return a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response" target="_blank" rel="noreferrer"><code>Response</code></a> or <code>Promise&lt;Response&gt;</code>. This makes it easier to use the same code for both sending &amp; receiving HTTP requests.</span> <pre numberoflines="5" language="typescript" data-language="typescript">// Simplified for brevity
interface BunRequest&lt;T extends string&gt; extends Request {
  params: Record&lt;T, string&gt;;
  readonly cookies: CookieMap;
}
</pre> <h2 id="asynchronous-routes"><span>Asynchronous Routes</span></h2> <h3 id="async/await"><span>Async/await</span></h3> <span data-as="p">You can use async/await in route handlers to return a <code>Promise&lt;Response&gt;</code>.</span> <pre numberoflines="11" language="typescript" data-language="typescript">import { sql, serve } from "bun";

serve({
  port: 3001,
  routes: {
    "/api/version": async () =&gt; {
      const [version] = await sql`SELECT version()`;
      return Response.json(version);
    },
  },
});
</pre> <h3 id="promise"><span>Promise</span></h3> <span data-as="p">You can also return a <code>Promise&lt;Response&gt;</code> from a route handler.</span> <pre numberoflines="14" language="typescript" data-language="typescript">import { sql, serve } from "bun";

serve({
  routes: {
    "/api/version": () =&gt; {
      return new Promise(resolve =&gt; {
        setTimeout(async () =&gt; {
          const [version] = await sql`SELECT version()`;
          resolve(Response.json(version));
        }, 100);
      });
    },
  },
});
</pre> <hr> <h2 id="route-precedence"><span>Route precedence</span></h2> <span data-as="p">Routes are matched in order of specificity:</span> <ol> <li>Exact routes (<code>/users/all</code>)</li> <li>Parameter routes (<code>/users/:id</code>)</li> <li>Wildcard routes (<code>/users/*</code>)</li> <li>Global catch-all (<code>/*</code>)</li> </ol> <pre numberoflines="9" language="typescript" data-language="typescript">Bun.serve({
  routes: {
    // Most specific first
    "/api/users/me": () =&gt; new Response("Current user"),
    "/api/users/:id": req =&gt; new Response(`User ${req.params.id}`),
    "/api/*": () =&gt; new Response("API catch-all"),
    "/*": () =&gt; new Response("Global catch-all"),
  },
});
</pre> <hr> <h2 id="type-safe-route-parameters"><span>Type-safe route parameters</span></h2> <span data-as="p">TypeScript parses route parameters when passed as a string literal, so that your editor will show autocomplete when accessing <code>request.params</code>.</span> <pre numberoflines="19" language="typescript" data-language="typescript">import type { BunRequest } from "bun";

Bun.serve({
  routes: {
    // TypeScript knows the shape of params when passed as a string literal
    "/orgs/:orgId/repos/:repoId": req =&gt; {
      const { orgId, repoId } = req.params;
      return Response.json({ orgId, repoId });
    },

    "/orgs/:orgId/repos/:repoId/settings": (
      // optional: you can explicitly pass a type to BunRequest:
      req: BunRequest&lt;"/orgs/:orgId/repos/:repoId/settings"&gt;,
    ) =&gt; {
      const { orgId, repoId } = req.params;
      return Response.json({ orgId, repoId });
    },
  },
});
</pre> <span data-as="p">Percent-encoded route parameter values are automatically decoded. Unicode characters are supported. Invalid unicode is replaced with the unicode replacement character <code>&amp;0xFFFD;</code>.</span> <h3 id="static-responses"><span>Static responses</span></h3> <span data-as="p">Routes can also be <code>Response</code> objects (without the handler function). Bun.serve() optimizes it for zero-allocation dispatch - perfect for health checks, redirects, and fixed content:</span> <pre numberoflines="21" language="typescript" data-language="typescript">Bun.serve({
  routes: {
    // Health checks
    "/health": new Response("OK"),
    "/ready": new Response("Ready", {
      headers: {
        // Pass custom headers
        "X-Ready": "1",
      },
    }),

    // Redirects
    "/blog": Response.redirect("https://bun.com/blog"),

    // API responses
    "/api/config": Response.json({
      version: "1.0.0",
      env: "production",
    }),
  },
});
</pre> <span data-as="p">Static responses do not allocate additional memory after initialization. You can generally expect at least a 15% performance improvement over manually returning a <code>Response</code> object.</span> <span data-as="p">Static route responses are cached for the lifetime of the server object. To reload static routes, call <code>server.reload(options)</code>.</span> <h3 id="file-responses-vs-static-responses"><span>File Responses vs Static Responses</span></h3> <span data-as="p">When serving files in routes, there are two distinct behaviors depending on whether you buffer the file content or serve it directly:</span> <pre numberoflines="9" language="typescript" data-language="typescript">Bun.serve({
  routes: {
    // Static route - content is buffered in memory at startup
    "/logo.png": new Response(await Bun.file("./logo.png").bytes()),

    // File route - content is read from filesystem on each request
    "/download.zip": new Response(Bun.file("./download.zip")),
  },
});
</pre> <span data-as="p"><strong>Static routes</strong> (<code>new Response(await file.bytes())</code>) buffer content in memory at startup:</span> <ul> <li>
<strong>Zero filesystem I/O</strong> during requests - content served entirely from memory</li> <li>
<strong>ETag support</strong> - Automatically generates and validates ETags for caching</li> <li>
<strong>If-None-Match</strong> - Returns <code>304 Not Modified</code> when client ETag matches</li> <li>
<strong>No 404 handling</strong> - Missing files cause startup errors, not runtime 404s</li> <li>
<strong>Memory usage</strong> - Full file content stored in RAM</li> <li>
<strong>Best for</strong>: Small static assets, API responses, frequently accessed files</li> </ul> <span data-as="p"><strong>File routes</strong> (<code>new Response(Bun.file(path))</code>) read from filesystem per request:</span> <ul> <li>
<strong>Filesystem reads</strong> on each request - checks file existence and reads content</li> <li>
<strong>Built-in 404 handling</strong> - Returns <code>404 Not Found</code> if file doesn’t exist or becomes inaccessible</li> <li>
<strong>Last-Modified support</strong> - Uses file modification time for <code>If-Modified-Since</code> headers</li> <li>
<strong>If-Modified-Since</strong> - Returns <code>304 Not Modified</code> when file hasn’t changed since client’s cached version</li> <li>
<strong>Range request support</strong> - Automatically handles partial content requests with <code>Content-Range</code> headers</li> <li>
<strong>Streaming transfers</strong> - Uses buffered reader with backpressure handling for efficient memory usage</li> <li>
<strong>Memory efficient</strong> - Only buffers small chunks during transfer, not entire file</li> <li>
<strong>Best for</strong>: Large files, dynamic content, user uploads, files that change frequently</li> </ul> <hr> <h2 id="streaming-files"><span>Streaming files</span></h2> <span data-as="p">To stream a file, return a <code>Response</code> object with a <code>BunFile</code> object as the body.</span> <pre numberoflines="5" language="typescript" data-language="typescript">Bun.serve({
  fetch(req) {
    return new Response(Bun.file("./hello.txt"));
  },
});
</pre> <div data-callout-type="info">

<div data-component-part="callout-content"><span data-as="p">⚡️ <strong>Speed</strong> — Bun automatically uses the <a href="https://man7.org/linux/man-pages/man2/sendfile.2.html" target="_blank" rel="noreferrer"><code>sendfile(2)</code></a> system call when possible, enabling zero-copy file transfers in the kernel—the fastest way to send files.</span></div>
</div> <span data-as="p">You can send part of a file using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob/slice" target="_blank" rel="noreferrer"><code>slice(start, end)</code></a> method on the <code>Bun.file</code> object. This automatically sets the <code>Content-Range</code> and <code>Content-Length</code> headers on the <code>Response</code> object.</span> <pre numberoflines="15" language="typescript" data-language="typescript">Bun.serve({
  fetch(req) {
    // parse `Range` header
    const [start = 0, end = Infinity] = req.headers
      .get("Range") // Range: bytes=0-100
      .split("=") // ["Range: bytes", "0-100"]
      .at(-1) // "0-100"
      .split("-") // ["0", "100"]
      .map(Number); // [0, 100]

    // return a slice of the file
    const bigFile = Bun.file("./big-video.mp4");
    return new Response(bigFile.slice(start, end));
  },
});
</pre> <hr> <h2 id="fetch-request-handler"><span><code>fetch</code> request handler</span></h2> <span data-as="p">The <code>fetch</code> handler handles incoming requests that weren’t matched by any route. It receives a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request" target="_blank" rel="noreferrer"><code>Request</code></a> object and returns a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response" target="_blank" rel="noreferrer"><code>Response</code></a> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noreferrer"><code>Promise&lt;Response&gt;</code></a>.</span> <pre numberoflines="8" language="typescript" data-language="typescript">Bun.serve({
  fetch(req) {
    const url = new URL(req.url);
    if (url.pathname === "/") return new Response("Home page!");
    if (url.pathname === "/blog") return new Response("Blog!");
    return new Response("404!");
  },
});
</pre> <span data-as="p">The <code>fetch</code> handler supports async/await:</span> <pre numberoflines="10" language="typescript" data-language="typescript">import { sleep, serve } from "bun";

serve({
  async fetch(req) {
    const start = performance.now();
    await sleep(10);
    const end = performance.now();
    return new Response(`Slept for ${end - start}ms`);
  },
});
</pre> <span data-as="p">Promise-based responses are also supported:</span> <pre numberoflines="6" language="typescript" data-language="typescript">Bun.serve({
  fetch(req) {
    // Forward the request to another server.
    return fetch("https://example.com");
  },
});
</pre> <span data-as="p">You can also access the <code>Server</code> object from the <code>fetch</code> handler. It’s the second argument passed to the <code>fetch</code> function.</span> <pre numberoflines="7" language="typescript" data-language="typescript">// `server` is passed in as the second argument to `fetch`.
const server = Bun.serve({
  fetch(req, server) {
    const ip = server.requestIP(req);
    return new Response(`Your IP is ${ip.address}`);
  },
});
</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/http/routing" class="_attribution-link">https://bun.com/docs/runtime/http/routing</a>
  </p>
</div>
