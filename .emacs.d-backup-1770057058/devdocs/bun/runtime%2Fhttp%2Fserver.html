<h1 id="header">Server</h1>
<div data-page-title="Server" data-page-href="/runtime/http/server" id="content">
<h2 id="basic-setup"><span>Basic Setup</span></h2> <pre numberoflines="38" language="typescript" data-language="typescript">const server = Bun.serve({
  // `routes` requires Bun v1.2.3+
  routes: {
    // Static routes
    "/api/status": new Response("OK"),

    // Dynamic routes
    "/users/:id": req =&gt; {
      return new Response(`Hello User ${req.params.id}!`);
    },

    // Per-HTTP method handlers
    "/api/posts": {
      GET: () =&gt; new Response("List posts"),
      POST: async req =&gt; {
        const body = await req.json();
        return Response.json({ created: true, ...body });
      },
    },

    // Wildcard route for all routes that start with "/api/" and aren't otherwise matched
    "/api/*": Response.json({ message: "Not found" }, { status: 404 }),

    // Redirect from /blog/hello to /blog/hello/world
    "/blog/hello": Response.redirect("/blog/hello/world"),

    // Serve a file by lazily loading it into memory
    "/favicon.ico": Bun.file("./favicon.ico"),
  },

  // (optional) fallback for unmatched routes:
  // Required if Bun's version &lt; 1.2.3
  fetch(req) {
    return new Response("Not Found", { status: 404 });
  },
});

console.log(`Server running at ${server.url}`);
</pre> <hr> <h2 id="html-imports"><span>HTML imports</span></h2> <span data-as="p">Bun supports importing HTML files directly into your server code, enabling full-stack applications with both server-side and client-side code. HTML imports work in two modes:</span> <span data-as="p"><strong>Development (<code>bun --hot</code>):</strong> Assets are bundled on-demand at runtime, enabling hot module replacement (HMR) for a fast, iterative development experience. When you change your frontend code, the browser automatically updates without a full page reload.</span> <span data-as="p"><strong>Production (<code>bun build</code>):</strong> When building with <code>bun build --target=bun</code>, the <code>import index from "./index.html"</code> statement resolves to a pre-built manifest object containing all bundled client assets. <code>Bun.serve</code> consumes this manifest to serve optimized assets with zero runtime bundling overhead. This is ideal for deploying to production.</span> <pre numberoflines="7" language="typescript" data-language="typescript">import myReactSinglePageApp from "./index.html";

Bun.serve({
  routes: {
    "/": myReactSinglePageApp,
  },
});
</pre> <span data-as="p">HTML imports don’t just serve HTML — it’s a full-featured frontend bundler, transpiler, and toolkit built using Bun’s <a href="../../bundler">bundler</a>, JavaScript transpiler and CSS parser. You can use this to build full-featured frontends with React, TypeScript, Tailwind CSS, and more.</span> <span data-as="p">For a complete guide on building full-stack applications with HTML imports, including detailed examples and best practices, see <a href="../../bundler/fullstack">/docs/bundler/fullstack</a>.</span> <hr> <h2 id="configuration"><span>Configuration</span></h2> <h3 id="changing-the-port-and-hostname"><span>Changing the <code>port</code> and <code>hostname</code></span></h3> <span data-as="p">To configure which port and hostname the server will listen on, set <code>port</code> and <code>hostname</code> in the options object.</span> <pre numberoflines="7" language="typescript" data-language="typescript">Bun.serve({
  port: 8080, // defaults to $BUN_PORT, $PORT, $NODE_PORT otherwise 3000
  hostname: "mydomain.com", // defaults to "0.0.0.0"
  fetch(req) {
    return new Response("404!");
  },
});
</pre> <span data-as="p">To randomly select an available port, set <code>port</code> to <code>0</code>.</span> <pre numberoflines="9" language="typescript" data-language="typescript">const server = Bun.serve({
  port: 0, // random port
  fetch(req) {
    return new Response("404!");
  },
});

// server.port is the randomly selected port
console.log(server.port);
</pre> <span data-as="p">You can view the chosen port by accessing the <code>port</code> property on the server object, or by accessing the <code>url</code> property.</span> <pre numberoflines="2" language="typescript" data-language="typescript">console.log(server.port); // 3000
console.log(server.url); // http://localhost:3000
</pre> <h3 id="configuring-a-default-port"><span>Configuring a default port</span></h3> <span data-as="p">Bun supports several options and environment variables to configure the default port. The default port is used when the <code>port</code> option is not set.</span> <ul> <li>
<code>--port</code> CLI flag</li> </ul> <pre numberoflines="1" language="shellscript" data-language="typescript">bun --port=4002 server.ts
</pre> <ul> <li>
<code>BUN_PORT</code> environment variable</li> </ul> <pre numberoflines="1" language="shellscript" data-language="typescript">BUN_PORT=4002 bun server.ts
</pre> <ul> <li>
<code>PORT</code> environment variable</li> </ul> <pre numberoflines="1" language="shellscript" data-language="typescript">PORT=4002 bun server.ts
</pre> <ul> <li>
<code>NODE_PORT</code> environment variable</li> </ul> <pre numberoflines="1" language="shellscript" data-language="typescript">NODE_PORT=4002 bun server.ts
</pre> <hr> <h2 id="unix-domain-sockets"><span>Unix domain sockets</span></h2> <span data-as="p">To listen on a <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noreferrer">unix domain socket</a>, pass the <code>unix</code> option with the path to the socket.</span> <pre numberoflines="6" language="typescript" data-language="typescript">Bun.serve({
  unix: "/tmp/my-socket.sock", // path to socket
  fetch(req) {
    return new Response(`404!`);
  },
});
</pre> <h3 id="abstract-namespace-sockets"><span>Abstract namespace sockets</span></h3> <span data-as="p">Bun supports Linux abstract namespace sockets. To use an abstract namespace socket, prefix the <code>unix</code> path with a null byte.</span> <pre numberoflines="6" language="typescript" data-language="typescript">Bun.serve({
  unix: "\0my-abstract-socket", // abstract namespace socket
  fetch(req) {
    return new Response(`404!`);
  },
});
</pre> <span data-as="p">Unlike unix domain sockets, abstract namespace sockets are not bound to the filesystem and are automatically removed when the last reference to the socket is closed.</span> <hr> <h2 id="idletimeout"><span>idleTimeout</span></h2> <span data-as="p">To configure the idle timeout, set the <code>idleTimeout</code> field in Bun.serve.</span> <pre numberoflines="8" language="typescript" data-language="typescript">Bun.serve({
  // 10 seconds:
  idleTimeout: 10,

  fetch(req) {
    return new Response("Bun!");
  },
});
</pre> <span data-as="p">This is the maximum amount of time a connection is allowed to be idle before the server closes it. A connection is idling if there is no data sent or received.</span> <hr> <h2 id="export-default-syntax"><span>export default syntax</span></h2> <span data-as="p">Thus far, the examples on this page have used the explicit <code>Bun.serve</code> API. Bun also supports an alternate syntax.</span> <pre numberoflines="7" language="typescript" data-language="typescript">import type { Serve } from "bun";

export default {
  fetch(req) {
    return new Response("Bun!");
  },
} satisfies Serve.Options&lt;undefined&gt;;
</pre> <span data-as="p">The type parameter <code>&lt;undefined&gt;</code> represents WebSocket data — if you add a <code>websocket</code> handler with custom data attached via <code>server.upgrade(req, { data: ... })</code>, replace <code>undefined</code> with your data type.</span> <span data-as="p">Instead of passing the server options into <code>Bun.serve</code>, <code>export default</code> it. This file can be executed as-is; when Bun sees a file with a <code>default</code> export containing a <code>fetch</code> handler, it passes it into <code>Bun.serve</code> under the hood.</span> <hr> <h2 id="hot-route-reloading"><span>Hot Route Reloading</span></h2> <span data-as="p">Update routes without server restarts using <code>server.reload()</code>:</span> <pre numberoflines="12" language="typescript" data-language="typescript">const server = Bun.serve({
  routes: {
    "/api/version": () =&gt; Response.json({ version: "1.0.0" }),
  },
});

// Deploy new routes without downtime
server.reload({
  routes: {
    "/api/version": () =&gt; Response.json({ version: "2.0.0" }),
  },
});
</pre> <hr> <h2 id="server-lifecycle-methods"><span>Server Lifecycle Methods</span></h2> <h3 id="server-stop"><span><code>server.stop()</code></span></h3> <span data-as="p">To stop the server from accepting new connections:</span> <pre numberoflines="11" language="typescript" data-language="typescript">const server = Bun.serve({
  fetch(req) {
    return new Response("Hello!");
  },
});

// Gracefully stop the server (waits for in-flight requests)
await server.stop();

// Force stop and close all active connections
await server.stop(true);
</pre> <span data-as="p">By default, <code>stop()</code> allows in-flight requests and WebSocket connections to complete. Pass <code>true</code> to immediately terminate all connections.</span> <h3 id="server-ref-and-server-unref"><span><code>server.ref()</code> and <code>server.unref()</code></span></h3> <span data-as="p">Control whether the server keeps the Bun process alive:</span> <pre numberoflines="5" language="typescript" data-language="typescript">// Don't keep process alive if server is the only thing running
server.unref();

// Restore default behavior - keep process alive
server.ref();
</pre> <h3 id="server-reload"><span><code>server.reload()</code></span></h3> <span data-as="p">Update the server’s handlers without restarting:</span> <pre numberoflines="18" language="typescript" data-language="typescript">const server = Bun.serve({
  routes: {
    "/api/version": Response.json({ version: "v1" }),
  },
  fetch(req) {
    return new Response("v1");
  },
});

// Update to new handler
server.reload({
  routes: {
    "/api/version": Response.json({ version: "v2" }),
  },
  fetch(req) {
    return new Response("v2");
  },
});
</pre> <span data-as="p">This is useful for development and hot reloading. Only <code>fetch</code>, <code>error</code>, and <code>routes</code> can be updated.</span> <hr> <h2 id="per-request-controls"><span>Per-Request Controls</span></h2> <h3 id="server-timeout-request,-seconds"><span><code>server.timeout(Request, seconds)</code></span></h3> <span data-as="p">Set a custom idle timeout for individual requests:</span> <pre numberoflines="11" language="typescript" data-language="typescript">const server = Bun.serve({
  async fetch(req, server) {
    // Set 60 second timeout for this request
    server.timeout(req, 60);

    // If they take longer than 60 seconds to send the body, the request will be aborted
    await req.text();

    return new Response("Done!");
  },
});
</pre> <span data-as="p">Pass <code>0</code> to disable the timeout for a request.</span> <h3 id="server-requestip-request"><span><code>server.requestIP(Request)</code></span></h3> <span data-as="p">Get client IP and port information:</span> <pre numberoflines="9" language="typescript" data-language="typescript">const server = Bun.serve({
  fetch(req, server) {
    const address = server.requestIP(req);
    if (address) {
      return new Response(`Client IP: ${address.address}, Port: ${address.port}`);
    }
    return new Response("Unknown client");
  },
});
</pre> <span data-as="p">Returns <code>null</code> for closed requests or Unix domain sockets.</span> <hr> <h2 id="server-metrics"><span>Server Metrics</span></h2> <h3 id="server-pendingrequests-and-server-pendingwebsockets"><span><code>server.pendingRequests</code> and <code>server.pendingWebSockets</code></span></h3> <span data-as="p">Monitor server activity with built-in counters:</span> <pre numberoflines="7" language="typescript" data-language="typescript">const server = Bun.serve({
  fetch(req, server) {
    return new Response(
      `Active requests: ${server.pendingRequests}\n` + `Active WebSockets: ${server.pendingWebSockets}`,
    );
  },
});
</pre> <h3 id="server-subscribercount-topic"><span><code>server.subscriberCount(topic)</code></span></h3> <span data-as="p">Get count of subscribers for a WebSocket topic:</span> <pre numberoflines="11" language="typescript" data-language="typescript">const server = Bun.serve({
  fetch(req, server) {
    const chatUsers = server.subscriberCount("chat");
    return new Response(`${chatUsers} users in chat`);
  },
  websocket: {
    message(ws) {
      ws.subscribe("chat");
    },
  },
});
</pre> <hr> <h2 id="benchmarks"><span>Benchmarks</span></h2> <span data-as="p">Below are Bun and Node.js implementations of a simple HTTP server that responds <code>Bun!</code> to each incoming <code>Request</code>.</span> <pre numberoflines="6" language="typescript" data-language="typescript">Bun.serve({
  fetch(req: Request) {
    return new Response("Bun!");
  },
  port: 3000,
});
</pre> <pre numberoflines="3" language="typescript" data-language="typescript">require("http")
  .createServer((req, res) =&gt; res.end("Bun!"))
  .listen(8080);
</pre> <span data-as="p">The <code>Bun.serve</code> server can handle roughly 2.5x more requests per second than Node.js on Linux.</span> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Runtime</th>
<th>Requests per second</th>
</tr></thead>
<tbody>
<tr>
<td>Node 16</td>
<td data-numeric="true">~64,000</td>
</tr>
<tr>
<td>Bun</td>
<td data-numeric="true">~160,000</td>
</tr>
</tbody>
</table></div></div>  <hr> <h2 id="practical-example:-rest-api"><span>Practical example: REST API</span></h2> <span data-as="p">Here’s a basic database-backed REST API using Bun’s router with zero dependencies:</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">server.tstypes.tsimport type { Post } from "./types.ts";
import { Database } from "bun:sqlite";

const db = new Database("posts.db");
db.exec(`
  CREATE TABLE IF NOT EXISTS posts (
    id TEXT PRIMARY KEY,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    created_at TEXT NOT NULL
  )
`);

Bun.serve({
  routes: {
    // List posts
    "/api/posts": {
      GET: () =&gt; {
        const posts = db.query("SELECT * FROM posts").all();
        return Response.json(posts);
      },

      // Create post
      POST: async req =&gt; {
        const post: Omit&lt;Post, "id" | "created_at"&gt; = await req.json();
        const id = crypto.randomUUID();

        db.query(
          `INSERT INTO posts (id, title, content, created_at)
           VALUES (?, ?, ?, ?)`,
        ).run(id, post.title, post.content, new Date().toISOString());

        return Response.json({ id, ...post }, { status: 201 });
      },
    },

    // Get post by ID
    "/api/posts/:id": req =&gt; {
      const post = db.query("SELECT * FROM posts WHERE id = ?").get(req.params.id);

      if (!post) {
        return new Response("Not Found", { status: 404 });
      }

      return Response.json(post);
    },
  },

  error(error) {
    console.error(error);
    return new Response("Internal Server Error", { status: 500 });
  },
});
See all 53 lines</pre> <hr> <h2 id="reference"><span>Reference</span></h2> <pre numberoflines="162" language="typescript" data-language="typescript">interface Server extends Disposable {
  /**
   * Stop the server from accepting new connections.
   * @param closeActiveConnections If true, immediately terminates all connections
   * @returns Promise that resolves when the server has stopped
   */
  stop(closeActiveConnections?: boolean): Promise&lt;void&gt;;

  /**
   * Update handlers without restarting the server.
   * Only fetch and error handlers can be updated.
   */
  reload(options: Serve): void;

  /**
   * Make a request to the running server.
   * Useful for testing or internal routing.
   */
  fetch(request: Request | string): Response | Promise&lt;Response&gt;;

  /**
   * Upgrade an HTTP request to a WebSocket connection.
   * @returns true if upgrade successful, false if failed
   */
  upgrade&lt;T = undefined&gt;(
    request: Request,
    options?: {
      headers?: Bun.HeadersInit;
      data?: T;
    },
  ): boolean;

  /**
   * Publish a message to all WebSocket clients subscribed to a topic.
   * @returns Bytes sent, 0 if dropped, -1 if backpressure applied
   */
  publish(
    topic: string,
    data: string | ArrayBufferView | ArrayBuffer | SharedArrayBuffer,
    compress?: boolean,
  ): ServerWebSocketSendStatus;

  /**
   * Get count of WebSocket clients subscribed to a topic.
   */
  subscriberCount(topic: string): number;

  /**
   * Get client IP address and port.
   * @returns null for closed requests or Unix sockets
   */
  requestIP(request: Request): SocketAddress | null;

  /**
   * Set custom idle timeout for a request.
   * @param seconds Timeout in seconds, 0 to disable
   */
  timeout(request: Request, seconds: number): void;

  /**
   * Keep process alive while server is running.
   */
  ref(): void;

  /**
   * Allow process to exit if server is only thing running.
   */
  unref(): void;

  /** Number of in-flight HTTP requests */
  readonly pendingRequests: number;

  /** Number of active WebSocket connections */
  readonly pendingWebSockets: number;

  /** Server URL including protocol, hostname and port */
  readonly url: URL;

  /** Port server is listening on */
  readonly port: number;

  /** Hostname server is bound to */
  readonly hostname: string;

  /** Whether server is in development mode */
  readonly development: boolean;

  /** Server instance identifier */
  readonly id: string;
}

interface WebSocketHandler&lt;T = undefined&gt; {
  /** Maximum WebSocket message size in bytes */
  maxPayloadLength?: number;

  /** Bytes of queued messages before applying backpressure */
  backpressureLimit?: number;

  /** Whether to close connection when backpressure limit hit */
  closeOnBackpressureLimit?: boolean;

  /** Called when backpressure is relieved */
  drain?(ws: ServerWebSocket&lt;T&gt;): void | Promise&lt;void&gt;;

  /** Seconds before idle timeout */
  idleTimeout?: number;

  /** Enable per-message deflate compression */
  perMessageDeflate?:
    | boolean
    | {
        compress?: WebSocketCompressor | boolean;
        decompress?: WebSocketCompressor | boolean;
      };

  /** Send ping frames to keep connection alive */
  sendPings?: boolean;

  /** Whether server receives its own published messages */
  publishToSelf?: boolean;

  /** Called when connection opened */
  open?(ws: ServerWebSocket&lt;T&gt;): void | Promise&lt;void&gt;;

  /** Called when message received */
  message(ws: ServerWebSocket&lt;T&gt;, message: string | Buffer): void | Promise&lt;void&gt;;

  /** Called when connection closed */
  close?(ws: ServerWebSocket&lt;T&gt;, code: number, reason: string): void | Promise&lt;void&gt;;

  /** Called when ping frame received */
  ping?(ws: ServerWebSocket&lt;T&gt;, data: Buffer): void | Promise&lt;void&gt;;

  /** Called when pong frame received */
  pong?(ws: ServerWebSocket&lt;T&gt;, data: Buffer): void | Promise&lt;void&gt;;
}

interface TLSOptions {
  /** Certificate authority chain */
  ca?: string | Buffer | BunFile | Array&lt;string | Buffer | BunFile&gt;;

  /** Server certificate */
  cert?: string | Buffer | BunFile | Array&lt;string | Buffer | BunFile&gt;;

  /** Path to DH parameters file */
  dhParamsFile?: string;

  /** Private key */
  key?: string | Buffer | BunFile | Array&lt;string | Buffer | BunFile&gt;;

  /** Reduce TLS memory usage */
  lowMemoryMode?: boolean;

  /** Private key passphrase */
  passphrase?: string;

  /** OpenSSL options flags */
  secureOptions?: number;

  /** Server name for SNI */
  serverName?: string;
}
See all 162 lines</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/http/server" class="_attribution-link">https://bun.com/docs/runtime/http/server</a>
  </p>
</div>
