<h1 id="header">Writing tests</h1>
<div data-page-title="Writing tests" data-page-href="/test/writing-tests" id="content">
<span data-as="p">Define tests with a Jest-like API imported from the built-in <code>bun:test</code> module. Long term, Bun aims for complete Jest compatibility; at the moment, a limited set of expect matchers are supported.</span> <h2 id="basic-usage"><span>Basic Usage</span></h2> <span data-as="p">To define a simple test:</span> <pre numberoflines="5" language="typescript" data-language="typescript">import { expect, test } from "bun:test";

test("2 + 2", () =&gt; {
  expect(2 + 2).toBe(4);
});
</pre> <h3 id="grouping-tests"><span>Grouping Tests</span></h3> <span data-as="p">Tests can be grouped into suites with <code>describe</code>.</span> <pre numberoflines="11" language="typescript" data-language="typescript">import { expect, test, describe } from "bun:test";

describe("arithmetic", () =&gt; {
  test("2 + 2", () =&gt; {
    expect(2 + 2).toBe(4);
  });

  test("2 * 2", () =&gt; {
    expect(2 * 2).toBe(4);
  });
});
</pre> <h3 id="async-tests"><span>Async Tests</span></h3> <span data-as="p">Tests can be async.</span> <pre numberoflines="6" language="typescript" data-language="typescript">import { expect, test } from "bun:test";

test("2 * 2", async () =&gt; {
  const result = await Promise.resolve(2 * 2);
  expect(result).toEqual(4);
});
</pre> <span data-as="p">Alternatively, use the <code>done</code> callback to signal completion. If you include the <code>done</code> callback as a parameter in your test definition, you must call it or the test will hang.</span> <pre numberoflines="8" language="typescript" data-language="typescript">import { expect, test } from "bun:test";

test("2 * 2", done =&gt; {
  Promise.resolve(2 * 2).then(result =&gt; {
    expect(result).toEqual(4);
    done();
  });
});
</pre> <h2 id="timeouts"><span>Timeouts</span></h2> <span data-as="p">Optionally specify a per-test timeout in milliseconds by passing a number as the third argument to <code>test</code>.</span> <pre numberoflines="6" language="typescript" data-language="typescript">import { test } from "bun:test";

test("wat", async () =&gt; {
  const data = await slowOperation();
  expect(data).toBe(42);
}, 500); // test must run in &lt;500ms
</pre> <span data-as="p">In <code>bun:test</code>, test timeouts throw an uncatchable exception to force the test to stop running and fail. We also kill any child processes that were spawned in the test to avoid leaving behind zombie processes lurking in the background.</span> <span data-as="p">The default timeout for each test is 5000ms (5 seconds) if not overridden by this timeout option or <code>jest.setDefaultTimeout()</code>.</span> <h2 id="retries-and-repeats"><span>Retries and Repeats</span></h2> <h3 id="test-retry"><span>test.retry</span></h3> <span data-as="p">Use the <code>retry</code> option to automatically retry a test if it fails. The test passes if it succeeds within the specified number of attempts. This is useful for flaky tests that may fail intermittently.</span> <pre numberoflines="10" language="typescript" data-language="typescript">import { test } from "bun:test";

test(
  "flaky network request",
  async () =&gt; {
    const response = await fetch("https://example.com/api");
    expect(response.ok).toBe(true);
  },
  { retry: 3 }, // Retry up to 3 times if the test fails
);
</pre> <h3 id="test-repeats"><span>test.repeats</span></h3> <span data-as="p">Use the <code>repeats</code> option to run a test multiple times regardless of pass/fail status. The test fails if any iteration fails. This is useful for detecting flaky tests or stress testing. Note that <code>repeats: N</code> runs the test N+1 times total (1 initial run + N repeats).</span> <pre numberoflines="9" language="typescript" data-language="typescript">import { test } from "bun:test";

test(
  "ensure test is stable",
  () =&gt; {
    expect(Math.random()).toBeLessThan(1);
  },
  { repeats: 20 }, // Runs 21 times total (1 initial + 20 repeats)
);
</pre> <div data-callout-type="note">

<div data-component-part="callout-content">You cannot use both <code>retry</code> and <code>repeats</code> on the same test.</div>
</div> <h3 id="üßü-zombie-process-killer"><span>üßü Zombie Process Killer</span></h3> <span data-as="p">When a test times out and processes spawned in the test via <code>Bun.spawn</code>, <code>Bun.spawnSync</code>, or <code>node:child_process</code> are not killed, they will be automatically killed and a message will be logged to the console. This prevents zombie processes from lingering in the background after timed-out tests.</span> <h2 id="test-modifiers"><span>Test Modifiers</span></h2> <h3 id="test-skip"><span>test.skip</span></h3> <span data-as="p">Skip individual tests with <code>test.skip</code>. These tests will not be run.</span> <pre numberoflines="6" language="typescript" data-language="typescript">import { expect, test } from "bun:test";

test.skip("wat", () =&gt; {
  // TODO: fix this
  expect(0.1 + 0.2).toEqual(0.3);
});
</pre> <h3 id="test-todo"><span>test.todo</span></h3> <span data-as="p">Mark a test as a todo with <code>test.todo</code>. These tests will not be run.</span> <pre numberoflines="5" language="typescript" data-language="typescript">import { expect, test } from "bun:test";

test.todo("fix this", () =&gt; {
  myTestFunction();
});
</pre> <span data-as="p">To run todo tests and find any which are passing, use <code>bun test --todo</code>.</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun test --todo
</pre> <pre numberoflines="8" language="text" data-language="typescript">my.test.ts:
‚úó unimplemented feature
  ^ this test is marked as todo but passes. Remove `.todo` or check that test is correct.

 0 pass
 1 fail
 1 expect() calls
</pre> <span data-as="p">With this flag, failing todo tests will not cause an error, but todo tests which pass will be marked as failing so you can remove the todo mark or fix the test.</span> <h3 id="test-only"><span>test.only</span></h3> <span data-as="p">To run a particular test or suite of tests use <code>test.only()</code> or <code>describe.only()</code>.</span> <pre numberoflines="15" language="typescript" data-language="typescript">import { test, describe } from "bun:test";

test("test #1", () =&gt; {
  // does not run
});

test.only("test #2", () =&gt; {
  // runs
});

describe.only("only", () =&gt; {
  test("test #3", () =&gt; {
    // runs
  });
});
</pre> <span data-as="p">The following command will only execute tests #2 and #3.</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun test --only
</pre> <span data-as="p">The following command will only execute tests #1, #2 and #3.</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun test
</pre> <h3 id="test-if"><span>test.if</span></h3> <span data-as="p">To run a test conditionally, use <code>test.if()</code>. The test will run if the condition is truthy. This is particularly useful for tests that should only run on specific architectures or operating systems.</span> <pre numberoflines="8" language="typescript" data-language="typescript">test.if(Math.random() &gt; 0.5)("runs half the time", () =&gt; {
  // ...
});

const macOS = process.platform === "darwin";
test.if(macOS)("runs on macOS", () =&gt; {
  // runs if macOS
});
</pre> <h3 id="test-skipif"><span>test.skipIf</span></h3> <span data-as="p">To instead skip a test based on some condition, use <code>test.skipIf()</code> or <code>describe.skipIf()</code>.</span> <pre numberoflines="5" language="typescript" data-language="typescript">const macOS = process.platform === "darwin";

test.skipIf(macOS)("runs on non-macOS", () =&gt; {
  // runs if *not* macOS
});
</pre> <h3 id="test-todoif"><span>test.todoIf</span></h3> <span data-as="p">If instead you want to mark the test as TODO, use <code>test.todoIf()</code> or <code>describe.todoIf()</code>. Carefully choosing <code>skipIf</code> or <code>todoIf</code> can show a difference between, for example, intent of ‚Äúinvalid for this target‚Äù and ‚Äúplanned but not implemented yet.‚Äù</span> <pre numberoflines="6" language="typescript" data-language="typescript">const macOS = process.platform === "darwin";

// TODO: we've only implemented this for Linux so far.
test.todoIf(macOS)("runs on posix", () =&gt; {
  // runs if *not* macOS
});
</pre> <h3 id="test-failing"><span>test.failing</span></h3> <span data-as="p">Use <code>test.failing()</code> when you know a test is currently failing but you want to track it and be notified when it starts passing. This inverts the test result:</span> <ul> <li>A failing test marked with <code>.failing()</code> will pass</li> <li>A passing test marked with <code>.failing()</code> will fail (with a message indicating it‚Äôs now passing and should be fixed)</li> </ul> <pre numberoflines="9" language="typescript" data-language="typescript">// This will pass because the test is failing as expected
test.failing("math is broken", () =&gt; {
  expect(0.1 + 0.2).toBe(0.3); // fails due to floating point precision
});

// This will fail with a message that the test is now passing
test.failing("fixed bug", () =&gt; {
  expect(1 + 1).toBe(2); // passes, but we expected it to fail
});
</pre> <span data-as="p">This is useful for tracking known bugs that you plan to fix later, or for implementing test-driven development.</span> <h2 id="conditional-tests-for-describe-blocks"><span>Conditional Tests for Describe Blocks</span></h2> <span data-as="p">The conditional modifiers <code>.if()</code>, <code>.skipIf()</code>, and <code>.todoIf()</code> can also be applied to describe blocks, affecting all tests within the suite:</span> <pre numberoflines="26" language="typescript" data-language="typescript">const isMacOS = process.platform === "darwin";

// Only runs the entire suite on macOS
describe.if(isMacOS)("macOS-specific features", () =&gt; {
  test("feature A", () =&gt; {
    // only runs on macOS
  });

  test("feature B", () =&gt; {
    // only runs on macOS
  });
});

// Skips the entire suite on Windows
describe.skipIf(process.platform === "win32")("Unix features", () =&gt; {
  test("feature C", () =&gt; {
    // skipped on Windows
  });
});

// Marks the entire suite as TODO on Linux
describe.todoIf(process.platform === "linux")("Upcoming Linux support", () =&gt; {
  test("feature D", () =&gt; {
    // marked as TODO on Linux
  });
});
</pre> <h2 id="parametrized-tests"><span>Parametrized Tests</span></h2> <h3 id="test-each-and-describe-each"><span><code>test.each</code> and <code>describe.each</code></span></h3> <span data-as="p">To run the same test with multiple sets of data, use <code>test.each</code>. This creates a parametrized test that runs once for each test case provided.</span> <pre numberoflines="8" language="typescript" data-language="typescript">const cases = [
  [1, 2, 3],
  [3, 4, 7],
];

test.each(cases)("%p + %p should be %p", (a, b, expected) =&gt; {
  expect(a + b).toBe(expected);
});
</pre> <span data-as="p">You can also use <code>describe.each</code> to create a parametrized suite that runs once for each test case:</span> <pre numberoflines="13" language="typescript" data-language="typescript">describe.each([
  [1, 2, 3],
  [3, 4, 7],
])("add(%i, %i)", (a, b, expected) =&gt; {
  test(`returns ${expected}`, () =&gt; {
    expect(a + b).toBe(expected);
  });

  test(`sum is greater than each value`, () =&gt; {
    expect(a + b).toBeGreaterThan(a);
    expect(a + b).toBeGreaterThan(b);
  });
});
</pre> <h3 id="argument-passing"><span>Argument Passing</span></h3> <span data-as="p">How arguments are passed to your test function depends on the structure of your test cases:</span> <ul> <li>If a table row is an array (like <code>[1, 2, 3]</code>), each element is passed as an individual argument</li> <li>If a row is not an array (like an object), it‚Äôs passed as a single argument</li> </ul> <pre numberoflines="15" language="typescript" data-language="typescript">// Array items passed as individual arguments
test.each([
  [1, 2, 3],
  [4, 5, 9],
])("add(%i, %i) = %i", (a, b, expected) =&gt; {
  expect(a + b).toBe(expected);
});

// Object items passed as a single argument
test.each([
  { a: 1, b: 2, expected: 3 },
  { a: 4, b: 5, expected: 9 },
])("add($a, $b) = $expected", data =&gt; {
  expect(data.a + data.b).toBe(data.expected);
});
</pre> <h3 id="format-specifiers"><span>Format Specifiers</span></h3> <span data-as="p">There are a number of options available for formatting the test title:</span> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Specifier</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code>%p</code></td>
<td>pretty-format</td>
</tr>
<tr>
<td><code>%s</code></td>
<td>String</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>Number</td>
</tr>
<tr>
<td><code>%i</code></td>
<td>Integer</td>
</tr>
<tr>
<td><code>%f</code></td>
<td>Floating point</td>
</tr>
<tr>
<td><code>%j</code></td>
<td>JSON</td>
</tr>
<tr>
<td><code>%o</code></td>
<td>Object</td>
</tr>
<tr>
<td><code>%#</code></td>
<td>Index of the test case</td>
</tr>
<tr>
<td data-numeric="true"><code>%%</code></td>
<td>Single percent sign (%)</td>
</tr>
</tbody>
</table></div></div> <h4 id="examples"><span>Examples</span></h4> <pre numberoflines="23" language="typescript" data-language="typescript">// Basic specifiers
test.each([
  ["hello", 123],
  ["world", 456],
])("string: %s, number: %i", (str, num) =&gt; {
  // "string: hello, number: 123"
  // "string: world, number: 456"
});

// %p for pretty-format output
test.each([
  [{ name: "Alice" }, { a: 1, b: 2 }],
  [{ name: "Bob" }, { x: 5, y: 10 }],
])("user %p with data %p", (user, data) =&gt; {
  // "user { name: 'Alice' } with data { a: 1, b: 2 }"
  // "user { name: 'Bob' } with data { x: 5, y: 10 }"
});

// %# for index
test.each(["apple", "banana"])("fruit #%# is %s", fruit =&gt; {
  // "fruit #0 is apple"
  // "fruit #1 is banana"
});
</pre> <h2 id="assertion-counting"><span>Assertion Counting</span></h2> <span data-as="p">Bun supports verifying that a specific number of assertions were called during a test:</span> <h3 id="expect-hasassertions"><span>expect.hasAssertions()</span></h3> <span data-as="p">Use <code>expect.hasAssertions()</code> to verify that at least one assertion is called during a test:</span> <pre numberoflines="6" language="typescript" data-language="typescript">test("async work calls assertions", async () =&gt; {
  expect.hasAssertions(); // Will fail if no assertions are called

  const data = await fetchData();
  expect(data).toBeDefined();
});
</pre> <span data-as="p">This is especially useful for async tests to ensure your assertions actually run.</span> <h3 id="expect-assertions-count"><span>expect.assertions(count)</span></h3> <span data-as="p">Use <code>expect.assertions(count)</code> to verify that a specific number of assertions are called during a test:</span> <pre numberoflines="6" language="typescript" data-language="typescript">test("exactly two assertions", () =&gt; {
  expect.assertions(2); // Will fail if not exactly 2 assertions are called

  expect(1 + 1).toBe(2);
  expect("hello").toContain("ell");
});
</pre> <span data-as="p">This helps ensure all your assertions run, especially in complex async code with multiple code paths.</span> <h2 id="type-testing"><span>Type Testing</span></h2> <span data-as="p">Bun includes <code>expectTypeOf</code> for testing TypeScript types, compatible with Vitest.</span> <h3 id="expecttypeof"><span>expectTypeOf</span></h3> <div data-callout-type="warning">

<div data-component-part="callout-content"><span data-as="p">These functions are no-ops at runtime - you need to run TypeScript separately to verify the type checks.</span></div>
</div> <span data-as="p">The <code>expectTypeOf</code> function provides type-level assertions that are checked by TypeScript‚Äôs type checker. To test your types:</span> <ol> <li>Write your type assertions using <code>expectTypeOf</code>
</li> <li>Run <code>bunx tsc --noEmit</code> to check that your types are correct</li> </ol> <pre numberoflines="24" language="typescript" data-language="typescript">import { expectTypeOf } from "bun:test";

// Basic type assertions
expectTypeOf&lt;string&gt;().toEqualTypeOf&lt;string&gt;();
expectTypeOf(123).toBeNumber();
expectTypeOf("hello").toBeString();

// Object type matching
expectTypeOf({ a: 1, b: "hello" }).toMatchObjectType&lt;{ a: number }&gt;();

// Function types
function greet(name: string): string {
  return `Hello ${name}`;
}

expectTypeOf(greet).toBeFunction();
expectTypeOf(greet).parameters.toEqualTypeOf&lt;[string]&gt;();
expectTypeOf(greet).returns.toEqualTypeOf&lt;string&gt;();

// Array types
expectTypeOf([1, 2, 3]).items.toBeNumber();

// Promise types
expectTypeOf(Promise.resolve(42)).resolves.toBeNumber();
</pre> <span data-as="p">For full documentation on expectTypeOf matchers, see the <a href="https://bun.com/reference/bun/test/expectTypeOf" target="_blank" rel="noreferrer">API Reference</a>.</span> <h2 id="matchers"><span>Matchers</span></h2> <span data-as="p">Bun implements the following matchers. Full Jest compatibility is on the roadmap; <a href="https://github.com/oven-sh/bun/issues/1825" target="_blank" rel="noreferrer">track progress here</a>.</span> <h3 id="basic-matchers"><span>Basic Matchers</span></h3> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Status</th>
<th>Matcher</th>
</tr></thead>
<tbody>
<tr>
<td>‚úÖ</td>
<td><code>.not</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toBe()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toEqual()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toBeNull()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toBeUndefined()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toBeNaN()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toBeDefined()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toBeFalsy()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toBeTruthy()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toStrictEqual()</code></td>
</tr>
</tbody>
</table></div></div> <h3 id="string-and-array-matchers"><span>String and Array Matchers</span></h3> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Status</th>
<th>Matcher</th>
</tr></thead>
<tbody>
<tr>
<td>‚úÖ</td>
<td><code>.toContain()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toHaveLength()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toMatch()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toContainEqual()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.stringContaining()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.stringMatching()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.arrayContaining()</code></td>
</tr>
</tbody>
</table></div></div> <h3 id="object-matchers"><span>Object Matchers</span></h3> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Status</th>
<th>Matcher</th>
</tr></thead>
<tbody>
<tr>
<td>‚úÖ</td>
<td><code>.toHaveProperty()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toMatchObject()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toContainAllKeys()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toContainValue()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toContainValues()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toContainAllValues()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toContainAnyValues()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.objectContaining()</code></td>
</tr>
</tbody>
</table></div></div> <h3 id="number-matchers"><span>Number Matchers</span></h3> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Status</th>
<th>Matcher</th>
</tr></thead>
<tbody>
<tr>
<td>‚úÖ</td>
<td><code>.toBeCloseTo()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.closeTo()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toBeGreaterThan()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toBeGreaterThanOrEqual()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toBeLessThan()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toBeLessThanOrEqual()</code></td>
</tr>
</tbody>
</table></div></div> <h3 id="function-and-class-matchers"><span>Function and Class Matchers</span></h3> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Status</th>
<th>Matcher</th>
</tr></thead>
<tbody>
<tr>
<td>‚úÖ</td>
<td><code>.toThrow()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toBeInstanceOf()</code></td>
</tr>
</tbody>
</table></div></div> <h3 id="promise-matchers"><span>Promise Matchers</span></h3> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Status</th>
<th>Matcher</th>
</tr></thead>
<tbody>
<tr>
<td>‚úÖ</td>
<td><code>.resolves()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.rejects()</code></td>
</tr>
</tbody>
</table></div></div> <h3 id="mock-function-matchers"><span>Mock Function Matchers</span></h3> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Status</th>
<th>Matcher</th>
</tr></thead>
<tbody>
<tr>
<td>‚úÖ</td>
<td><code>.toHaveBeenCalled()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toHaveBeenCalledTimes()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toHaveBeenCalledWith()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toHaveBeenLastCalledWith()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toHaveBeenNthCalledWith()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toHaveReturned()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toHaveReturnedTimes()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toHaveReturnedWith()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toHaveLastReturnedWith()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toHaveNthReturnedWith()</code></td>
</tr>
</tbody>
</table></div></div> <h3 id="snapshot-matchers"><span>Snapshot Matchers</span></h3> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Status</th>
<th>Matcher</th>
</tr></thead>
<tbody>
<tr>
<td>‚úÖ</td>
<td><code>.toMatchSnapshot()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toMatchInlineSnapshot()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toThrowErrorMatchingSnapshot()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.toThrowErrorMatchingInlineSnapshot()</code></td>
</tr>
</tbody>
</table></div></div> <h3 id="utility-matchers"><span>Utility Matchers</span></h3> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Status</th>
<th>Matcher</th>
</tr></thead>
<tbody>
<tr>
<td>‚úÖ</td>
<td><code>.extend</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.anything()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.any()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.assertions()</code></td>
</tr>
<tr>
<td>‚úÖ</td>
<td><code>.hasAssertions()</code></td>
</tr>
</tbody>
</table></div></div> <h3 id="not-yet-implemented"><span>Not Yet Implemented</span></h3> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Status</th>
<th>Matcher</th>
</tr></thead>
<tbody><tr>
<td>‚ùå</td>
<td><code>.addSnapshotSerializer()</code></td>
</tr></tbody>
</table></div></div> <h2 id="best-practices"><span>Best Practices</span></h2> <h3 id="use-descriptive-test-names"><span>Use Descriptive Test Names</span></h3> <pre numberoflines="9" language="typescript" data-language="typescript">// Good
test("should calculate total price including tax for multiple items", () =&gt; {
  // test implementation
});

// Avoid
test("price calculation", () =&gt; {
  // test implementation
});
</pre> <h3 id="group-related-tests"><span>Group Related Tests</span></h3> <pre numberoflines="17" language="typescript" data-language="typescript">describe("User authentication", () =&gt; {
  describe("with valid credentials", () =&gt; {
    test("should return user data", () =&gt; {
      // test implementation
    });

    test("should set authentication token", () =&gt; {
      // test implementation
    });
  });

  describe("with invalid credentials", () =&gt; {
    test("should throw authentication error", () =&gt; {
      // test implementation
    });
  });
});
</pre> <h3 id="use-appropriate-matchers"><span>Use Appropriate Matchers</span></h3> <pre numberoflines="9" language="typescript" data-language="typescript">// Good: Use specific matchers
expect(users).toHaveLength(3);
expect(user.email).toContain("@");
expect(response.status).toBeGreaterThanOrEqual(200);

// Avoid: Using toBe for everything
expect(users.length === 3).toBe(true);
expect(user.email.includes("@")).toBe(true);
expect(response.status &gt;= 200).toBe(true);
</pre> <h3 id="test-error-conditions"><span>Test Error Conditions</span></h3> <pre numberoflines="11" language="typescript" data-language="typescript">test("should throw error for invalid input", () =&gt; {
  expect(() =&gt; {
    validateEmail("not-an-email");
  }).toThrow("Invalid email format");
});

test("should handle async errors", async () =&gt; {
  await expect(async () =&gt; {
    await fetchUser("invalid-id");
  }).rejects.toThrow("User not found");
});
</pre> <h3 id="use-setup-and-teardown"><span>Use Setup and Teardown</span></h3> <pre numberoflines="15" language="typescript" data-language="typescript">import { beforeEach, afterEach, test } from "bun:test";

let testUser;

beforeEach(() =&gt; {
  testUser = createTestUser();
});

afterEach(() =&gt; {
  cleanupTestUser(testUser);
});

test("should update user profile", () =&gt; {
  // Use testUser in test
});
</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/test/writing-tests" class="_attribution-link">https://bun.com/docs/test/writing-tests</a>
  </p>
</div>
