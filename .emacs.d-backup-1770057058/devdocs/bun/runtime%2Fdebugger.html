<h1 id="header">Debugging</h1>
<div data-page-title="Debugging" data-page-href="/runtime/debugger" id="content">
<span data-as="p">Bun speaks the <a href="https://github.com/oven-sh/bun/blob/main/packages/bun-inspector-protocol/src/protocol/jsc/index.d.ts" target="_blank" rel="noreferrer">WebKit Inspector Protocol</a>, so you can debug your code with an interactive debugger. For demonstration purposes, consider the following simple web server.</span> <h2 id="debugging-javascript-and-typescript"><span>Debugging JavaScript and TypeScript</span></h2> <pre numberoflines="6" language="typescript" data-language="typescript">Bun.serve({
  fetch(req) {
    console.log(req.url);
    return new Response("Hello, world!");
  },
});
</pre> <h3 id="inspect"><span><code>--inspect</code></span></h3> <span data-as="p">To enable debugging when running code with Bun, use the <code>--inspect</code> flag. This automatically starts a WebSocket server on an available port that can be used to introspect the running Bun process.</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun --inspect server.ts
</pre> <pre numberoflines="8" language="text" data-language="typescript">------------------ Bun Inspector ------------------
Listening at:
  ws://localhost:6499/0tqxs9exrgrm

Inspect in browser:
  https://debug.bun.sh/#localhost:6499/0tqxs9exrgrm
------------------ Bun Inspector ------------------
</pre> <h3 id="inspect-brk"><span><code>--inspect-brk</code></span></h3> <span data-as="p">The <code>--inspect-brk</code> flag behaves identically to <code>--inspect</code>, except it automatically injects a breakpoint at the first line of the executed script. This is useful for debugging scripts that run quickly and exit immediately.</span> <h3 id="inspect-wait"><span><code>--inspect-wait</code></span></h3> <span data-as="p">The <code>--inspect-wait</code> flag behaves identically to <code>--inspect</code>, except the code will not execute until a debugger has attached to the running process.</span> <h3 id="setting-a-port-or-url-for-the-debugger"><span>Setting a port or URL for the debugger</span></h3> <span data-as="p">Regardless of which flag you use, you can optionally specify a port number, URL prefix, or both.</span> <pre numberoflines="3" language="shellscript" data-language="typescript">bun --inspect=4000 server.ts
bun --inspect=localhost:4000 server.ts
bun --inspect=localhost:4000/prefix server.ts
</pre> <hr> <h2 id="debuggers"><span>Debuggers</span></h2> <span data-as="p">Various debugging tools can connect to this server to provide an interactive debugging experience.</span> <h3 id="debug-bun-sh"><span><code>debug.bun.sh</code></span></h3> <span data-as="p">Bun hosts a web-based debugger at <a href="https://debug.bun.sh" target="_blank" rel="noreferrer">debug.bun.sh</a>. It is a modified version of WebKit’s <a href="https://webkit.org/web-inspector/web-inspector-interface/" target="_blank" rel="noreferrer">Web Inspector Interface</a>, which will look familiar to Safari users.</span> <span data-as="p">Open the provided <code>debug.bun.sh</code> URL in your browser to start a debugging session. From this interface, you’ll be able to view the source code of the running file, view and set breakpoints, and execute code with the built-in console.</span>  <span data-as="p">Let’s set a breakpoint. Navigate to the Sources tab; you should see the code from earlier. Click on the line number <code>3</code> to set a breakpoint on our <code>console.log(req.url)</code> statement.</span>  <span data-as="p">Then visit <a href="http://localhost:3000" target="_blank" rel="noreferrer"><code>http://localhost:3000</code></a> in your web browser. This will send an HTTP request to our <code>localhost</code> web server. It will seem like the page isn’t loading. Why? Because the program has paused execution at the breakpoint we set earlier.</span> <span data-as="p">Note how the UI has changed.</span>  <span data-as="p">At this point there’s a lot we can do to introspect the current execution environment. We can use the console at the bottom to run arbitrary code in the context of the program, with full access to the variables in scope at our breakpoint.</span>  <span data-as="p">On the right side of the Sources pane, we can see all local variables currently in scope, and drill down to see their properties and methods. Here, we’re inspecting the <code>req</code> variable.</span>  <span data-as="p">In the upper left of the Sources pane, we can control the execution of the program.</span>  <span data-as="p">Here’s a cheat sheet explaining the functions of the control flow buttons.</span> <ul> <li>
<em>Continue script execution</em> — continue running the program until the next breakpoint or exception.</li> <li>
<em>Step over</em> — The program will continue to the next line.</li> <li>
<em>Step into</em> — If the current statement contains a function call, the debugger will “step into” the called function.</li> <li>
<em>Step out</em> — If the current statement is a function call, the debugger will finish executing the call, then “step out” of the function to the location where it was called.</li> </ul>  <h3 id="visual-studio-code-debugger"><span>Visual Studio Code Debugger</span></h3> <span data-as="p">Experimental support for debugging Bun scripts is available in Visual Studio Code. To use it, you’ll need to install the <a href="../guides/runtime/vscode-debugger">Bun VSCode extension</a>.</span> <hr> <h2 id="debugging-network-requests"><span>Debugging Network Requests</span></h2> <span data-as="p">The <code>BUN_CONFIG_VERBOSE_FETCH</code> environment variable lets you log network requests made with <code>fetch()</code> or <code>node:http</code> automatically.</span> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Value</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code>curl</code></td>
<td>Print requests as <code>curl</code> commands.</td>
</tr>
<tr>
<td><code>true</code></td>
<td>Print request &amp; response info</td>
</tr>
<tr>
<td><code>false</code></td>
<td>Don’t print anything. Default</td>
</tr>
</tbody>
</table></div></div> <h3 id="print-fetch-&amp;-node:http-requests-as-curl-commands"><span>Print fetch &amp; node:http requests as curl commands</span></h3> <span data-as="p">Bun also supports printing <code>fetch()</code> and <code>node:http</code> network requests as <code>curl</code> commands by setting the environment variable <code>BUN_CONFIG_VERBOSE_FETCH</code> to <code>curl</code>. This prints the <code>fetch</code> request as a single-line <code>curl</code> command to let you copy-paste into your terminal to replicate the request.</span> <pre numberoflines="9" language="typescript" data-language="typescript">process.env.BUN_CONFIG_VERBOSE_FETCH = "curl";

await fetch("https://example.com", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({ foo: "bar" }),
});
</pre> <pre numberoflines="21" language="text" data-language="typescript">[fetch] $ curl --http1.1 "https://example.com/" -X POST -H "content-type: application/json" -H "Connection: keep-alive" -H "User-Agent: Bun/1.3.3" -H "Accept: */*" -H "Host: example.com" -H "Accept-Encoding: gzip, deflate, br" --compressed -H "Content-Length: 13" --data-raw "{\"foo\":\"bar\"}"
[fetch] &gt; HTTP/1.1 POST https://example.com/
[fetch] &gt; content-type: application/json
[fetch] &gt; Connection: keep-alive
[fetch] &gt; User-Agent: Bun/1.3.3
[fetch] &gt; Accept: */*
[fetch] &gt; Host: example.com
[fetch] &gt; Accept-Encoding: gzip, deflate, br
[fetch] &gt; Content-Length: 13

[fetch] &lt; 200 OK
[fetch] &lt; Accept-Ranges: bytes
[fetch] &lt; Cache-Control: max-age=604800
[fetch] &lt; Content-Type: text/html; charset=UTF-8
[fetch] &lt; Date: Tue, 18 Jun 2024 05:12:07 GMT
[fetch] &lt; Etag: "3147526947"
[fetch] &lt; Expires: Tue, 25 Jun 2024 05:12:07 GMT
[fetch] &lt; Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
[fetch] &lt; Server: EOS (vny/044F)
[fetch] &lt; Content-Length: 1256
</pre> <span data-as="p">The lines with <code>[fetch] &gt;</code> are the request from your local code, and the lines with <code>[fetch] &lt;</code> are the response from the remote server.</span> <span data-as="p">The <code>BUN_CONFIG_VERBOSE_FETCH</code> environment variable is supported in both <code>fetch()</code> and <code>node:http</code> requests, so it should just work.</span> <span data-as="p">To print without the <code>curl</code> command, set <code>BUN_CONFIG_VERBOSE_FETCH</code> to <code>true</code>.</span> <pre numberoflines="9" language="typescript" data-language="typescript">process.env.BUN_CONFIG_VERBOSE_FETCH = "true";

await fetch("https://example.com", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({ foo: "bar" }),
});
</pre> <pre numberoflines="20" language="text" data-language="typescript">[fetch] &gt; HTTP/1.1 POST https://example.com/
[fetch] &gt; content-type: application/json
[fetch] &gt; Connection: keep-alive
[fetch] &gt; User-Agent: Bun/1.3.3
[fetch] &gt; Accept: */*
[fetch] &gt; Host: example.com
[fetch] &gt; Accept-Encoding: gzip, deflate, br
[fetch] &gt; Content-Length: 13

[fetch] &lt; 200 OK
[fetch] &lt; Accept-Ranges: bytes
[fetch] &lt; Cache-Control: max-age=604800
[fetch] &lt; Content-Type: text/html; charset=UTF-8
[fetch] &lt; Date: Tue, 18 Jun 2024 05:12:07 GMT
[fetch] &lt; Etag: "3147526947"
[fetch] &lt; Expires: Tue, 25 Jun 2024 05:12:07 GMT
[fetch] &lt; Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
[fetch] &lt; Server: EOS (vny/044F)
[fetch] &lt; Content-Length: 1256
</pre> <hr> <h2 id="stacktraces-&amp;-sourcemaps"><span>Stacktraces &amp; sourcemaps</span></h2> <span data-as="p">Bun transpiles every file, which sounds like it would mean that the stack traces you see in the console would unhelpfully point to the transpiled output. To address this, Bun automatically generates and serves sourcemapped files for every file it transpiles. When you see a stack trace in the console, you can click on the file path and be taken to the original source code, even though it was written in TypeScript or JSX, or has some other transformation applied.</span> <span data-as="p">Bun automatically loads sourcemaps both at runtime when transpiling files on-demand, and when using <code>bun build</code> to precompile files ahead of time.</span> <h3 id="syntax-highlighted-source-code-preview"><span>Syntax-highlighted source code preview</span></h3> <span data-as="p">To help with debugging, Bun automatically prints a small source-code preview when an unhandled exception or rejection occurs. You can simulate this behavior by calling <code>Bun.inspect(error)</code>:</span> <pre numberoflines="3" language="typescript" data-language="typescript">// Create an error
const err = new Error("Something went wrong");
console.log(Bun.inspect(err, { colors: true }));
</pre> <span data-as="p">This prints a syntax-highlighted preview of the source code where the error occurred, along with the error message and stack trace.</span> <pre numberoflines="5" language="typescript" data-language="typescript">1 | // Create an error
2 | const err = new Error("Something went wrong");
                ^
error: Something went wrong
      at file.js:2:13
</pre> <h3 id="v8-stack-traces"><span>V8 Stack Traces</span></h3> <span data-as="p">Bun uses JavaScriptCore as it’s engine, but much of the Node.js ecosystem &amp; npm expects V8. JavaScript engines differ in <code>error.stack</code> formatting. Bun intends to be a drop-in replacement for Node.js, and that means it’s our job to make sure that even though the engine is different, the stack traces are as similar as possible.</span> <span data-as="p">That’s why when you log <code>error.stack</code> in Bun, the formatting of <code>error.stack</code> is the same as in Node.js’s V8 engine. This is especially useful when you’re using libraries that expect V8 stack traces.</span> <h4 id="v8-stack-trace-api"><span>V8 Stack Trace API</span></h4> <span data-as="p">Bun implements the <a href="https://v8.dev/docs/stack-trace-api" target="_blank" rel="noreferrer">V8 Stack Trace API</a>, which is a set of functions that allow you to manipulate stack traces.</span> <h5><code>Error.prepareStackTrace</code></h5> <span data-as="p">The <code>Error.prepareStackTrace</code> function is a global function that lets you customize the stack trace output. This function is called with the error object and an array of <code>CallSite</code> objects and lets you return a custom stack trace.</span> <pre numberoflines="9" language="typescript" data-language="typescript">Error.prepareStackTrace = (err, stack) =&gt; {
  return stack.map(callSite =&gt; {
    return callSite.getFileName();
  });
};

const err = new Error("Something went wrong");
console.log(err.stack);
// [ "error.js" ]
</pre> <span data-as="p">The <code>CallSite</code> object has the following methods:</span> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Method</th>
<th>Returns</th>
</tr></thead>
<tbody>
<tr>
<td><code>getThis</code></td>
<td>
<code>this</code> value of the function call</td>
</tr>
<tr>
<td><code>getTypeName</code></td>
<td>typeof <code>this</code>
</td>
</tr>
<tr>
<td><code>getFunction</code></td>
<td>function object</td>
</tr>
<tr>
<td><code>getFunctionName</code></td>
<td>function name as a string</td>
</tr>
<tr>
<td><code>getMethodName</code></td>
<td>method name as a string</td>
</tr>
<tr>
<td><code>getFileName</code></td>
<td>file name or URL</td>
</tr>
<tr>
<td><code>getLineNumber</code></td>
<td>line number</td>
</tr>
<tr>
<td><code>getColumnNumber</code></td>
<td>column number</td>
</tr>
<tr>
<td><code>getEvalOrigin</code></td>
<td><code>undefined</code></td>
</tr>
<tr>
<td><code>getScriptNameOrSourceURL</code></td>
<td>source URL</td>
</tr>
<tr>
<td><code>isToplevel</code></td>
<td>returns <code>true</code> if the function is in the global scope</td>
</tr>
<tr>
<td><code>isEval</code></td>
<td>returns <code>true</code> if the function is an <code>eval</code> call</td>
</tr>
<tr>
<td><code>isNative</code></td>
<td>returns <code>true</code> if the function is native</td>
</tr>
<tr>
<td><code>isConstructor</code></td>
<td>returns <code>true</code> if the function is a constructor</td>
</tr>
<tr>
<td><code>isAsync</code></td>
<td>returns <code>true</code> if the function is <code>async</code>
</td>
</tr>
<tr>
<td><code>isPromiseAll</code></td>
<td>Not implemented yet.</td>
</tr>
<tr>
<td><code>getPromiseIndex</code></td>
<td>Not implemented yet.</td>
</tr>
<tr>
<td><code>toString</code></td>
<td>returns a string representation of the call site</td>
</tr>
</tbody>
</table></div></div> <span data-as="p">In some cases, the <code>Function</code> object may have already been garbage collected, so some of these methods may return <code>undefined</code>.</span> <h5><code>Error.captureStackTrace(error, startFn)</code></h5> <span data-as="p">The <code>Error.captureStackTrace</code> function lets you capture a stack trace at a specific point in your code, rather than at the point where the error was thrown.</span> <span data-as="p">This can be helpful when you have callbacks or asynchronous code that makes it difficult to determine where an error originated. The 2nd argument to <code>Error.captureStackTrace</code> is the function where you want the stack trace to start.</span> <span data-as="p">For example, the below code will make <code>err.stack</code> point to the code calling <code>fn()</code>, even though the error was thrown at <code>myInner</code>.</span> <pre numberoflines="18" language="typescript" data-language="typescript">const fn = () =&gt; {
  function myInner() {
    throw err;
  }

  try {
    myInner();
  } catch (err) {
    console.log(err.stack);
    console.log("");
    console.log("-- captureStackTrace --");
    console.log("");
    Error.captureStackTrace(err, fn);
    console.log(err.stack);
  }
};

fn();
</pre> <pre numberoflines="16" language="text" data-language="typescript">Error: here!
    at myInner (file.js:4:15)
    at fn (file.js:8:5)
    at module code (file.js:17:1)
    at moduleEvaluation (native)
    at moduleEvaluation (native)
    at &lt;anonymous&gt; (native)

-- captureStackTrace --

Error: here!
    at module code (file.js:17:1)
    at moduleEvaluation (native)
    at moduleEvaluation (native)
    at &lt;anonymous&gt; (native)
</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/debugger" class="_attribution-link">https://bun.com/docs/runtime/debugger</a>
  </p>
</div>
