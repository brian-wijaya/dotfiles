<h1 id="header">Transpiler</h1>
<div data-page-title="Transpiler" data-page-href="/runtime/transpiler" id="content">
<span data-as="p">Bun exposes its internal transpiler via the <code>Bun.Transpiler</code> class. To create an instance of Bun’s transpiler:</span> <pre numberoflines="3" language="typescript" data-language="typescript">const transpiler = new Bun.Transpiler({
  loader: "tsx", // "js | "jsx" | "ts" | "tsx"
});
</pre> <hr> <h2 id="transformsync"><span><code>.transformSync()</code></span></h2> <span data-as="p">Transpile code synchronously with the <code>.transformSync()</code> method. Modules are not resolved and the code is not executed. The result is a string of vanilla JavaScript code.</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">transpile.tsoutputconst transpiler = new Bun.Transpiler({
  loader: 'tsx',
});

const code = `
import * as whatever from "./whatever.ts"
export function Home(props: {title: string}){
  return &lt;p&gt;{props.title}&lt;/p&gt;;
}`;

const result = transpiler.transformSync(code);

</pre> <span data-as="p">To override the default loader specified in the <code>new Bun.Transpiler()</code> constructor, pass a second argument to <code>.transformSync()</code>.</span> <pre numberoflines="1" language="typescript" data-language="typescript">transpiler.transformSync("&lt;div&gt;hi!&lt;/div&gt;", "tsx");
</pre> <details><summary aria-controls="nitty-gritty accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">Nitty gritty</p></div></summary><div id="nitty-gritty accordion children" role="region" aria-labelledby="nitty-gritty" data-component-part="accordion-content">
<span data-as="p">When <code>.transformSync</code> is called, the transpiler is run in the same thread as the currently executed code.</span><span data-as="p">If a macro is used, it will be run in the same thread as the transpiler, but in a separate event loop from the rest of your application. Currently, globals between macros and regular code are shared, which means it is possible (but not recommended) to share states between macros and regular code. Attempting to use AST nodes outside of a macro is undefined behavior.</span>
</div></details> <hr> <h2 id="transform"><span><code>.transform()</code></span></h2> <span data-as="p">The <code>transform()</code> method is an async version of <code>.transformSync()</code> that returns a <code>Promise&lt;string&gt;</code>.</span> <pre numberoflines="3" language="javascript" data-language="typescript">const transpiler = new Bun.Transpiler({ loader: "jsx" });
const result = await transpiler.transform("&lt;div&gt;hi!&lt;/div&gt;");
console.log(result);
</pre> <span data-as="p">Unless you’re transpiling <em>many</em> large files, you should probably use <code>Bun.Transpiler.transformSync</code>. The cost of the threadpool will often take longer than actually transpiling code.</span> <pre numberoflines="1" language="typescript" data-language="typescript">await transpiler.transform("&lt;div&gt;hi!&lt;/div&gt;", "tsx");
</pre> <details><summary aria-controls="nitty-gritty accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">Nitty gritty</p></div></summary><div id="nitty-gritty accordion children" role="region" aria-labelledby="nitty-gritty" data-component-part="accordion-content">
<span data-as="p">The <code>.transform()</code> method runs the transpiler in Bun’s worker threadpool, so if you run it 100 times, it will run it across <code>Math.floor($cpu_count * 0.8)</code> threads, without blocking the main JavaScript thread.</span><span data-as="p">If your code uses a macro, it will potentially spawn a new copy of Bun’s JavaScript runtime environment in that new thread.</span>
</div></details> <h2 id="scan"><span><code>.scan()</code></span></h2> <span data-as="p">The <code>Transpiler</code> instance can also scan some source code and return a list of its imports and exports, plus additional metadata about each one. <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export" target="_blank" rel="noreferrer">Type-only</a> imports and exports are ignored.</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">example.tsoutputconst transpiler = new Bun.Transpiler({
  loader: "tsx",
});

const code = `
import React from 'react';
import type {ReactNode} from 'react';
const val = require('./cjs.js')
import('./loader');

export const name = "hello";
`;

const result = transpiler.scan(code);
</pre> <span data-as="p">Each import in the <code>imports</code> array has a <code>path</code> and <code>kind</code>. Bun categories imports into the following kinds:</span> <ul> <li>
<code>import-statement</code>: <code>import React from 'react'</code>
</li> <li>
<code>require-call</code>: <code>const val = require('./cjs.js')</code>
</li> <li>
<code>require-resolve</code>: <code>require.resolve('./cjs.js')</code>
</li> <li>
<code>dynamic-import</code>: <code>import('./loader')</code>
</li> <li>
<code>import-rule</code>: <code>@import 'foo.css'</code>
</li> <li>
<code>url-token</code>: <code>url('./foo.png')</code>
</li> </ul> <hr> <h2 id="scanimports"><span><code>.scanImports()</code></span></h2> <span data-as="p">For performance-sensitive code, you can use the <code>.scanImports()</code> method to get a list of imports. It’s faster than <code>.scan()</code> (especially for large files) but marginally less accurate due to some performance optimizations.</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">example.tsresultsconst transpiler = new Bun.Transpiler({
  loader: "tsx",
});

const code = `
import React from 'react';
import type {ReactNode} from 'react';
const val = require('./cjs.js')
import('./loader');

export const name = "hello";
`;

const result = transpiler.scanImports(code);
</pre> <hr> <h2 id="reference"><span>Reference</span></h2> <pre numberoflines="90" language="typescript" data-language="typescript">type Loader = "jsx" | "js" | "ts" | "tsx";

interface TranspilerOptions {
  // Replace key with value. Value must be a JSON string.
  // { "process.env.NODE_ENV": "\"production\"" }
  define?: Record&lt;string, string&gt;,

  // Default loader for this transpiler
  loader?: Loader,

  // Default platform to target
  // This affects how import and/or require is used
  target?: "browser" | "bun" | "node",

  // Specify a tsconfig.json file as stringified JSON or an object
  // Use this to set a custom JSX factory, fragment, or import source
  // For example, if you want to use Preact instead of React. Or if you want to use Emotion.
  tsconfig?: string | TSConfig,

  // Replace imports with macros
  macro?: MacroMap,

  // Specify a set of exports to eliminate
  // Or rename certain exports
  exports?: {
      eliminate?: string[];
      replace?: Record&lt;string, string&gt;;
  },

  // Whether to remove unused imports from transpiled file
  // Default: false
  trimUnusedImports?: boolean,

  // Whether to enable a set of JSX optimizations
  // jsxOptimizationInline ...,

  // Experimental whitespace minification
  minifyWhitespace?: boolean,

  // Whether to inline constant values
  // Typically improves performance and decreases bundle size
  // Default: true
  inline?: boolean,
}

// Map import paths to macros
interface MacroMap {
  // {
  //   "react-relay": {
  //     "graphql": "bun-macro-relay/bun-macro-relay.tsx"
  //   }
  // }
  [packagePath: string]: {
    [importItemName: string]: string,
  },
}

class Bun.Transpiler {
  constructor(options: TranspilerOptions)

  transform(code: string, loader?: Loader): Promise&lt;string&gt;
  transformSync(code: string, loader?: Loader): string

  scan(code: string): {exports: string[], imports: Import}
  scanImports(code: string): Import[]
}

type Import = {
  path: string,
  kind:
  // import foo from 'bar'; in JavaScript
  | "import-statement"
  // require("foo") in JavaScript
  | "require-call"
  // require.resolve("foo") in JavaScript
  | "require-resolve"
  // Dynamic import() in JavaScript
  | "dynamic-import"
  // @import() in CSS
  | "import-rule"
  // url() in CSS
  | "url-token"
  // The import was injected by Bun
  | "internal"
  // Entry point (not common)
  | "entry-point-build"
  | "entry-point-run"
}

const transpiler = new Bun.Transpiler({ loader: "jsx" });
See all 90 lines</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/transpiler" class="_attribution-link">https://bun.com/docs/runtime/transpiler</a>
  </p>
</div>
