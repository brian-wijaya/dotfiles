<h1 id="header">Use TanStack Start with Bun</h1>
<div data-page-title="Use TanStack Start with Bun" data-page-href="/guides/ecosystem/tanstack-start" id="content">
<span data-as="p"><a href="https://tanstack.com/start/latest" target="_blank" rel="noreferrer">TanStack Start</a> is a full-stack framework powered by TanStack Router. It supports full-document SSR, streaming, server functions, bundling and more, powered by TanStack Router and <a href="https://vite.dev/" target="_blank" rel="noreferrer">Vite</a>.</span> <hr> <div role="list">
<div role="listitem">

<div data-component-part="step-number" contenteditable="false"><div>1</div></div>
<div>
<p contenteditable="false" data-component-part="step-title">Create a new TanStack Start app</p>
<div data-component-part="step-content">
<span data-as="p">Use the interactive CLI to create a new TanStack Start app.</span><pre numberoflines="1" language="shellscript" data-language="typescript">bun create @tanstack/start@latest my-tanstack-app
</pre>
</div>
</div>
</div>
<div role="listitem">

<div data-component-part="step-number" contenteditable="false"><div>2</div></div>
<div>
<p contenteditable="false" data-component-part="step-title">Start the dev server</p>
<div data-component-part="step-content">
<span data-as="p">Change to the project directory and run the dev server with Bun.</span><pre numberoflines="2" language="shellscript" data-language="typescript">cd my-tanstack-app
bun --bun run dev
</pre>
<span data-as="p">This starts the Vite dev server with Bun.</span>
</div>
</div>
</div>
<div role="listitem">

<div data-component-part="step-number" contenteditable="false"><div>3</div></div>
<div>
<p contenteditable="false" data-component-part="step-title">Update scripts in package.json</p>
<div data-component-part="step-content">
<span data-as="p">Modify the scripts field in your <code>package.json</code> by prefixing the Vite CLI commands with <code>bun --bun</code>. This ensures that Bun executes the Vite CLI for common tasks like <code>dev</code>, <code>build</code>, and <code>preview</code>.</span><pre numberoflines="7" language="json" data-language="typescript">{
  "scripts": {
    "dev": "bun --bun vite dev", 
    "build": "bun --bun vite build", 
    "serve": "bun --bun vite preview"
  }
}
</pre>
</div>
</div>
</div>
</div> <hr> <h2 id="hosting"><span>Hosting</span></h2> <span data-as="p">To host your TanStack Start app, you can use <a href="https://nitro.build/" target="_blank" rel="noreferrer">Nitro</a> or a custom Bun server for production deployments.</span> <div id="nitro">
<ul role="tablist" data-component-part="tabs-list">
<li id="nitro" role="tab" aria-selected="true" aria-controls="panel-nitro-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-Nitro"> Nitro</div></li>
<li id="custom-server" role="tab" aria-selected="false" aria-controls="panel-custom-server-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-Custom Server"> Custom Server</div></li>
</ul>
<div>
<div id="panel-nitro-0" role="tabpanel" aria-labelledby="nitro" data-component-part="tab-content"><div role="list">
<div role="listitem">

<div data-component-part="step-number" contenteditable="false"><div>1</div></div>
<div>
<p contenteditable="false" data-component-part="step-title">Add Nitro to your project</p>
<div data-component-part="step-content">
<span data-as="p">Add <a href="https://nitro.build/" target="_blank" rel="noreferrer">Nitro</a> to your project. This tool allows you to deploy your TanStack Start app to different platforms.</span><pre numberoflines="1" language="shellscript" data-language="typescript">bun add nitro
</pre>
</div>
</div>
</div>
<div role="listitem">

<div data-component-part="step-number" contenteditable="false"><div>2</div></div>
<div><div data-component-part="step-content">
<span data-as="p">Update your <code>vite.config.ts</code> file to include the necessary plugins for TanStack Start with Bun.</span><pre numberoflines="12" language="typescript" data-language="typescript">// other imports...
import { nitro } from "nitro/vite"; 

const config = defineConfig({
  plugins: [
    tanstackStart(),
    nitro({ preset: "bun" }), 
    // other plugins...
  ],
});

export default config;
</pre>
<div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p">The <code>bun</code> preset is optional, but it configures the build output specifically for Bun‚Äôs runtime.</span></div>
</div>
</div></div>
</div>
<div role="listitem">

<div data-component-part="step-number" contenteditable="false"><div>3</div></div>
<div>
<p contenteditable="false" data-component-part="step-title">Update the start command</p>
<div data-component-part="step-content">
<span data-as="p">Make sure <code>build</code> and <code>start</code> scripts are present in your <code>package.json</code> file:</span><pre numberoflines="8" language="json" data-language="typescript">  {
    "scripts": {
      "build": "bun --bun vite build", 
      // The .output files are created by Nitro when you run `bun run build`.
      // Not necessary when deploying to Vercel.
      "start": "bun run .output/server/index.mjs"
    }
  }
</pre>
<div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p">You do <strong>not</strong> need the custom <code>start</code> script when deploying to Vercel.</span></div>
</div>
</div>
</div>
</div>
<div role="listitem">

<div data-component-part="step-number" contenteditable="false"><div>4</div></div>
<div>
<p contenteditable="false" data-component-part="step-title">Deploy your app</p>
<div data-component-part="step-content">
<span data-as="p">Check out one of our guides to deploy your app to a hosting provider.</span><div data-callout-type="note">

<div data-component-part="callout-content">
<span data-as="p">When deploying to Vercel, you can either add the <code>"bunVersion": "1.x"</code> to your <code>vercel.json</code> file, or add it to the <code>nitro</code> config in your <code>vite.config.ts</code> file:</span><div data-callout-type="warning">

<div data-component-part="callout-content"><span data-as="p">Do <strong>not</strong> use the <code>bun</code> Nitro preset when deploying to Vercel.</span></div>
</div>
<pre numberoflines="13" language="typescript" data-language="typescript">export default defineConfig({
  plugins: [
    tanstackStart(),
    nitro({
      preset: "bun", 
      vercel: { 
        functions: { 
          runtime: "bun1.x", 
        }, 
    }, 
    }),
  ],
});
</pre>
</div>
</div>
</div>
</div>
</div>
</div></div>
<div id="panel-custom-server-1" role="tabpanel" aria-labelledby="custom-server" data-component-part="tab-content">
<div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p">This custom server implementation is based on <a href="https://github.com/TanStack/router/blob/main/examples/react/start-bun/server.ts" target="_blank" rel="noreferrer">TanStack‚Äôs Bun template</a>. It provides fine-grained control over static asset serving, including configurable memory management that preloads small files into memory for fast serving while serving larger files on-demand. This approach is useful when you need precise control over resource usage and asset loading behavior in production deployments.</span></div>
</div>
<div role="list">
<div role="listitem">

<div data-component-part="step-number" contenteditable="false"><div>1</div></div>
<div>
<p contenteditable="false" data-component-part="step-title">Create the production server</p>
<div data-component-part="step-content">
<span data-as="p">Create a <code>server.ts</code> file in your project root with the following custom server implementation:</span><pre numberoflines="556" language="typescript" data-language="typescript">/**
* TanStack Start Production Server with Bun
*
* A high-performance production server for TanStack Start applications that
* implements intelligent static asset loading with configurable memory management.
*
* Features:
* - Hybrid loading strategy (preload small files, serve large files on-demand)
* - Configurable file filtering with include/exclude patterns
* - Memory-efficient response generation
* - Production-ready caching headers
*
* Environment Variables:
*
* PORT (number)
*   - Server port number
*   - Default: 3000
*
* ASSET_PRELOAD_MAX_SIZE (number)
*   - Maximum file size in bytes to preload into memory
*   - Files larger than this will be served on-demand from disk
*   - Default: 5242880 (5MB)
*   - Example: ASSET_PRELOAD_MAX_SIZE=5242880 (5MB)
*
* ASSET_PRELOAD_INCLUDE_PATTERNS (string)
*   - Comma-separated list of glob patterns for files to include
*   - If specified, only matching files are eligible for preloading
*   - Patterns are matched against filenames only, not full paths
*   - Example: ASSET_PRELOAD_INCLUDE_PATTERNS="*.js,*.css,*.woff2"
*
* ASSET_PRELOAD_EXCLUDE_PATTERNS (string)
*   - Comma-separated list of glob patterns for files to exclude
*   - Applied after include patterns
*   - Patterns are matched against filenames only, not full paths
*   - Example: ASSET_PRELOAD_EXCLUDE_PATTERNS="*.map,*.txt"
*
* ASSET_PRELOAD_VERBOSE_LOGGING (boolean)
*   - Enable detailed logging of loaded and skipped files
*   - Default: false
*   - Set to "true" to enable verbose output
*
* ASSET_PRELOAD_ENABLE_ETAG (boolean)
*   - Enable ETag generation for preloaded assets
*   - Default: true
*   - Set to "false" to disable ETag support
*
* ASSET_PRELOAD_ENABLE_GZIP (boolean)
*   - Enable Gzip compression for eligible assets
*   - Default: true
*   - Set to "false" to disable Gzip compression
*
* ASSET_PRELOAD_GZIP_MIN_SIZE (number)
*   - Minimum file size in bytes required for Gzip compression
*   - Files smaller than this will not be compressed
*   - Default: 1024 (1KB)
*
* ASSET_PRELOAD_GZIP_MIME_TYPES (string)
*   - Comma-separated list of MIME types eligible for Gzip compression
*   - Supports partial matching for types ending with "/"
*   - Default: text/,application/javascript,application/json,application/xml,image/svg+xml
*
* Usage:
*   bun run server.ts
*/

import path from 'node:path'

// Configuration
const SERVER_PORT = Number(process.env.PORT ?? 3000)
const CLIENT_DIRECTORY = './dist/client'
const SERVER_ENTRY_POINT = './dist/server/server.js'

// Logging utilities for professional output
const log = {
  info: (message: string) =&gt; {
    console.log(`[INFO] ${message}`)
  },
  success: (message: string) =&gt; {
    console.log(`[SUCCESS] ${message}`)
  },
  warning: (message: string) =&gt; {
    console.log(`[WARNING] ${message}`)
  },
  error: (message: string) =&gt; {
    console.log(`[ERROR] ${message}`)
  },
  header: (message: string) =&gt; {
    console.log(`\n${message}\n`)
  },
}

// Preloading configuration from environment variables
const MAX_PRELOAD_BYTES = Number(
  process.env.ASSET_PRELOAD_MAX_SIZE ?? 5 * 1024 * 1024, // 5MB default
)

// Parse comma-separated include patterns (no defaults)
const INCLUDE_PATTERNS = (process.env.ASSET_PRELOAD_INCLUDE_PATTERNS ?? '')
  .split(',')
  .map((s) =&gt; s.trim())
  .filter(Boolean)
  .map((pattern: string) =&gt; convertGlobToRegExp(pattern))

// Parse comma-separated exclude patterns (no defaults)
const EXCLUDE_PATTERNS = (process.env.ASSET_PRELOAD_EXCLUDE_PATTERNS ?? '')
  .split(',')
  .map((s) =&gt; s.trim())
  .filter(Boolean)
  .map((pattern: string) =&gt; convertGlobToRegExp(pattern))

// Verbose logging flag
const VERBOSE = process.env.ASSET_PRELOAD_VERBOSE_LOGGING === 'true'

// Optional ETag feature
const ENABLE_ETAG = (process.env.ASSET_PRELOAD_ENABLE_ETAG ?? 'true') === 'true'

// Optional Gzip feature
const ENABLE_GZIP = (process.env.ASSET_PRELOAD_ENABLE_GZIP ?? 'true') === 'true'
const GZIP_MIN_BYTES = Number(process.env.ASSET_PRELOAD_GZIP_MIN_SIZE ?? 1024) // 1KB
const GZIP_TYPES = (
  process.env.ASSET_PRELOAD_GZIP_MIME_TYPES ??
  'text/,application/javascript,application/json,application/xml,image/svg+xml'
)
  .split(',')
  .map((v) =&gt; v.trim())
  .filter(Boolean)

/**
* Convert a simple glob pattern to a regular expression
* Supports * wildcard for matching any characters
*/
function convertGlobToRegExp(globPattern: string): RegExp {
  // Escape regex special chars except *, then replace * with .*
  const escapedPattern = globPattern
    .replace(/[-/\\^$+?.()|[\]{}]/g, '\\$&amp;')
    .replace(/\*/g, '.*')
  return new RegExp(`^${escapedPattern}$`, 'i')
}

/**
* Compute ETag for a given data buffer
*/
function computeEtag(data: Uint8Array): string {
  const hash = Bun.hash(data)
  return `W/"${hash.toString(16)}-${data.byteLength.toString()}"`
}

/**
* Metadata for preloaded static assets
*/
interface AssetMetadata {
  route: string
  size: number
  type: string
}

/**
* In-memory asset with ETag and Gzip support
*/
interface InMemoryAsset {
  raw: Uint8Array
  gz?: Uint8Array
  etag?: string
  type: string
  immutable: boolean
  size: number
}

/**
* Result of static asset preloading process
*/
interface PreloadResult {
  routes: Record&lt;string, (req: Request) =&gt; Response | Promise&lt;Response&gt;&gt;
  loaded: AssetMetadata[]
  skipped: AssetMetadata[]
}

/**
* Check if a file is eligible for preloading based on configured patterns
*/
function isFileEligibleForPreloading(relativePath: string): boolean {
  const fileName = relativePath.split(/[/\\]/).pop() ?? relativePath

  // If include patterns are specified, file must match at least one
  if (INCLUDE_PATTERNS.length &gt; 0) {
    if (!INCLUDE_PATTERNS.some((pattern) =&gt; pattern.test(fileName))) {
      return false
    }
  }

  // If exclude patterns are specified, file must not match any
  if (EXCLUDE_PATTERNS.some((pattern) =&gt; pattern.test(fileName))) {
    return false
  }

  return true
}

/**
* Check if a MIME type is compressible
*/
function isMimeTypeCompressible(mimeType: string): boolean {
  return GZIP_TYPES.some((type) =&gt;
    type.endsWith('/') ? mimeType.startsWith(type) : mimeType === type,
  )
}

/**
* Conditionally compress data based on size and MIME type
*/
function compressDataIfAppropriate(
  data: Uint8Array,
  mimeType: string,
): Uint8Array | undefined {
  if (!ENABLE_GZIP) return undefined
  if (data.byteLength &lt; GZIP_MIN_BYTES) return undefined
  if (!isMimeTypeCompressible(mimeType)) return undefined
  try {
    return Bun.gzipSync(data.buffer as ArrayBuffer)
  } catch {
    return undefined
  }
}

/**
* Create response handler function with ETag and Gzip support
*/
function createResponseHandler(
  asset: InMemoryAsset,
): (req: Request) =&gt; Response {
  return (req: Request) =&gt; {
    const headers: Record&lt;string, string&gt; = {
      'Content-Type': asset.type,
      'Cache-Control': asset.immutable
        ? 'public, max-age=31536000, immutable'
        : 'public, max-age=3600',
    }

    if (ENABLE_ETAG &amp;&amp; asset.etag) {
      const ifNone = req.headers.get('if-none-match')
      if (ifNone &amp;&amp; ifNone === asset.etag) {
        return new Response(null, {
          status: 304,
          headers: { ETag: asset.etag },
        })
      }
      headers.ETag = asset.etag
    }

    if (
      ENABLE_GZIP &amp;&amp;
      asset.gz &amp;&amp;
      req.headers.get('accept-encoding')?.includes('gzip')
    ) {
      headers['Content-Encoding'] = 'gzip'
      headers['Content-Length'] = String(asset.gz.byteLength)
      const gzCopy = new Uint8Array(asset.gz)
      return new Response(gzCopy, { status: 200, headers })
    }

    headers['Content-Length'] = String(asset.raw.byteLength)
    const rawCopy = new Uint8Array(asset.raw)
    return new Response(rawCopy, { status: 200, headers })
  }
}

/**
* Create composite glob pattern from include patterns
*/
function createCompositeGlobPattern(): Bun.Glob {
  const raw = (process.env.ASSET_PRELOAD_INCLUDE_PATTERNS ?? '')
    .split(',')
    .map((s) =&gt; s.trim())
    .filter(Boolean)
  if (raw.length === 0) return new Bun.Glob('**/*')
  if (raw.length === 1) return new Bun.Glob(raw[0])
  return new Bun.Glob(`{${raw.join(',')}}`)
}

/**
* Initialize static routes with intelligent preloading strategy
* Small files are loaded into memory, large files are served on-demand
*/
async function initializeStaticRoutes(
  clientDirectory: string,
): Promise&lt;PreloadResult&gt; {
  const routes: Record&lt;string, (req: Request) =&gt; Response | Promise&lt;Response&gt;&gt; =
    {}
  const loaded: AssetMetadata[] = []
  const skipped: AssetMetadata[] = []

  log.info(`Loading static assets from ${clientDirectory}...`)
  if (VERBOSE) {
    console.log(
      `Max preload size: ${(MAX_PRELOAD_BYTES / 1024 / 1024).toFixed(2)} MB`,
    )
    if (INCLUDE_PATTERNS.length &gt; 0) {
      console.log(
        `Include patterns: ${process.env.ASSET_PRELOAD_INCLUDE_PATTERNS ?? ''}`,
      )
    }
    if (EXCLUDE_PATTERNS.length &gt; 0) {
      console.log(
        `Exclude patterns: ${process.env.ASSET_PRELOAD_EXCLUDE_PATTERNS ?? ''}`,
      )
    }
  }

  let totalPreloadedBytes = 0

  try {
    const glob = createCompositeGlobPattern()
    for await (const relativePath of glob.scan({ cwd: clientDirectory })) {
      const filepath = path.join(clientDirectory, relativePath)
      const route = `/${relativePath.split(path.sep).join(path.posix.sep)}`

      try {
        // Get file metadata
        const file = Bun.file(filepath)

        // Skip if file doesn't exist or is empty
        if (!(await file.exists()) || file.size === 0) {
          continue
        }

        const metadata: AssetMetadata = {
          route,
          size: file.size,
          type: file.type || 'application/octet-stream',
        }

        // Determine if file should be preloaded
        const matchesPattern = isFileEligibleForPreloading(relativePath)
        const withinSizeLimit = file.size &lt;= MAX_PRELOAD_BYTES

        if (matchesPattern &amp;&amp; withinSizeLimit) {
          // Preload small files into memory with ETag and Gzip support
          const bytes = new Uint8Array(await file.arrayBuffer())
          const gz = compressDataIfAppropriate(bytes, metadata.type)
          const etag = ENABLE_ETAG ? computeEtag(bytes) : undefined
          const asset: InMemoryAsset = {
            raw: bytes,
            gz,
            etag,
            type: metadata.type,
            immutable: true,
            size: bytes.byteLength,
          }
          routes[route] = createResponseHandler(asset)

          loaded.push({ ...metadata, size: bytes.byteLength })
          totalPreloadedBytes += bytes.byteLength
        } else {
          // Serve large or filtered files on-demand
          routes[route] = () =&gt; {
            const fileOnDemand = Bun.file(filepath)
            return new Response(fileOnDemand, {
              headers: {
                'Content-Type': metadata.type,
                'Cache-Control': 'public, max-age=3600',
              },
            })
          }

          skipped.push(metadata)
        }
      } catch (error: unknown) {
        if (error instanceof Error &amp;&amp; error.name !== 'EISDIR') {
          log.error(`Failed to load ${filepath}: ${error.message}`)
        }
      }
    }

    // Show detailed file overview only when verbose mode is enabled
    if (VERBOSE &amp;&amp; (loaded.length &gt; 0 || skipped.length &gt; 0)) {
      const allFiles = [...loaded, ...skipped].sort((a, b) =&gt;
        a.route.localeCompare(b.route),
      )

      // Calculate max path length for alignment
      const maxPathLength = Math.min(
        Math.max(...allFiles.map((f) =&gt; f.route.length)),
        60,
      )

      // Format file size with KB and actual gzip size
      const formatFileSize = (bytes: number, gzBytes?: number) =&gt; {
        const kb = bytes / 1024
        const sizeStr = kb &lt; 100 ? kb.toFixed(2) : kb.toFixed(1)

        if (gzBytes !== undefined) {
          const gzKb = gzBytes / 1024
          const gzStr = gzKb &lt; 100 ? gzKb.toFixed(2) : gzKb.toFixed(1)
          return {
            size: sizeStr,
            gzip: gzStr,
          }
        }

        // Rough gzip estimation (typically 30-70% compression) if no actual gzip data
        const gzipKb = kb * 0.35
        return {
          size: sizeStr,
          gzip: gzipKb &lt; 100 ? gzipKb.toFixed(2) : gzipKb.toFixed(1),
        }
      }

      if (loaded.length &gt; 0) {
        console.log('\nüìÅ Preloaded into memory:')
        console.log(
          'Path                                          ‚îÇ    Size ‚îÇ Gzip Size',
        )
        loaded
          .sort((a, b) =&gt; a.route.localeCompare(b.route))
          .forEach((file) =&gt; {
            const { size, gzip } = formatFileSize(file.size)
            const paddedPath = file.route.padEnd(maxPathLength)
            const sizeStr = `${size.padStart(7)} kB`
            const gzipStr = `${gzip.padStart(7)} kB`
            console.log(`${paddedPath} ‚îÇ ${sizeStr} ‚îÇ  ${gzipStr}`)
          })
      }

      if (skipped.length &gt; 0) {
        console.log('\nüíæ Served on-demand:')
        console.log(
          'Path                                          ‚îÇ    Size ‚îÇ Gzip Size',
        )
        skipped
          .sort((a, b) =&gt; a.route.localeCompare(b.route))
          .forEach((file) =&gt; {
            const { size, gzip } = formatFileSize(file.size)
            const paddedPath = file.route.padEnd(maxPathLength)
            const sizeStr = `${size.padStart(7)} kB`
            const gzipStr = `${gzip.padStart(7)} kB`
            console.log(`${paddedPath} ‚îÇ ${sizeStr} ‚îÇ  ${gzipStr}`)
          })
      }
    }

    // Show detailed verbose info if enabled
    if (VERBOSE) {
      if (loaded.length &gt; 0 || skipped.length &gt; 0) {
        const allFiles = [...loaded, ...skipped].sort((a, b) =&gt;
          a.route.localeCompare(b.route),
        )
        console.log('\nüìä Detailed file information:')
        console.log(
          'Status       ‚îÇ Path                            ‚îÇ MIME Type                    ‚îÇ Reason',
        )
        allFiles.forEach((file) =&gt; {
          const isPreloaded = loaded.includes(file)
          const status = isPreloaded ? 'MEMORY' : 'ON-DEMAND'
          const reason =
            !isPreloaded &amp;&amp; file.size &gt; MAX_PRELOAD_BYTES
              ? 'too large'
              : !isPreloaded
                ? 'filtered'
                : 'preloaded'
          const route =
            file.route.length &gt; 30
              ? file.route.substring(0, 27) + '...'
              : file.route
          console.log(
            `${status.padEnd(12)} ‚îÇ ${route.padEnd(30)} ‚îÇ ${file.type.padEnd(28)} ‚îÇ ${reason.padEnd(10)}`,
          )
        })
      } else {
        console.log('\nüìä No files found to display')
      }
    }

    // Log summary after the file list
    console.log() // Empty line for separation
    if (loaded.length &gt; 0) {
      log.success(
        `Preloaded ${String(loaded.length)} files (${(totalPreloadedBytes / 1024 / 1024).toFixed(2)} MB) into memory`,
      )
    } else {
      log.info('No files preloaded into memory')
    }

    if (skipped.length &gt; 0) {
      const tooLarge = skipped.filter((f) =&gt; f.size &gt; MAX_PRELOAD_BYTES).length
      const filtered = skipped.length - tooLarge
      log.info(
        `${String(skipped.length)} files will be served on-demand (${String(tooLarge)} too large, ${String(filtered)} filtered)`,
      )
    }
  } catch (error) {
    log.error(
      `Failed to load static files from ${clientDirectory}: ${String(error)}`,
    )
  }

  return { routes, loaded, skipped }
}

/**
* Initialize the server
*/
async function initializeServer() {
  log.header('Starting Production Server')

  // Load TanStack Start server handler
  let handler: { fetch: (request: Request) =&gt; Response | Promise&lt;Response&gt; }
  try {
    const serverModule = (await import(SERVER_ENTRY_POINT)) as {
      default: { fetch: (request: Request) =&gt; Response | Promise&lt;Response&gt; }
    }
    handler = serverModule.default
    log.success('TanStack Start application handler initialized')
  } catch (error) {
    log.error(`Failed to load server handler: ${String(error)}`)
    process.exit(1)
  }

  // Build static routes with intelligent preloading
  const { routes } = await initializeStaticRoutes(CLIENT_DIRECTORY)

  // Create Bun server
  const server = Bun.serve({
    port: SERVER_PORT,

    routes: {
      // Serve static assets (preloaded or on-demand)
      ...routes,

      // Fallback to TanStack Start handler for all other routes
      '/*': (req: Request) =&gt; {
        try {
          return handler.fetch(req)
        } catch (error) {
          log.error(`Server handler error: ${String(error)}`)
          return new Response('Internal Server Error', { status: 500 })
        }
      },
    },

    // Global error handler
    error(error) {
      log.error(
        `Uncaught server error: ${error instanceof Error ? error.message : String(error)}`,
      )
      return new Response('Internal Server Error', { status: 500 })
    },
  })

  log.success(`Server listening on http://localhost:${String(server.port)}`)
}

// Initialize the server
initializeServer().catch((error: unknown) =&gt; {
  log.error(`Failed to start server: ${String(error)}`)
  process.exit(1)
})
See all 556 lines</pre>
</div>
</div>
</div>
<div role="listitem">

<div data-component-part="step-number" contenteditable="false"><div>2</div></div>
<div>
<p contenteditable="false" data-component-part="step-title">Update package.json scripts</p>
<div data-component-part="step-content">
<span data-as="p">Add a <code>start</code> script to run the custom server:</span><pre numberoflines="6" language="json" data-language="typescript">{
  "scripts": {
    "build": "bun --bun vite build",
    "start": "bun run server.ts"
  }
}
</pre>
</div>
</div>
</div>
<div role="listitem">

<div data-component-part="step-number" contenteditable="false"><div>3</div></div>
<div>
<p contenteditable="false" data-component-part="step-title">Build and run</p>
<div data-component-part="step-content">
<span data-as="p">Build your application and start the server:</span><pre numberoflines="2" language="shellscript" data-language="typescript">bun run build
bun run start
</pre>
<span data-as="p">The server will start on port 3000 by default (configurable via <code>PORT</code> environment variable).</span>
</div>
</div>
</div>
</div>
</div>
</div>
</div> <div>
<a href="../deployment/vercel"><div data-component-part="card-content-container">


<div>
<h2 contenteditable="false" data-component-part="card-title">Vercel</h2>
<div data-component-part="card-content"><span data-as="p">Deploy on Vercel</span></div>
</div>
</div></a><a href="../deployment/render"><div data-component-part="card-content-container">


<div>
<h2 contenteditable="false" data-component-part="card-title">Render</h2>
<div data-component-part="card-content"><span data-as="p">Deploy on Render</span></div>
</div>
</div></a><a href="../deployment/railway"><div data-component-part="card-content-container">


<div>
<h2 contenteditable="false" data-component-part="card-title">Railway</h2>
<div data-component-part="card-content"><span data-as="p">Deploy on Railway</span></div>
</div>
</div></a><a href="../deployment/digital-ocean"><div data-component-part="card-content-container">


<div>
<h2 contenteditable="false" data-component-part="card-title">DigitalOcean</h2>
<div data-component-part="card-content"><span data-as="p">Deploy on DigitalOcean</span></div>
</div>
</div></a><a href="../deployment/aws-lambda"><div data-component-part="card-content-container">


<div>
<h2 contenteditable="false" data-component-part="card-title">AWS Lambda</h2>
<div data-component-part="card-content"><span data-as="p">Deploy on AWS Lambda</span></div>
</div>
</div></a><a href="../deployment/google-cloud-run"><div data-component-part="card-content-container">


<div>
<h2 contenteditable="false" data-component-part="card-title">Google Cloud Run</h2>
<div data-component-part="card-content"><span data-as="p">Deploy on Google Cloud Run</span></div>
</div>
</div></a>
</div> <hr> <h2 id="templates"><span>Templates</span></h2> <div>
<a target="_blank" rel="noreferrer" href="https://github.com/bun-templates/bun-tanstack-todo"><div data-component-part="card-content-container">

<div>
<h2 contenteditable="false" data-component-part="card-title">Todo App with Tanstack + Bun</h2>
<div data-component-part="card-content"><span data-as="p">A Todo application built with Bun, TanStack Start, and PostgreSQL.</span></div>
<div data-component-part="card-cta"><button>Go to template</button></div>
</div>
</div></a><a target="_blank" rel="noreferrer" href="https://github.com/bun-templates/bun-tanstack-basic"><div data-component-part="card-content-container">

<div>
<h2 contenteditable="false" data-component-part="card-title">Bun + TanStack Start Application</h2>
<div data-component-part="card-content"><span data-as="p">A TanStack Start template using Bun with SSR and file-based routing.</span></div>
<div data-component-part="card-cta"><button>Go to template</button></div>
</div>
</div></a><a target="_blank" rel="noreferrer" href="https://github.com/bun-templates/bun-tanstack-start"><div data-component-part="card-content-container">

<div>
<h2 contenteditable="false" data-component-part="card-title">Basic Bun + Tanstack Starter</h2>
<div data-component-part="card-content"><span data-as="p">The basic TanStack starter using the Bun runtime and Bun‚Äôs file APIs.</span></div>
<div data-component-part="card-cta"><button>Go to template</button></div>
</div>
</div></a>
</div> <hr> <span data-as="p"><a href="https://tanstack.com/start/latest/docs/framework/react/guide/hosting" target="_blank" rel="noreferrer">‚Üí See TanStack Start‚Äôs official documentation</a> for more information on hosting.</span>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/guides/ecosystem/tanstack-start" class="_attribution-link">https://bun.com/docs/guides/ecosystem/tanstack-start</a>
  </p>
</div>
