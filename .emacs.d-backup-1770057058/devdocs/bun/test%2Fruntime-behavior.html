<h1 id="header">Runtime behavior</h1>
<div data-page-title="Runtime behavior" data-page-href="/test/runtime-behavior" id="content">
<span data-as="p"><code>bun test</code> is deeply integrated with Bun’s runtime. This is part of what makes <code>bun test</code> fast and simple to use.</span> <h2 id="environment-variables"><span>Environment Variables</span></h2> <h3 id="node-env"><span>NODE_ENV</span></h3> <span data-as="p"><code>bun test</code> automatically sets <code>$NODE_ENV</code> to <code>"test"</code> unless it’s already set in the environment or via <code>.env</code> files. This is standard behavior for most test runners and helps ensure consistent test behavior.</span> <pre numberoflines="5" language="typescript" data-language="typescript">import { test, expect } from "bun:test";

test("NODE_ENV is set to test", () =&gt; {
  expect(process.env.NODE_ENV).toBe("test");
});
</pre> <span data-as="p">You can override this by setting <code>NODE_ENV</code> explicitly:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">NODE_ENV=development bun test
</pre> <h3 id="tz-timezone"><span>TZ (Timezone)</span></h3> <span data-as="p">By default, all <code>bun test</code> runs use UTC (<code>Etc/UTC</code>) as the time zone unless overridden by the <code>TZ</code> environment variable. This ensures consistent date and time behavior across different development environments.</span> <pre numberoflines="6" language="typescript" data-language="typescript">import { test, expect } from "bun:test";

test("timezone is UTC by default", () =&gt; {
  const date = new Date();
  expect(date.getTimezoneOffset()).toBe(0);
});
</pre> <span data-as="p">To test with a specific timezone:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">TZ=America/New_York bun test
</pre> <h2 id="test-timeouts"><span>Test Timeouts</span></h2> <span data-as="p">Each test has a default timeout of 5000ms (5 seconds) if not explicitly overridden. Tests that exceed this timeout will fail.</span> <h3 id="global-timeout"><span>Global Timeout</span></h3> <span data-as="p">Change the timeout globally with the <code>--timeout</code> flag:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun test --timeout 10000  # 10 seconds
</pre> <h3 id="per-test-timeout"><span>Per-Test Timeout</span></h3> <span data-as="p">Set timeout per test as the third parameter to the test function:</span> <pre numberoflines="9" language="typescript" data-language="typescript">import { test, expect } from "bun:test";

test("fast test", () =&gt; {
  expect(1 + 1).toBe(2);
}, 1000); // 1 second timeout

test("slow test", async () =&gt; {
  await new Promise(resolve =&gt; setTimeout(resolve, 8000));
}, 10000); // 10 second timeout
</pre> <h3 id="infinite-timeout"><span>Infinite Timeout</span></h3> <span data-as="p">Use <code>0</code> or <code>Infinity</code> to disable timeout:</span> <pre numberoflines="4" language="typescript" data-language="typescript">test("test without timeout", async () =&gt; {
  // This test can run indefinitely
  await someVeryLongOperation();
}, 0);
</pre> <h2 id="error-handling"><span>Error Handling</span></h2> <h3 id="unhandled-errors"><span>Unhandled Errors</span></h3> <span data-as="p"><code>bun test</code> tracks unhandled promise rejections and errors that occur between tests. If such errors occur, the final exit code will be non-zero (specifically, the count of such errors), even if all tests pass.</span> <span data-as="p">This helps catch errors in asynchronous code that might otherwise go unnoticed:</span> <pre numberoflines="19" language="typescript" data-language="typescript">import { test } from "bun:test";

test("test 1", () =&gt; {
  // This test passes
  expect(true).toBe(true);
});

// This error happens outside any test
setTimeout(() =&gt; {
  throw new Error("Unhandled error");
}, 0);

test("test 2", () =&gt; {
  // This test also passes
  expect(true).toBe(true);
});

// The test run will still fail with a non-zero exit code
// because of the unhandled error
</pre> <h3 id="promise-rejections"><span>Promise Rejections</span></h3> <span data-as="p">Unhandled promise rejections are also caught:</span> <pre numberoflines="8" language="typescript" data-language="typescript">import { test } from "bun:test";

test("passing test", () =&gt; {
  expect(1).toBe(1);
});

// This will cause the test run to fail
Promise.reject(new Error("Unhandled rejection"));
</pre> <h3 id="custom-error-handling"><span>Custom Error Handling</span></h3> <span data-as="p">You can set up custom error handlers in your test setup:</span> <pre numberoflines="9" language="typescript" data-language="typescript">process.on("uncaughtException", error =&gt; {
  console.error("Uncaught Exception:", error);
  process.exit(1);
});

process.on("unhandledRejection", (reason, promise) =&gt; {
  console.error("Unhandled Rejection at:", promise, "reason:", reason);
  process.exit(1);
});
</pre> <h2 id="cli-flags-integration"><span>CLI Flags Integration</span></h2> <span data-as="p">Several Bun CLI flags can be used with <code>bun test</code> to modify its behavior:</span> <h3 id="memory-usage"><span>Memory Usage</span></h3> <pre numberoflines="2" language="shellscript" data-language="typescript"># Reduces memory usage for the test runner VM
bun test --smol
</pre> <h3 id="debugging"><span>Debugging</span></h3> <pre numberoflines="3" language="shellscript" data-language="typescript"># Attaches the debugger to the test runner process
bun test --inspect
bun test --inspect-brk
</pre> <h3 id="module-loading"><span>Module Loading</span></h3> <pre numberoflines="17" language="shellscript" data-language="typescript"># Runs scripts before test files (useful for global setup/mocks)
bun test --preload ./setup.ts

# Sets compile-time constants
bun test --define "process.env.API_URL='http://localhost:3000'"

# Configures custom loaders
bun test --loader .special:special-loader

# Uses a different tsconfig
bun test --tsconfig-override ./test-tsconfig.json

# Sets package.json conditions for module resolution
bun test --conditions development

# Loads environment variables for tests
bun test --env-file .env.test
</pre> <h3 id="installation-related-flags"><span>Installation-related Flags</span></h3> <pre numberoflines="3" language="shellscript" data-language="typescript"># Affect any network requests or auto-installs during test execution
bun test --prefer-offline
bun test --frozen-lockfile
</pre> <h2 id="watch-and-hot-reloading"><span>Watch and Hot Reloading</span></h2> <h3 id="watch-mode"><span>Watch Mode</span></h3> <span data-as="p">When running <code>bun test</code> with the <code>--watch</code> flag, the test runner will watch for file changes and re-run affected tests.</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun test --watch
</pre> <span data-as="p">The test runner is smart about which tests to re-run:</span> <pre numberoflines="6" language="typescript" data-language="typescript">import { add } from "./math.js";
import { test, expect } from "bun:test";

test("addition", () =&gt; {
  expect(add(2, 3)).toBe(5);
});
</pre> <span data-as="p">If you modify <code>math.js</code>, only <code>math.test.ts</code> will re-run, not all tests.</span> <h3 id="hot-reloading"><span>Hot Reloading</span></h3> <span data-as="p">The <code>--hot</code> flag provides similar functionality but is more aggressive about trying to preserve state between runs:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun test --hot
</pre> <span data-as="p">For most test scenarios, <code>--watch</code> is the recommended option as it provides better isolation between test runs.</span> <h2 id="global-variables"><span>Global Variables</span></h2> <span data-as="p">The following globals are automatically available in test files without importing (though they can be imported from <code>bun:test</code> if preferred):</span> <pre numberoflines="20" language="typescript" data-language="typescript">// All of these are available globally
test("global test function", () =&gt; {
  expect(true).toBe(true);
});

describe("global describe", () =&gt; {
  beforeAll(() =&gt; {
    // global beforeAll
  });

  it("global it function", () =&gt; {
    // it is an alias for test
  });
});

// Jest compatibility
jest.fn();

// Vitest compatibility
vi.fn();
</pre> <span data-as="p">You can also import them explicitly if you prefer:</span> <pre numberoflines="1" language="typescript" data-language="typescript">import { test, it, describe, expect, beforeAll, beforeEach, afterAll, afterEach, jest, vi } from "bun:test";
</pre> <h2 id="process-integration"><span>Process Integration</span></h2> <h3 id="exit-codes"><span>Exit Codes</span></h3> <span data-as="p"><code>bun test</code> uses standard exit codes:</span> <ul> <li>
<code>0</code>: All tests passed, no unhandled errors</li> <li>
<code>1</code>: Test failures occurred</li> <li>
<code>&gt;1</code>: Number of unhandled errors (even if tests passed)</li> </ul> <h3 id="signal-handling"><span>Signal Handling</span></h3> <span data-as="p">The test runner properly handles common signals:</span> <pre numberoflines="5" language="shellscript" data-language="typescript"># Gracefully stops test execution
kill -SIGTERM &lt;test-process-pid&gt;

# Immediately stops test execution
kill -SIGKILL &lt;test-process-pid&gt;
</pre> <h3 id="environment-detection"><span>Environment Detection</span></h3> <span data-as="p">Bun automatically detects certain environments and adjusts behavior:</span> <pre numberoflines="9" language="typescript" data-language="typescript">// GitHub Actions detection
if (process.env.GITHUB_ACTIONS) {
  // Bun automatically emits GitHub Actions annotations
}

// CI detection
if (process.env.CI) {
  // Certain behaviors may be adjusted for CI environments
}
</pre> <h2 id="performance-considerations"><span>Performance Considerations</span></h2> <h3 id="single-process"><span>Single Process</span></h3> <span data-as="p">The test runner runs all tests in a single process by default. This provides:</span> <ul> <li>
<strong>Faster startup</strong> - No need to spawn multiple processes</li> <li>
<strong>Shared memory</strong> - Efficient resource usage</li> <li>
<strong>Simple debugging</strong> - All tests in one process</li> </ul> <span data-as="p">However, this means:</span> <ul> <li>Tests share global state (use lifecycle hooks to clean up)</li> <li>One test crash can affect others</li> <li>No true parallelization of individual tests</li> </ul> <h3 id="memory-management"><span>Memory Management</span></h3> <pre numberoflines="6" language="shellscript" data-language="typescript"># Monitor memory usage
bun test --smol  # Reduces memory footprint

# For large test suites, consider splitting files
bun test src/unit/
bun test src/integration/
</pre> <h3 id="test-isolation"><span>Test Isolation</span></h3> <span data-as="p">Since tests run in the same process, ensure proper cleanup:</span> <pre numberoflines="10" language="typescript" data-language="typescript">import { afterEach } from "bun:test";

afterEach(() =&gt; {
  // Clean up global state
  global.myGlobalVar = undefined;
  delete process.env.TEST_VAR;

  // Reset modules if needed
  jest.resetModules();
});
</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/test/runtime-behavior" class="_attribution-link">https://bun.com/docs/test/runtime-behavior</a>
  </p>
</div>
