<h1 id="header">FFI</h1>
<div data-page-title="FFI" data-page-href="/runtime/ffi" id="content">
<div data-callout-type="warning">

<div data-component-part="callout-content"><span data-as="p"><code>bun:ffi</code> is <strong>experimental</strong>, with known bugs and limitations, and should not be relied on in production. The most stable way to interact with native code from Bun is to write a <a href="node-api">Node-API module</a>.</span></div>
</div> <span data-as="p">Use the built-in <code>bun:ffi</code> module to efficiently call native libraries from JavaScript. It works with languages that support the C ABI (Zig, Rust, C/C++, C#, Nim, Kotlin, etc).</span> <hr> <h2 id="dlopen-usage-bun:ffi"><span>dlopen usage (<code>bun:ffi</code>)</span></h2> <span data-as="p">To print the version number of <code>sqlite3</code>:</span> <pre numberoflines="22" language="typescript" data-language="typescript">import { dlopen, FFIType, suffix } from "bun:ffi";

// `suffix` is either "dylib", "so", or "dll" depending on the platform
// you don't have to use "suffix", it's just there for convenience
const path = `libsqlite3.${suffix}`;

const {
  symbols: {
    sqlite3_libversion, // the function to call
  },
} = dlopen(
  path, // a library name or file path
  {
    sqlite3_libversion: {
      // no arguments, returns a string
      args: [],
      returns: FFIType.cstring,
    },
  },
);

console.log(`SQLite 3 version: ${sqlite3_libversion()}`);
</pre> <hr> <h2 id="performance"><span>Performance</span></h2> <span data-as="p">According to <a href="https://github.com/oven-sh/bun/tree/main/bench/ffi" target="_blank" rel="noreferrer">our benchmark</a>, <code>bun:ffi</code> is roughly 2-6x faster than Node.js FFI via <code>Node-API</code>.</span>  <span data-as="p">Bun generates &amp; just-in-time compiles C bindings that efficiently convert values between JavaScript types and native types. To compile C, Bun embeds <a href="https://github.com/TinyCC/tinycc" target="_blank" rel="noreferrer">TinyCC</a>, a small and fast C compiler.</span> <hr> <h2 id="usage"><span>Usage</span></h2> <h3 id="zig"><span>Zig</span></h3> <pre numberoflines="3" language="zig" data-language="typescript">pub export fn add(a: i32, b: i32) i32 {
  return a + b;
}
</pre> <span data-as="p">To compile:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">zig build-lib add.zig -dynamic -OReleaseFast
</pre> <span data-as="p">Pass a path to the shared library and a map of symbols to import into <code>dlopen</code>:</span> <pre numberoflines="13" language="typescript" data-language="typescript">import { dlopen, FFIType, suffix } from "bun:ffi";
const { i32 } = FFIType;

const path = `libadd.${suffix}`;

const lib = dlopen(path, {
  add: {
    args: [i32, i32],
    returns: i32,
  },
});

console.log(lib.symbols.add(1, 2));
</pre> <h3 id="rust"><span>Rust</span></h3> <pre numberoflines="5" language="rust" data-language="typescript">// add.rs
#[no_mangle]
pub extern "C" fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
</pre> <span data-as="p">To compile:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">rustc --crate-type cdylib add.rs
</pre> <h3 id="c++"><span>C++</span></h3> <pre numberoflines="5" language="c" data-language="typescript">#include &lt;cstdint&gt;

extern "C" int32_t add(int32_t a, int32_t b) {
    return a + b;
}
</pre> <span data-as="p">To compile:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">zig build-lib add.cpp -dynamic -lc -lc++
</pre> <hr> <h2 id="ffi-types"><span>FFI types</span></h2> <span data-as="p">The following <code>FFIType</code> values are supported.</span> <div data-table-wrapper="true"><div><table> <thead><tr>
<th><code>FFIType</code></th>
<th>C Type</th>
<th>Aliases</th>
</tr></thead> <tbody>
<tr>
<td>buffer</td>
<td><code>char*</code></td>
<td></td>
</tr>
<tr>
<td>cstring</td>
<td><code>char*</code></td>
<td></td>
</tr>
<tr>
<td>function</td>
<td><code>(void*)(*)()</code></td>
<td>
<code>fn</code>, <code>callback</code>
</td>
</tr>
<tr>
<td>ptr</td>
<td><code>void*</code></td>
<td>
<code>pointer</code>, <code>void*</code>, <code>char*</code>
</td>
</tr>
<tr>
<td>i8</td>
<td><code>int8_t</code></td>
<td><code>int8_t</code></td>
</tr>
<tr>
<td>i16</td>
<td><code>int16_t</code></td>
<td><code>int16_t</code></td>
</tr>
<tr>
<td>i32</td>
<td><code>int32_t</code></td>
<td>
<code>int32_t</code>, <code>int</code>
</td>
</tr>
<tr>
<td>i64</td>
<td><code>int64_t</code></td>
<td><code>int64_t</code></td>
</tr>
<tr>
<td>i64_fast</td>
<td><code>int64_t</code></td>
<td></td>
</tr>
<tr>
<td>u8</td>
<td><code>uint8_t</code></td>
<td><code>uint8_t</code></td>
</tr>
<tr>
<td>u16</td>
<td><code>uint16_t</code></td>
<td><code>uint16_t</code></td>
</tr>
<tr>
<td>u32</td>
<td><code>uint32_t</code></td>
<td><code>uint32_t</code></td>
</tr>
<tr>
<td>u64</td>
<td><code>uint64_t</code></td>
<td><code>uint64_t</code></td>
</tr>
<tr>
<td>u64_fast</td>
<td><code>uint64_t</code></td>
<td></td>
</tr>
<tr>
<td>f32</td>
<td><code>float</code></td>
<td><code>float</code></td>
</tr>
<tr>
<td>f64</td>
<td><code>double</code></td>
<td><code>double</code></td>
</tr>
<tr>
<td>bool</td>
<td><code>bool</code></td>
<td></td>
</tr>
<tr>
<td>char</td>
<td><code>char</code></td>
<td></td>
</tr>
<tr>
<td>napi_env</td>
<td><code>napi_env</code></td>
<td></td>
</tr>
<tr>
<td>napi_value</td>
<td><code>napi_value</code></td>
<td></td>
</tr>
</tbody> </table></div></div> <span data-as="p">Note: <code>buffer</code> arguments must be a <code>TypedArray</code> or <code>DataView</code>.</span> <hr> <h2 id="strings"><span>Strings</span></h2> <span data-as="p">JavaScript strings and C-like strings are different, and that complicates using strings with native libraries.</span> <details><summary aria-controls="how-are-javascript-strings-and-c-strings-different accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">How are JavaScript strings and C strings different?</p></div></summary><div id="how-are-javascript-strings-and-c-strings-different accordion children" role="region" aria-labelledby="how-are-javascript-strings-and-c-strings-different" data-component-part="accordion-content">
<span data-as="p">JavaScript strings:</span><ul> <li>UTF16 (2 bytes per letter) or potentially latin1, depending on the JavaScript engine &amp; what characters are used</li> <li>
<code>length</code> stored separately</li> <li>Immutable</li> </ul>
<span data-as="p">C strings:</span><ul> <li>UTF8 (1 byte per letter), usually</li> <li>The length is not stored. Instead, the string is null-terminated which means the length is the index of the first <code>\0</code> it finds</li> <li>Mutable</li> </ul>
</div></details> <span data-as="p">To solve this, <code>bun:ffi</code> exports <code>CString</code> which extends JavaScript’s built-in <code>String</code> to support null-terminated strings and add a few extras:</span> <pre numberoflines="17" language="typescript" data-language="typescript">class CString extends String {
  /**
   * Given a `ptr`, this will automatically search for the closing `\0` character and transcode from UTF-8 to UTF-16 if necessary.
   */
  constructor(ptr: number, byteOffset?: number, byteLength?: number): string;

  /**
   * The ptr to the C string
   *
   * This `CString` instance is a clone of the string, so it
   * is safe to continue using this instance after the `ptr` has been
   * freed.
   */
  ptr: number;
  byteOffset?: number;
  byteLength?: number;
}
</pre> <span data-as="p">To convert from a null-terminated string pointer to a JavaScript string:</span> <pre numberoflines="1" language="typescript" data-language="typescript">const myString = new CString(ptr);
</pre> <span data-as="p">To convert from a pointer with a known length to a JavaScript string:</span> <pre numberoflines="1" language="typescript" data-language="typescript">const myString = new CString(ptr, 0, byteLength);
</pre> <span data-as="p">The <code>new CString()</code> constructor clones the C string, so it is safe to continue using <code>myString</code> after <code>ptr</code> has been freed.</span> <pre numberoflines="4" language="typescript" data-language="typescript">my_library_free(myString.ptr);

// this is safe because myString is a clone
console.log(myString);
</pre> <span data-as="p">When used in <code>returns</code>, <code>FFIType.cstring</code> coerces the pointer to a JavaScript <code>string</code>. When used in <code>args</code>, <code>FFIType.cstring</code> is identical to <code>ptr</code>.</span> <hr> <h2 id="function-pointers"><span>Function pointers</span></h2> <div data-callout-type="note">

<div data-component-part="callout-content">Async functions are not yet supported</div>
</div> <span data-as="p">To call a function pointer from JavaScript, use <code>CFunction</code>. This is useful if using Node-API (napi) with Bun, and you’ve already loaded some symbols.</span> <pre numberoflines="10" language="typescript" data-language="typescript">import { CFunction } from "bun:ffi";

let myNativeLibraryGetVersion = /* somehow, you got this pointer */

const getVersion = new CFunction({
  returns: "cstring",
  args: [],
  ptr: myNativeLibraryGetVersion,
});
getVersion();
</pre> <span data-as="p">If you have multiple function pointers, you can define them all at once with <code>linkSymbols</code>:</span> <pre numberoflines="29" language="typescript" data-language="typescript">import { linkSymbols } from "bun:ffi";

// getVersionPtrs defined elsewhere
const [majorPtr, minorPtr, patchPtr] = getVersionPtrs();

const lib = linkSymbols({
  // Unlike with dlopen(), the names here can be whatever you want
  getMajor: {
    returns: "cstring",
    args: [],

    // Since this doesn't use dlsym(), you have to provide a valid ptr
    // That ptr could be a number or a bigint
    // An invalid pointer will crash your program.
    ptr: majorPtr,
  },
  getMinor: {
    returns: "cstring",
    args: [],
    ptr: minorPtr,
  },
  getPatch: {
    returns: "cstring",
    args: [],
    ptr: patchPtr,
  },
});

const [major, minor, patch] = [lib.symbols.getMajor(), lib.symbols.getMinor(), lib.symbols.getPatch()];
</pre> <hr> <h2 id="callbacks"><span>Callbacks</span></h2> <span data-as="p">Use <code>JSCallback</code> to create JavaScript callback functions that can be passed to C/FFI functions. The C/FFI function can call into the JavaScript/TypeScript code. This is useful for asynchronous code or whenever you want to call into JavaScript code from C.</span> <pre numberoflines="27" language="typescript" data-language="typescript">import { dlopen, JSCallback, ptr, CString } from "bun:ffi";

const {
  symbols: { search },
  close,
} = dlopen("libmylib", {
  search: {
    returns: "usize",
    args: ["cstring", "callback"],
  },
});

const searchIterator = new JSCallback((ptr, length) =&gt; /hello/.test(new CString(ptr, length)), {
  returns: "bool",
  args: ["ptr", "usize"],
});

const str = Buffer.from("wwutwutwutwutwutwutwutwutwutwutut\0", "utf8");
if (search(ptr(str), searchIterator)) {
  // found a match!
}

// Sometime later:
setTimeout(() =&gt; {
  searchIterator.close();
  close();
}, 5000);
</pre> <span data-as="p">When you’re done with a JSCallback, you should call <code>close()</code> to free the memory.</span> <h3 id="experimental-thread-safe-callbacks"><span>Experimental thread-safe callbacks</span></h3> <span data-as="p"><code>JSCallback</code> has experimental support for thread-safe callbacks. This will be needed if you pass a callback function into a different thread from its instantiation context. You can enable it with the optional <code>threadsafe</code> parameter.</span> <span data-as="p">Currently, thread-safe callbacks work best when run from another thread that is running JavaScript code, i.e. a <a href="workers"><code>Worker</code></a>. A future version of Bun will enable them to be called from any thread (such as new threads spawned by your native library that Bun is not aware of).</span> <pre numberoflines="5" language="typescript" data-language="typescript">const searchIterator = new JSCallback((ptr, length) =&gt; /hello/.test(new CString(ptr, length)), {
  returns: "bool",
  args: ["ptr", "usize"],
  threadsafe: true, // Optional. Defaults to `false`
});
</pre> <div data-callout-type="note">

<div data-component-part="callout-content">
<span data-as="p"><strong>⚡️ Performance tip</strong> — For a slight performance boost, directly pass <code>JSCallback.prototype.ptr</code> instead of the <code>JSCallback</code> object:</span><pre numberoflines="15" language="typescript" data-language="typescript">const onResolve = new JSCallback(arg =&gt; arg === 42, {
  returns: "bool",
  args: ["i32"],
});
const setOnResolve = new CFunction({
  returns: "bool",
  args: ["function"],
  ptr: myNativeLibrarySetOnResolve,
});

// This code runs slightly faster:
setOnResolve(onResolve.ptr);

// Compared to this:
setOnResolve(onResolve);
</pre>
</div>
</div> <hr> <h2 id="pointers"><span>Pointers</span></h2> <span data-as="p">Bun represents <a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)" target="_blank" rel="noreferrer">pointers</a> as a <code>number</code> in JavaScript.</span> <details><summary aria-controls="how-does-a-64-bit-pointer-fit-in-a-javascript-number accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">How does a 64 bit pointer fit in a JavaScript number?</p></div></summary><div id="how-does-a-64-bit-pointer-fit-in-a-javascript-number accordion children" role="region" aria-labelledby="how-does-a-64-bit-pointer-fit-in-a-javascript-number" data-component-part="accordion-content">
<span data-as="p">64-bit processors support up to <a href="https://en.wikipedia.org/wiki/64-bit_computing#Limits_of_processors" target="_blank" rel="noreferrer">52 bits of addressable space</a>. <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format#IEEE_754_double-precision_binary_floating-point_format:_binary64" target="_blank" rel="noreferrer">JavaScript numbers</a> support 53 bits of usable space, so that leaves us with about 11 bits of extra space.</span><span data-as="p"><strong>Why not <code>BigInt</code>?</strong> <code>BigInt</code> is slower. JavaScript engines allocate a separate <code>BigInt</code> which means they can’t fit into a regular JavaScript value. If you pass a <code>BigInt</code> to a function, it will be converted to a <code>number</code></span>
</div></details> <span data-as="p">To convert from a <code>TypedArray</code> to a pointer:</span> <pre numberoflines="3" language="typescript" data-language="typescript">import { ptr } from "bun:ffi";
let myTypedArray = new Uint8Array(32);
const myPtr = ptr(myTypedArray);
</pre> <span data-as="p">To convert from a pointer to an <code>ArrayBuffer</code>:</span> <pre numberoflines="7" language="typescript" data-language="typescript">import { ptr, toArrayBuffer } from "bun:ffi";
let myTypedArray = new Uint8Array(32);
const myPtr = ptr(myTypedArray);

// toArrayBuffer accepts a `byteOffset` and `byteLength`
// if `byteLength` is not provided, it is assumed to be a null-terminated pointer
myTypedArray = new Uint8Array(toArrayBuffer(myPtr, 0, 32), 0, 32);
</pre> <span data-as="p">To read data from a pointer, you have two options. For long-lived pointers, use a <code>DataView</code>:</span> <pre numberoflines="9" language="typescript" data-language="typescript">import { toArrayBuffer } from "bun:ffi";
let myDataView = new DataView(toArrayBuffer(myPtr, 0, 32));

console.log(
  myDataView.getUint8(0, true),
  myDataView.getUint8(1, true),
  myDataView.getUint8(2, true),
  myDataView.getUint8(3, true),
);
</pre> <span data-as="p">For short-lived pointers, use <code>read</code>:</span> <pre numberoflines="9" language="typescript" data-language="typescript">import { read } from "bun:ffi";

console.log(
  // ptr, byteOffset
  read.u8(myPtr, 0),
  read.u8(myPtr, 1),
  read.u8(myPtr, 2),
  read.u8(myPtr, 3),
);
</pre> <span data-as="p">The <code>read</code> function behaves similarly to <code>DataView</code>, but it’s usually faster because it doesn’t need to create a <code>DataView</code> or <code>ArrayBuffer</code>.</span> <div data-table-wrapper="true"><div><table> <thead><tr>
<th><code>FFIType</code></th>
<th>
<code>read</code> function</th>
</tr></thead> <tbody>
<tr>
<td>ptr</td>
<td><code>read.ptr</code></td>
</tr>
<tr>
<td>i8</td>
<td><code>read.i8</code></td>
</tr>
<tr>
<td>i16</td>
<td><code>read.i16</code></td>
</tr>
<tr>
<td>i32</td>
<td><code>read.i32</code></td>
</tr>
<tr>
<td>i64</td>
<td><code>read.i64</code></td>
</tr>
<tr>
<td>u8</td>
<td><code>read.u8</code></td>
</tr>
<tr>
<td>u16</td>
<td><code>read.u16</code></td>
</tr>
<tr>
<td>u32</td>
<td><code>read.u32</code></td>
</tr>
<tr>
<td>u64</td>
<td><code>read.u64</code></td>
</tr>
<tr>
<td>f32</td>
<td><code>read.f32</code></td>
</tr>
<tr>
<td>f64</td>
<td><code>read.f64</code></td>
</tr>
</tbody> </table></div></div> <h3 id="memory-management"><span>Memory management</span></h3> <span data-as="p"><code>bun:ffi</code> does not manage memory for you. You must free the memory when you’re done with it.</span> <h4 id="from-javascript"><span>From JavaScript</span></h4> <span data-as="p">If you want to track when a <code>TypedArray</code> is no longer in use from JavaScript, you can use a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry" target="_blank" rel="noreferrer">FinalizationRegistry</a>.</span> <h4 id="from-c,-rust,-zig,-etc"><span>From C, Rust, Zig, etc</span></h4> <span data-as="p">If you want to track when a <code>TypedArray</code> is no longer in use from C or FFI, you can pass a callback and an optional context pointer to <code>toArrayBuffer</code> or <code>toBuffer</code>. This function is called at some point later, once the garbage collector frees the underlying <code>ArrayBuffer</code> JavaScript object.</span> <span data-as="p">The expected signature is the same as in <a href="https://developer.apple.com/documentation/javascriptcore/jstypedarraybytesdeallocator?language=objc" target="_blank" rel="noreferrer">JavaScriptCore’s C API</a>:</span> <pre numberoflines="1" language="c" data-language="typescript">typedef void (*JSTypedArrayBytesDeallocator)(void *bytes, void *deallocatorContext);
</pre> <pre numberoflines="26" language="typescript" data-language="typescript">import { toArrayBuffer } from "bun:ffi";

// with a deallocatorContext:
toArrayBuffer(
  bytes,
  byteOffset,

  byteLength,

  // this is an optional pointer to a callback
  deallocatorContext,

  // this is a pointer to a function
  jsTypedArrayBytesDeallocator,
);

// without a deallocatorContext:
toArrayBuffer(
  bytes,
  byteOffset,

  byteLength,

  // this is a pointer to a function
  jsTypedArrayBytesDeallocator,
);
</pre> <h3 id="memory-safety"><span>Memory safety</span></h3> <span data-as="p">Using raw pointers outside of FFI is extremely not recommended. A future version of Bun may add a CLI flag to disable <code>bun:ffi</code>.</span> <h3 id="pointer-alignment"><span>Pointer alignment</span></h3> <span data-as="p">If an API expects a pointer sized to something other than <code>char</code> or <code>u8</code>, make sure the <code>TypedArray</code> is also that size. A <code>u64*</code> is not exactly the same as <code>[8]u8*</code> due to alignment.</span> <h3 id="passing-a-pointer"><span>Passing a pointer</span></h3> <span data-as="p">Where FFI functions expect a pointer, pass a <code>TypedArray</code> of equivalent size:</span> <pre numberoflines="23" language="typescript" data-language="typescript">import { dlopen, FFIType } from "bun:ffi";

const {
  symbols: { encode_png },
} = dlopen(myLibraryPath, {
  encode_png: {
    // FFIType's can be specified as strings too
    args: ["ptr", "u32", "u32"],
    returns: FFIType.ptr,
  },
});

const pixels = new Uint8ClampedArray(128 * 128 * 4);
pixels.fill(254);
pixels.subarray(0, 32 * 32 * 2).fill(0);

const out = encode_png(
  // pixels will be passed as a pointer
  pixels,

  128,
  128,
);
</pre> <span data-as="p">The <a href="https://github.com/oven-sh/bun/blob/6a65631cbdcae75bfa1e64323a6ad613a922cd1a/src/bun.js/ffi.exports.js#L180-L182" target="_blank" rel="noreferrer">auto-generated wrapper</a> converts the pointer to a <code>TypedArray</code>.</span> <details><summary aria-controls="hardmode accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">Hardmode</p></div></summary><div id="hardmode accordion children" role="region" aria-labelledby="hardmode" data-component-part="accordion-content">
<span data-as="p">If you don’t want the automatic conversion or you want a pointer to a specific byte offset within the <code>TypedArray</code>, you can also directly get the pointer to the <code>TypedArray</code>:</span><pre numberoflines="25" language="typescript" data-language="typescript">import { dlopen, FFIType, ptr } from "bun:ffi";

const {
  symbols: { encode_png },
} = dlopen(myLibraryPath, {
  encode_png: {
    // FFIType's can be specified as strings too
    args: ["ptr", "u32", "u32"],
    returns: FFIType.ptr,
  },
});

const pixels = new Uint8ClampedArray(128 * 128 * 4);
pixels.fill(254);

// this returns a number! not a BigInt!
const myPtr = ptr(pixels);

const out = encode_png(
  myPtr,

  // dimensions:
  128,
  128,
);
</pre>
</div></details> <h3 id="reading-pointers"><span>Reading pointers</span></h3> <pre numberoflines="14" language="typescript" data-language="typescript">const out = encode_png(
  // pixels will be passed as a pointer
  pixels,

  // dimensions:
  128,
  128,
);

// assuming it is 0-terminated, it can be read like this:
let png = new Uint8Array(toArrayBuffer(out));

// save it to disk:
await Bun.write("out.png", png);
</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/ffi" class="_attribution-link">https://bun.com/docs/runtime/ffi</a>
  </p>
</div>
