<h1 id="header">Workers</h1>
<div data-page-title="Workers" data-page-href="/runtime/workers" id="content">
<div data-callout-type="warning">

<div data-component-part="callout-content"><span data-as="p">The <code>Worker</code> API is still experimental (particularly for terminating workers). We are actively working on improving this.</span></div>
</div> <span data-as="p"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker" target="_blank" rel="noreferrer"><code>Worker</code></a> lets you start and communicate with a new JavaScript instance running on a separate thread while sharing I/O resources with the main thread.</span> <span data-as="p">Bun implements a minimal version of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API" target="_blank" rel="noreferrer">Web Workers API</a> with extensions that make it work better for server-side use cases. Like the rest of Bun, <code>Worker</code> in Bun support CommonJS, ES Modules, TypeScript, JSX, TSX and more out of the box. No extra build steps are necessary.</span> <h2 id="creating-a-worker"><span>Creating a <code>Worker</code></span></h2> <span data-as="p">Like in browsers, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker" target="_blank" rel="noreferrer"><code>Worker</code></a> is a global. Use it to create a new worker thread.</span> <h3 id="from-the-main-thread"><span>From the main thread</span></h3> <pre numberoflines="6" language="typescript" data-language="typescript">const worker = new Worker("./worker.ts");

worker.postMessage("hello");
worker.onmessage = event =&gt; {
  console.log(event.data);
};
</pre> <h3 id="worker-thread"><span>Worker thread</span></h3> <pre numberoflines="7" language="typescript" data-language="typescript">// prevents TS errors
declare var self: Worker;

self.onmessage = (event: MessageEvent) =&gt; {
  console.log(event.data);
  postMessage("world");
};
</pre> <span data-as="p">To prevent TypeScript errors when using <code>self</code>, add this line to the top of your worker file.</span> <pre numberoflines="1" language="typescript" data-language="typescript">declare var self: Worker;
</pre> <span data-as="p">You can use <code>import</code> and <code>export</code> syntax in your worker code. Unlike in browsers, there’s no need to specify <code>{type: "module"}</code> to use ES Modules.</span> <span data-as="p">To simplify error handling, the initial script to load is resolved at the time <code>new Worker(url)</code> is called.</span> <pre numberoflines="2" language="javascript" data-language="typescript">const worker = new Worker("/not-found.js");
// throws an error immediately
</pre> <span data-as="p">The specifier passed to <code>Worker</code> is resolved relative to the project root (like typing <code>bun ./path/to/file.js</code>).</span> <h3 id="preload-load-modules-before-the-worker-starts"><span><code>preload</code> - load modules before the worker starts</span></h3> <span data-as="p">You can pass an array of module specifiers to the <code>preload</code> option to load modules before the worker starts. This is useful when you want to ensure some code is always loaded before the application starts, like loading OpenTelemetry, Sentry, DataDog, etc.</span> <pre numberoflines="3" language="typescript" data-language="typescript">const worker = new Worker("./worker.ts", {
  preload: ["./load-sentry.js"],
});
</pre> <span data-as="p">Like the <code>--preload</code> CLI argument, the <code>preload</code> option is processed before the worker starts.</span> <span data-as="p">You can also pass a single string to the <code>preload</code> option:</span> <pre numberoflines="3" language="typescript" data-language="typescript">const worker = new Worker("./worker.ts", {
  preload: "./load-sentry.js",
});
</pre> <h3 id="blob:-urls"><span><code>blob:</code> URLs</span></h3> <span data-as="p">You can also pass a <code>blob:</code> URL to <code>Worker</code>. This is useful for creating workers from strings or other sources.</span> <pre numberoflines="5" language="javascript" data-language="typescript">const blob = new Blob([`self.onmessage = (event: MessageEvent) =&gt; postMessage(event.data)`], {
  type: "application/typescript",
});
const url = URL.createObjectURL(blob);
const worker = new Worker(url);
</pre> <span data-as="p">Like the rest of Bun, workers created from <code>blob:</code> URLs support TypeScript, JSX, and other file types out of the box. You can communicate it should be loaded via typescript either via <code>type</code> or by passing a <code>filename</code> to the <code>File</code> constructor.</span> <pre numberoflines="3" language="typescript" data-language="typescript">const file = new File([`self.onmessage = (event: MessageEvent) =&gt; postMessage(event.data)`], "worker.ts");
const url = URL.createObjectURL(file);
const worker = new Worker(url);
</pre> <h3 id='"open"'><span><code>"open"</code></span></h3> <span data-as="p">The <code>"open"</code> event is emitted when a worker is created and ready to receive messages. This can be used to send an initial message to a worker once it’s ready. (This event does not exist in browsers.)</span> <pre numberoflines="5" language="typescript" data-language="typescript">const worker = new Worker(new URL("worker.ts", import.meta.url).href);

worker.addEventListener("open", () =&gt; {
  console.log("worker is ready");
});
</pre> <span data-as="p">Messages are automatically enqueued until the worker is ready, so there is no need to wait for the <code>"open"</code> event to send messages.</span> <h2 id="messages-with-postmessage"><span>Messages with <code>postMessage</code></span></h2> <span data-as="p">To send messages, use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage" target="_blank" rel="noreferrer"><code>worker.postMessage</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" target="_blank" rel="noreferrer"><code>self.postMessage</code></a>. This leverages the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm" target="_blank" rel="noreferrer">HTML Structured Clone Algorithm</a>.</span> <h3 id="performance-optimizations"><span>Performance optimizations</span></h3> <span data-as="p">Bun includes optimized fast paths for <code>postMessage</code> to dramatically improve performance for common data types:</span> <span data-as="p"><strong>String fast path</strong> - When posting pure string values, Bun bypasses the structured clone algorithm entirely, achieving significant performance gains with no serialization overhead.</span> <span data-as="p"><strong>Simple object fast path</strong> - For plain objects containing only primitive values (strings, numbers, booleans, null, undefined), Bun uses an optimized serialization path that stores properties directly without full structured cloning.</span> <span data-as="p">The simple object fast path activates when the object:</span> <ul> <li>Is a plain object with no prototype chain modifications</li> <li>Contains only enumerable, configurable data properties</li> <li>Has no indexed properties or getter/setter methods</li> <li>All property values are primitives or strings</li> </ul> <span data-as="p">With these fast paths, Bun’s <code>postMessage</code> performs <strong>2-241x faster</strong> because the message length no longer has a meaningful impact on performance.</span> <span data-as="p"><strong>Bun (with fast paths):</strong></span> <pre numberoflines="3" language="typescript" data-language="typescript">postMessage({ prop: 11 chars string, ...9 more props }) - 648ns
postMessage({ prop: 14 KB string, ...9 more props })    - 719ns
postMessage({ prop: 3 MB string, ...9 more props })     - 1.26µs
</pre> <span data-as="p"><strong>Node.js v24.6.0 (for comparison):</strong></span> <pre numberoflines="3" language="javascript" data-language="typescript">postMessage({ prop: 11 chars string, ...9 more props }) - 1.19µs
postMessage({ prop: 14 KB string, ...9 more props })    - 2.69µs
postMessage({ prop: 3 MB string, ...9 more props })     - 304µs
</pre> <pre numberoflines="17" language="javascript" data-language="typescript">// String fast path - optimized
postMessage("Hello, worker!");

// Simple object fast path - optimized
postMessage({
  message: "Hello",
  count: 42,
  enabled: true,
  data: null,
});

// Complex objects still work but use standard structured clone
postMessage({
  nested: { deep: { object: true } },
  date: new Date(),
  buffer: new ArrayBuffer(8),
});
</pre> <pre numberoflines="5" language="javascript" data-language="typescript">// On the worker thread, `postMessage` is automatically "routed" to the parent thread.
postMessage({ hello: "world" });

// On the main thread
worker.postMessage({ hello: "world" });
</pre> <span data-as="p">To receive messages, use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/message_event" target="_blank" rel="noreferrer"><code>message</code> event handler</a> on the worker and main thread.</span> <pre numberoflines="13" language="javascript" data-language="typescript">// Worker thread:
self.addEventListener("message", event =&gt; {
  console.log(event.data);
});
// or use the setter:
// self.onmessage = fn

// if on the main thread
worker.addEventListener("message", event =&gt; {
  console.log(event.data);
});
// or use the setter:
// worker.onmessage = fn
</pre> <h2 id="terminating-a-worker"><span>Terminating a worker</span></h2> <span data-as="p">A <code>Worker</code> instance terminates automatically once it’s event loop has no work left to do. Attaching a <code>"message"</code> listener on the global or any <code>MessagePort</code>s will keep the event loop alive. To forcefully terminate a <code>Worker</code>, call <code>worker.terminate()</code>.</span> <pre numberoflines="4" language="typescript" data-language="typescript">const worker = new Worker(new URL("worker.ts", import.meta.url).href);

// ...some time later
worker.terminate();
</pre> <span data-as="p">This will cause the worker’s to exit as soon as possible.</span> <h3 id="process-exit"><span><code>process.exit()</code></span></h3> <span data-as="p">A worker can terminate itself with <code>process.exit()</code>. This does not terminate the main process. Like in Node.js, <code>process.on('beforeExit', callback)</code> and <code>process.on('exit', callback)</code> are emitted on the worker thread (and not on the main thread), and the exit code is passed to the <code>"close"</code> event.</span> <h3 id='"close"'><span><code>"close"</code></span></h3> <span data-as="p">The <code>"close"</code> event is emitted when a worker has been terminated. It can take some time for the worker to actually terminate, so this event is emitted when the worker has been marked as terminated. The <code>CloseEvent</code> will contain the exit code passed to <code>process.exit()</code>, or 0 if closed for other reasons.</span> <pre numberoflines="5" language="typescript" data-language="typescript">const worker = new Worker(new URL("worker.ts", import.meta.url).href);

worker.addEventListener("close", event =&gt; {
  console.log("worker is being closed");
});
</pre> <span data-as="p">This event does not exist in browsers.</span> <h2 id="managing-lifetime"><span>Managing lifetime</span></h2> <span data-as="p">By default, an active <code>Worker</code> will keep the main (spawning) process alive, so async tasks like <code>setTimeout</code> and promises will keep the process alive. Attaching <code>message</code> listeners will also keep the <code>Worker</code> alive.</span> <h3 id="worker-unref"><span><code>worker.unref()</code></span></h3> <span data-as="p">To stop a running worker from keeping the process alive, call <code>worker.unref()</code>. This decouples the lifetime of the worker to the lifetime of the main process, and is equivalent to what Node.js’ <code>worker_threads</code> does.</span> <pre numberoflines="2" language="typescript" data-language="typescript">const worker = new Worker(new URL("worker.ts", import.meta.url).href);
worker.unref();
</pre> <span data-as="p">Note: <code>worker.unref()</code> is not available in browsers.</span> <h3 id="worker-ref"><span><code>worker.ref()</code></span></h3> <span data-as="p">To keep the process alive until the <code>Worker</code> terminates, call <code>worker.ref()</code>. A ref’d worker is the default behavior, and still needs something going on in the event loop (such as a <code>"message"</code> listener) for the worker to continue running.</span> <pre numberoflines="4" language="typescript" data-language="typescript">const worker = new Worker(new URL("worker.ts", import.meta.url).href);
worker.unref();
// later...
worker.ref();
</pre> <span data-as="p">Alternatively, you can also pass an <code>options</code> object to <code>Worker</code>:</span> <pre numberoflines="3" language="typescript" data-language="typescript">const worker = new Worker(new URL("worker.ts", import.meta.url).href, {
  ref: false,
});
</pre> <span data-as="p">Note: <code>worker.ref()</code> is not available in browsers.</span> <h2 id="memory-usage-with-smol"><span>Memory usage with <code>smol</code></span></h2> <span data-as="p">JavaScript instances can use a lot of memory. Bun’s <code>Worker</code> supports a <code>smol</code> mode that reduces memory usage, at a cost of performance. To enable <code>smol</code> mode, pass <code>smol: true</code> to the <code>options</code> object in the <code>Worker</code> constructor.</span> <pre numberoflines="3" language="typescript" data-language="typescript">const worker = new Worker("./i-am-smol.ts", {
  smol: true,
});
</pre> <details><summary aria-controls="what-does-smol-mode-actually-do accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">What does `smol` mode actually do?</p></div></summary><div id="what-does-smol-mode-actually-do accordion children" role="region" aria-labelledby="what-does-smol-mode-actually-do" data-component-part="accordion-content"><span data-as="p">Setting <code>smol: true</code> sets <code>JSC::HeapSize</code> to be <code>Small</code> instead of the default <code>Large</code>.</span></div></details> <h2 id="environment-data"><span>Environment Data</span></h2> <span data-as="p">Share data between the main thread and workers using <code>setEnvironmentData()</code> and <code>getEnvironmentData()</code>.</span> <pre numberoflines="8" language="typescript" data-language="typescript">import { setEnvironmentData, getEnvironmentData } from "worker_threads";

// In main thread
setEnvironmentData("config", { apiUrl: "https://api.example.com" });

// In worker
const config = getEnvironmentData("config");
console.log(config); // =&gt; { apiUrl: "https://api.example.com" }
</pre> <h2 id="worker-events"><span>Worker Events</span></h2> <span data-as="p">Listen for worker creation events using <code>process.emit()</code>:</span> <pre numberoflines="3" language="typescript" data-language="typescript">process.on("worker", worker =&gt; {
  console.log("New worker created:", worker.threadId);
});
</pre> <h2 id="bun-ismainthread"><span><code>Bun.isMainThread</code></span></h2> <span data-as="p">You can check if you’re in the main thread by checking <code>Bun.isMainThread</code>.</span> <pre numberoflines="5" language="typescript" data-language="typescript">if (Bun.isMainThread) {
  console.log("I'm the main thread");
} else {
  console.log("I'm in a worker");
}
</pre> <span data-as="p">This is useful for conditionally running code based on whether you’re in the main thread or not.</span>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/workers" class="_attribution-link">https://bun.com/docs/runtime/workers</a>
  </p>
</div>
