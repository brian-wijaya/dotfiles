<h1 id="header">C Compiler</h1>
<div data-page-title="C Compiler" data-page-href="/runtime/c-compiler" id="content">
<span data-as="p"><code>bun:ffi</code> has experimental support for compiling and running C from JavaScript with low overhead.</span> <hr> <h2 id="usage-cc-in-bun:ffi"><span>Usage (cc in <code>bun:ffi</code>)</span></h2> <span data-as="p">See the <a href="https://bun.com/blog/compile-and-run-c-in-js" target="_blank" rel="noreferrer">introduction blog post</a> for more information.</span> <span data-as="p">JavaScript:</span> <pre numberoflines="16" language="typescript" data-language="typescript">import { cc } from "bun:ffi";
import source from "./hello.c" with { type: "file" };

const {
  symbols: { hello },
} = cc({
  source,
  symbols: {
    hello: {
      args: [],
      returns: "int",
    },
  },
});

console.log("What is the answer to the universe?", hello());
</pre> <span data-as="p">C source:</span> <pre numberoflines="3" language="c" data-language="typescript">int hello() {
  return 42;
}
</pre> <span data-as="p">When you run <code>hello.js</code>, it will print:</span> <pre numberoflines="2" language="shellscript" data-language="typescript">bun hello.js
What is the answer to the universe? 42
</pre> <span data-as="p">Under the hood, <code>cc</code> uses <a href="https://bellard.org/tcc/" target="_blank" rel="noreferrer">TinyCC</a> to compile the C code and then link it with the JavaScript runtime, efficiently converting types in-place.</span> <h3 id="primitive-types"><span>Primitive types</span></h3> <span data-as="p">The same <code>FFIType</code> values in <a href="ffi"><code>dlopen</code></a> are supported in <code>cc</code>.</span> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th><code>FFIType</code></th>
<th>C Type</th>
<th>Aliases</th>
</tr></thead>
<tbody>
<tr>
<td>cstring</td>
<td><code>char*</code></td>
<td></td>
</tr>
<tr>
<td>function</td>
<td><code>(void*)(*)()</code></td>
<td>
<code>fn</code>, <code>callback</code>
</td>
</tr>
<tr>
<td>ptr</td>
<td><code>void*</code></td>
<td>
<code>pointer</code>, <code>void*</code>, <code>char*</code>
</td>
</tr>
<tr>
<td>i8</td>
<td><code>int8_t</code></td>
<td><code>int8_t</code></td>
</tr>
<tr>
<td>i16</td>
<td><code>int16_t</code></td>
<td><code>int16_t</code></td>
</tr>
<tr>
<td>i32</td>
<td><code>int32_t</code></td>
<td>
<code>int32_t</code>, <code>int</code>
</td>
</tr>
<tr>
<td>i64</td>
<td><code>int64_t</code></td>
<td><code>int64_t</code></td>
</tr>
<tr>
<td>i64_fast</td>
<td><code>int64_t</code></td>
<td></td>
</tr>
<tr>
<td>u8</td>
<td><code>uint8_t</code></td>
<td><code>uint8_t</code></td>
</tr>
<tr>
<td>u16</td>
<td><code>uint16_t</code></td>
<td><code>uint16_t</code></td>
</tr>
<tr>
<td>u32</td>
<td><code>uint32_t</code></td>
<td><code>uint32_t</code></td>
</tr>
<tr>
<td>u64</td>
<td><code>uint64_t</code></td>
<td><code>uint64_t</code></td>
</tr>
<tr>
<td>u64_fast</td>
<td><code>uint64_t</code></td>
<td></td>
</tr>
<tr>
<td>f32</td>
<td><code>float</code></td>
<td><code>float</code></td>
</tr>
<tr>
<td>f64</td>
<td><code>double</code></td>
<td><code>double</code></td>
</tr>
<tr>
<td>bool</td>
<td><code>bool</code></td>
<td></td>
</tr>
<tr>
<td>char</td>
<td><code>char</code></td>
<td></td>
</tr>
<tr>
<td>napi_env</td>
<td><code>napi_env</code></td>
<td></td>
</tr>
<tr>
<td>napi_value</td>
<td><code>napi_value</code></td>
<td></td>
</tr>
</tbody>
</table></div></div> <h3 id="strings,-objects,-and-non-primitive-types"><span>Strings, objects, and non-primitive types</span></h3> <span data-as="p">To make it easier to work with strings, objects, and other non-primitive types that donâ€™t map 1:1 to C types, <code>cc</code> supports N-API.</span> <span data-as="p">To pass or receive a JavaScript values without any type conversions from a C function, you can use <code>napi_value</code>.</span> <span data-as="p">You can also pass a <code>napi_env</code> to receive the N-API environment used to call the JavaScript function.</span> <h4 id="returning-a-c-string-to-javascript"><span>Returning a C string to JavaScript</span></h4> <span data-as="p">For example, if you have a string in C, you can return it to JavaScript like this:</span> <pre numberoflines="16" language="typescript" data-language="typescript">import { cc } from "bun:ffi";
import source from "./hello.c" with { type: "file" };

const {
  symbols: { hello },
} = cc({
  source,
  symbols: {
    hello: {
      args: ["napi_env"],
      returns: "napi_value",
    },
  },
});

const result = hello();
</pre> <span data-as="p">And in C:</span> <pre numberoflines="7" language="c" data-language="typescript">#include &lt;node/node_api.h&gt;

napi_value hello(napi_env env) {
  napi_value result;
  napi_create_string_utf8(env, "Hello, Napi!", NAPI_AUTO_LENGTH, &amp;result);
  return result;
}
</pre> <span data-as="p">You can also use this to return other types like objects and arrays:</span> <pre numberoflines="7" language="c" data-language="typescript">#include &lt;node/node_api.h&gt;

napi_value hello(napi_env env) {
  napi_value result;
  napi_create_object(env, &amp;result);
  return result;
}
</pre> <h3 id="cc-reference"><span><code>cc</code> Reference</span></h3> <h4 id="library:-string[]"><span><code>library: string[]</code></span></h4> <span data-as="p">The <code>library</code> array is used to specify the libraries that should be linked with the C code.</span> <pre numberoflines="6" language="typescript" data-language="typescript">type Library = string[];

cc({
  source: "hello.c",
  library: ["sqlite3"],
});
</pre> <h4 id="symbols"><span><code>symbols</code></span></h4> <span data-as="p">The <code>symbols</code> object is used to specify the functions and variables that should be exposed to JavaScript.</span> <pre numberoflines="6" language="typescript" data-language="typescript">type Symbols = {
  [key: string]: {
    args: FFIType[];
    returns: FFIType;
  };
};
</pre> <h4 id="source"><span><code>source</code></span></h4> <span data-as="p">The <code>source</code> is a file path to the C code that should be compiled and linked with the JavaScript runtime.</span> <pre numberoflines="11" language="typescript" data-language="typescript">type Source = string | URL | BunFile;

cc({
  source: "hello.c",
  symbols: {
    hello: {
      args: [],
      returns: "int",
    },
  },
});
</pre> <h4 id="flags:-string-|-string[]"><span><code>flags: string | string[]</code></span></h4> <span data-as="p">The <code>flags</code> is an optional array of strings that should be passed to the TinyCC compiler.</span> <pre numberoflines="1" language="typescript" data-language="typescript">type Flags = string | string[];
</pre> <span data-as="p">These are flags like <code>-I</code> for include directories and <code>-D</code> for preprocessor definitions.</span> <h4 id="define:-record&lt;string,-string&gt;"><span><code>define: Record&lt;string, string&gt;</code></span></h4> <span data-as="p">The <code>define</code> is an optional object that should be passed to the TinyCC compiler.</span> <pre numberoflines="8" language="typescript" data-language="typescript">type Defines = Record&lt;string, string&gt;;

cc({
  source: "hello.c",
  define: {
    NDEBUG: "1",
  },
});
</pre> <span data-as="p">These are preprocessor definitions passed to the TinyCC compiler.</span>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/c-compiler" class="_attribution-link">https://bun.com/docs/runtime/c-compiler</a>
  </p>
</div>
