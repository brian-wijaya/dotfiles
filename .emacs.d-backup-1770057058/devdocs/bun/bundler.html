<h1 id="header">Bundler</h1>
<div data-page-title="Bundler" data-page-href="/bundler/index" id="content">
<span data-as="p">Bun’s fast native bundler can be used via the <code>bun build</code> CLI command or the <code>Bun.build()</code> JavaScript API.</span> <h3 id="at-a-glance"><span>At a Glance</span></h3> <ul> <li>JS API: <code>await Bun.build({ entrypoints, outdir })</code>
</li> <li>CLI: <code>bun build &lt;entry&gt; --outdir ./out</code>
</li> <li>Watch: <code>--watch</code> for incremental rebuilds</li> <li>Targets: <code>--target browser|bun|node</code>
</li> <li>Formats: <code>--format esm|cjs|iife</code> (experimental for cjs/iife)</li> </ul> <div id="javascript">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript" role="tab" aria-selected="true" aria-controls="panel-javascript-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli" role="tab" aria-selected="false" aria-controls="panel-cli-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-0" role="tabpanel" aria-labelledby="javascript" data-component-part="tab-content"><pre numberoflines="4" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './build',
});
</pre></div>
<div id="panel-cli-1" role="tabpanel" aria-labelledby="cli" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./build
</pre></div>
</div>
</div> <span data-as="p">It’s fast. The numbers below represent performance on esbuild’s <a href="https://github.com/oven-sh/bun/tree/main/bench/bundle" target="_blank" rel="noreferrer">three.js benchmark</a>.</span>  <h2 id="why-bundle"><span>Why bundle?</span></h2> <span data-as="p">The bundler is a key piece of infrastructure in the JavaScript ecosystem. As a brief overview of why bundling is so important:</span> <ul> <li>
<strong>Reducing HTTP requests.</strong> A single package in <code>node_modules</code> may consist of hundreds of files, and large applications may have dozens of such dependencies. Loading each of these files with a separate HTTP request becomes untenable very quickly, so bundlers are used to convert our application source code into a smaller number of self-contained “bundles” that can be loaded with a single request.</li> <li>
<strong>Code transforms.</strong> Modern apps are commonly built with languages or tools like TypeScript, JSX, and CSS modules, all of which must be converted into plain JavaScript and CSS before they can be consumed by a browser. The bundler is the natural place to configure these transformations.</li> <li>
<strong>Framework features.</strong> Frameworks rely on bundler plugins &amp; code transformations to implement common patterns like file-system routing, client-server code co-location (think <code>getServerSideProps</code> or Remix loaders), and server components.</li> <li>
<strong>Full-stack Applications.</strong> Bun’s bundler can handle both server and client code in a single command, enabling optimized production builds and single-file executables. With build-time HTML imports, you can bundle your entire application — frontend assets and backend server — into a single deployable unit.</li> </ul> <span data-as="p">Let’s jump into the bundler API.</span> <div data-callout-type="note">

<div data-component-part="callout-content">The Bun bundler is not intended to replace <code>tsc</code> for typechecking or generating type declarations.</div>
</div> <h2 id="basic-example"><span>Basic example</span></h2> <span data-as="p">Let’s build our first bundle. You have the following two files, which implement a simple client-side rendered React app.</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">index.tsxComponent.tsximport * as ReactDOM from "react-dom/client";
import { Component } from "./Component";

const root = ReactDOM.createRoot(document.getElementById("root")!);
root.render(&lt;Component message="Sup!" /&gt;);
</pre> <span data-as="p">Here, <code>index.tsx</code> is the “entrypoint” to our application. Commonly, this will be a script that performs some side effect, like starting a server or—in this case—initializing a React root. Because we’re using TypeScript &amp; JSX, we need to bundle our code before it can be sent to the browser.</span> <span data-as="p">To create our bundle:</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">build.tsterminalawait Bun.build({
  entrypoints: ["./index.tsx"],
  outdir: "./out",
});
</pre> <span data-as="p">For each file specified in <code>entrypoints</code>, Bun will generate a new bundle. This bundle will be written to disk in the <code>./out</code> directory (as resolved from the current working directory). After running the build, the file system looks like this:</span> <pre numberoflines="6" language="text" data-language="typescript">.
├── index.tsx
├── Component.tsx
└── out
    └── index.js
</pre> <span data-as="p">The contents of <code>out/index.js</code> will look something like this:</span> <pre numberoflines="35" language="javascript" data-language="typescript">// out/index.js
// ...
// ~20k lines of code
// including the contents of `react-dom/client` and all its dependencies
// this is where the $jsxDEV and $createRoot functions are defined

// Component.tsx
function Component(props) {
  return $jsxDEV(
    "p",
    {
      children: props.message,
    },
    undefined,
    false,
    undefined,
    this,
  );
}

// index.tsx
var rootNode = document.getElementById("root");
var root = $createRoot(rootNode);
root.render(
  $jsxDEV(
    Component,
    {
      message: "Sup!",
    },
    undefined,
    false,
    undefined,
    this,
  ),
);
</pre> <h2 id="watch-mode"><span>Watch mode</span></h2> <span data-as="p">Like the runtime and test runner, the bundler supports watch mode natively.</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --watch
</pre> <h2 id="content-types"><span>Content types</span></h2> <span data-as="p">Like the Bun runtime, the bundler supports an array of file types out of the box. The following table breaks down the bundler’s set of standard “loaders”. Refer to <a href="bundler/loaders">Bundler &gt; File types</a> for full documentation.</span> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Extensions</th>
<th>Details</th>
</tr></thead>
<tbody>
<tr>
<td>
<code>.js</code> <code>.jsx</code> <code>.cjs</code> <code>.mjs</code> <code>.mts</code> <code>.cts</code> <code>.ts</code> <code>.tsx</code>
</td>
<td>Uses Bun’s built-in transpiler to parse the file and transpile TypeScript/JSX syntax to vanilla JavaScript. The bundler executes a set of default transforms including dead code elimination and tree shaking. At the moment Bun does not attempt to down-convert syntax; if you use recently ECMAScript syntax, that will be reflected in the bundled code.</td>
</tr>
<tr>
<td><code>.json</code></td>
<td>JSON files are parsed and inlined into the bundle as a JavaScript object.<br><br><code>js&lt;br/&gt;import pkg from "./package.json";&lt;br/&gt;pkg.name; // =&gt; "my-package"&lt;br/&gt;</code>
</td>
</tr>
<tr>
<td><code>.jsonc</code></td>
<td>JSON with comments. Files are parsed and inlined into the bundle as a JavaScript object.<br><br><code>js&lt;br/&gt;import config from "./config.jsonc";&lt;br/&gt;config.name; // =&gt; "my-config"&lt;br/&gt;</code>
</td>
</tr>
<tr>
<td><code>.toml</code></td>
<td>TOML files are parsed and inlined into the bundle as a JavaScript object.<br><br><code>js&lt;br/&gt;import config from "./bunfig.toml";&lt;br/&gt;config.logLevel; // =&gt; "debug"&lt;br/&gt;</code>
</td>
</tr>
<tr>
<td>
<code>.yaml</code> <code>.yml</code>
</td>
<td>YAML files are parsed and inlined into the bundle as a JavaScript object.<br><br><code>js&lt;br/&gt;import config from "./config.yaml";&lt;br/&gt;config.name; // =&gt; "my-app"&lt;br/&gt;</code>
</td>
</tr>
<tr>
<td><code>.txt</code></td>
<td>The contents of the text file are read and inlined into the bundle as a string.<br><br><code>js&lt;br/&gt;import contents from "./file.txt";&lt;br/&gt;console.log(contents); // =&gt; "Hello, world!"&lt;br/&gt;</code>
</td>
</tr>
<tr>
<td><code>.html</code></td>
<td>HTML files are processed and any referenced assets (scripts, stylesheets, images) are bundled.</td>
</tr>
<tr>
<td><code>.css</code></td>
<td>CSS files are bundled together into a single <code>.css</code> file in the output directory.</td>
</tr>
<tr>
<td>
<code>.node</code> <code>.wasm</code>
</td>
<td>These files are supported by the Bun runtime, but during bundling they are treated as assets.</td>
</tr>
</tbody>
</table></div></div> <h3 id="assets"><span>Assets</span></h3> <span data-as="p">If the bundler encounters an import with an unrecognized extension, it treats the imported file as an external file. The referenced file is copied as-is into <code>outdir</code>, and the import is resolved as a path to the file.</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">InputOutput// bundle entrypoint
import logo from "./logo.svg";
console.log(logo);
</pre> <span data-as="p">The exact behavior of the file loader is also impacted by <a href="#naming"><code>naming</code></a> and <a href="#publicpath"><code>publicPath</code></a>.</span> <div data-callout-type="info">

<div data-component-part="callout-content">Refer to the <a href="bundler/loaders">Bundler &gt; Loaders</a> page for more complete documentation on the file loader.</div>
</div> <h3 id="plugins"><span>Plugins</span></h3> <span data-as="p">The behavior described in this table can be overridden or extended with plugins. Refer to the <a href="bundler/loaders">Bundler &gt; Loaders</a> page for complete documentation.</span> <h2 id="api"><span>API</span></h2> <h3 id="entrypoints"><span>entrypoints</span></h3> <span data-shape="rounded" data-stroke="false" data-disabled="false">Required</span> <span data-as="p">An array of paths corresponding to the entrypoints of our application. One bundle will be generated for each entrypoint.</span> <div id="javascript-2">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-2" role="tab" aria-selected="true" aria-controls="panel-javascript-2-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-2" role="tab" aria-selected="false" aria-controls="panel-cli-2-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-2-0" role="tabpanel" aria-labelledby="javascript-2" data-component-part="tab-content"><pre numberoflines="4" language="typescript" data-language="typescript">const result = await Bun.build({
  entrypoints: ["./index.ts"],
});
// =&gt; { success: boolean, outputs: BuildArtifact[], logs: BuildMessage[] }
</pre></div>
<div id="panel-cli-2-1" role="tabpanel" aria-labelledby="cli-2" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.ts
</pre></div>
</div>
</div> <h3 id="outdir"><span>outdir</span></h3> <span data-as="p">The directory where output files will be written.</span> <div id="javascript-3">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-3" role="tab" aria-selected="true" aria-controls="panel-javascript-3-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-3" role="tab" aria-selected="false" aria-controls="panel-cli-3-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-3-0" role="tabpanel" aria-labelledby="javascript-3" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">const result = await Bun.build({
  entrypoints: ['./index.ts'],
  outdir: './out'
});
// =&gt; { success: boolean, outputs: BuildArtifact[], logs: BuildMessage[] }
</pre></div>
<div id="panel-cli-3-1" role="tabpanel" aria-labelledby="cli-3" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.ts --outdir ./out
</pre></div>
</div>
</div> <span data-as="p">If <code>outdir</code> is not passed to the JavaScript API, bundled code will not be written to disk. Bundled files are returned in an array of <code>BuildArtifact</code> objects. These objects are Blobs with extra properties; see <a href="#outputs">Outputs</a> for complete documentation.</span> <pre numberoflines="14" language="typescript" data-language="typescript">const result = await Bun.build({
  entrypoints: ["./index.ts"],
});

for (const res of result.outputs) {
  // Can be consumed as blobs
  await res.text();

  // Bun will set Content-Type and Etag headers
  new Response(res);

  // Can be written manually, but you should use `outdir` in this case.
  Bun.write(path.join("out", res.path), res);
}
</pre> <span data-as="p">When <code>outdir</code> is set, the <code>path</code> property on a <code>BuildArtifact</code> will be the absolute path to where it was written to.</span> <h3 id="target"><span>target</span></h3> <span data-as="p">The intended execution environment for the bundle.</span> <div id="javascript-4">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-4" role="tab" aria-selected="true" aria-controls="panel-javascript-4-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-4" role="tab" aria-selected="false" aria-controls="panel-cli-4-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-4-0" role="tabpanel" aria-labelledby="javascript-4" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.ts'],
  outdir: './out',
  target: 'browser', // default
})
</pre></div>
<div id="panel-cli-4-1" role="tabpanel" aria-labelledby="cli-4" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.ts --outdir ./out --target browser
</pre></div>
</div>
</div> <span data-as="p">Depending on the target, Bun will apply different module resolution rules and optimizations.</span> <div><div data-component-part="card-content-container">

<div>
<h2 contenteditable="false" data-component-part="card-title">browser</h2>
<div data-component-part="card-content"><span data-as="p"><strong>Default.</strong> For generating bundles that are intended for execution by a browser. Prioritizes the <code>"browser"</code> export condition when resolving imports. Importing any built-in modules, like <code>node:events</code> or <code>node:path</code> will work, but calling some functions, like <code>fs.readFile</code> will not work.</span></div>
</div>
</div></div> <div><div data-component-part="card-content-container">

<div>
<h2 contenteditable="false" data-component-part="card-title">bun</h2>
<div data-component-part="card-content">
<span data-as="p">For generating bundles that are intended to be run by the Bun runtime. In many cases, it isn’t necessary to bundle server-side code; you can directly execute the source code without modification. However, bundling your server code can reduce startup times and improve running performance. This is the target to use for building full-stack applications with build-time HTML imports, where both server and client code are bundled together.</span><span data-as="p">All bundles generated with <code>target: "bun"</code> are marked with a special <code>// @bun</code> pragma, which indicates to the Bun runtime that there’s no need to re-transpile the file before execution.</span><span data-as="p">If any entrypoints contains a Bun shebang (<code>#!/usr/bin/env bun</code>) the bundler will default to <code>target: "bun"</code> instead of <code>"browser"</code>.</span><span data-as="p">When using <code>target: "bun"</code> and <code>format: "cjs"</code> together, the <code>// @bun @bun-cjs</code> pragma is added and the CommonJS wrapper function is not compatible with Node.js.</span>
</div>
</div>
</div></div> <div><div data-component-part="card-content-container">

<div>
<h2 contenteditable="false" data-component-part="card-title">node</h2>
<div data-component-part="card-content"><span data-as="p">For generating bundles that are intended to be run by Node.js. Prioritizes the <code>"node"</code> export condition when resolving imports, and outputs <code>.mjs</code>. In the future, this will automatically polyfill the Bun global and other built-in <code>bun:*</code> modules, though this is not yet implemented.</span></div>
</div>
</div></div> <h3 id="format"><span>format</span></h3> <span data-as="p">Specifies the module format to be used in the generated bundles.</span> <span data-as="p">Bun defaults to <code>"esm"</code>, and provides experimental support for <code>"cjs"</code> and <code>"iife"</code>.</span> <h4 id="format:-“esm”-es-module"><span>format: “esm” - ES Module</span></h4> <span data-as="p">This is the default format, which supports ES Module syntax including top-level await, <code>import.meta</code>, and more.</span> <div id="javascript-5">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-5" role="tab" aria-selected="true" aria-controls="panel-javascript-5-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-5" role="tab" aria-selected="false" aria-controls="panel-cli-5-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-5-0" role="tabpanel" aria-labelledby="javascript-5" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  format: "esm",
})
</pre></div>
<div id="panel-cli-5-1" role="tabpanel" aria-labelledby="cli-5" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --format esm
</pre></div>
</div>
</div> <span data-as="p">To use ES Module syntax in browsers, set <code>format</code> to <code>"esm"</code> and make sure your <code>&lt;script type="module"&gt;</code> tag has <code>type="module"</code> set.</span> <h4 id="format:-“cjs”-commonjs"><span>format: “cjs” - CommonJS</span></h4> <span data-as="p">To build a CommonJS module, set <code>format</code> to <code>"cjs"</code>. When choosing <code>"cjs"</code>, the default target changes from <code>"browser"</code> (esm) to <code>"node"</code> (cjs). CommonJS modules transpiled with <code>format: "cjs"</code>, <code>target: "node"</code> can be executed in both Bun and Node.js (assuming the APIs in use are supported by both).</span> <div id="javascript-6">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-6" role="tab" aria-selected="true" aria-controls="panel-javascript-6-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-6" role="tab" aria-selected="false" aria-controls="panel-cli-6-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-6-0" role="tabpanel" aria-labelledby="javascript-6" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  format: "cjs",
})
</pre></div>
<div id="panel-cli-6-1" role="tabpanel" aria-labelledby="cli-6" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --format cjs
</pre></div>
</div>
</div> <h4 id="format:-“iife”-iife"><span>format: “iife” - IIFE</span></h4> <span data-as="p">TODO: document IIFE once we support globalNames.</span> <h3 id="jsx"><span><code>jsx</code></span></h3> <span data-as="p">Configure JSX transform behavior. Allows fine-grained control over how JSX is compiled.</span> <span data-as="p"><strong>Classic runtime example</strong> (uses <code>factory</code> and <code>fragment</code>):</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">index.tsterminalawait Bun.build({
  entrypoints: ["./app.tsx"],
  outdir: "./out",
  jsx: {
    factory: "h",
    fragment: "Fragment",
    runtime: "classic",
  },
});
</pre> <span data-as="p"><strong>Automatic runtime example</strong> (uses <code>importSource</code>):</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">index.tsterminalawait Bun.build({
  entrypoints: ["./app.tsx"],
  outdir: "./out",
  jsx: {
    importSource: "preact",
    runtime: "automatic",
  },
});
</pre> <h3 id="splitting"><span>splitting</span></h3> <span data-as="p">Whether to enable code splitting.</span> <div id="javascript-7">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-7" role="tab" aria-selected="true" aria-controls="panel-javascript-7-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-7" role="tab" aria-selected="false" aria-controls="panel-cli-7-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-7-0" role="tabpanel" aria-labelledby="javascript-7" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  splitting: false, // default
})
</pre></div>
<div id="panel-cli-7-1" role="tabpanel" aria-labelledby="cli-7" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --splitting
</pre></div>
</div>
</div> <span data-as="p">When <code>true</code>, the bundler will enable code splitting. When multiple entrypoints both import the same file, module, or set of files/modules, it’s often useful to split the shared code into a separate bundle. This shared bundle is known as a chunk. Consider the following files:</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">entry-a.tsentry-b.tsshared.tsimport { shared } from "./shared.ts";
</pre> <span data-as="p">To bundle <code>entry-a.ts</code> and <code>entry-b.ts</code> with code-splitting enabled:</span> <div id="javascript-8">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-8" role="tab" aria-selected="true" aria-controls="panel-javascript-8-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-8" role="tab" aria-selected="false" aria-controls="panel-cli-8-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-8-0" role="tabpanel" aria-labelledby="javascript-8" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./entry-a.ts', './entry-b.ts'],
  outdir: './out',
  splitting: true,
})
</pre></div>
<div id="panel-cli-8-1" role="tabpanel" aria-labelledby="cli-8" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./entry-a.ts ./entry-b.ts --outdir ./out --splitting
</pre></div>
</div>
</div> <span data-as="p">Running this build will result in the following files:</span> <pre numberoflines="9" language="text" data-language="typescript">.
├── entry-a.tsx
├── entry-b.tsx
├── shared.tsx
└── out
    ├── entry-a.js
    ├── entry-b.js
    └── chunk-2fce6291bf86559d.js
</pre> <span data-as="p">The generated <code>chunk-2fce6291bf86559d.js</code> file contains the shared code. To avoid collisions, the file name automatically includes a content hash by default. This can be customized with <a href="#naming"><code>naming</code></a>.</span> <h3 id="plugins-2"><span>plugins</span></h3> <span data-as="p">A list of plugins to use during bundling.</span> <pre numberoflines="7" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ["./index.tsx"],
  outdir: "./out",
  plugins: [
    /* ... */
  ],
});
</pre> <span data-as="p">Bun implements a universal plugin system for both Bun’s runtime and bundler. Refer to the <a href="bundler/plugins">plugin documentation</a> for complete documentation.</span> <h3 id="env"><span>env</span></h3> <span data-as="p">Controls how environment variables are handled during bundling. Internally, this uses <code>define</code> to inject environment variables into the bundle, but makes it easier to specify the environment variables to inject.</span> <h4 id="env:-“inline”"><span>env: “inline”</span></h4> <span data-as="p">Injects environment variables into the bundled output by converting <code>process.env.FOO</code> references to string literals containing the actual environment variable values.</span> <div id="javascript-9">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-9" role="tab" aria-selected="true" aria-controls="panel-javascript-9-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-9" role="tab" aria-selected="false" aria-controls="panel-cli-9-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-9-0" role="tabpanel" aria-labelledby="javascript-9" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  env: "inline",
})
</pre></div>
<div id="panel-cli-9-1" role="tabpanel" aria-labelledby="cli-9" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --env inline
</pre></div>
</div>
</div> <span data-as="p">For the input below:</span> <pre numberoflines="3" language="javascript" data-language="typescript">// input.js
console.log(process.env.FOO);
console.log(process.env.BAZ);
</pre> <span data-as="p">The generated bundle will contain the following code:</span> <pre numberoflines="3" language="javascript" data-language="typescript">// output.js
console.log("bar");
console.log("123");
</pre> <h4 id="env:-“public-”-prefix"><span>env: “PUBLIC_*” (prefix)</span></h4> <span data-as="p">Inlines environment variables matching the given prefix (the part before the <code>*</code> character), replacing <code>process.env.FOO</code> with the actual environment variable value. This is useful for selectively inlining environment variables for things like public-facing URLs or client-side tokens, without worrying about injecting private credentials into output bundles.</span> <div id="javascript-10">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-10" role="tab" aria-selected="true" aria-controls="panel-javascript-10-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-10" role="tab" aria-selected="false" aria-controls="panel-cli-10-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-10-0" role="tabpanel" aria-labelledby="javascript-10" data-component-part="tab-content"><pre numberoflines="7" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  
  // Inline all env vars that start with "ACME_PUBLIC_"
  env: "ACME_PUBLIC_*",
})
</pre></div>
<div id="panel-cli-10-1" role="tabpanel" aria-labelledby="cli-10" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --env ACME_PUBLIC_*
</pre></div>
</div>
</div> <span data-as="p">For example, given the following environment variables:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">FOO=bar BAZ=123 ACME_PUBLIC_URL=https://acme.com
</pre> <span data-as="p">And source code:</span> <pre numberoflines="3" language="tsx" data-language="typescript">console.log(process.env.FOO);
console.log(process.env.ACME_PUBLIC_URL);
console.log(process.env.BAZ);
</pre> <span data-as="p">The generated bundle will contain the following code:</span> <pre numberoflines="3" language="javascript" data-language="typescript">console.log(process.env.FOO);
console.log("https://acme.com");
console.log(process.env.BAZ);
</pre> <h4 id="env:-“disable”"><span>env: “disable”</span></h4> <span data-as="p">Disables environment variable injection entirely.</span> <h3 id="sourcemap"><span>sourcemap</span></h3> <span data-as="p">Specifies the type of sourcemap to generate.</span> <div id="javascript-11">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-11" role="tab" aria-selected="true" aria-controls="panel-javascript-11-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-11" role="tab" aria-selected="false" aria-controls="panel-cli-11-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-11-0" role="tabpanel" aria-labelledby="javascript-11" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  sourcemap: 'linked', // default 'none'
})
</pre></div>
<div id="panel-cli-11-1" role="tabpanel" aria-labelledby="cli-11" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --sourcemap linked
</pre></div>
</div>
</div> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Value</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code>"none"</code></td>
<td>Default. No sourcemap is generated.</td>
</tr>
<tr>
<td><code>"linked"</code></td>
<td>A separate <code>*.js.map</code> file is created alongside each <code>*.js</code> bundle using a <code>//# sourceMappingURL</code> comment to link the two. Requires <code>--outdir</code> to be set. The base URL of this can be customized with <code>--public-path</code>.<br><br><code>js&lt;br/&gt;// &lt;bundled code here&gt;&lt;br/&gt;&lt;br/&gt;//# sourceMappingURL=bundle.js.map&lt;br/&gt;</code>
</td>
</tr>
<tr>
<td><code>"external"</code></td>
<td>A separate <code>*.js.map</code> file is created alongside each <code>*.js</code> bundle without inserting a <code>//# sourceMappingURL</code> comment.<br><br>Generated bundles contain a debug id that can be used to associate a bundle with its corresponding sourcemap. This <code>debugId</code> is added as a comment at the bottom of the file.<br><br><code>js&lt;br/&gt;// &lt;generated bundle code&gt;&lt;br/&gt;&lt;br/&gt;//# debugId=&lt;DEBUG ID&gt;&lt;br/&gt;</code>
</td>
</tr>
<tr>
<td><code>"inline"</code></td>
<td>A sourcemap is generated and appended to the end of the generated bundle as a base64 payload.<br><br><code>js&lt;br/&gt;// &lt;bundled code here&gt;&lt;br/&gt;&lt;br/&gt;//# sourceMappingURL=data:application/json;base64,&lt;encoded sourcemap here&gt;&lt;br/&gt;</code>
</td>
</tr>
</tbody>
</table></div></div> <span data-as="p">The associated <code>*.js.map</code> sourcemap will be a JSON file containing an equivalent <code>debugId</code> property.</span> <h3 id="minify"><span>minify</span></h3> <span data-as="p">Whether to enable minification. Default <code>false</code>.</span> <div data-callout-type="note">

<div data-component-part="callout-content">When targeting <code>bun</code>, identifiers will be minified by default.</div>
</div> <span data-as="p">To enable all minification options:</span> <div id="javascript-12">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-12" role="tab" aria-selected="true" aria-controls="panel-javascript-12-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-12" role="tab" aria-selected="false" aria-controls="panel-cli-12-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-12-0" role="tabpanel" aria-labelledby="javascript-12" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  minify: true, // default false
})
</pre></div>
<div id="panel-cli-12-1" role="tabpanel" aria-labelledby="cli-12" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --minify
</pre></div>
</div>
</div> <span data-as="p">To granularly enable certain minifications:</span> <div id="javascript-13">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-13" role="tab" aria-selected="true" aria-controls="panel-javascript-13-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-13" role="tab" aria-selected="false" aria-controls="panel-cli-13-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-13-0" role="tabpanel" aria-labelledby="javascript-13" data-component-part="tab-content"><pre numberoflines="9" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  minify: {
    whitespace: true,
    identifiers: true,
    syntax: true,
  },
})
</pre></div>
<div id="panel-cli-13-1" role="tabpanel" aria-labelledby="cli-13" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --minify-whitespace --minify-identifiers --minify-syntax
</pre></div>
</div>
</div> <h3 id="external"><span>external</span></h3> <span data-as="p">A list of import paths to consider external. Defaults to <code>[]</code>.</span> <div id="javascript-14">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-14" role="tab" aria-selected="true" aria-controls="panel-javascript-14-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-14" role="tab" aria-selected="false" aria-controls="panel-cli-14-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-14-0" role="tabpanel" aria-labelledby="javascript-14" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  external: ["lodash", "react"], // default: []
})
</pre></div>
<div id="panel-cli-14-1" role="tabpanel" aria-labelledby="cli-14" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --external lodash --external react
</pre></div>
</div>
</div> <span data-as="p">An external import is one that will not be included in the final bundle. Instead, the import statement will be left as-is, to be resolved at runtime.</span> <span data-as="p">For instance, consider the following entrypoint file:</span> <pre numberoflines="5" language="tsx" data-language="typescript">import _ from "lodash";
import { z } from "zod";

const value = z.string().parse("Hello world!");
console.log(_.upperCase(value));
</pre> <span data-as="p">Normally, bundling <code>index.tsx</code> would generate a bundle containing the entire source code of the “zod” package. If instead, we want to leave the import statement as-is, we can mark it as external:</span> <div id="javascript-15">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-15" role="tab" aria-selected="true" aria-controls="panel-javascript-15-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-15" role="tab" aria-selected="false" aria-controls="panel-cli-15-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-15-0" role="tabpanel" aria-labelledby="javascript-15" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  external: ['zod'],
})
</pre></div>
<div id="panel-cli-15-1" role="tabpanel" aria-labelledby="cli-15" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --external zod
</pre></div>
</div>
</div> <span data-as="p">The generated bundle will look something like this:</span> <pre numberoflines="8" language="javascript" data-language="typescript">import { z } from "zod";

// ...
// the contents of the "lodash" package
// including the `_.upperCase` function

var value = z.string().parse("Hello world!");
console.log(_.upperCase(value));
</pre> <span data-as="p">To mark all imports as external, use the wildcard <code>*</code>:</span> <div id="javascript-16">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-16" role="tab" aria-selected="true" aria-controls="panel-javascript-16-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-16" role="tab" aria-selected="false" aria-controls="panel-cli-16-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-16-0" role="tabpanel" aria-labelledby="javascript-16" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  external: ['*'],
})
</pre></div>
<div id="panel-cli-16-1" role="tabpanel" aria-labelledby="cli-16" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --external '*'
</pre></div>
</div>
</div> <h3 id="packages"><span>packages</span></h3> <span data-as="p">Control whether package dependencies are included to bundle or not. Possible values: <code>bundle</code> (default), <code>external</code>. Bun treats any import which path do not start with <code>.</code>, <code>..</code> or <code>/</code> as package.</span> <div id="javascript-17">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-17" role="tab" aria-selected="true" aria-controls="panel-javascript-17-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-17" role="tab" aria-selected="false" aria-controls="panel-cli-17-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-17-0" role="tabpanel" aria-labelledby="javascript-17" data-component-part="tab-content"><pre numberoflines="4" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.ts'],
  packages: 'external',
})
</pre></div>
<div id="panel-cli-17-1" role="tabpanel" aria-labelledby="cli-17" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.ts --packages external
</pre></div>
</div>
</div> <h3 id="naming"><span>naming</span></h3> <span data-as="p">Customizes the generated file names. Defaults to <code>./[dir]/[name].[ext]</code>.</span> <div id="javascript-18">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-18" role="tab" aria-selected="true" aria-controls="panel-javascript-18-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-18" role="tab" aria-selected="false" aria-controls="panel-cli-18-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-18-0" role="tabpanel" aria-labelledby="javascript-18" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  naming: "[dir]/[name].[ext]", // default
})
</pre></div>
<div id="panel-cli-18-1" role="tabpanel" aria-labelledby="cli-18" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --entry-naming "[dir]/[name].[ext]"
</pre></div>
</div>
</div> <span data-as="p">By default, the names of the generated bundles are based on the name of the associated entrypoint.</span> <pre numberoflines="5" language="text" data-language="typescript">.
├── index.tsx
└── out
    └── index.js
</pre> <span data-as="p">With multiple entrypoints, the generated file hierarchy will reflect the directory structure of the entrypoints.</span> <pre numberoflines="9" language="text" data-language="typescript">.
├── index.tsx
└── nested
    └── index.tsx
└── out
    ├── index.js
    └── nested
        └── index.js
</pre> <span data-as="p">The names and locations of the generated files can be customized with the <code>naming</code> field. This field accepts a template string that is used to generate the filenames for all bundles corresponding to entrypoints. where the following tokens are replaced with their corresponding values:</span> <ul> <li>
<code>[name]</code> - The name of the entrypoint file, without the extension.</li> <li>
<code>[ext]</code> - The extension of the generated bundle.</li> <li>
<code>[hash]</code> - A hash of the bundle contents.</li> <li>
<code>[dir]</code> - The relative path from the project root to the parent directory of the source file.</li> </ul> <span data-as="p">For example:</span> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Token</th>
<th><code>[name]</code></th>
<th><code>[ext]</code></th>
<th><code>[hash]</code></th>
<th><code>[dir]</code></th>
</tr></thead>
<tbody>
<tr>
<td><code>./index.tsx</code></td>
<td><code>index</code></td>
<td><code>js</code></td>
<td><code>a1b2c3d4</code></td>
<td>
<code>""</code> (empty string)</td>
</tr>
<tr>
<td><code>./nested/entry.ts</code></td>
<td><code>entry</code></td>
<td><code>js</code></td>
<td><code>c3d4e5f6</code></td>
<td><code>"nested"</code></td>
</tr>
</tbody>
</table></div></div> <span data-as="p">We can combine these tokens to create a template string. For instance, to include the hash in the generated bundle names:</span> <div id="javascript-19">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-19" role="tab" aria-selected="true" aria-controls="panel-javascript-19-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-19" role="tab" aria-selected="false" aria-controls="panel-cli-19-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-19-0" role="tabpanel" aria-labelledby="javascript-19" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  naming: 'files/[dir]/[name]-[hash].[ext]',
})
</pre></div>
<div id="panel-cli-19-1" role="tabpanel" aria-labelledby="cli-19" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --entry-naming 'files/[dir]/[name]-[hash].[ext]'
</pre></div>
</div>
</div> <span data-as="p">This build would result in the following file structure:</span> <pre numberoflines="6" language="text" data-language="typescript">.
├── index.tsx
└── out
    └── files
        └── index-a1b2c3d4.js
</pre> <span data-as="p">When a string is provided for the <code>naming</code> field, it is used only for bundles that correspond to entrypoints. The names of chunks and copied assets are not affected. Using the JavaScript API, separate template strings can be specified for each type of generated file.</span> <div id="javascript-20">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-20" role="tab" aria-selected="true" aria-controls="panel-javascript-20-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-20" role="tab" aria-selected="false" aria-controls="panel-cli-20-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-20-0" role="tabpanel" aria-labelledby="javascript-20" data-component-part="tab-content"><pre numberoflines="10" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  naming: {
    // default values
    entry: '[dir]/[name].[ext]',
    chunk: '[name]-[hash].[ext]',
    asset: '[name]-[hash].[ext]',
  },
})
</pre></div>
<div id="panel-cli-20-1" role="tabpanel" aria-labelledby="cli-20" data-component-part="tab-content"><pre numberoflines="4" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out \
  --entry-naming '[dir]/[name].[ext]' \
  --chunk-naming '[name]-[hash].[ext]' \
  --asset-naming '[name]-[hash].[ext]'
</pre></div>
</div>
</div> <h3 id="root"><span>root</span></h3> <span data-as="p">The root directory of the project.</span> <div id="javascript-21">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-21" role="tab" aria-selected="true" aria-controls="panel-javascript-21-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-21" role="tab" aria-selected="false" aria-controls="panel-cli-21-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-21-0" role="tabpanel" aria-labelledby="javascript-21" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./pages/a.tsx', './pages/b.tsx'],
  outdir: './out',
  root: '.',
})
</pre></div>
<div id="panel-cli-21-1" role="tabpanel" aria-labelledby="cli-21" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./pages/a.tsx ./pages/b.tsx --outdir ./out --root .
</pre></div>
</div>
</div> <span data-as="p">If unspecified, it is computed to be the first common ancestor of all entrypoint files. Consider the following file structure:</span> <pre numberoflines="5" language="text" data-language="typescript">.
└── pages
  └── index.tsx
  └── settings.tsx
</pre> <span data-as="p">We can build both entrypoints in the <code>pages</code> directory:</span> <div id="javascript-22">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-22" role="tab" aria-selected="true" aria-controls="panel-javascript-22-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-22" role="tab" aria-selected="false" aria-controls="panel-cli-22-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-22-0" role="tabpanel" aria-labelledby="javascript-22" data-component-part="tab-content"><pre numberoflines="4" language="javascript" data-language="typescript">await Bun.build({
  entrypoints: ['./pages/index.tsx', './pages/settings.tsx'],
  outdir: './out',
})
</pre></div>
<div id="panel-cli-22-1" role="tabpanel" aria-labelledby="cli-22" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./pages/index.tsx ./pages/settings.tsx --outdir ./out
</pre></div>
</div>
</div> <span data-as="p">This would result in a file structure like this:</span> <pre numberoflines="8" language="text" data-language="typescript">.
└── pages
  └── index.tsx
  └── settings.tsx
└── out
  └── index.js
  └── settings.js
</pre> <span data-as="p">Since the <code>pages</code> directory is the first common ancestor of the entrypoint files, it is considered the project root. This means that the generated bundles live at the top level of the <code>out</code> directory; there is no <code>out/pages</code> directory.</span> <span data-as="p">This behavior can be overridden by specifying the <code>root</code> option:</span> <div id="javascript-23">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-23" role="tab" aria-selected="true" aria-controls="panel-javascript-23-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-23" role="tab" aria-selected="false" aria-controls="panel-cli-23-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-23-0" role="tabpanel" aria-labelledby="javascript-23" data-component-part="tab-content"><pre numberoflines="5" language="javascript" data-language="typescript">await Bun.build({
  entrypoints: ['./pages/index.tsx', './pages/settings.tsx'],
  outdir: './out',
  root: '.',
})
</pre></div>
<div id="panel-cli-23-1" role="tabpanel" aria-labelledby="cli-23" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./pages/index.tsx ./pages/settings.tsx --outdir ./out --root .
</pre></div>
</div>
</div> <span data-as="p">By specifying <code>.</code> as <code>root</code>, the generated file structure will look like this:</span> <pre numberoflines="9" language="text" data-language="typescript">.
└── pages
  └── index.tsx
  └── settings.tsx
└── out
  └── pages
    └── index.js
    └── settings.js
</pre> <h3 id="publicpath"><span>publicPath</span></h3> <span data-as="p">A prefix to be appended to any import paths in bundled code.</span> <span data-as="p">In many cases, generated bundles will contain no import statements. After all, the goal of bundling is to combine all of the code into a single file. However there are a number of cases with the generated bundles will contain import statements.</span> <ul> <li>
<strong>Asset imports</strong> — When importing an unrecognized file type like <code>*.svg</code>, the bundler defers to the file loader, which copies the file into <code>outdir</code> as is. The import is converted into a variable</li> <li>
<strong>External modules</strong> — Files and modules can be marked as external, in which case they will not be included in the bundle. Instead, the import statement will be left in the final bundle.</li> <li>
<strong>Chunking.</strong> When <code>splitting</code> is enabled, the bundler may generate separate “chunk” files that represent code that is shared among multiple entrypoints.</li> </ul> <span data-as="p">In any of these cases, the final bundles may contain paths to other files. By default these imports are relative. Here is an example of a simple asset import:</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">InputOutputimport logo from "./logo.svg";
console.log(logo);
</pre> <span data-as="p">Setting <code>publicPath</code> will prefix all file paths with the specified value.</span> <div id="javascript-24">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-24" role="tab" aria-selected="true" aria-controls="panel-javascript-24-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-24" role="tab" aria-selected="false" aria-controls="panel-cli-24-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-24-0" role="tabpanel" aria-labelledby="javascript-24" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  publicPath: 'https://cdn.example.com/', // default is undefined
})
</pre></div>
<div id="panel-cli-24-1" role="tabpanel" aria-labelledby="cli-24" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --public-path 'https://cdn.example.com/'
</pre></div>
</div>
</div> <span data-as="p">The output file would now look something like this.</span> <pre numberoflines="1" language="javascript" data-language="typescript">var logo = "https://cdn.example.com/logo-a7305bdef.svg";
</pre> <h3 id="define"><span>define</span></h3> <span data-as="p">A map of global identifiers to be replaced at build time. Keys of this object are identifier names, and values are JSON strings that will be inlined.</span> <div id="javascript-25">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-25" role="tab" aria-selected="true" aria-controls="panel-javascript-25-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-25" role="tab" aria-selected="false" aria-controls="panel-cli-25-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-25-0" role="tabpanel" aria-labelledby="javascript-25" data-component-part="tab-content"><pre numberoflines="8" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  define: {
    STRING: JSON.stringify("value"),
    "nested.boolean": "true",
  },
})
</pre></div>
<div id="panel-cli-25-1" role="tabpanel" aria-labelledby="cli-25" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --define STRING='"value"' --define nested.boolean=true
</pre></div>
</div>
</div> <h3 id="loader"><span>loader</span></h3> <span data-as="p">A map of file extensions to built-in loader names. This can be used to quickly customize how certain files are loaded.</span> <div id="javascript-26">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-26" role="tab" aria-selected="true" aria-controls="panel-javascript-26-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-26" role="tab" aria-selected="false" aria-controls="panel-cli-26-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-26-0" role="tabpanel" aria-labelledby="javascript-26" data-component-part="tab-content"><pre numberoflines="8" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  loader: {
    ".png": "dataurl",
    ".txt": "file",
  },
})
</pre></div>
<div id="panel-cli-26-1" role="tabpanel" aria-labelledby="cli-26" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --loader .png:dataurl --loader .txt:file
</pre></div>
</div>
</div> <h3 id="banner"><span>banner</span></h3> <span data-as="p">A banner to be added to the final bundle, this can be a directive like <code>"use client"</code> for react or a comment block such as a license for the code.</span> <div id="javascript-27">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-27" role="tab" aria-selected="true" aria-controls="panel-javascript-27-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-27" role="tab" aria-selected="false" aria-controls="panel-cli-27-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-27-0" role="tabpanel" aria-labelledby="javascript-27" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  banner: '"use client";'
})
</pre></div>
<div id="panel-cli-27-1" role="tabpanel" aria-labelledby="cli-27" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --banner '"use client";'
</pre></div>
</div>
</div> <h3 id="footer"><span>footer</span></h3> <span data-as="p">A footer to be added to the final bundle, this can be something like a comment block for a license or just a fun easter egg.</span> <div id="javascript-28">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-28" role="tab" aria-selected="true" aria-controls="panel-javascript-28-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-28" role="tab" aria-selected="false" aria-controls="panel-cli-28-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-28-0" role="tabpanel" aria-labelledby="javascript-28" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  footer: '// built with love in SF'
})
</pre></div>
<div id="panel-cli-28-1" role="tabpanel" aria-labelledby="cli-28" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --footer '// built with love in SF'
</pre></div>
</div>
</div> <h3 id="drop"><span>drop</span></h3> <span data-as="p">Remove function calls from a bundle. For example, <code>--drop=console</code> will remove all calls to <code>console.log</code>. Arguments to calls will also be removed, regardless of if those arguments may have side effects. Dropping <code>debugger</code> will remove all <code>debugger</code> statements.</span> <div id="javascript-29">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-29" role="tab" aria-selected="true" aria-controls="panel-javascript-29-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-29" role="tab" aria-selected="false" aria-controls="panel-cli-29-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-29-0" role="tabpanel" aria-labelledby="javascript-29" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  drop: ["console", "debugger", "anyIdentifier.or.propertyAccess"],
})
</pre></div>
<div id="panel-cli-29-1" role="tabpanel" aria-labelledby="cli-29" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --drop console --drop debugger
</pre></div>
</div>
</div> <h3 id="features"><span>features</span></h3> <span data-as="p">Enable compile-time feature flags for dead-code elimination. This provides a way to conditionally include or exclude code paths at bundle time using <code>import { feature } from "bun:bundle"</code>.</span> <pre numberoflines="11" language="typescript" data-language="typescript">import { feature } from "bun:bundle";

if (feature("PREMIUM")) {
  // Only included when PREMIUM flag is enabled
  initPremiumFeatures();
}

if (feature("DEBUG")) {
  // Only included when DEBUG flag is enabled
  console.log("Debug mode");
}
</pre> <div id="javascript-30">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-30" role="tab" aria-selected="true" aria-controls="panel-javascript-30-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-30" role="tab" aria-selected="false" aria-controls="panel-cli-30-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-30-0" role="tabpanel" aria-labelledby="javascript-30" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ['./app.ts'],
  outdir: './out',
  features: ["PREMIUM"],  // PREMIUM=true, DEBUG=false
})
</pre></div>
<div id="panel-cli-30-1" role="tabpanel" aria-labelledby="cli-30" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./app.ts --outdir ./out --feature PREMIUM
</pre></div>
</div>
</div> <span data-as="p">The <code>feature()</code> function is replaced with <code>true</code> or <code>false</code> at bundle time. Combined with minification, unreachable code is eliminated:</span> <pre numberoflines="2" language="typescript" data-language="typescript">import { feature } from "bun:bundle";
const mode = feature("PREMIUM") ? "premium" : "free";
</pre> <pre numberoflines="1" language="javascript" data-language="typescript">var mode = "premium";
</pre> <pre numberoflines="1" language="javascript" data-language="typescript">var mode = "free";
</pre> <span data-as="p"><strong>Key behaviors:</strong></span> <ul> <li>
<code>feature()</code> requires a string literal argument — dynamic values are not supported</li> <li>The <code>bun:bundle</code> import is completely removed from the output</li> <li>Works with <code>bun build</code>, <code>bun run</code>, and <code>bun test</code>
</li> <li>Multiple flags can be enabled: <code>--feature FLAG_A --feature FLAG_B</code>
</li> <li>For type safety, augment the <code>Registry</code> interface to restrict <code>feature()</code> to known flags (see below)</li> </ul> <span data-as="p"><strong>Use cases:</strong></span> <ul> <li>Platform-specific code (<code>feature("SERVER")</code> vs <code>feature("CLIENT")</code>)</li> <li>Environment-based features (<code>feature("DEVELOPMENT")</code>)</li> <li>Gradual feature rollouts</li> <li>A/B testing variants</li> <li>Paid tier features</li> </ul> <span data-as="p"><strong>Type safety:</strong> By default, <code>feature()</code> accepts any string. To get autocomplete and catch typos at compile time, create an <code>env.d.ts</code> file (or add to an existing <code>.d.ts</code>) and augment the <code>Registry</code> interface:</span> <pre numberoflines="5" language="typescript" data-language="typescript">declare module "bun:bundle" {
  interface Registry {
    features: "DEBUG" | "PREMIUM" | "BETA_FEATURES";
  }
}
</pre> <span data-as="p">Ensure the file is included in your <code>tsconfig.json</code> (e.g., <code>"include": ["src", "env.d.ts"]</code>). Now <code>feature()</code> only accepts those flags, and invalid strings like <code>feature("TYPO")</code> become type errors.</span> <h2 id="outputs"><span>Outputs</span></h2> <span data-as="p">The <code>Bun.build</code> function returns a <code>Promise&lt;BuildOutput&gt;</code>, defined as:</span> <pre numberoflines="13" language="typescript" data-language="typescript">interface BuildOutput {
  outputs: BuildArtifact[];
  success: boolean;
  logs: Array&lt;object&gt;; // see docs for details
}

interface BuildArtifact extends Blob {
  kind: "entry-point" | "chunk" | "asset" | "sourcemap";
  path: string;
  loader: Loader;
  hash: string | null;
  sourcemap: BuildArtifact | null;
}
</pre> <span data-as="p">The <code>outputs</code> array contains all the files that were generated by the build. Each artifact implements the Blob interface.</span> <pre numberoflines="9" language="typescript" data-language="typescript">const build = await Bun.build({
  /* */
});

for (const output of build.outputs) {
  await output.arrayBuffer(); // =&gt; ArrayBuffer
  await output.bytes(); // =&gt; Uint8Array
  await output.text(); // string
}
</pre> <span data-as="p">Each artifact also contains the following properties:</span> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Property</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code>kind</code></td>
<td>What kind of build output this file is. A build generates bundled entrypoints, code-split “chunks”, sourcemaps, bytecode, and copied assets (like images).</td>
</tr>
<tr>
<td><code>path</code></td>
<td>Absolute path to the file on disk</td>
</tr>
<tr>
<td><code>loader</code></td>
<td>The loader was used to interpret the file. See <a href="bundler/loaders">Bundler &gt; Loaders</a> to see how Bun maps file extensions to the appropriate built-in loader.</td>
</tr>
<tr>
<td><code>hash</code></td>
<td>The hash of the file contents. Always defined for assets.</td>
</tr>
<tr>
<td><code>sourcemap</code></td>
<td>The sourcemap file corresponding to this file, if generated. Only defined for entrypoints and chunks.</td>
</tr>
</tbody>
</table></div></div> <span data-as="p">Similar to <code>BunFile</code>, <code>BuildArtifact</code> objects can be passed directly into <code>new Response()</code>.</span> <pre numberoflines="8" language="typescript" data-language="typescript">const build = await Bun.build({
  /* */
});

const artifact = build.outputs[0];

// Content-Type header is automatically set
return new Response(artifact);
</pre> <span data-as="p">The Bun runtime implements special pretty-printing of <code>BuildArtifact</code> object to make debugging easier.</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">build.tsShell output// build.ts
const build = await Bun.build({
  /* */
});

const artifact = build.outputs[0];
console.log(artifact);
</pre> <h2 id="bytecode"><span>Bytecode</span></h2> <span data-as="p">The <code>bytecode: boolean</code> option can be used to generate bytecode for any JavaScript/TypeScript entrypoints. This can greatly improve startup times for large applications. Only supported for <code>"cjs"</code> format, only supports <code>"target": "bun"</code> and dependent on a matching version of Bun. This adds a corresponding <code>.jsc</code> file for each entrypoint.</span> <div id="javascript-31">
<ul role="tablist" data-component-part="tabs-list">
<li id="javascript-31" role="tab" aria-selected="true" aria-controls="panel-javascript-31-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-JavaScript"> JavaScript</div></li>
<li id="cli-31" role="tab" aria-selected="false" aria-controls="panel-cli-31-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-CLI"> CLI</div></li>
</ul>
<div>
<div id="panel-javascript-31-0" role="tabpanel" aria-labelledby="javascript-31" data-component-part="tab-content"><pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ["./index.tsx"],
  outdir: "./out",
  bytecode: true,
})
</pre></div>
<div id="panel-cli-31-1" role="tabpanel" aria-labelledby="cli-31" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./index.tsx --outdir ./out --bytecode
</pre></div>
</div>
</div> <h2 id="executables"><span>Executables</span></h2> <span data-as="p">Bun supports “compiling” a JavaScript/TypeScript entrypoint into a standalone executable. This executable contains a copy of the Bun binary.</span> <pre numberoflines="2" language="shellscript" data-language="typescript">bun build ./cli.tsx --outfile mycli --compile
./mycli
</pre> <span data-as="p">Refer to <a href="bundler/executables">Bundler &gt; Executables</a> for complete documentation.</span> <h2 id="logs-and-errors"><span>Logs and errors</span></h2> <span data-as="p">On failure, <code>Bun.build</code> returns a rejected promise with an <code>AggregateError</code>. This can be logged to the console for pretty printing of the error list, or programmatically read with a try/catch block.</span> <pre numberoflines="16" language="typescript" data-language="typescript">try {
  const result = await Bun.build({
    entrypoints: ["./index.tsx"],
    outdir: "./out",
  });
} catch (e) {
  // TypeScript does not allow annotations on the catch clause
  const error = e as AggregateError;
  console.error("Build Failed");

  // Example: Using the built-in formatter
  console.error(error);

  // Example: Serializing the failure as a JSON string.
  console.error(JSON.stringify(error, null, 2));
}
</pre> <span data-as="p">Most of the time, an explicit try/catch is not needed, as Bun will neatly print uncaught exceptions. It is enough to just use a top-level await on the <code>Bun.build</code> call.</span> <span data-as="p">Each item in <code>error.errors</code> is an instance of <code>BuildMessage</code> or <code>ResolveMessage</code> (subclasses of <code>Error</code>), containing detailed information for each error.</span> <pre numberoflines="13" language="typescript" data-language="typescript">class BuildMessage {
  name: string;
  position?: Position;
  message: string;
  level: "error" | "warning" | "info" | "debug" | "verbose";
}

class ResolveMessage extends BuildMessage {
  code: string;
  referrer: string;
  specifier: string;
  importKind: ImportKind;
}
</pre> <span data-as="p">On build success, the returned object contains a <code>logs</code> property, which contains bundler warnings and info messages.</span> <pre numberoflines="12" language="typescript" data-language="typescript">const result = await Bun.build({
  entrypoints: ["./index.tsx"],
  outdir: "./out",
});

if (result.logs.length &gt; 0) {
  console.warn("Build succeeded with warnings:");
  for (const message of result.logs) {
    // Bun will pretty print the message object
    console.warn(message);
  }
}
</pre> <h2 id="reference"><span>Reference</span></h2> <pre numberoflines="186" language="typescript" data-language="typescript">interface Bun {
  build(options: BuildOptions): Promise&lt;BuildOutput&gt;;
}

interface BuildConfig {
  entrypoints: string[]; // list of file path
  outdir?: string; // output directory
  target?: Target; // default: "browser"
  /**
   * Output module format. Top-level await is only supported for `"esm"`.
   *
   * Can be:
   * - `"esm"`
   * - `"cjs"` (**experimental**)
   * - `"iife"` (**experimental**)
   *
   * @default "esm"
   */
  format?: "esm" | "cjs" | "iife";
  /**
   * JSX configuration object for controlling JSX transform behavior
   */
  jsx?: {
    runtime?: "automatic" | "classic";
    importSource?: string;
    factory?: string;
    fragment?: string;
    sideEffects?: boolean;
    development?: boolean;
  };
  naming?:
    | string
    | {
        chunk?: string;
        entry?: string;
        asset?: string;
      };
  root?: string; // project root
  splitting?: boolean; // default true, enable code splitting
  plugins?: BunPlugin[];
  external?: string[];
  packages?: "bundle" | "external";
  publicPath?: string;
  define?: Record&lt;string, string&gt;;
  loader?: { [k in string]: Loader };
  sourcemap?: "none" | "linked" | "inline" | "external" | boolean; // default: "none", true -&gt; "inline"
  /**
   * package.json `exports` conditions used when resolving imports
   *
   * Equivalent to `--conditions` in `bun build` or `bun run`.
   *
   * https://nodejs.org/api/packages.html#exports
   */
  conditions?: Array&lt;string&gt; | string;

  /**
   * Controls how environment variables are handled during bundling.
   *
   * Can be one of:
   * - `"inline"`: Injects environment variables into the bundled output by converting `process.env.FOO`
   *   references to string literals containing the actual environment variable values
   * - `"disable"`: Disables environment variable injection entirely
   * - A string ending in `*`: Inlines environment variables that match the given prefix.
   *   For example, `"MY_PUBLIC_*"` will only include env vars starting with "MY_PUBLIC_"
   */
  env?: "inline" | "disable" | `${string}*`;
  minify?:
    | boolean
    | {
        whitespace?: boolean;
        syntax?: boolean;
        identifiers?: boolean;
      };
  /**
   * Ignore dead code elimination/tree-shaking annotations such as @__PURE__ and package.json
   * "sideEffects" fields. This should only be used as a temporary workaround for incorrect
   * annotations in libraries.
   */
  ignoreDCEAnnotations?: boolean;
  /**
   * Force emitting @__PURE__ annotations even if minify.whitespace is true.
   */
  emitDCEAnnotations?: boolean;

  /**
   * Generate bytecode for the output. This can dramatically improve cold
   * start times, but will make the final output larger and slightly increase
   * memory usage.
   *
   * Bytecode is currently only supported for CommonJS (`format: "cjs"`).
   *
   * Must be `target: "bun"`
   * @default false
   */
  bytecode?: boolean;
  /**
   * Add a banner to the bundled code such as "use client";
   */
  banner?: string;
  /**
   * Add a footer to the bundled code such as a comment block like
   *
   * `// made with bun!`
   */
  footer?: string;

  /**
   * Drop function calls to matching property accesses.
   */
  drop?: string[];

  /**
   * - When set to `true`, the returned promise rejects with an AggregateError when a build failure happens.
   * - When set to `false`, returns a {@link BuildOutput} with `{success: false}`
   *
   * @default true
   */
  throw?: boolean;

  /**
   * Custom tsconfig.json file path to use for path resolution.
   * Equivalent to `--tsconfig-override` in the CLI.
   */
  tsconfig?: string;

  outdir?: string;
}

interface BuildOutput {
  outputs: BuildArtifact[];
  success: boolean;
  logs: Array&lt;BuildMessage | ResolveMessage&gt;;
}

interface BuildArtifact extends Blob {
  path: string;
  loader: Loader;
  hash: string | null;
  kind: "entry-point" | "chunk" | "asset" | "sourcemap" | "bytecode";
  sourcemap: BuildArtifact | null;
}

type Loader =
  | "js"
  | "jsx"
  | "ts"
  | "tsx"
  | "css"
  | "json"
  | "jsonc"
  | "toml"
  | "yaml"
  | "text"
  | "file"
  | "napi"
  | "wasm"
  | "html";

interface BuildOutput {
  outputs: BuildArtifact[];
  success: boolean;
  logs: Array&lt;BuildMessage | ResolveMessage&gt;;
}

declare class ResolveMessage {
  readonly name: "ResolveMessage";
  readonly position: Position | null;
  readonly code: string;
  readonly message: string;
  readonly referrer: string;
  readonly specifier: string;
  readonly importKind:
    | "entry_point"
    | "stmt"
    | "require"
    | "import"
    | "dynamic"
    | "require_resolve"
    | "at"
    | "at_conditional"
    | "url"
    | "internal";
  readonly level: "error" | "warning" | "info" | "debug" | "verbose";

  toString(): string;
}
See all 186 lines</pre> <hr> <h2 id="cli-usage"><span>CLI Usage</span></h2> <pre numberoflines="1" language="shellscript" data-language="typescript">bun build &lt;entry points&gt;
</pre> <h3 id="general-configuration"><span>General Configuration</span></h3> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-production">--productionboolean</code><div data-component-part="field-content"><span data-as="p">Set <code>NODE_ENV=production</code> and enable minification</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-bytecode">--bytecodeboolean</code><div data-component-part="field-content"><span data-as="p">Use a bytecode cache when compiling</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-target">--targetstringdefault:"browser"</code><div data-component-part="field-content"><span data-as="p">Intended execution environment for the bundle. One of <code>browser</code>, <code>bun</code>, or <code>node</code></span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-conditions">--conditionsstring</code><div data-component-part="field-content"><span data-as="p">Pass custom resolution conditions</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-env">--envstringdefault:"disable"</code><div data-component-part="field-content"><span data-as="p">Inline environment variables into the bundle as <code>process.env.$</code>. To inline variables matching a prefix, use a glob like <code>FOO_PUBLIC_*</code></span></div>
</div> <h3 id="output-&amp;-file-handling"><span>Output &amp; File Handling</span></h3> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-outdir">--outdirstringdefault:"dist"</code><div data-component-part="field-content"><span data-as="p">Output directory (used when building multiple entry points)</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-outfile">--outfilestring</code><div data-component-part="field-content"><span data-as="p">Write output to a specific file</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-sourcemap">--sourcemapstringdefault:"none"</code><div data-component-part="field-content"><span data-as="p">Generate source maps. One of <code>linked</code>, <code>inline</code>, <code>external</code>, or <code>none</code></span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-banner">--bannerstring</code><div data-component-part="field-content"><span data-as="p">Add a banner to the output (e.g. <code>“use client”</code> for React Server Components)</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-footer">--footerstring</code><div data-component-part="field-content"><span data-as="p">Add a footer to the output (e.g. <code>// built with bun!</code>)</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-format">--formatstringdefault:"esm"</code><div data-component-part="field-content"><span data-as="p">Module format of the output bundle. One of <code>esm</code>, <code>cjs</code>, or <code>iife</code></span></div>
</div> <h3 id="file-naming"><span>File Naming</span></h3> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-entry-naming">--entry-namingstringdefault:"[dir]/[name].[ext]"</code><div data-component-part="field-content"><span data-as="p">Customize entry point filenames</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-chunk-naming">--chunk-namingstringdefault:"[name]-[hash].[ext]"</code><div data-component-part="field-content"><span data-as="p">Customize chunk filenames</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-asset-naming">--asset-namingstringdefault:"[name]-[hash].[ext]"</code><div data-component-part="field-content"><span data-as="p">Customize asset filenames</span></div>
</div> <h3 id="bundling-options"><span>Bundling Options</span></h3> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-root">--rootstring</code><div data-component-part="field-content"><span data-as="p">Root directory used when bundling multiple entry points</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-splitting">--splittingboolean</code><div data-component-part="field-content"><span data-as="p">Enable code splitting for shared modules</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-public-path">--public-pathstring</code><div data-component-part="field-content"><span data-as="p">Prefix to be added to import paths in bundled code</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-external">--externalstring</code><div data-component-part="field-content"><span data-as="p">Exclude modules from the bundle (supports wildcards). Alias: <code>-e</code></span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-packages">--packagesstringdefault:"bundle"</code><div data-component-part="field-content"><span data-as="p">How to treat dependencies: <code>external</code> or <code>bundle</code></span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-no-bundle">--no-bundleboolean</code><div data-component-part="field-content"><span data-as="p">Transpile only — do not bundle</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-css-chunking">--css-chunkingboolean</code><div data-component-part="field-content"><span data-as="p">Chunk CSS files together to reduce duplication (only when multiple entry points import CSS)</span></div>
</div> <h3 id="minification-&amp;-optimization"><span>Minification &amp; Optimization</span></h3> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-emit-dce-annotations">--emit-dce-annotationsbooleandefault:"true"</code><div data-component-part="field-content"><span data-as="p">Re-emit Dead Code Elimination annotations. Disabled when <code>—minify-whitespace</code> is used</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-minify">--minifyboolean</code><div data-component-part="field-content"><span data-as="p">Enable all minification options</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-minify-syntax">--minify-syntaxboolean</code><div data-component-part="field-content"><span data-as="p">Minify syntax and inline constants</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-minify-whitespace">--minify-whitespaceboolean</code><div data-component-part="field-content"><span data-as="p">Minify whitespace</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-minify-identifiers">--minify-identifiersboolean</code><div data-component-part="field-content"><span data-as="p">Minify variable and function identifiers</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-keep-names">--keep-namesboolean</code><div data-component-part="field-content"><span data-as="p">Preserve original function and class names when minifying</span></div>
</div> <h3 id="development-features"><span>Development Features</span></h3> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-watch">--watchboolean</code><div data-component-part="field-content"><span data-as="p">Rebuild automatically when files change</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-no-clear-screen">--no-clear-screenboolean</code><div data-component-part="field-content"><span data-as="p">Don’t clear the terminal when rebuilding with <code>—watch</code></span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-react-fast-refresh">--react-fast-refreshboolean</code><div data-component-part="field-content"><span data-as="p">Enable React Fast Refresh transform (for development testing)</span></div>
</div> <h3 id="standalone-executables"><span>Standalone Executables</span></h3> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-compile">--compileboolean</code><div data-component-part="field-content"><span data-as="p">Generate a standalone Bun executable containing the bundle. Implies <code>—production</code></span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-compile-exec-argv">--compile-exec-argvstring</code><div data-component-part="field-content"><span data-as="p">Prepend arguments to the standalone executable’s <code>execArgv</code></span></div>
</div> <h3 id="windows-executable-details"><span>Windows Executable Details</span></h3> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-windows-hide-console">--windows-hide-consoleboolean</code><div data-component-part="field-content"><span data-as="p">Prevent a console window from opening when running a compiled Windows executable</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-windows-icon">--windows-iconstring</code><div data-component-part="field-content"><span data-as="p">Set an icon for the Windows executable</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-windows-title">--windows-titlestring</code><div data-component-part="field-content"><span data-as="p">Set the Windows executable product name</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-windows-publisher">--windows-publisherstring</code><div data-component-part="field-content"><span data-as="p">Set the Windows executable company name</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-windows-version">--windows-versionstring</code><div data-component-part="field-content"><span data-as="p">Set the Windows executable version (e.g. <code>1.2.3.4</code>)</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-windows-description">--windows-descriptionstring</code><div data-component-part="field-content"><span data-as="p">Set the Windows executable description</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-windows-copyright">--windows-copyrightstring</code><div data-component-part="field-content"><span data-as="p">Set the Windows executable copyright notice</span></div>
</div> <h3 id="experimental-&amp;-app-building"><span>Experimental &amp; App Building</span></h3> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-app">--appboolean</code><div data-component-part="field-content"><span data-as="p"><b>(EXPERIMENTAL)</b> Build a web app for production using Bun Bake</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-server-components">--server-componentsboolean</code><div data-component-part="field-content"><span data-as="p"><b>(EXPERIMENTAL)</b> Enable React Server Components</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-debug-dump-server-files">--debug-dump-server-filesboolean</code><div data-component-part="field-content"><span data-as="p">When <code>—app</code> is set, dump all server files to disk even for static builds</span></div>
</div> <div>
<code class="flex font-mono text-sm group/param-head param-head break-all relative" id="param-debug-no-minify">--debug-no-minifyboolean</code><div data-component-part="field-content"><span data-as="p">When <code>—app</code> is set, disable all minification</span></div>
</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/bundler" class="_attribution-link">https://bun.com/docs/bundler</a>
  </p>
</div>
