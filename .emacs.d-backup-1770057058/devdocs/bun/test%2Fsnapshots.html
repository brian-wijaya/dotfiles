<h1 id="header">Snapshots</h1>
<div data-page-title="Snapshots" data-page-href="/test/snapshots" id="content">
<span data-as="p">Snapshot testing saves the output of a value and compares it against future test runs. This is particularly useful for UI components, complex objects, or any output that needs to remain consistent.</span> <h2 id="basic-snapshots"><span>Basic Snapshots</span></h2> <span data-as="p">Snapshot tests are written using the <code>.toMatchSnapshot()</code> matcher:</span> <pre numberoflines="5" language="typescript" data-language="typescript">import { test, expect } from "bun:test";

test("snap", () =&gt; {
  expect("foo").toMatchSnapshot();
});
</pre> <span data-as="p">The first time this test is run, the argument to <code>expect</code> will be serialized and written to a special snapshot file in a <code>__snapshots__</code> directory alongside the test file.</span> <h3 id="snapshot-files"><span>Snapshot Files</span></h3> <span data-as="p">After running the test above, Bun will create:</span> <pre numberoflines="5" language="text" data-language="typescript">your-project/
├── snap.test.ts
└── __snapshots__/
    └── snap.test.ts.snap
</pre> <span data-as="p">The snapshot file contains:</span> <pre numberoflines="3" language="typescript" data-language="typescript">// Bun Snapshot v1, https://bun.com/docs/test/snapshots

exports[`snap 1`] = `"foo"`;
</pre> <span data-as="p">On future runs, the argument is compared against the snapshot on disk.</span> <h2 id="updating-snapshots"><span>Updating Snapshots</span></h2> <span data-as="p">Snapshots can be re-generated with the following command:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun test --update-snapshots
</pre> <span data-as="p">This is useful when:</span> <ul> <li>You’ve intentionally changed the output</li> <li>You’re adding new snapshot tests</li> <li>The expected output has legitimately changed</li> </ul> <h2 id="inline-snapshots"><span>Inline Snapshots</span></h2> <span data-as="p">For smaller values, you can use inline snapshots with <code>.toMatchInlineSnapshot()</code>. These snapshots are stored directly in your test file:</span> <pre numberoflines="6" language="typescript" data-language="typescript">import { test, expect } from "bun:test";

test("inline snapshot", () =&gt; {
  // First run: snapshot will be inserted automatically
  expect({ hello: "world" }).toMatchInlineSnapshot();
});
</pre> <span data-as="p">After the first run, Bun automatically updates your test file:</span> <pre numberoflines="9" language="typescript" data-language="typescript">import { test, expect } from "bun:test";

test("inline snapshot", () =&gt; {
  expect({ hello: "world" }).toMatchInlineSnapshot(`
{
  "hello": "world",
}
`);
});
</pre> <h3 id="using-inline-snapshots"><span>Using Inline Snapshots</span></h3> <ol> <li>Write your test with <code>.toMatchInlineSnapshot()</code>
</li> <li>Run the test once</li> <li>Bun automatically updates your test file with the snapshot</li> <li>On subsequent runs, the value will be compared against the inline snapshot</li> </ol> <span data-as="p">Inline snapshots are particularly useful for small, simple values where it’s helpful to see the expected output right in the test file.</span> <h2 id="error-snapshots"><span>Error Snapshots</span></h2> <span data-as="p">You can also snapshot error messages using <code>.toThrowErrorMatchingSnapshot()</code> and <code>.toThrowErrorMatchingInlineSnapshot()</code>:</span> <pre numberoflines="11" language="typescript" data-language="typescript">import { test, expect } from "bun:test";

test("error snapshot", () =&gt; {
  expect(() =&gt; {
    throw new Error("Something went wrong");
  }).toThrowErrorMatchingSnapshot();

  expect(() =&gt; {
    throw new Error("Another error");
  }).toThrowErrorMatchingInlineSnapshot();
});
</pre> <span data-as="p">After running, the inline version becomes:</span> <pre numberoflines="9" language="typescript" data-language="typescript">test("error snapshot", () =&gt; {
  expect(() =&gt; {
    throw new Error("Something went wrong");
  }).toThrowErrorMatchingSnapshot();

  expect(() =&gt; {
    throw new Error("Another error");
  }).toThrowErrorMatchingInlineSnapshot(`"Another error"`);
});
</pre> <h2 id="advanced-snapshot-usage"><span>Advanced Snapshot Usage</span></h2> <h3 id="complex-objects"><span>Complex Objects</span></h3> <span data-as="p">Snapshots work well with complex nested objects:</span> <pre numberoflines="19" language="typescript" data-language="typescript">import { test, expect } from "bun:test";

test("complex object snapshot", () =&gt; {
  const user = {
    id: 1,
    name: "John Doe",
    email: "john@example.com",
    profile: {
      age: 30,
      preferences: {
        theme: "dark",
        notifications: true,
      },
    },
    tags: ["developer", "javascript", "bun"],
  };

  expect(user).toMatchSnapshot();
});
</pre> <h3 id="array-snapshots"><span>Array Snapshots</span></h3> <span data-as="p">Arrays are also well-suited for snapshot testing:</span> <pre numberoflines="6" language="typescript" data-language="typescript">import { test, expect } from "bun:test";

test("array snapshot", () =&gt; {
  const numbers = [1, 2, 3, 4, 5].map(n =&gt; n * 2);
  expect(numbers).toMatchSnapshot();
});
</pre> <h3 id="function-output-snapshots"><span>Function Output Snapshots</span></h3> <span data-as="p">Snapshot the output of functions:</span> <pre numberoflines="18" language="typescript" data-language="typescript">import { test, expect } from "bun:test";

function generateReport(data: any[]) {
  return {
    total: data.length,
    summary: data.map(item =&gt; ({ id: item.id, name: item.name })),
    timestamp: "2024-01-01", // Fixed for testing
  };
}

test("report generation", () =&gt; {
  const data = [
    { id: 1, name: "Alice", age: 30 },
    { id: 2, name: "Bob", age: 25 },
  ];

  expect(generateReport(data)).toMatchSnapshot();
});
</pre> <h2 id="react-component-snapshots"><span>React Component Snapshots</span></h2> <span data-as="p">Snapshots are particularly useful for React components:</span> <pre numberoflines="14" language="tsx" data-language="typescript">import { test, expect } from "bun:test";
import { render } from "@testing-library/react";

function Button({ children, variant = "primary" }) {
  return &lt;button className={`btn btn-${variant}`}&gt;{children}&lt;/button&gt;;
}

test("Button component snapshots", () =&gt; {
  const { container: primary } = render(&lt;Button&gt;Click me&lt;/Button&gt;);
  const { container: secondary } = render(&lt;Button variant="secondary"&gt;Cancel&lt;/Button&gt;);

  expect(primary.innerHTML).toMatchSnapshot();
  expect(secondary.innerHTML).toMatchSnapshot();
});
</pre> <h2 id="property-matchers"><span>Property Matchers</span></h2> <span data-as="p">For values that change between test runs (like timestamps or IDs), use property matchers:</span> <pre numberoflines="14" language="typescript" data-language="typescript">import { test, expect } from "bun:test";

test("snapshot with dynamic values", () =&gt; {
  const user = {
    id: Math.random(), // This changes every run
    name: "John",
    createdAt: new Date().toISOString(), // This also changes
  };

  expect(user).toMatchSnapshot({
    id: expect.any(Number),
    createdAt: expect.any(String),
  });
});
</pre> <span data-as="p">The snapshot will store:</span> <pre numberoflines="8" language="text" data-language="typescript">exports[`snapshot with dynamic values 1`] = `
{
  "createdAt": Any&lt;String&gt;,
  "id": Any&lt;Number&gt;,
  "name": "John",
}
`;
</pre> <h2 id="custom-serializers"><span>Custom Serializers</span></h2> <span data-as="p">You can customize how objects are serialized in snapshots:</span> <pre numberoflines="16" language="typescript" data-language="typescript">import { test, expect } from "bun:test";

// Custom serializer for Date objects
expect.addSnapshotSerializer({
  test: val =&gt; val instanceof Date,
  serialize: val =&gt; `"${val.toISOString()}"`,
});

test("custom serializer", () =&gt; {
  const event = {
    name: "Meeting",
    date: new Date("2024-01-01T10:00:00Z"),
  };

  expect(event).toMatchSnapshot();
});
</pre> <h2 id="best-practices"><span>Best Practices</span></h2> <h3 id="keep-snapshots-small"><span>Keep Snapshots Small</span></h3> <pre numberoflines="11" language="typescript" data-language="typescript">// Good: Focused snapshots
test("user name formatting", () =&gt; {
  const formatted = formatUserName("john", "doe");
  expect(formatted).toMatchInlineSnapshot(`"John Doe"`);
});

// Avoid: Huge snapshots that are hard to review
test("entire page render", () =&gt; {
  const page = renderEntirePage();
  expect(page).toMatchSnapshot(); // This could be thousands of lines
});
</pre> <h3 id="use-descriptive-test-names"><span>Use Descriptive Test Names</span></h3> <pre numberoflines="9" language="typescript" data-language="typescript">// Good: Clear what the snapshot represents
test("formats currency with USD symbol", () =&gt; {
  expect(formatCurrency(99.99)).toMatchInlineSnapshot(`"$99.99"`);
});

// Avoid: Unclear what's being tested
test("format test", () =&gt; {
  expect(format(99.99)).toMatchInlineSnapshot(`"$99.99"`);
});
</pre> <h3 id="group-related-snapshots"><span>Group Related Snapshots</span></h3> <pre numberoflines="18" language="typescript" data-language="typescript">import { describe, test, expect } from "bun:test";

describe("Button component", () =&gt; {
  test("primary variant", () =&gt; {
    expect(render(&lt;Button variant="primary"&gt;Click&lt;/Button&gt;))
      .toMatchSnapshot();
  });

  test("secondary variant", () =&gt; {
    expect(render(&lt;Button variant="secondary"&gt;Cancel&lt;/Button&gt;))
      .toMatchSnapshot();
  });

  test("disabled state", () =&gt; {
    expect(render(&lt;Button disabled&gt;Disabled&lt;/Button&gt;))
      .toMatchSnapshot();
  });
});
</pre> <h3 id="handle-dynamic-data"><span>Handle Dynamic Data</span></h3> <pre numberoflines="24" language="typescript" data-language="typescript">// Good: Normalize dynamic data
test("API response format", () =&gt; {
  const response = {
    data: { id: 1, name: "Test" },
    timestamp: Date.now(),
    requestId: generateId(),
  };

  expect({
    ...response,
    timestamp: "TIMESTAMP",
    requestId: "REQUEST_ID",
  }).toMatchSnapshot();
});

// Or use property matchers
test("API response with matchers", () =&gt; {
  const response = getApiResponse();

  expect(response).toMatchSnapshot({
    timestamp: expect.any(Number),
    requestId: expect.any(String),
  });
});
</pre> <h2 id="managing-snapshots"><span>Managing Snapshots</span></h2> <h3 id="reviewing-snapshot-changes"><span>Reviewing Snapshot Changes</span></h3> <span data-as="p">When snapshots change, carefully review them:</span> <pre numberoflines="9" language="shellscript" data-language="typescript"># See what changed
git diff __snapshots__/

# Update if changes are intentional
bun test --update-snapshots

# Commit the updated snapshots
git add __snapshots__/
git commit -m "Update snapshots after UI changes"
</pre> <h3 id="cleaning-up-unused-snapshots"><span>Cleaning Up Unused Snapshots</span></h3> <span data-as="p">Bun will warn about unused snapshots:</span> <pre numberoflines="3" language="text" data-language="typescript">Warning: 1 unused snapshot found:
  my-test.test.ts.snap: "old test that no longer exists 1"
</pre> <span data-as="p">Remove unused snapshots by deleting them from the snapshot files or by running tests with cleanup flags if available.</span> <h3 id="organizing-large-snapshot-files"><span>Organizing Large Snapshot Files</span></h3> <span data-as="p">For large projects, consider organizing tests to keep snapshot files manageable:</span> <pre numberoflines="10" language="text" data-language="typescript">tests/
├── components/
│   ├── Button.test.tsx
│   └── __snapshots__/
│       └── Button.test.tsx.snap
├── utils/
│   ├── formatters.test.ts
│   └── __snapshots__/
│       └── formatters.test.ts.snap
</pre> <h2 id="troubleshooting"><span>Troubleshooting</span></h2> <h3 id="snapshot-failures"><span>Snapshot Failures</span></h3> <span data-as="p">When snapshots fail, you’ll see a diff:</span> <pre numberoflines="7" language="diff" data-language="typescript">- Expected
+ Received

  Object {
-   "name": "John",
+   "name": "Jane",
  }
</pre> <span data-as="p">Common causes:</span> <ul> <li>Intentional changes (update with <code>--update-snapshots</code>)</li> <li>Unintentional changes (fix the code)</li> <li>Dynamic data (use property matchers)</li> <li>Environment differences (normalize the data)</li> </ul> <h3 id="platform-differences"><span>Platform Differences</span></h3> <span data-as="p">Be aware of platform-specific differences:</span> <pre numberoflines="9" language="typescript" data-language="typescript">// Paths might differ between Windows/Unix
test("file operations", () =&gt; {
  const result = processFile("./test.txt");

  expect({
    ...result,
    path: result.path.replace(/\\/g, "/"), // Normalize paths
  }).toMatchSnapshot();
});
</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/test/snapshots" class="_attribution-link">https://bun.com/docs/test/snapshots</a>
  </p>
</div>
