<h1 id="header">Secrets</h1>
<div data-page-title="Secrets" data-page-href="/runtime/secrets" id="content">
<span data-as="p">Store and retrieve sensitive credentials securely using the operating system’s native credential storage APIs.</span> <div data-callout-type="warning">

<div data-component-part="callout-content">This API is new and experimental. It may change in the future.</div>
</div> <pre numberoflines="24" language="typescript" data-language="typescript">import { secrets } from "bun";

let githubToken: string | null = await secrets.get({
  service: "my-cli-tool",
  name: "github-token",
});

if (!githubToken) {
  githubToken = prompt("Please enter your GitHub token");

  await secrets.set({
    service: "my-cli-tool",
    name: "github-token",
    value: githubToken,
  });

  console.log("GitHub token stored");
}

const response = await fetch("https://api.github.com/user", {
  headers: { Authorization: `token ${githubToken}` },
});

console.log(`Logged in as ${(await response.json()).login}`);
</pre> <hr> <h2 id="overview"><span>Overview</span></h2> <span data-as="p"><code>Bun.secrets</code> provides a cross-platform API for managing sensitive credentials that CLI tools and development applications typically store in plaintext files like <code>~/.npmrc</code>, <code>~/.aws/credentials</code>, or <code>.env</code> files. It uses:</span> <ul> <li>
<strong>macOS</strong>: Keychain Services</li> <li>
<strong>Linux</strong>: libsecret (GNOME Keyring, KWallet, etc.)</li> <li>
<strong>Windows</strong>: Windows Credential Manager</li> </ul> <span data-as="p">All operations are asynchronous and non-blocking, running on Bun’s threadpool.</span> <div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p">In the future, we may add an additional <code>provider</code> option to make this better for production deployment secrets, but today this API is mostly useful for local development tools.</span></div>
</div> <hr> <h2 id="api"><span>API</span></h2> <h3 id="bun-secrets-get-options"><span><code>Bun.secrets.get(options)</code></span></h3> <span data-as="p">Retrieve a stored credential.</span> <pre numberoflines="10" language="typescript" data-language="typescript">import { secrets } from "bun";

const password = await Bun.secrets.get({
  service: "my-app",
  name: "alice@example.com",
});
// Returns: string | null

// Or if you prefer without an object
const password = await Bun.secrets.get("my-app", "alice@example.com");
</pre> <span data-as="p"><strong>Parameters:</strong></span> <ul> <li>
<code>options.service</code> (string, required) - The service or application name</li> <li>
<code>options.name</code> (string, required) - The username or account identifier</li> </ul> <span data-as="p"><strong>Returns:</strong></span> <ul> <li>
<code>Promise&lt;string | null&gt;</code> - The stored password, or <code>null</code> if not found</li> </ul> <h3 id="bun-secrets-set-options,-value"><span><code>Bun.secrets.set(options, value)</code></span></h3> <span data-as="p">Store or update a credential.</span> <pre numberoflines="7" language="typescript" data-language="typescript">import { secrets } from "bun";

await secrets.set({
  service: "my-app",
  name: "alice@example.com",
  value: "super-secret-password",
});
</pre> <span data-as="p"><strong>Parameters:</strong></span> <ul> <li>
<code>options.service</code> (string, required) - The service or application name</li> <li>
<code>options.name</code> (string, required) - The username or account identifier</li> <li>
<code>value</code> (string, required) - The password or secret to store</li> </ul> <span data-as="p"><strong>Notes:</strong></span> <ul> <li>If a credential already exists for the given service/name combination, it will be replaced</li> <li>The stored value is encrypted by the operating system</li> </ul> <h3 id="bun-secrets-delete-options"><span><code>Bun.secrets.delete(options)</code></span></h3> <span data-as="p">Delete a stored credential.</span> <pre numberoflines="6" language="typescript" data-language="typescript">const deleted = await Bun.secrets.delete({
  service: "my-app",
  name: "alice@example.com",
  value: "super-secret-password",
});
// Returns: boolean
</pre> <span data-as="p"><strong>Parameters:</strong></span> <ul> <li>
<code>options.service</code> (string, required) - The service or application name</li> <li>
<code>options.name</code> (string, required) - The username or account identifier</li> </ul> <span data-as="p"><strong>Returns:</strong></span> <ul> <li>
<code>Promise&lt;boolean&gt;</code> - <code>true</code> if a credential was deleted, <code>false</code> if not found</li> </ul> <hr> <h2 id="examples"><span>Examples</span></h2> <h3 id="storing-cli-tool-credentials"><span>Storing CLI Tool Credentials</span></h3> <pre numberoflines="30" language="javascript" data-language="typescript">// Store GitHub CLI token (instead of ~/.config/gh/hosts.yml)
await Bun.secrets.set({
  service: "my-app.com",
  name: "github-token",
  value: "ghp_xxxxxxxxxxxxxxxxxxxx",
});

// Or if you prefer without an object
await Bun.secrets.set("my-app.com", "github-token", "ghp_xxxxxxxxxxxxxxxxxxxx");

// Store npm registry token (instead of ~/.npmrc)
await Bun.secrets.set({
  service: "npm-registry",
  name: "https://registry.npmjs.org",
  value: "npm_xxxxxxxxxxxxxxxxxxxx",
});

// Retrieve for API calls
const token = await Bun.secrets.get({
  service: "gh-cli",
  name: "github.com",
});

if (token) {
  const response = await fetch("https://api.github.com/name", {
    headers: {
      Authorization: `token ${token}`,
    },
  });
}
</pre> <h3 id="migrating-from-plaintext-config-files"><span>Migrating from Plaintext Config Files</span></h3> <pre numberoflines="20" language="javascript" data-language="typescript">// Instead of storing in ~/.aws/credentials
await Bun.secrets.set({
  service: "aws-cli",
  name: "AWS_SECRET_ACCESS_KEY",
  value: process.env.AWS_SECRET_ACCESS_KEY,
});

// Instead of .env files with sensitive data
await Bun.secrets.set({
  service: "my-app",
  name: "api-key",
  value: "sk_live_xxxxxxxxxxxxxxxxxxxx",
});

// Load at runtime
const apiKey =
  (await Bun.secrets.get({
    service: "my-app",
    name: "api-key",
  })) || process.env.API_KEY; // Fallback for CI/production
</pre> <h3 id="error-handling"><span>Error Handling</span></h3> <pre numberoflines="19" language="javascript" data-language="typescript">try {
  await Bun.secrets.set({
    service: "my-app",
    name: "alice",
    value: "password123",
  });
} catch (error) {
  console.error("Failed to store credential:", error.message);
}

// Check if a credential exists
const password = await Bun.secrets.get({
  service: "my-app",
  name: "alice",
});

if (password === null) {
  console.log("No credential found");
}
</pre> <h3 id="updating-credentials"><span>Updating Credentials</span></h3> <pre numberoflines="15" language="javascript" data-language="typescript">// Initial password
await Bun.secrets.set({
  service: "email-server",
  name: "admin@example.com",
  value: "old-password",
});

// Update to new password
await Bun.secrets.set({
  service: "email-server",
  name: "admin@example.com",
  value: "new-password",
});

// The old password is replaced
</pre> <hr> <h2 id="platform-behavior"><span>Platform Behavior</span></h2> <h3 id="macos-keychain"><span>macOS (Keychain)</span></h3> <ul> <li>Credentials are stored in the name’s login keychain</li> <li>The keychain may prompt for access permission on first use</li> <li>Credentials persist across system restarts</li> <li>Accessible by the name who stored them</li> </ul> <h3 id="linux-libsecret"><span>Linux (libsecret)</span></h3> <ul> <li>Requires a secret service daemon (GNOME Keyring, KWallet, etc.)</li> <li>Credentials are stored in the default collection</li> <li>May prompt for unlock if the keyring is locked</li> <li>The secret service must be running</li> </ul> <h3 id="windows-credential-manager"><span>Windows (Credential Manager)</span></h3> <ul> <li>Credentials are stored in Windows Credential Manager</li> <li>Visible in Control Panel → Credential Manager → Windows Credentials</li> <li>Persist with <code>CRED_PERSIST_ENTERPRISE</code> flag so it’s scoped per user</li> <li>Encrypted using Windows Data Protection API</li> </ul> <h2 id="security-considerations"><span>Security Considerations</span></h2> <ol> <li>
<strong>Encryption</strong>: Credentials are encrypted by the operating system’s credential manager</li> <li>
<strong>Access Control</strong>: Only the name who stored the credential can retrieve it</li> <li>
<strong>No Plain Text</strong>: Passwords are never stored in plain text</li> <li>
<strong>Memory Safety</strong>: Bun zeros out password memory after use</li> <li>
<strong>Process Isolation</strong>: Credentials are isolated per name account</li> </ol> <h2 id="limitations"><span>Limitations</span></h2> <ul> <li>Maximum password length varies by platform (typically 2048-4096 bytes)</li> <li>Service and name names should be reasonable lengths (&lt; 256 characters)</li> <li>Some special characters may need escaping depending on the platform</li> <li>Requires appropriate system services: <ul> <li>Linux: Secret service daemon must be running</li> <li>macOS: Keychain Access must be available</li> <li>Windows: Credential Manager service must be enabled</li> </ul> </li> </ul> <hr> <h2 id="comparison-with-environment-variables"><span>Comparison with Environment Variables</span></h2> <span data-as="p">Unlike environment variables, <code>Bun.secrets</code>:</span> <ul> <li>✅ Encrypts credentials at rest (thanks to the operating system)</li> <li>✅ Avoids exposing secrets in process memory dumps (memory is zeroed after its no longer needed)</li> <li>✅ Survives application restarts</li> <li>✅ Can be updated without restarting the application</li> <li>✅ Provides name-level access control</li> <li>❌ Requires OS credential service</li> <li>❌ Not very useful for deployment secrets (use environment variables in production)</li> </ul> <hr> <h2 id="best-practices"><span>Best Practices</span></h2> <ol> <li> <span data-as="p"><strong>Use descriptive service names</strong>: Match the tool or application name If you’re building a CLI for external use, you probably should use a UTI (Uniform Type Identifier) for the service name.</span> <pre numberoflines="6" language="javascript" data-language="typescript">// Good - matches the actual tool
{ service: "com.docker.hub", name: "username" }
{ service: "com.vercel.cli", name: "team-name" }

// Avoid - too generic
{ service: "api", name: "key" }
</pre> </li> <li> <span data-as="p"><strong>Credentials-only</strong>: Don’t store application configuration in this API This API is slow, you probably still need to use a config file for some things.</span> </li> <li> <span data-as="p"><strong>Use for local development tools</strong>:</span> <ul> <li>✅ CLI tools (gh, npm, docker, kubectl)</li> <li>✅ Local development servers</li> <li>✅ Personal API keys for testing</li> <li>❌ Production servers (use proper secret management)</li> </ul> </li> </ol> <hr> <h2 id="typescript"><span>TypeScript</span></h2> <pre numberoflines="14" language="typescript" data-language="typescript">namespace Bun {
  interface SecretsOptions {
    service: string;
    name: string;
  }

  interface Secrets {
    get(options: SecretsOptions): Promise&lt;string | null&gt;;
    set(options: SecretsOptions, value: string): Promise&lt;void&gt;;
    delete(options: SecretsOptions): Promise&lt;boolean&gt;;
  }

  const secrets: Secrets;
}
</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/secrets" class="_attribution-link">https://bun.com/docs/runtime/secrets</a>
  </p>
</div>
