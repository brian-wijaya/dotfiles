<h1 id="header">Plugins</h1>
<div data-page-title="Plugins" data-page-href="/bundler/plugins" id="content">
<span data-as="p">Bun provides a universal plugin API that can be used to extend both the runtime and bundler.</span> <span data-as="p">Plugins intercept imports and perform custom loading logic: reading files, transpiling code, etc. They can be used to add support for additional file types, like <code>.scss</code> or <code>.yaml</code>. In the context of Bun’s bundler, plugins can be used to implement framework-level features like CSS extraction, macros, and client-server code co-location.</span> <h2 id="lifecycle-hooks"><span>Lifecycle hooks</span></h2> <span data-as="p">Plugins can register callbacks to be run at various points in the lifecycle of a bundle:</span> <ul> <li>
<code>onStart()</code>: Run once the bundler has started a bundle</li> <li>
<code>onResolve()</code>: Run before a module is resolved</li> <li>
<code>onLoad()</code>: Run before a module is loaded</li> <li>
<code>onBeforeParse()</code>: Run zero-copy native addons in the parser thread before a file is parsed</li> </ul> <h2 id="reference"><span>Reference</span></h2> <span data-as="p">A rough overview of the types (please refer to Bun’s <code>bun.d.ts</code> for the full type definitions):</span> <pre numberoflines="36" language="typescript" data-language="typescript">type PluginBuilder = {
  onStart(callback: () =&gt; void): void;
  onResolve: (
    args: { filter: RegExp; namespace?: string },
    callback: (args: { path: string; importer: string }) =&gt; {
      path: string;
      namespace?: string;
    } | void,
  ) =&gt; void;
  onLoad: (
    args: { filter: RegExp; namespace?: string },
    defer: () =&gt; Promise&lt;void&gt;,
    callback: (args: { path: string }) =&gt; {
      loader?: Loader;
      contents?: string;
      exports?: Record&lt;string, any&gt;;
    },
  ) =&gt; void;
  config: BuildConfig;
};

type Loader =
  | "js"
  | "jsx"
  | "ts"
  | "tsx"
  | "json"
  | "jsonc"
  | "toml"
  | "yaml"
  | "file"
  | "napi"
  | "wasm"
  | "text"
  | "css"
  | "html";
</pre> <h2 id="usage"><span>Usage</span></h2> <span data-as="p">A plugin is defined as simple JavaScript object containing a <code>name</code> property and a <code>setup</code> function.</span> <pre numberoflines="8" language="typescript" data-language="typescript">import type { BunPlugin } from "bun";

const myPlugin: BunPlugin = {
  name: "Custom loader",
  setup(build) {
    // implementation
  },
};
</pre> <span data-as="p">This plugin can be passed into the <code>plugins</code> array when calling <code>Bun.build</code>.</span> <pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ["./app.ts"],
  outdir: "./out",
  plugins: [myPlugin],
});
</pre> <h2 id="plugin-lifecycle"><span>Plugin lifecycle</span></h2> <h3 id="namespaces"><span>Namespaces</span></h3> <span data-as="p"><code>onLoad</code> and <code>onResolve</code> accept an optional <code>namespace</code> string. What is a namespace?</span> <span data-as="p">Every module has a namespace. Namespaces are used to prefix the import in transpiled code; for instance, a loader with a <code>filter: /\.yaml$/</code> and <code>namespace: "yaml:"</code> will transform an import from <code>./myfile.yaml</code> into <code>yaml:./myfile.yaml</code>.</span> <span data-as="p">The default namespace is <code>"file"</code> and it is not necessary to specify it, for instance: <code>import myModule from "./my-module.ts"</code> is the same as <code>import myModule from "file:./my-module.ts"</code>.</span> <span data-as="p">Other common namespaces are:</span> <ul> <li>
<code>"bun"</code>: for Bun-specific modules (e.g. <code>"bun:test"</code>, <code>"bun:sqlite"</code>)</li> <li>
<code>"node"</code>: for Node.js modules (e.g. <code>"node:fs"</code>, <code>"node:path"</code>)</li> </ul> <h3 id="onstart"><span>onStart</span></h3> <pre numberoflines="1" language="typescript" data-language="typescript">onStart(callback: () =&gt; void): Promise&lt;void&gt; | void;
</pre> <span data-as="p">Registers a callback to be run when the bundler starts a new bundle.</span> <pre numberoflines="11" language="typescript" data-language="typescript">import { plugin } from "bun";

plugin({
  name: "onStart example",

  setup(build) {
    build.onStart(() =&gt; {
      console.log("Bundle started!");
    });
  },
});
</pre> <span data-as="p">The callback can return a Promise. After the bundle process has initialized, the bundler waits until all <code>onStart()</code> callbacks have completed before continuing.</span> <span data-as="p">For example:</span> <pre numberoflines="24" language="typescript" data-language="typescript">const result = await Bun.build({
  entrypoints: ["./app.ts"],
  outdir: "./dist",
  sourcemap: "external",
  plugins: [
    {
      name: "Sleep for 10 seconds",
      setup(build) {
        build.onStart(async () =&gt; {
          await Bun.sleep(10_000);
        });
      },
    },
    {
      name: "Log bundle time to a file",
      setup(build) {
        build.onStart(async () =&gt; {
          const now = Date.now();
          await Bun.$`echo ${now} &gt; bundle-time.txt`;
        });
      },
    },
  ],
});
</pre> <span data-as="p">In the above example, Bun will wait until the first <code>onStart()</code> (sleeping for 10 seconds) has completed, as well as the second <code>onStart()</code> (writing the bundle time to a file).</span> <div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p"><code>onStart()</code> callbacks (like every other lifecycle callback) do not have the ability to modify the <code>build.config</code> object. If you want to mutate <code>build.config</code>, you must do so directly in the <code>setup()</code> function.</span></div>
</div> <h3 id="onresolve"><span>onResolve</span></h3> <pre numberoflines="7" language="typescript" data-language="typescript">onResolve(
  args: { filter: RegExp; namespace?: string },
  callback: (args: { path: string; importer: string }) =&gt; {
    path: string;
    namespace?: string;
  } | void,
): void;
</pre> <span data-as="p">To bundle your project, Bun walks down the dependency tree of all modules in your project. For each imported module, Bun actually has to find and read that module. The “finding” part is known as “resolving” a module.</span> <span data-as="p">The <code>onResolve()</code> plugin lifecycle callback allows you to configure how a module is resolved.</span> <span data-as="p">The first argument to <code>onResolve()</code> is an object with a <code>filter</code> and <code>namespace</code> property. The <code>filter</code> is a regular expression which is run on the import string. Effectively, these allow you to filter which modules your custom resolution logic will apply to.</span> <span data-as="p">The second argument to <code>onResolve()</code> is a callback which is run for each module import Bun finds that matches the filter and namespace defined in the first argument.</span> <span data-as="p">The callback receives as input the path to the matching module. The callback can return a new path for the module. Bun will read the contents of the new path and parse it as a module.</span> <span data-as="p">For example, redirecting all imports to <code>images/</code> to <code>./public/images/</code>:</span> <pre numberoflines="14" language="typescript" data-language="typescript">import { plugin } from "bun";

plugin({
  name: "onResolve example",
  setup(build) {
    build.onResolve({ filter: /.*/, namespace: "file" }, args =&gt; {
      if (args.path.startsWith("images/")) {
        return {
          path: args.path.replace("images/", "./public/images/"),
        };
      }
    });
  },
});
</pre> <h3 id="onload"><span>onLoad</span></h3> <pre numberoflines="9" language="typescript" data-language="typescript">onLoad(
  args: { filter: RegExp; namespace?: string },
  defer: () =&gt; Promise&lt;void&gt;,
  callback: (args: { path: string, importer: string, namespace: string, kind: ImportKind  }) =&gt; {
    loader?: Loader;
    contents?: string;
    exports?: Record&lt;string, any&gt;;
  },
): void;
</pre> <span data-as="p">After Bun’s bundler has resolved a module, it needs to read the contents of the module and parse it.</span> <span data-as="p">The <code>onLoad()</code> plugin lifecycle callback allows you to modify the contents of a module before it is read and parsed by Bun.</span> <span data-as="p">Like <code>onResolve()</code>, the first argument to <code>onLoad()</code> allows you to filter which modules this invocation of <code>onLoad()</code> will apply to.</span> <span data-as="p">The second argument to <code>onLoad()</code> is a callback which is run for each matching module before Bun loads the contents of the module into memory.</span> <span data-as="p">This callback receives as input the path to the matching module, the importer of the module (the module that imported the module), the namespace of the module, and the kind of the module.</span> <span data-as="p">The callback can return a new <code>contents</code> string for the module as well as a new <code>loader</code>.</span> <span data-as="p">For example:</span> <pre numberoflines="22" language="typescript" data-language="typescript">import { plugin } from "bun";

const envPlugin: BunPlugin = {
  name: "env plugin",
  setup(build) {
    build.onLoad({ filter: /env/, namespace: "file" }, args =&gt; {
      return {
        contents: `export default ${JSON.stringify(process.env)}`,
        loader: "js",
      };
    });
  },
});

Bun.build({
  entrypoints: ["./app.ts"],
  outdir: "./dist",
  plugins: [envPlugin],
});

// import env from "env"
// env.FOO === "bar"
</pre> <span data-as="p">This plugin will transform all imports of the form <code>import env from "env"</code> into a JavaScript module that exports the current environment variables.</span> <h4 id="defer"><span>.defer()</span></h4> <span data-as="p">One of the arguments passed to the <code>onLoad</code> callback is a <code>defer</code> function. This function returns a Promise that is resolved when all other modules have been loaded.</span> <span data-as="p">This allows you to delay execution of the <code>onLoad</code> callback until all other modules have been loaded.</span> <span data-as="p">This is useful for returning contents of a module that depends on other modules.</span> <details><summary aria-controls="example-tracking-and-reporting-unused-exports accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">Example: tracking and reporting unused exports</p></div></summary><div id="example-tracking-and-reporting-unused-exports accordion children" role="region" aria-labelledby="example-tracking-and-reporting-unused-exports" data-component-part="accordion-content"><pre numberoflines="37" language="typescript" data-language="typescript">import { plugin } from "bun";

plugin({
  name: "track imports",
  setup(build) {
    const transpiler = new Bun.Transpiler();

    let trackedImports: Record&lt;string, number&gt; = {};

    // Each module that goes through this onLoad callback
    // will record its imports in `trackedImports`
    build.onLoad({ filter: /\.ts/ }, async ({ path }) =&gt; {
      const contents = await Bun.file(path).arrayBuffer();

      const imports = transpiler.scanImports(contents);

      for (const i of imports) {
        trackedImports[i.path] = (trackedImports[i.path] || 0) + 1;
      }

      return undefined;
    });

    build.onLoad({ filter: /stats\.json/ }, async ({ defer }) =&gt; {
      // Wait for all files to be loaded, ensuring
      // that every file goes through the above `onLoad()` function
      // and their imports tracked
      await defer();

      // Emit JSON containing the stats of each import
      return {
        contents: `export default ${JSON.stringify(trackedImports)}`,
        loader: "json",
      };
    });
  },
});
</pre></div></details> <div data-callout-type="warning">

<div data-component-part="callout-content"><span data-as="p">The <code>.defer()</code> function currently has the limitation that it can only be called once per <code>onLoad</code> callback.</span></div>
</div> <h2 id="native-plugins"><span>Native plugins</span></h2> <span data-as="p">One of the reasons why Bun’s bundler is so fast is that it is written in native code and leverages multi-threading to load and parse modules in parallel.</span> <span data-as="p">However, one limitation of plugins written in JavaScript is that JavaScript itself is single-threaded.</span> <span data-as="p">Native plugins are written as NAPI modules and can be run on multiple threads. This allows native plugins to run much faster than JavaScript plugins.</span> <span data-as="p">In addition, native plugins can skip unnecessary work such as the UTF-8 -&gt; UTF-16 conversion needed to pass strings to JavaScript.</span> <span data-as="p">These are the following lifecycle hooks which are available to native plugins:</span> <ul> <li>
<code>onBeforeParse()</code>: Called on any thread before a file is parsed by Bun’s bundler.</li> </ul> <span data-as="p">Native plugins are NAPI modules which expose lifecycle hooks as C ABI functions.</span> <span data-as="p">To create a native plugin, you must export a C ABI function which matches the signature of the native lifecycle hook you want to implement.</span> <h3 id="creating-a-native-plugin-in-rust"><span>Creating a native plugin in Rust</span></h3> <span data-as="p">Native plugins are NAPI modules which expose lifecycle hooks as C ABI functions.</span> <span data-as="p">To create a native plugin, you must export a C ABI function which matches the signature of the native lifecycle hook you want to implement.</span> <pre numberoflines="2" language="shellscript" data-language="typescript">bun add -g @napi-rs/cli
napi new
</pre> <span data-as="p">Then install this crate:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">cargo add bun-native-plugin
</pre> <span data-as="p">Now, inside the <code>lib.rs</code> file, we’ll use the <code>bun_native_plugin::bun</code> proc macro to define a function which will implement our native plugin.</span> <span data-as="p">Here’s an example implementing the <code>onBeforeParse</code> hook:</span> <pre numberoflines="27" language="rust" data-language="typescript">use bun_native_plugin::{define_bun_plugin, OnBeforeParse, bun, Result, anyhow, BunLoader};
use napi_derive::napi;

/// Define the plugin and its name
define_bun_plugin!("replace-foo-with-bar");

/// Here we'll implement `onBeforeParse` with code that replaces all occurrences of
/// `foo` with `bar`.
///
/// We use the #[bun] macro to generate some of the boilerplate code.
///
/// The argument of the function (`handle: &amp;mut OnBeforeParse`) tells
/// the macro that this function implements the `onBeforeParse` hook.
#[bun]
pub fn replace_foo_with_bar(handle: &amp;mut OnBeforeParse) -&gt; Result&lt;()&gt; {
  // Fetch the input source code.
  let input_source_code = handle.input_source_code()?;

  // Get the Loader for the file
  let loader = handle.output_loader();

  let output_source_code = input_source_code.replace("foo", "bar");

  handle.set_output_source_code(output_source_code, BunLoader::BUN_LOADER_JSX);

  Ok(())
}
</pre> <span data-as="p">And to use it in <code>Bun.build()</code>:</span> <pre numberoflines="24" language="typescript" data-language="typescript">import myNativeAddon from "./my-native-addon";

Bun.build({
  entrypoints: ["./app.tsx"],
  plugins: [
    {
      name: "my-plugin",

      setup(build) {
        build.onBeforeParse(
          {
            namespace: "file",
            filter: "**/*.tsx",
          },
          {
            napiModule: myNativeAddon,
            symbol: "replace_foo_with_bar",
            // external: myNativeAddon.getSharedState()
          },
        );
      },
    },
  ],
});
</pre> <h3 id="onbeforeparse"><span>onBeforeParse</span></h3> <pre numberoflines="4" language="typescript" data-language="typescript">onBeforeParse(
  args: { filter: RegExp; namespace?: string },
  callback: { napiModule: NapiModule; symbol: string; external?: unknown },
): void;
</pre> <span data-as="p">This lifecycle callback is run immediately before a file is parsed by Bun’s bundler.</span> <span data-as="p">As input, it receives the file’s contents and can optionally return new source code.</span> <div data-callout-type="info">

<div data-component-part="callout-content">This callback can be called from any thread and so the napi module implementation must be thread-safe.</div>
</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/bundler/plugins" class="_attribution-link">https://bun.com/docs/bundler/plugins</a>
  </p>
</div>
