<h1 id="header">Hot reloading</h1>
<div data-page-title="Hot reloading" data-page-href="/bundler/hot-reloading" id="content">
<span data-as="p">Hot Module Replacement (HMR) allows you to update modules in a running application without needing a full page reload. This preserves the application state and improves the development experience.</span> <div data-callout-type="note">

<div data-component-part="callout-content">HMR is enabled by default when using Bun‚Äôs full-stack development server.</div>
</div> <h2 id="import-meta-hot-api-reference"><span><code>import.meta.hot</code> API Reference</span></h2> <span data-as="p">Bun implements a client-side HMR API modeled after <a href="https://vite.dev/guide/api-hmr" target="_blank" rel="noreferrer">Vite‚Äôs <code>import.meta.hot</code> API</a>. It can be checked for with <code>if (import.meta.hot)</code>, tree-shaking it in production.</span> <pre numberoflines="3" language="typescript" data-language="typescript">if (import.meta.hot) {
  // HMR APIs are available.
}
</pre> <span data-as="p">However, this check is often not needed as Bun will dead-code-eliminate calls to all of the HMR APIs in production builds.</span> <pre numberoflines="4" language="typescript" data-language="typescript">// This entire function call will be removed in production!
import.meta.hot.dispose(() =&gt; {
  console.log("dispose");
});
</pre> <div data-callout-type="warning">

<div data-component-part="callout-content">
<span data-as="p">For this to work, Bun forces these APIs to be called without indirection. That means the following do not work:</span><pre numberoflines="17" language="typescript" data-language="typescript">// INVALID: Assigning `hot` to a variable
const hot = import.meta.hot;
hot.accept();

// INVALID: Assigning `import.meta` to a variable
const meta = import.meta;
meta.hot.accept();
console.log(meta.hot.data);

// INVALID: Passing to a function
doSomething(import.meta.hot.dispose);

// OK: The full phrase "import.meta.hot.&lt;API&gt;" must be called directly:
import.meta.hot.accept();

// OK: `data` can be passed to functions:
doSomething(import.meta.hot.data);
</pre>
</div>
</div> <div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p">The HMR API is still a work in progress. Some features are missing. HMR can be disabled in <code>Bun.serve</code> by setting the development option to <code>{ hmr: false }</code>.</span></div>
</div> <h2 id="api-methods"><span>API Methods</span></h2> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Method</th>
<th>Status</th>
<th>Notes</th>
</tr></thead>
<tbody>
<tr>
<td><code>hot.accept()</code></td>
<td>‚úÖ</td>
<td>Indicate that a hot update can be replaced gracefully.</td>
</tr>
<tr>
<td><code>hot.data</code></td>
<td>‚úÖ</td>
<td>Persist data between module evaluations.</td>
</tr>
<tr>
<td><code>hot.dispose()</code></td>
<td>‚úÖ</td>
<td>Add a callback function to run when a module is about to be replaced.</td>
</tr>
<tr>
<td><code>hot.invalidate()</code></td>
<td>‚ùå</td>
<td></td>
</tr>
<tr>
<td><code>hot.on()</code></td>
<td>‚úÖ</td>
<td>Attach an event listener</td>
</tr>
<tr>
<td><code>hot.off()</code></td>
<td>‚úÖ</td>
<td>Remove an event listener from <code>on</code>.</td>
</tr>
<tr>
<td><code>hot.send()</code></td>
<td>‚ùå</td>
<td></td>
</tr>
<tr>
<td><code>hot.prune()</code></td>
<td>üöß</td>
<td>NOTE: Callback is currently never called.</td>
</tr>
<tr>
<td><code>hot.decline()</code></td>
<td>‚úÖ</td>
<td>No-op to match Vite‚Äôs <code>import.meta.hot</code>
</td>
</tr>
</tbody>
</table></div></div> <h2 id="import-meta-hot-accept"><span>import.meta.hot.accept()</span></h2> <span data-as="p">The <code>accept()</code> method indicates that a module can be hot-replaced. When called without arguments, it indicates that this module can be replaced simply by re-evaluating the file. After a hot update, importers of this module will be automatically patched.</span> <pre numberoflines="10" language="typescript" data-language="typescript">// index.ts
import { getCount } from "./foo.ts";

console.log("count is ", getCount());

import.meta.hot.accept();

export function getNegativeCount() {
  return -getCount();
}
</pre> <span data-as="p">This creates a hot-reloading boundary for all of the files that <code>index.ts</code> imports. That means whenever <code>foo.ts</code> or any of its dependencies are saved, the update will bubble up to <code>index.ts</code> will re-evaluate. Files that import <code>index.ts</code> will then be patched to import the new version of <code>getNegativeCount()</code>. If only <code>index.ts</code> is updated, only the one file will be re-evaluated, and the counter in <code>foo.ts</code> is reused.</span> <span data-as="p">This may be used in combination with <code>import.meta.hot.data</code> to transfer state from the previous module to the new one.</span> <div data-callout-type="info">

<div data-component-part="callout-content"><span data-as="p">When no modules call <code>import.meta.hot.accept()</code> (and there isn‚Äôt React Fast Refresh or a plugin calling it for you), the page will reload when the file updates, and a console warning shows which files were invalidated. This warning is safe to ignore if it makes more sense to rely on full page reloads.</span></div>
</div> <h3 id="with-callback"><span>With callback</span></h3> <span data-as="p">When provided one callback, <code>import.meta.hot.accept</code> will function how it does in Vite. Instead of patching the importers of this module, it will call the callback with the new module.</span> <pre numberoflines="8" language="typescript" data-language="typescript">export const count = 0;

import.meta.hot.accept(newModule =&gt; {
  if (newModule) {
    // newModule is undefined when SyntaxError happened
    console.log("updated: count is now ", newModule.count);
  }
});
</pre> <div data-callout-type="tip">

<div data-component-part="callout-content"><span data-as="p">Prefer using <code>import.meta.hot.accept()</code> without an argument as it usually makes your code easier to understand.</span></div>
</div> <h3 id="accepting-other-modules"><span>Accepting other modules</span></h3> <pre numberoflines="7" language="typescript" data-language="typescript">import { count } from "./foo";

import.meta.hot.accept("./foo", () =&gt; {
  if (!newModule) return;

  console.log("updated: count is now ", count);
});
</pre> <span data-as="p">Indicates that a dependency‚Äôs module can be accepted. When the dependency is updated, the callback will be called with the new module.</span> <h3 id="with-multiple-dependencies"><span>With multiple dependencies</span></h3> <pre numberoflines="4" language="typescript" data-language="typescript">import.meta.hot.accept(["./foo", "./bar"], newModules =&gt; {
  // newModules is an array where each item corresponds to the updated module
  // or undefined if that module had a syntax error
});
</pre> <span data-as="p">Indicates that multiple dependencies‚Äô modules can be accepted. This variant accepts an array of dependencies, where the callback will receive the updated modules, and <code>undefined</code> for any that had errors.</span> <h2 id="import-meta-hot-data"><span>import.meta.hot.data</span></h2> <span data-as="p"><code>import.meta.hot.data</code> maintains state between module instances during hot replacement, enabling data transfer from previous to new versions. When <code>import.meta.hot.data</code> is written into, Bun will also mark this module as capable of self-accepting (equivalent of calling <code>import.meta.hot.accept()</code>).</span> <pre numberoflines="5" language="tsx" data-language="typescript">import { createRoot } from "react-dom/client";
import { App } from "./app";

const root = (import.meta.hot.data.root ??= createRoot(elem));
root.render(&lt;App /&gt;); // re-use an existing root
</pre> <span data-as="p">In production, <code>data</code> is inlined to be <code>{}</code>, meaning it cannot be used as a state holder.</span> <div data-callout-type="tip">

<div data-component-part="callout-content"><span data-as="p">The above pattern is recommended for stateful modules because Bun knows it can minify <code>{}.prop ??= value</code> into <code>value</code> in production.</span></div>
</div> <h2 id="import-meta-hot-dispose"><span>import.meta.hot.dispose()</span></h2> <span data-as="p">Attaches an on-dispose callback. This is called:</span> <ul> <li>Just before the module is replaced with another copy (before the next is loaded)</li> <li>After the module is detached (removing all imports to this module, see <code>import.meta.hot.prune()</code>)</li> </ul> <pre numberoflines="5" language="typescript" data-language="typescript">const sideEffect = setupSideEffect();

import.meta.hot.dispose(() =&gt; {
  sideEffect.cleanup();
});
</pre> <div data-callout-type="warning">

<div data-component-part="callout-content">This callback is not called on route navigation or when the browser tab closes.</div>
</div> <span data-as="p">Returning a promise will delay module replacement until the module is disposed. All dispose callbacks are called in parallel.</span> <h2 id="import-meta-hot-prune"><span>import.meta.hot.prune()</span></h2> <span data-as="p">Attaches an on-prune callback. This is called when all imports to this module are removed, but the module was previously loaded.</span> <span data-as="p">This can be used to clean up resources that were created when the module was loaded. Unlike <code>import.meta.hot.dispose()</code>, this pairs much better with <code>accept</code> and <code>data</code> to manage stateful resources. A full example managing a WebSocket:</span> <pre numberoflines="9" language="typescript" data-language="typescript">import { something } from "./something";

// Initialize or re-use a WebSocket connection
export const ws = (import.meta.hot.data.ws ??= new WebSocket(location.origin));

// If the module's import is removed, clean up the WebSocket connection.
import.meta.hot.prune(() =&gt; {
  ws.close();
});
</pre> <div data-callout-type="info">

<div data-component-part="callout-content"><span data-as="p">If <code>dispose</code> was used instead, the WebSocket would close and re-open on every hot update. Both versions of the code will prevent page reloads when imported files are updated.</span></div>
</div> <h2 id="import-meta-hot-on-and-off"><span>import.meta.hot.on() and off()</span></h2> <span data-as="p"><code>on()</code> and <code>off()</code> are used to listen for events from the HMR runtime. Event names are prefixed with a prefix so that plugins do not conflict with each other.</span> <pre numberoflines="3" language="typescript" data-language="typescript">import.meta.hot.on("bun:beforeUpdate", () =&gt; {
  console.log("before a hot update");
});
</pre> <span data-as="p">When a file is replaced, all of its event listeners are automatically removed.</span> <h3 id="built-in-events"><span>Built-in events</span></h3> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Event</th>
<th>Emitted when</th>
</tr></thead>
<tbody>
<tr>
<td><code>bun:beforeUpdate</code></td>
<td>before a hot update is applied.</td>
</tr>
<tr>
<td><code>bun:afterUpdate</code></td>
<td>after a hot update is applied.</td>
</tr>
<tr>
<td><code>bun:beforeFullReload</code></td>
<td>before a full page reload happens.</td>
</tr>
<tr>
<td><code>bun:beforePrune</code></td>
<td>before prune callbacks are called.</td>
</tr>
<tr>
<td><code>bun:invalidate</code></td>
<td>when a module is invalidated with <code>import.meta.hot.invalidate()</code>
</td>
</tr>
<tr>
<td><code>bun:error</code></td>
<td>when a build or runtime error occurs</td>
</tr>
<tr>
<td><code>bun:ws:disconnect</code></td>
<td>when the HMR WebSocket connection is lost. This can indicate the development server is offline.</td>
</tr>
<tr>
<td><code>bun:ws:connect</code></td>
<td>when the HMR WebSocket connects or re-connects.</td>
</tr>
</tbody>
</table></div></div> <div data-callout-type="note">

<div data-component-part="callout-content">For compatibility with Vite, the above events are also available via <code>vite:*</code> prefix instead of <code>bun:*</code>.</div>
</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/bundler/hot-reloading" class="_attribution-link">https://bun.com/docs/bundler/hot-reloading</a>
  </p>
</div>
