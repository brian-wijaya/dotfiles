<h1 id="header">File Types</h1>
<div data-page-title="File Types" data-page-href="/runtime/file-types" id="content">
<span data-as="p">The Bun bundler implements a set of default loaders out of the box. As a rule of thumb, the bundler and the runtime both support the same set of file types out of the box.</span> <span data-as="p"><code>.js</code> <code>.cjs</code> <code>.mjs</code> <code>.mts</code> <code>.cts</code> <code>.ts</code> <code>.tsx</code> <code>.jsx</code> <code>.css</code> <code>.json</code> <code>.jsonc</code> <code>.toml</code> <code>.yaml</code> <code>.yml</code> <code>.txt</code> <code>.wasm</code> <code>.node</code> <code>.html</code> <code>.sh</code></span> <span data-as="p">Bun uses the file extension to determine which built-in <em>loader</em> should be used to parse the file. Every loader has a name, such as <code>js</code>, <code>tsx</code>, or <code>json</code>. These names are used when building <a href="../bundler/plugins">plugins</a> that extend Bun with custom loaders.</span> <span data-as="p">You can explicitly specify which loader to use using the <code>'type'</code> import attribute.</span> <pre numberoflines="3" language="typescript" data-language="typescript">import my_toml from "./my_file" with { type: "toml" };
// or with dynamic imports
const { default: my_toml } = await import("./my_file", { with: { type: "toml" } });
</pre> <hr> <h2 id="built-in-loaders"><span>Built-in loaders</span></h2> <h3 id="js"><span><code>js</code></span></h3> <span data-as="p"><strong>JavaScript</strong>. Default for <code>.cjs</code> and <code>.mjs</code>.</span> <span data-as="p">Parses the code and applies a set of default transforms like dead-code elimination and tree shaking. Note that Bun does not attempt to down-convert syntax at the moment.</span> <h3 id="jsx"><span><code>jsx</code></span></h3> <span data-as="p"><strong>JavaScript + JSX.</strong>. Default for <code>.js</code> and <code>.jsx</code>.</span> <span data-as="p">Same as the <code>js</code> loader, but JSX syntax is supported. By default, JSX is down-converted to plain JavaScript; the details of how this is done depends on the <code>jsx*</code> compiler options in your <code>tsconfig.json</code>. Refer to the TypeScript documentation <a href="https://www.typescriptlang.org/docs/handbook/jsx.html" target="_blank" rel="noreferrer">on JSX</a> for more information.</span> <h3 id="ts"><span><code>ts</code></span></h3> <span data-as="p"><strong>TypeScript loader</strong>. Default for <code>.ts</code>, <code>.mts</code>, and <code>.cts</code>.</span> <span data-as="p">Strips out all TypeScript syntax, then behaves identically to the <code>js</code> loader. Bun does not perform typechecking.</span> <h3 id="tsx"><span><code>tsx</code></span></h3> <span data-as="p"><strong>TypeScript + JSX loader</strong>. Default for <code>.tsx</code>. Transpiles both TypeScript and JSX to vanilla JavaScript.</span> <h3 id="json"><span><code>json</code></span></h3> <span data-as="p"><strong>JSON loader</strong>. Default for <code>.json</code>.</span> <span data-as="p">JSON files can be directly imported.</span> <pre numberoflines="2" language="typescript" data-language="typescript">import pkg from "./package.json";
pkg.name; // =&gt; "my-package"
</pre> <span data-as="p">During bundling, the parsed JSON is inlined into the bundle as a JavaScript object.</span> <pre numberoflines="5" language="typescript" data-language="typescript">var pkg = {
  name: "my-package",
  // ... other fields
};
pkg.name;
</pre> <span data-as="p">If a <code>.json</code> file is passed as an entrypoint to the bundler, it will be converted to a <code>.js</code> module that <code>export default</code>s the parsed object.</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">InputOutput{
  "name": "John Doe",
  "age": 35,
  "email": "johndoe@example.com"
}
</pre> <h3 id="jsonc"><span><code>jsonc</code></span></h3> <span data-as="p"><strong>JSON with Comments loader</strong>. Default for <code>.jsonc</code>.</span> <span data-as="p">JSONC (JSON with Comments) files can be directly imported. Bun will parse them, stripping out comments and trailing commas.</span> <pre numberoflines="2" language="typescript" data-language="typescript">import config from "./config.jsonc";
console.log(config);
</pre> <span data-as="p">During bundling, the parsed JSONC is inlined into the bundle as a JavaScript object, identical to the <code>json</code> loader.</span> <pre numberoflines="3" language="typescript" data-language="typescript">var config = {
  option: "value",
};
</pre> <div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p">Bun automatically uses the <code>jsonc</code> loader for <code>tsconfig.json</code>, <code>jsconfig.json</code>, <code>package.json</code>, and <code>bun.lock</code> files.</span></div>
</div> <h3 id="toml"><span><code>toml</code></span></h3> <span data-as="p"><strong>TOML loader</strong>. Default for <code>.toml</code>.</span> <span data-as="p">TOML files can be directly imported. Bun will parse them with its fast native TOML parser.</span> <pre numberoflines="5" language="typescript" data-language="typescript">import config from "./bunfig.toml";
config.logLevel; // =&gt; "debug"

// via import attribute:
// import myCustomTOML from './my.config' with {type: "toml"};
</pre> <span data-as="p">During bundling, the parsed TOML is inlined into the bundle as a JavaScript object.</span> <pre numberoflines="5" language="typescript" data-language="typescript">var config = {
  logLevel: "debug",
  // ...other fields
};
config.logLevel;
</pre> <span data-as="p">If a <code>.toml</code> file is passed as an entrypoint, it will be converted to a <code>.js</code> module that <code>export default</code>s the parsed object.</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">InputOutputname = "John Doe"
age = 35
email = "johndoe@example.com"
</pre> <h3 id="yaml"><span><code>yaml</code></span></h3> <span data-as="p"><strong>YAML loader</strong>. Default for <code>.yaml</code> and <code>.yml</code>.</span> <span data-as="p">YAML files can be directly imported. Bun will parse them with its fast native YAML parser.</span> <pre numberoflines="5" language="typescript" data-language="typescript">import config from "./config.yaml";
console.log(config);

// via import attribute:
import data from "./data.txt" with { type: "yaml" };
</pre> <span data-as="p">During bundling, the parsed YAML is inlined into the bundle as a JavaScript object.</span> <pre numberoflines="5" language="typescript" data-language="typescript">var config = {
  name: "my-app",
  version: "1.0.0",
  // ...other fields
};
</pre> <span data-as="p">If a <code>.yaml</code> or <code>.yml</code> file is passed as an entrypoint, it will be converted to a <code>.js</code> module that <code>export default</code>s the parsed object.</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">InputOutputname: John Doe
age: 35
email: johndoe@example.com
</pre> <h3 id="text"><span><code>text</code></span></h3> <span data-as="p"><strong>Text loader</strong>. Default for <code>.txt</code>.</span> <span data-as="p">The contents of the text file are read and inlined into the bundle as a string. Text files can be directly imported. The file is read and returned as a string.</span> <pre numberoflines="6" language="typescript" data-language="typescript">import contents from "./file.txt";
console.log(contents); // =&gt; "Hello, world!"

// To import an html file as text
// The "type' attribute can be used to override the default loader.
import html from "./index.html" with { type: "text" };
</pre> <span data-as="p">When referenced during a build, the contents are inlined into the bundle as a string.</span> <pre numberoflines="2" language="typescript" data-language="typescript">var contents = `Hello, world!`;
console.log(contents);
</pre> <span data-as="p">If a <code>.txt</code> file is passed as an entrypoint, it will be converted to a <code>.js</code> module that <code>export default</code>s the file contents.</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">InputOutputHello, world!
</pre> <h3 id="napi"><span><code>napi</code></span></h3> <span data-as="p"><strong>Native addon loader</strong>. Default for <code>.node</code>.</span> <span data-as="p">In the runtime, native addons can be directly imported.</span> <pre numberoflines="2" language="typescript" data-language="typescript">import addon from "./addon.node";
console.log(addon);
</pre> <span data-as="p">In the bundler, <code>.node</code> files are handled using the <a href="#file"><code>file</code></a> loader.</span> <h3 id="sqlite"><span><code>sqlite</code></span></h3> <span data-as="p"><strong>SQLite loader</strong>. <code>with { "type": "sqlite" }</code> import attribute</span> <span data-as="p">In the runtime and bundler, SQLite databases can be directly imported. This will load the database using <a href="sqlite"><code>bun:sqlite</code></a>.</span> <pre numberoflines="1" language="typescript" data-language="typescript">import db from "./my.db" with { type: "sqlite" };
</pre> <span data-as="p">This is only supported when the <code>target</code> is <code>bun</code>.</span> <span data-as="p">By default, the database is external to the bundle (so that you can potentially use a database loaded elsewhere), so the database file on-disk won’t be bundled into the final output.</span> <span data-as="p">You can change this behavior with the <code>"embed"</code> attribute:</span> <pre numberoflines="2" language="typescript" data-language="typescript">// embed the database into the bundle
import db from "./my.db" with { type: "sqlite", embed: "true" };
</pre> <span data-as="p">When using a <a href="../bundler/executables">standalone executable</a>, the database is embedded into the single-file executable.</span> <span data-as="p">Otherwise, the database to embed is copied into the <code>outdir</code> with a hashed filename.</span> <h3 id="html"><span><code>html</code></span></h3> <span data-as="p">The html loader processes HTML files and bundles any referenced assets. It will:</span> <ul> <li>Bundle and hash referenced JavaScript files (<code>&lt;script src="..."&gt;</code>)</li> <li>Bundle and hash referenced CSS files (<code>&lt;link rel="stylesheet" href="..."&gt;</code>)</li> <li>Hash referenced images (<code>&lt;img src="..."&gt;</code>)</li> <li>Preserve external URLs (by default, anything starting with <code>http://</code> or <code>https://</code>)</li> </ul> <span data-as="p">For example, given this HTML file:</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">src/index.html&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;img src="./image.jpg" alt="Local image" /&gt;
    &lt;img src="https://example.com/image.jpg" alt="External image" /&gt;
    &lt;script type="module" src="./script.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre> <span data-as="p">It will output a new HTML file with the bundled assets:</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">dist/output.html&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;img src="./image-HASHED.jpg" alt="Local image" /&gt;
    &lt;img src="https://example.com/image.jpg" alt="External image" /&gt;
    &lt;script type="module" src="./output-ALSO-HASHED.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre> <span data-as="p">Under the hood, it uses <a href="https://github.com/cloudflare/lol-html" target="_blank" rel="noreferrer"><code>lol-html</code></a> to extract script and link tags as entrypoints, and other assets as external.</span> <span data-as="p">Currently, the list of selectors is:</span> <ul> <li><code>audio[src]</code></li> <li><code>iframe[src]</code></li> <li><code>img[src]</code></li> <li><code>img[srcset]</code></li> <li><code>link:not([rel~='stylesheet']):not([rel~='modulepreload']):not([rel~='manifest']):not([rel~='icon']):not([rel~='apple-touch-icon'])[href]</code></li> <li><code>link[as='font'][href], link[type^='font/'][href]</code></li> <li><code>link[as='image'][href]</code></li> <li><code>link[as='style'][href]</code></li> <li><code>link[as='video'][href], link[as='audio'][href]</code></li> <li><code>link[as='worker'][href]</code></li> <li><code>link[rel='icon'][href], link[rel='apple-touch-icon'][href]</code></li> <li><code>link[rel='manifest'][href]</code></li> <li><code>link[rel='stylesheet'][href]</code></li> <li><code>script[src]</code></li> <li><code>source[src]</code></li> <li><code>source[srcset]</code></li> <li><code>video[poster]</code></li> <li><code>video[src]</code></li> </ul> <div data-callout-type="note">

<div data-component-part="callout-content">
<span data-as="p"><strong>HTML Loader Behavior in Different Contexts</strong></span><span data-as="p">The <code>html</code> loader behaves differently depending on how it’s used:</span><ol> <li> <span data-as="p"><strong>Static Build:</strong> When you run <code>bun build ./index.html</code>, Bun produces a static site with all assets bundled and hashed.</span> </li> <li> <span data-as="p"><strong>Runtime:</strong> When you run <code>bun run server.ts</code> (where <code>server.ts</code> imports an HTML file), Bun bundles assets on-the-fly during development, enabling features like hot module replacement.</span> </li> <li> <span data-as="p"><strong>Full-stack Build:</strong> When you run <code>bun build --target=bun server.ts</code> (where <code>server.ts</code> imports an HTML file), the import resolves to a manifest object that <code>Bun.serve</code> uses to efficiently serve pre-bundled assets in production.</span> </li> </ol>
</div>
</div> <h3 id="css"><span><code>css</code></span></h3> <span data-as="p"><strong>CSS loader</strong>. Default for <code>.css</code>.</span> <span data-as="p">CSS files can be directly imported. This is primarily useful for <a href="../bundler/html-static">full-stack applications</a> where CSS is bundled alongside HTML.</span> <pre numberoflines="1" language="typescript" data-language="typescript">import "./styles.css";
</pre> <span data-as="p">There isn’t any value returned from the import, it’s only used for side effects.</span> <h3 id="sh-loader"><span><code>sh</code> loader</span></h3> <span data-as="p"><strong>Bun Shell loader</strong>. Default for <code>.sh</code> files</span> <span data-as="p">This loader is used to parse <a href="shell">Bun Shell</a> scripts. It’s only supported when starting Bun itself, so it’s not available in the bundler or in the runtime.</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun run ./script.sh
</pre> <h3 id="file"><span><code>file</code></span></h3> <span data-as="p"><strong>File loader</strong>. Default for all unrecognized file types.</span> <span data-as="p">The file loader resolves the import as a <em>path/URL</em> to the imported file. It’s commonly used for referencing media or font assets.</span> <pre numberoflines="2" language="typescript" data-language="typescript">import logo from "./logo.svg";
console.log(logo);
</pre> <span data-as="p"><em>In the runtime</em>, Bun checks that the <code>logo.svg</code> file exists and converts it to an absolute path to the location of <code>logo.svg</code> on disk.</span> <pre numberoflines="2" language="shellscript" data-language="typescript">bun run logo.ts
/path/to/project/logo.svg
</pre> <span data-as="p"><em>In the bundler</em>, things are slightly different. The file is copied into <code>outdir</code> as-is, and the import is resolved as a relative path pointing to the copied file.</span> <pre numberoflines="2" language="typescript" data-language="typescript">var logo = "./logo.svg";
console.log(logo);
</pre> <span data-as="p">If a value is specified for <code>publicPath</code>, the import will use value as a prefix to construct an absolute path/URL.</span> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Public path</th>
<th>Resolved import</th>
</tr></thead>
<tbody>
<tr>
<td>
<code>""</code> (default)</td>
<td><code>/logo.svg</code></td>
</tr>
<tr>
<td><code>"/assets"</code></td>
<td><code>/assets/logo.svg</code></td>
</tr>
<tr>
<td><code>"https://cdn.example.com/"</code></td>
<td><code>https://cdn.example.com/logo.svg</code></td>
</tr>
</tbody>
</table></div></div> <div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p">The location and file name of the copied file is determined by the value of <a href="../bundler#naming"><code>naming.asset</code></a>.</span></div>
</div> <span data-as="p">This loader is copied into the <code>outdir</code> as-is. The name of the copied file is determined using the value of <code>naming.asset</code>.</span> <details><summary aria-controls="fixing-typescript-import-errors accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">Fixing TypeScript import errors</p></div></summary><div id="fixing-typescript-import-errors accordion children" role="region" aria-labelledby="fixing-typescript-import-errors" data-component-part="accordion-content">
<span data-as="p">If you’re using TypeScript, you may get an error like this:</span><pre numberoflines="2" language="typescript" data-language="typescript">// TypeScript error
// Cannot find module './logo.svg' or its corresponding type declarations.
</pre>
<span data-as="p">This can be fixed by creating <code>*.d.ts</code> file anywhere in your project (any name will work) with the following contents:</span><pre numberoflines="4" language="typescript" data-language="typescript">declare module "*.svg" {
  const content: string;
  export default content;
}
</pre>
<span data-as="p">This tells TypeScript that any default imports from <code>.svg</code> should be treated as a string.</span>
</div></details>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/file-types" class="_attribution-link">https://bun.com/docs/runtime/file-types</a>
  </p>
</div>
