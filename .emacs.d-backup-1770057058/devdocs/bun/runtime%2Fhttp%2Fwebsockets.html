<h1 id="header">WebSockets</h1>
<div data-page-title="WebSockets" data-page-href="/runtime/http/websockets" id="content">
<span data-as="p"><code>Bun.serve()</code> supports server-side WebSockets, with on-the-fly compression, TLS support, and a Bun-native publish-subscribe API.</span> <div data-callout-type="info">

<div data-component-part="callout-content">
<span data-as="p"><strong>⚡️ 7x more throughput</strong></span><span data-as="p">Bun’s WebSockets are fast. For a <a href="https://github.com/oven-sh/bun/tree/main/bench/websocket-server/README" target="_blank" rel="noreferrer">simple chatroom</a> on Linux x64, Bun can handle 7x more requests per second than Node.js + <a href="https://github.com/websockets/ws" target="_blank" rel="noreferrer"><code>"ws"</code></a>.</span><div data-table-wrapper="true"><div><table>
<thead><tr>
<th><strong>Messages sent per second</strong></th>
<th><strong>Runtime</strong></th>
<th><strong>Clients</strong></th>
</tr></thead>
<tbody>
<tr>
<td data-numeric="true">~700,000</td>
<td>(<code>Bun.serve</code>) Bun v0.2.1 (x64)</td>
<td data-numeric="true">16</td>
</tr>
<tr>
<td data-numeric="true">~100,000</td>
<td>(<code>ws</code>) Node v18.10.0 (x64)</td>
<td data-numeric="true">16</td>
</tr>
</tbody>
</table></div></div>
<span data-as="p">Internally Bun’s WebSocket implementation is built on <a href="https://github.com/uNetworking/uWebSockets" target="_blank" rel="noreferrer">uWebSockets</a>.</span>
</div>
</div> <hr> <h2 id="start-a-websocket-server"><span>Start a WebSocket server</span></h2> <span data-as="p">Below is a simple WebSocket server built with <code>Bun.serve</code>, in which all incoming requests are <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Protocol_upgrade_mechanism" target="_blank" rel="noreferrer">upgraded</a> to WebSocket connections in the <code>fetch</code> handler. The socket handlers are declared in the <code>websocket</code> parameter.</span> <pre numberoflines="10" language="typescript" data-language="typescript">Bun.serve({
  fetch(req, server) {
    // upgrade the request to a WebSocket
    if (server.upgrade(req)) {
      return; // do not return a Response
    }
    return new Response("Upgrade failed", { status: 500 });
  },
  websocket: {}, // handlers
});
</pre> <span data-as="p">The following WebSocket event handlers are supported:</span> <pre numberoflines="9" language="typescript" data-language="typescript">Bun.serve({
  fetch(req, server) {}, // upgrade logic
  websocket: {
    message(ws, message) {}, // a message is received
    open(ws) {}, // a socket is opened
    close(ws, code, message) {}, // a socket is closed
    drain(ws) {}, // the socket is ready to receive more data
  },
});
</pre> <details><summary aria-controls="an-api-designed-for-speed accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">An API designed for speed</p></div></summary><div id="an-api-designed-for-speed accordion children" role="region" aria-labelledby="an-api-designed-for-speed" data-component-part="accordion-content">
<span data-as="p">In Bun, handlers are declared once per server, instead of per socket.</span><span data-as="p"><code>ServerWebSocket</code> expects you to pass a <code>WebSocketHandler</code> object to the <code>Bun.serve()</code> method which has methods for <code>open</code>, <code>message</code>, <code>close</code>, <code>drain</code>, and <code>error</code>. This is different than the client-side <code>WebSocket</code> class which extends <code>EventTarget</code> (onmessage, onopen, onclose),</span><span data-as="p">Clients tend to not have many socket connections open so an event-based API makes sense.</span><span data-as="p">But servers tend to have <strong>many</strong> socket connections open, which means:</span><ul> <li>Time spent adding/removing event listeners for each connection adds up</li> <li>Extra memory spent on storing references to callbacks function for each connection</li> <li>Usually, people create new functions for each connection, which also means more memory</li> </ul>
<span data-as="p">So, instead of using an event-based API, <code>ServerWebSocket</code> expects you to pass a single object with methods for each event in <code>Bun.serve()</code> and it is reused for each connection.</span><span data-as="p">This leads to less memory usage and less time spent adding/removing event listeners.</span>
</div></details> <span data-as="p">The first argument to each handler is the instance of <code>ServerWebSocket</code> handling the event. The <code>ServerWebSocket</code> class is a fast, Bun-native implementation of <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" target="_blank" rel="noreferrer"><code>WebSocket</code></a> with some additional features.</span> <pre numberoflines="8" language="typescript" data-language="typescript">Bun.serve({
  fetch(req, server) {}, // upgrade logic
  websocket: {
    message(ws, message) {
      ws.send(message); // echo back the message
    },
  },
});
</pre> <h3 id="sending-messages"><span>Sending messages</span></h3> <span data-as="p">Each <code>ServerWebSocket</code> instance has a <code>.send()</code> method for sending messages to the client. It supports a range of input types.</span> <pre focus="[4,5,6]" numberoflines="10" language="typescript" data-language="typescript">Bun.serve({
  fetch(req, server) {}, // upgrade logic
  websocket: {
    message(ws, message) {
      ws.send("Hello world"); // string
      ws.send(response.arrayBuffer()); // ArrayBuffer
      ws.send(new Uint8Array([1, 2, 3])); // TypedArray | DataView
    },
  },
});
</pre> <h3 id="headers"><span>Headers</span></h3> <span data-as="p">Once the upgrade succeeds, Bun will send a <code>101 Switching Protocols</code> response per the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Protocol_upgrade_mechanism" target="_blank" rel="noreferrer">spec</a>. Additional <code>headers</code> can be attached to this <code>Response</code> in the call to <code>server.upgrade()</code>.</span> <pre numberoflines="11" language="typescript" data-language="typescript">Bun.serve({
  fetch(req, server) {
    const sessionId = await generateSessionId();
    server.upgrade(req, {
      headers: { 
        "Set-Cookie": `SessionId=${sessionId}`, 
      }, 
    });
  },
  websocket: {}, // handlers
});
</pre> <h3 id="contextual-data"><span>Contextual data</span></h3> <span data-as="p">Contextual <code>data</code> can be attached to a new WebSocket in the <code>.upgrade()</code> call. This data is made available on the <code>ws.data</code> property inside the WebSocket handlers.</span> <span data-as="p">To strongly type <code>ws.data</code>, add a <code>data</code> property to the <code>websocket</code> handler object. This types <code>ws.data</code> across all lifecycle hooks.</span> <pre numberoflines="37" language="typescript" data-language="typescript">type WebSocketData = {
  createdAt: number;
  channelId: string;
  authToken: string;
};

Bun.serve({
  fetch(req, server) {
    const cookies = new Bun.CookieMap(req.headers.get("cookie")!);

    server.upgrade(req, {
      // this object must conform to WebSocketData
      data: {
        createdAt: Date.now(),
        channelId: new URL(req.url).searchParams.get("channelId"),
        authToken: cookies.get("X-Token"),
      },
    });

    return undefined;
  },
  websocket: {
    // TypeScript: specify the type of ws.data like this
    data: {} as WebSocketData,
    // handler called when a message is received
    async message(ws, message) {
      // ws.data is now properly typed as WebSocketData
      const user = getUserFromToken(ws.data.authToken);

      await saveMessageToDatabase({
        channel: ws.data.channelId,
        message: String(message),
        userId: user.id,
      });
    },
  },
});
</pre> <div data-callout-type="info">

<div data-component-part="callout-content"><span data-as="p"><strong>Note:</strong> Previously, you could specify the type of <code>ws.data</code> using a type parameter on <code>Bun.serve</code>, like <code>Bun.serve&lt;MyData&gt;({...})</code>. This pattern was removed due to <a href="https://github.com/microsoft/TypeScript/issues/26242" target="_blank" rel="noreferrer">a limitation in TypeScript</a> in favor of the <code>data</code> property shown above.</span></div>
</div> <span data-as="p">To connect to this server from the browser, create a new <code>WebSocket</code>.</span> <pre numberoflines="5" language="javascript" data-language="typescript">const socket = new WebSocket("ws://localhost:3000/chat");

socket.addEventListener("message", event =&gt; {
  console.log(event.data);
});
</pre> <div data-callout-type="info">

<div data-component-part="callout-content">
<span data-as="p"><strong>Identifying users</strong></span><span data-as="p">The cookies that are currently set on the page will be sent with the WebSocket upgrade request and available on <code>req.headers</code> in the <code>fetch</code> handler. Parse these cookies to determine the identity of the connecting user and set the value of <code>data</code> accordingly.</span>
</div>
</div> <h3 id="pub/sub"><span>Pub/Sub</span></h3> <span data-as="p">Bun’s <code>ServerWebSocket</code> implementation implements a native publish-subscribe API for topic-based broadcasting. Individual sockets can <code>.subscribe()</code> to a topic (specified with a string identifier) and <code>.publish()</code> messages to all other subscribers to that topic (excluding itself). This topic-based broadcast API is similar to <a href="https://en.wikipedia.org/wiki/MQTT" target="_blank" rel="noreferrer">MQTT</a> and <a href="https://redis.io/topics/pubsub" target="_blank" rel="noreferrer">Redis Pub/Sub</a>.</span> <pre numberoflines="37" language="typescript" data-language="typescript">const server = Bun.serve({
  fetch(req, server) {
    const url = new URL(req.url);
    if (url.pathname === "/chat") {
      console.log(`upgrade!`);
      const username = getUsernameFromReq(req);
      const success = server.upgrade(req, { data: { username } });
      return success ? undefined : new Response("WebSocket upgrade error", { status: 400 });
    }

    return new Response("Hello world");
  },
  websocket: {
    // TypeScript: specify the type of ws.data like this
    data: {} as { username: string },
    open(ws) {
      const msg = `${ws.data.username} has entered the chat`;
      ws.subscribe("the-group-chat");
      server.publish("the-group-chat", msg);
    },
    message(ws, message) {
      // this is a group chat
      // so the server re-broadcasts incoming message to everyone
      server.publish("the-group-chat", `${ws.data.username}: ${message}`);

      // inspect current subscriptions
      console.log(ws.subscriptions); // ["the-group-chat"]
    },
    close(ws) {
      const msg = `${ws.data.username} has left the chat`;
      ws.unsubscribe("the-group-chat");
      server.publish("the-group-chat", msg);
    },
  },
});

console.log(`Listening on ${server.hostname}:${server.port}`);
</pre> <span data-as="p">Calling <code>.publish(data)</code> will send the message to all subscribers of a topic <em>except</em> the socket that called <code>.publish()</code>. To send a message to all subscribers of a topic, use the <code>.publish()</code> method on the <code>Server</code> instance.</span> <pre numberoflines="8" language="typescript" data-language="typescript">const server = Bun.serve({
  websocket: {
    // ...
  },
});

// listen for some external event
server.publish("the-group-chat", "Hello world");
</pre> <h3 id="compression"><span>Compression</span></h3> <span data-as="p">Per-message <a href="https://websockets.readthedocs.io/en/stable/topics/compression.html" target="_blank" rel="noreferrer">compression</a> can be enabled with the <code>perMessageDeflate</code> parameter.</span> <pre numberoflines="5" language="typescript" data-language="typescript">Bun.serve({
  websocket: {
    perMessageDeflate: true, 
  },
});
</pre> <span data-as="p">Compression can be enabled for individual messages by passing a <code>boolean</code> as the second argument to <code>.send()</code>.</span> <pre numberoflines="1" language="typescript" data-language="typescript">ws.send("Hello world", true);
</pre> <span data-as="p">For fine-grained control over compression characteristics, refer to the <a href="#reference">Reference</a>.</span> <h3 id="backpressure"><span>Backpressure</span></h3> <span data-as="p">The <code>.send(message)</code> method of <code>ServerWebSocket</code> returns a <code>number</code> indicating the result of the operation.</span> <ul> <li>
<code>-1</code> — The message was enqueued but there is backpressure</li> <li>
<code>0</code> — The message was dropped due to a connection issue</li> <li>
<code>1+</code> — The number of bytes sent</li> </ul> <span data-as="p">This gives you better control over backpressure in your server.</span> <h3 id="timeouts-and-limits"><span>Timeouts and limits</span></h3> <span data-as="p">By default, Bun will close a WebSocket connection if it is idle for 120 seconds. This can be configured with the <code>idleTimeout</code> parameter.</span> <pre numberoflines="6" language="typescript" data-language="typescript">Bun.serve({
  fetch(req, server) {}, // upgrade logic
  websocket: {
    idleTimeout: 60, // 60 seconds
  },
});
</pre> <span data-as="p">Bun will also close a WebSocket connection if it receives a message that is larger than 16 MB. This can be configured with the <code>maxPayloadLength</code> parameter.</span> <pre numberoflines="6" language="typescript" data-language="typescript">Bun.serve({
  fetch(req, server) {}, // upgrade logic
  websocket: {
    maxPayloadLength: 1024 * 1024, // 1 MB
  },
});
</pre> <hr> <h2 id="connect-to-a-websocket-server"><span>Connect to a <code>Websocket</code> server</span></h2> <span data-as="p">Bun implements the <code>WebSocket</code> class. To create a WebSocket client that connects to a <code>ws://</code> or <code>wss://</code> server, create an instance of <code>WebSocket</code>, as you would in the browser.</span> <pre numberoflines="4" language="typescript" data-language="typescript">const socket = new WebSocket("ws://localhost:3000");

// With subprotocol negotiation
const socket2 = new WebSocket("ws://localhost:3000", ["soap", "wamp"]);
</pre> <span data-as="p">In browsers, the cookies that are currently set on the page will be sent with the WebSocket upgrade request. This is a standard feature of the <code>WebSocket</code> API.</span> <span data-as="p">For convenience, Bun lets you setting custom headers directly in the constructor. This is a Bun-specific extension of the <code>WebSocket</code> standard. <em>This will not work in browsers.</em></span> <pre numberoflines="5" language="typescript" data-language="typescript">const socket = new WebSocket("ws://localhost:3000", {
  headers: {
    /* custom headers */
  }, 
});
</pre> <span data-as="p">To add event listeners to the socket:</span> <pre numberoflines="11" language="typescript" data-language="typescript">// message is received
socket.addEventListener("message", event =&gt; {});

// socket opened
socket.addEventListener("open", event =&gt; {});

// socket closed
socket.addEventListener("close", event =&gt; {});

// error handler
socket.addEventListener("error", event =&gt; {});
</pre> <hr> <h2 id="reference"><span>Reference</span></h2> <pre numberoflines="65" language="typescript" data-language="typescript">namespace Bun {
  export function serve(params: {
    fetch: (req: Request, server: Server) =&gt; Response | Promise&lt;Response&gt;;
    websocket?: {
      message: (ws: ServerWebSocket, message: string | ArrayBuffer | Uint8Array) =&gt; void;
      open?: (ws: ServerWebSocket) =&gt; void;
      close?: (ws: ServerWebSocket, code: number, reason: string) =&gt; void;
      error?: (ws: ServerWebSocket, error: Error) =&gt; void;
      drain?: (ws: ServerWebSocket) =&gt; void;

      maxPayloadLength?: number; // default: 16 * 1024 * 1024 = 16 MB
      idleTimeout?: number; // default: 120 (seconds)
      backpressureLimit?: number; // default: 1024 * 1024 = 1 MB
      closeOnBackpressureLimit?: boolean; // default: false
      sendPings?: boolean; // default: true
      publishToSelf?: boolean; // default: false

      perMessageDeflate?:
        | boolean
        | {
            compress?: boolean | Compressor;
            decompress?: boolean | Compressor;
          };
    };
  }): Server;
}

type Compressor =
  | `"disable"`
  | `"shared"`
  | `"dedicated"`
  | `"3KB"`
  | `"4KB"`
  | `"8KB"`
  | `"16KB"`
  | `"32KB"`
  | `"64KB"`
  | `"128KB"`
  | `"256KB"`;

interface Server {
  pendingWebSockets: number;
  publish(topic: string, data: string | ArrayBufferView | ArrayBuffer, compress?: boolean): number;
  upgrade(
    req: Request,
    options?: {
      headers?: HeadersInit;
      data?: any;
    },
  ): boolean;
}

interface ServerWebSocket {
  readonly data: any;
  readonly readyState: number;
  readonly remoteAddress: string;
  readonly subscriptions: string[];
  send(message: string | ArrayBuffer | Uint8Array, compress?: boolean): number;
  close(code?: number, reason?: string): void;
  subscribe(topic: string): void;
  unsubscribe(topic: string): void;
  publish(topic: string, message: string | ArrayBuffer | Uint8Array): void;
  isSubscribed(topic: string): boolean;
  cork(cb: (ws: ServerWebSocket) =&gt; void): void;
}
See all 65 lines</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/http/websockets" class="_attribution-link">https://bun.com/docs/runtime/http/websockets</a>
  </p>
</div>
