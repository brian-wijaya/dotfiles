<h1 id="header">TCP</h1>
<div data-page-title="TCP" data-page-href="/runtime/networking/tcp" id="content">
<span data-as="p">This is a low-level API intended for library authors and for advanced use cases.</span> <h2 id="start-a-server-bun-listen"><span>Start a server (<code>Bun.listen()</code>)</span></h2> <span data-as="p">To start a TCP server with <code>Bun.listen</code>:</span> <pre numberoflines="11" language="typescript" data-language="typescript">Bun.listen({
  hostname: "localhost",
  port: 8080,
  socket: {
    data(socket, data) {}, // message received from client
    open(socket) {}, // socket opened
    close(socket, error) {}, // socket closed
    drain(socket) {}, // socket ready for more data
    error(socket, error) {}, // error handler
  },
});
</pre> <details><summary aria-controls="an-api-designed-for-speed accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">An API designed for speed</p></div></summary><div id="an-api-designed-for-speed accordion children" role="region" aria-labelledby="an-api-designed-for-speed" data-component-part="accordion-content">
<span data-as="p">In Bun, a set of handlers are declared once per server instead of assigning callbacks to each socket, as with Node.js <code>EventEmitters</code> or the web-standard <code>WebSocket</code> API.</span><pre numberoflines="11" language="typescript" data-language="typescript">Bun.listen({
  hostname: "localhost",
  port: 8080,
  socket: {
    open(socket) {},
    data(socket, data) {},
    drain(socket) {},
    close(socket, error) {},
    error(socket, error) {},
  },
});
</pre>
<span data-as="p">For performance-sensitive servers, assigning listeners to each socket can cause significant garbage collector pressure and increase memory usage. By contrast, Bun only allocates one handler function for each event and shares it among all sockets. This is a small optimization, but it adds up.</span>
</div></details> <span data-as="p">Contextual data can be attached to a socket in the <code>open</code> handler.</span> <pre numberoflines="14" language="typescript" data-language="typescript">type SocketData = { sessionId: string };

Bun.listen&lt;SocketData&gt;({
  hostname: "localhost",
  port: 8080,
  socket: {
    data(socket, data) {
      socket.write(`${socket.data.sessionId}: ack`); 
    },
    open(socket) {
      socket.data = { sessionId: "abcd" }; 
    },
  },
});
</pre> <span data-as="p">To enable TLS, pass a <code>tls</code> object containing <code>key</code> and <code>cert</code> fields.</span> <pre numberoflines="12" language="typescript" data-language="typescript">Bun.listen({
  hostname: "localhost",
  port: 8080,
  socket: {
    data(socket, data) {},
  },
  tls: {
    // can be string, BunFile, TypedArray, Buffer, or array thereof
    key: Bun.file("./key.pem"), 
    cert: Bun.file("./cert.pem"), 
  },
});
</pre> <span data-as="p">The <code>key</code> and <code>cert</code> fields expect the <em>contents</em> of your TLS key and certificate. This can be a string, <code>BunFile</code>, <code>TypedArray</code>, or <code>Buffer</code>.</span> <pre numberoflines="9" language="typescript" data-language="typescript">Bun.listen({
  // ...
  tls: {
    key: Bun.file("./key.pem"), // BunFile
    key: fs.readFileSync("./key.pem"), // Buffer
    key: fs.readFileSync("./key.pem", "utf8"), // string
    key: [Bun.file("./key1.pem"), Bun.file("./key2.pem")], // array of above
  },
});
</pre> <span data-as="p">The result of <code>Bun.listen</code> is a server that conforms to the <code>TCPSocket</code> interface.</span> <pre numberoflines="10" language="typescript" data-language="typescript">const server = Bun.listen({
  /* config*/
});

// stop listening
// parameter determines whether active connections are closed
server.stop(true);

// let Bun process exit even if server is still listening
server.unref();
</pre> <hr> <h2 id="create-a-connection-bun-connect"><span>Create a connection (<code>Bun.connect()</code>)</span></h2> <span data-as="p">Use <code>Bun.connect</code> to connect to a TCP server. Specify the server to connect to with <code>hostname</code> and <code>port</code>. TCP clients can define the same set of handlers as <code>Bun.listen</code>, plus a couple client-specific handlers.</span> <pre numberoflines="18" language="typescript" data-language="typescript">// The client
const socket = await Bun.connect({
  hostname: "localhost",
  port: 8080,

  socket: {
    data(socket, data) {},
    open(socket) {},
    close(socket, error) {},
    drain(socket) {},
    error(socket, error) {},

    // client-specific handlers
    connectError(socket, error) {}, // connection failed
    end(socket) {}, // connection closed by server
    timeout(socket) {}, // connection timed out
  },
});
</pre> <span data-as="p">To require TLS, specify <code>tls: true</code>.</span> <pre numberoflines="5" language="typescript" data-language="typescript">// The client
const socket = await Bun.connect({
  // ... config
  tls: true, 
});
</pre> <hr> <h2 id="hot-reloading"><span>Hot reloading</span></h2> <span data-as="p">Both TCP servers and sockets can be hot reloaded with new handlers.</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">server.tsclient.tsconst server = Bun.listen({
  /* config */
});

// reloads handlers for all active server-side sockets
server.reload({
  socket: {
    data() {
      // new 'data' handler
    },
  },
});
</pre> <hr> <h2 id="buffering"><span>Buffering</span></h2> <span data-as="p">Currently, TCP sockets in Bun do not buffer data. For performance-sensitive code, it’s important to consider buffering carefully. For example, this:</span> <pre numberoflines="5" language="typescript" data-language="typescript">socket.write("h");
socket.write("e");
socket.write("l");
socket.write("l");
socket.write("o");
</pre> <span data-as="p">…performs significantly worse than this:</span> <pre numberoflines="1" language="typescript" data-language="typescript">socket.write("hello");
</pre> <span data-as="p">To simplify this for now, consider using Bun’s <code>ArrayBufferSink</code> with the <code>{stream: true}</code> option:</span> <pre numberoflines="22" language="typescript" data-language="typescript">import { ArrayBufferSink } from "bun";

const sink = new ArrayBufferSink();
sink.start({
  stream: true, 
  highWaterMark: 1024,
});

sink.write("h");
sink.write("e");
sink.write("l");
sink.write("l");
sink.write("o");

queueMicrotask(() =&gt; {
  const data = sink.flush();
  const wrote = socket.write(data);
  if (wrote &lt; data.byteLength) {
    // put it back in the sink if the socket is full
    sink.write(data.subarray(wrote));
  }
});
</pre> <div data-callout-type="note">

<div data-component-part="callout-content">
<span data-as="p"><strong>Corking</strong></span><span data-as="p">Support for corking is planned, but in the meantime backpressure must be managed manually with the <code>drain</code> handler.</span>
</div>
</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/networking/tcp" class="_attribution-link">https://bun.com/docs/runtime/networking/tcp</a>
  </p>
</div>
