<h1 id="header">Utils</h1>
<div data-page-title="Utils" data-page-href="/runtime/utils" id="content">
<h2 id="bun-version"><span><code>Bun.version</code></span></h2> <span data-as="p">A <code>string</code> containing the version of the <code>bun</code> CLI that is currently running.</span> <pre numberoflines="2" language="typescript" data-language="typescript">Bun.version;
// =&gt; "1.3.3"
</pre> <h2 id="bun-revision"><span><code>Bun.revision</code></span></h2> <span data-as="p">The git commit of <a href="https://github.com/oven-sh/bun" target="_blank" rel="noreferrer">Bun</a> that was compiled to create the current <code>bun</code> CLI.</span> <pre numberoflines="2" language="typescript" data-language="typescript">Bun.revision;
// =&gt; "f02561530fda1ee9396f51c8bc99b38716e38296"
</pre> <h2 id="bun-env"><span><code>Bun.env</code></span></h2> <span data-as="p">An alias for <code>process.env</code>.</span> <h2 id="bun-main"><span><code>Bun.main</code></span></h2> <span data-as="p">An absolute path to the entrypoint of the current program (the file that was executed with <code>bun run</code>).</span> <pre numberoflines="2" language="typescript" data-language="typescript">Bun.main;
// /path/to/script.ts
</pre> <span data-as="p">This is particular useful for determining whether a script is being directly executed, as opposed to being imported by another script.</span> <pre numberoflines="5" language="typescript" data-language="typescript">if (import.meta.path === Bun.main) {
  // this script is being directly executed
} else {
  // this file is being imported from another script
}
</pre> <span data-as="p">This is analogous to the <a href="https://stackoverflow.com/questions/6398196/detect-if-called-through-require-or-directly-by-command-line" target="_blank" rel="noreferrer"><code>require.main = module</code> trick</a> in Node.js.</span> <h2 id="bun-sleep"><span><code>Bun.sleep()</code></span></h2> <span data-as="p"><code>Bun.sleep(ms: number)</code></span> <span data-as="p">Returns a <code>Promise</code> that resolves after the given number of milliseconds.</span> <pre numberoflines="3" language="typescript" data-language="typescript">console.log("hello");
await Bun.sleep(1000);
console.log("hello one second later!");
</pre> <span data-as="p">Alternatively, pass a <code>Date</code> object to receive a <code>Promise</code> that resolves at that point in time.</span> <pre numberoflines="5" language="typescript" data-language="typescript">const oneSecondInFuture = new Date(Date.now() + 1000);

console.log("hello");
await Bun.sleep(oneSecondInFuture);
console.log("hello one second later!");
</pre> <h2 id="bun-sleepsync"><span><code>Bun.sleepSync()</code></span></h2> <span data-as="p"><code>Bun.sleepSync(ms: number)</code></span> <span data-as="p">A blocking synchronous version of <code>Bun.sleep</code>.</span> <pre numberoflines="3" language="typescript" data-language="typescript">console.log("hello");
Bun.sleepSync(1000); // blocks thread for one second
console.log("hello one second later!");
</pre> <h2 id="bun-which"><span><code>Bun.which()</code></span></h2> <span data-as="p"><code>Bun.which(bin: string)</code></span> <span data-as="p">Returns the path to an executable, similar to typing <code>which</code> in your terminal.</span> <pre numberoflines="2" language="typescript" data-language="typescript">const ls = Bun.which("ls");
console.log(ls); // "/usr/bin/ls"
</pre> <span data-as="p">By default Bun looks at the current <code>PATH</code> environment variable to determine the path. To configure <code>PATH</code>:</span> <pre numberoflines="4" language="typescript" data-language="typescript">const ls = Bun.which("ls", {
  PATH: "/usr/local/bin:/usr/bin:/bin",
});
console.log(ls); // "/usr/bin/ls"
</pre> <span data-as="p">Pass a <code>cwd</code> option to resolve for executable from within a specific directory.</span> <pre numberoflines="6" language="typescript" data-language="typescript">const ls = Bun.which("ls", {
  cwd: "/tmp",
  PATH: "",
});

console.log(ls); // null
</pre> <span data-as="p">You can think of this as a builtin alternative to the <a href="https://www.npmjs.com/package/which" target="_blank" rel="noreferrer"><code>which</code></a> npm package.</span> <h2 id="bun-randomuuidv7"><span><code>Bun.randomUUIDv7()</code></span></h2> <span data-as="p"><code>Bun.randomUUIDv7()</code> returns a <a href="https://www.ietf.org/archive/id/draft-peabody-dispatch-new-uuid-format-01.html#name-uuidv7-layout-and-bit-order" target="_blank" rel="noreferrer">UUID v7</a>, which is monotonic and suitable for sorting and databases.</span> <pre numberoflines="4" language="typescript" data-language="typescript">import { randomUUIDv7 } from "bun";

const id = randomUUIDv7();
// =&gt; "0192ce11-26d5-7dc3-9305-1426de888c5a"
</pre> <span data-as="p">A UUID v7 is a 128-bit value that encodes the current timestamp, a random value, and a counter. The timestamp is encoded using the lowest 48 bits, and the random value and counter are encoded using the remaining bits.</span> <span data-as="p">The <code>timestamp</code> parameter defaults to the current time in milliseconds. When the timestamp changes, the counter is reset to a pseudo-random integer wrapped to 4096. This counter is atomic and threadsafe, meaning that using <code>Bun.randomUUIDv7()</code> in many Workers within the same process running at the same timestamp will not have colliding counter values.</span> <span data-as="p">The final 8 bytes of the UUID are a cryptographically secure random value. It uses the same random number generator used by <code>crypto.randomUUID()</code> (which comes from BoringSSL, which in turn comes from the platform-specific system random number generator usually provided by the underlying hardware).</span> <pre numberoflines="10" language="typescript" data-language="typescript">namespace Bun {
  function randomUUIDv7(encoding?: "hex" | "base64" | "base64url" = "hex", timestamp?: number = Date.now()): string;
  /**
   * If you pass "buffer", you get a 16-byte buffer instead of a string.
   */
  function randomUUIDv7(encoding: "buffer", timestamp?: number = Date.now()): Buffer;

  // If you only pass a timestamp, you get a hex string
  function randomUUIDv7(timestamp?: number = Date.now()): string;
}
</pre> <span data-as="p">You can optionally set encoding to <code>"buffer"</code> to get a 16-byte buffer instead of a string. This can sometimes avoid string conversion overhead.</span> <pre numberoflines="1" language="typescript" data-language="typescript">const buffer = Bun.randomUUIDv7("buffer");
</pre> <span data-as="p"><code>base64</code> and <code>base64url</code> encodings are also supported when you want a slightly shorter string.</span> <pre numberoflines="2" language="typescript" data-language="typescript">const base64 = Bun.randomUUIDv7("base64");
const base64url = Bun.randomUUIDv7("base64url");
</pre> <h2 id="bun-peek"><span><code>Bun.peek()</code></span></h2> <span data-as="p"><code>Bun.peek(prom: Promise)</code></span> <span data-as="p">Reads a promise’s result without <code>await</code> or <code>.then</code>, but only if the promise has already fulfilled or rejected.</span> <pre numberoflines="7" language="typescript" data-language="typescript">import { peek } from "bun";

const promise = Promise.resolve("hi");

// no await!
const result = peek(promise);
console.log(result); // "hi"
</pre> <span data-as="p">This is important when attempting to reduce number of extraneous microticks in performance-sensitive code. It’s an advanced API and you probably shouldn’t use it unless you know what you’re doing.</span> <pre numberoflines="27" language="typescript" data-language="typescript">import { peek } from "bun";
import { expect, test } from "bun:test";

test("peek", () =&gt; {
  const promise = Promise.resolve(true);

  // no await necessary!
  expect(peek(promise)).toBe(true);

  // if we peek again, it returns the same value
  const again = peek(promise);
  expect(again).toBe(true);

  // if we peek a non-promise, it returns the value
  const value = peek(42);
  expect(value).toBe(42);

  // if we peek a pending promise, it returns the promise again
  const pending = new Promise(() =&gt; {});
  expect(peek(pending)).toBe(pending);

  // If we peek a rejected promise, it:
  // - returns the error
  // - does not mark the promise as handled
  const rejected = Promise.reject(new Error("Successfully tested promise rejection"));
  expect(peek(rejected).message).toBe("Successfully tested promise rejection");
});
</pre> <span data-as="p">The <code>peek.status</code> function lets you read the status of a promise without resolving it.</span> <pre numberoflines="13" language="typescript" data-language="typescript">import { peek } from "bun";
import { expect, test } from "bun:test";

test("peek.status", () =&gt; {
  const promise = Promise.resolve(true);
  expect(peek.status(promise)).toBe("fulfilled");

  const pending = new Promise(() =&gt; {});
  expect(peek.status(pending)).toBe("pending");

  const rejected = Promise.reject(new Error("oh nooo"));
  expect(peek.status(rejected)).toBe("rejected");
});
</pre> <h2 id="bun-openineditor"><span><code>Bun.openInEditor()</code></span></h2> <span data-as="p">Opens a file in your default editor. Bun auto-detects your editor via the <code>$VISUAL</code> or <code>$EDITOR</code> environment variables.</span> <pre numberoflines="2" language="typescript" data-language="typescript">const currentFile = import.meta.url;
Bun.openInEditor(currentFile);
</pre> <span data-as="p">You can override this via the <code>debug.editor</code> setting in your <a href="bunfig"><code>bunfig.toml</code></a>.</span> <pre numberoflines="2" language="toml" data-language="typescript">[debug]
editor = "code"
</pre> <span data-as="p">Or specify an editor with the <code>editor</code> param. You can also specify a line and column number.</span> <pre numberoflines="5" language="typescript" data-language="typescript">Bun.openInEditor(import.meta.url, {
  editor: "vscode", // or "subl"
  line: 10,
  column: 5,
});
</pre> <h2 id="bun-deepequals"><span><code>Bun.deepEquals()</code></span></h2> <span data-as="p">Recursively checks if two objects are equivalent. This is used internally by <code>expect().toEqual()</code> in <code>bun:test</code>.</span> <pre numberoflines="7" language="typescript" data-language="typescript">const foo = { a: 1, b: 2, c: { d: 3 } };

// true
Bun.deepEquals(foo, { a: 1, b: 2, c: { d: 3 } });

// false
Bun.deepEquals(foo, { a: 1, b: 2, c: { d: 4 } });
</pre> <span data-as="p">A third boolean parameter can be used to enable “strict” mode. This is used by <code>expect().toStrictEqual()</code> in the test runner.</span> <pre numberoflines="5" language="typescript" data-language="typescript">const a = { entries: [1, 2] };
const b = { entries: [1, 2], extra: undefined };

Bun.deepEquals(a, b); // =&gt; true
Bun.deepEquals(a, b, true); // =&gt; false
</pre> <span data-as="p">In strict mode, the following are considered unequal:</span> <pre numberoflines="14" language="typescript" data-language="typescript">// undefined values
Bun.deepEquals({}, { a: undefined }, true); // false

// undefined in arrays
Bun.deepEquals(["asdf"], ["asdf", undefined], true); // false

// sparse arrays
Bun.deepEquals([, 1], [undefined, 1], true); // false

// object literals vs instances w/ same properties
class Foo {
  a = 1;
}
Bun.deepEquals(new Foo(), { a: 1 }, true); // false
</pre> <h2 id="bun-escapehtml"><span><code>Bun.escapeHTML()</code></span></h2> <span data-as="p"><code>Bun.escapeHTML(value: string | object | number | boolean): string</code></span> <span data-as="p">Escapes the following characters from an input string:</span> <ul> <li>
<code>"</code> becomes <code>&amp;quot;</code>
</li> <li>
<code>&amp;</code> becomes <code>&amp;amp;</code>
</li> <li>
<code>'</code> becomes <code>&amp;#x27;</code>
</li> <li>
<code>&lt;</code> becomes <code>&amp;lt;</code>
</li> <li>
<code>&gt;</code> becomes <code>&amp;gt;</code>
</li> </ul> <span data-as="p">This function is optimized for large input. On an M1X, it processes 480 MB/s - 20 GB/s, depending on how much data is being escaped and whether there is non-ascii text. Non-string types will be converted to a string before escaping.</span> <h2 id="bun-stringwidth"><span><code>Bun.stringWidth()</code></span></h2> <div data-callout-type="note">

<div data-component-part="callout-content">~6,756x faster <code>string-width</code> alternative</div>
</div> <span data-as="p">Get the column count of a string as it would be displayed in a terminal. Supports ANSI escape codes, emoji, and wide characters.</span> <span data-as="p">Example usage:</span> <pre numberoflines="3" language="typescript" data-language="typescript">Bun.stringWidth("hello"); // =&gt; 5
Bun.stringWidth("\u001b[31mhello\u001b[0m"); // =&gt; 5
Bun.stringWidth("\u001b[31mhello\u001b[0m", { countAnsiEscapeCodes: true }); // =&gt; 12
</pre> <span data-as="p">This is useful for:</span> <ul> <li>Aligning text in a terminal</li> <li>Quickly checking if a string contains ANSI escape codes</li> <li>Measuring the width of a string in a terminal</li> </ul> <span data-as="p">This API is designed to match the popular “string-width” package, so that existing code can be easily ported to Bun and vice versa.</span> <span data-as="p"><a href="https://github.com/oven-sh/bun/blob/5147c0ba7379d85d4d1ed0714b84d6544af917eb/bench/snippets/string-width.mjs#L13" target="_blank" rel="noreferrer">In this benchmark</a>, <code>Bun.stringWidth</code> is a ~6,756x faster than the <code>string-width</code> npm package for input larger than about 500 characters. Big thanks to <a href="https://github.com/sindresorhus" target="_blank" rel="noreferrer">sindresorhus</a> for their work on <code>string-width</code>!</span> <pre numberoflines="13" language="typescript" data-language="typescript">❯ bun string-width.mjs
cpu: 13th Gen Intel(R) Core(TM) i9-13900
runtime: bun 1.0.29 (x64-linux)

benchmark                                          time (avg)             (min … max)       p75       p99      p995
------------------------------------------------------------------------------------- -----------------------------
Bun.stringWidth     500 chars ascii              37.09 ns/iter   (36.77 ns … 41.11 ns)  37.07 ns  38.84 ns  38.99 ns

❯ node string-width.mjs

benchmark                                          time (avg)             (min … max)       p75       p99      p995
------------------------------------------------------------------------------------- -----------------------------
npm/string-width    500 chars ascii             249,710 ns/iter (239,970 ns … 293,180 ns) 250,930 ns  276,700 ns 281,450 ns
</pre> <span data-as="p">To make <code>Bun.stringWidth</code> fast, we’ve implemented it in Zig using optimized SIMD instructions, accounting for Latin1, UTF-16, and UTF-8 encodings. It passes <code>string-width</code>’s tests.</span> <details><summary aria-controls="view-full-benchmark accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">View full benchmark</p></div></summary><div id="view-full-benchmark accordion children" role="region" aria-labelledby="view-full-benchmark" data-component-part="accordion-content">
<span data-as="p">As a reminder, 1 nanosecond (ns) is 1 billionth of a second. Here’s a quick reference for converting between units:</span><div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Unit</th>
<th>1 Millisecond</th>
</tr></thead>
<tbody>
<tr>
<td>ns</td>
<td data-numeric="true">1,000,000</td>
</tr>
<tr>
<td>µs</td>
<td data-numeric="true">1,000</td>
</tr>
<tr>
<td>ms</td>
<td data-numeric="true">1</td>
</tr>
</tbody>
</table></div></div>
<pre numberoflines="26" language="shellscript" data-language="typescript">❯ bun string-width.mjs
cpu: 13th Gen Intel(R) Core(TM) i9-13900
runtime: bun 1.0.29 (x64-linux)

benchmark                                          time (avg)             (min … max)       p75       p99      p995
------------------------------------------------------------------------------------- -----------------------------
Bun.stringWidth      5 chars ascii              16.45 ns/iter   (16.27 ns … 19.71 ns)  16.48 ns  16.93 ns  17.21 ns
Bun.stringWidth     50 chars ascii              19.42 ns/iter   (18.61 ns … 27.85 ns)  19.35 ns   21.7 ns  22.31 ns
Bun.stringWidth    500 chars ascii              37.09 ns/iter   (36.77 ns … 41.11 ns)  37.07 ns  38.84 ns  38.99 ns
Bun.stringWidth  5,000 chars ascii              216.9 ns/iter  (215.8 ns … 228.54 ns) 216.23 ns 228.52 ns 228.53 ns
Bun.stringWidth 25,000 chars ascii               1.01 µs/iter     (1.01 µs … 1.01 µs)   1.01 µs   1.01 µs   1.01 µs
Bun.stringWidth      7 chars ascii+emoji         54.2 ns/iter   (53.36 ns … 58.19 ns)  54.23 ns  57.55 ns  57.94 ns
Bun.stringWidth     70 chars ascii+emoji       354.26 ns/iter (350.51 ns … 363.96 ns) 355.93 ns 363.11 ns 363.96 ns
Bun.stringWidth    700 chars ascii+emoji          3.3 µs/iter      (3.27 µs … 3.4 µs)    3.3 µs    3.4 µs    3.4 µs
Bun.stringWidth  7,000 chars ascii+emoji        32.69 µs/iter   (32.22 µs … 45.27 µs)   32.7 µs  34.57 µs  34.68 µs
Bun.stringWidth 35,000 chars ascii+emoji       163.35 µs/iter (161.17 µs … 170.79 µs) 163.82 µs 169.66 µs 169.93 µs
Bun.stringWidth      8 chars ansi+emoji         66.15 ns/iter   (65.17 ns … 69.97 ns)  66.12 ns   69.8 ns  69.87 ns
Bun.stringWidth     80 chars ansi+emoji        492.95 ns/iter  (488.05 ns … 499.5 ns)  494.8 ns 498.58 ns  499.5 ns
Bun.stringWidth    800 chars ansi+emoji          4.73 µs/iter     (4.71 µs … 4.88 µs)   4.72 µs   4.88 µs   4.88 µs
Bun.stringWidth  8,000 chars ansi+emoji         47.02 µs/iter   (46.37 µs … 67.44 µs)  46.96 µs  49.57 µs  49.63 µs
Bun.stringWidth 40,000 chars ansi+emoji        234.45 µs/iter (231.78 µs … 240.98 µs) 234.92 µs 236.34 µs 236.62 µs
Bun.stringWidth     19 chars ansi+emoji+ascii  135.46 ns/iter (133.67 ns … 143.26 ns) 135.32 ns 142.55 ns 142.77 ns
Bun.stringWidth    190 chars ansi+emoji+ascii    1.17 µs/iter     (1.16 µs … 1.17 µs)   1.17 µs   1.17 µs   1.17 µs
Bun.stringWidth  1,900 chars ansi+emoji+ascii   11.45 µs/iter   (11.26 µs … 20.41 µs)  11.45 µs  12.08 µs  12.11 µs
Bun.stringWidth 19,000 chars ansi+emoji+ascii  114.06 µs/iter (112.86 µs … 120.06 µs) 114.25 µs 115.86 µs 116.15 µs
Bun.stringWidth 95,000 chars ansi+emoji+ascii  572.69 µs/iter (565.52 µs … 607.22 µs) 572.45 µs 604.86 µs 605.21 µs
</pre>
<pre numberoflines="26" language="shellscript" data-language="typescript">❯ node string-width.mjs
cpu: 13th Gen Intel(R) Core(TM) i9-13900
runtime: node v21.4.0 (x64-linux)

benchmark                                           time (avg)             (min … max)       p75       p99      p995
-------------------------------------------------------------------------------------- -----------------------------
npm/string-width      5 chars ascii               3.19 µs/iter     (3.13 µs … 3.48 µs)   3.25 µs   3.48 µs   3.48 µs
npm/string-width     50 chars ascii              20.09 µs/iter  (18.93 µs … 435.06 µs)  19.49 µs  21.89 µs  22.59 µs
npm/string-width    500 chars ascii             249.71 µs/iter (239.97 µs … 293.18 µs) 250.93 µs  276.7 µs 281.45 µs
npm/string-width  5,000 chars ascii               6.69 ms/iter     (6.58 ms … 6.76 ms)   6.72 ms   6.76 ms   6.76 ms
npm/string-width 25,000 chars ascii             139.57 ms/iter (137.17 ms … 143.28 ms) 140.49 ms 143.28 ms 143.28 ms
npm/string-width      7 chars ascii+emoji          3.7 µs/iter     (3.62 µs … 3.94 µs)   3.73 µs   3.94 µs   3.94 µs
npm/string-width     70 chars ascii+emoji        23.93 µs/iter   (22.44 µs … 331.2 µs)  23.15 µs  25.98 µs   30.2 µs
npm/string-width    700 chars ascii+emoji       251.65 µs/iter (237.78 µs … 444.69 µs) 252.92 µs 325.89 µs 354.08 µs
npm/string-width  7,000 chars ascii+emoji         4.95 ms/iter     (4.82 ms … 5.19 ms)      5 ms   5.04 ms   5.19 ms
npm/string-width 35,000 chars ascii+emoji        96.93 ms/iter  (94.39 ms … 102.58 ms)  97.68 ms 102.58 ms 102.58 ms
npm/string-width      8 chars ansi+emoji          3.92 µs/iter     (3.45 µs … 4.57 µs)   4.09 µs   4.57 µs   4.57 µs
npm/string-width     80 chars ansi+emoji         24.46 µs/iter     (22.87 µs … 4.2 ms)  23.54 µs  25.89 µs  27.41 µs
npm/string-width    800 chars ansi+emoji        259.62 µs/iter (246.76 µs … 480.12 µs) 258.65 µs 349.84 µs 372.55 µs
npm/string-width  8,000 chars ansi+emoji          5.46 ms/iter     (5.41 ms … 5.57 ms)   5.48 ms   5.55 ms   5.57 ms
npm/string-width 40,000 chars ansi+emoji        108.91 ms/iter  (107.55 ms … 109.5 ms) 109.25 ms  109.5 ms  109.5 ms
npm/string-width     19 chars ansi+emoji+ascii    6.53 µs/iter     (6.35 µs … 6.75 µs)   6.54 µs   6.75 µs   6.75 µs
npm/string-width    190 chars ansi+emoji+ascii   55.52 µs/iter  (52.59 µs … 352.73 µs)  54.19 µs  80.77 µs 167.21 µs
npm/string-width  1,900 chars ansi+emoji+ascii  701.71 µs/iter (653.94 µs … 893.78 µs)  715.3 µs 855.37 µs  872.9 µs
npm/string-width 19,000 chars ansi+emoji+ascii   27.19 ms/iter   (26.89 ms … 27.41 ms)  27.28 ms  27.41 ms  27.41 ms
npm/string-width 95,000 chars ansi+emoji+ascii     3.68 s/iter        (3.66 s … 3.7 s)    3.69 s     3.7 s     3.7 s
</pre>
</div></details> <span data-as="p">TypeScript definition:</span> <pre numberoflines="22" language="typescript" data-language="typescript">namespace Bun {
  export function stringWidth(
    /**
     * The string to measure
     */
    input: string,
    options?: {
      /**
       * If `true`, count ANSI escape codes as part of the string width. If `false`, ANSI escape codes are ignored when calculating the string width.
       *
       * @default false
       */
      countAnsiEscapeCodes?: boolean;
      /**
       * When it's ambiugous and `true`, count emoji as 1 characters wide. If `false`, emoji are counted as 2 character wide.
       *
       * @default true
       */
      ambiguousIsNarrow?: boolean;
    },
  ): number;
}
See all 22 lines</pre> <hr> <h2 id="bun-fileurltopath"><span><code>Bun.fileURLToPath()</code></span></h2> <span data-as="p">Converts a <code>file://</code> URL to an absolute path.</span> <pre numberoflines="2" language="typescript" data-language="typescript">const path = Bun.fileURLToPath(new URL("file:///foo/bar.txt"));
console.log(path); // "/foo/bar.txt"
</pre> <hr> <h2 id="bun-pathtofileurl"><span><code>Bun.pathToFileURL()</code></span></h2> <span data-as="p">Converts an absolute path to a <code>file://</code> URL.</span> <pre numberoflines="2" language="typescript" data-language="typescript">const url = Bun.pathToFileURL("/foo/bar.txt");
console.log(url); // "file:///foo/bar.txt"
</pre> <hr> <h2 id="bun-gzipsync"><span><code>Bun.gzipSync()</code></span></h2> <span data-as="p">Compresses a <code>Uint8Array</code> using zlib’s GZIP algorithm.</span> <pre numberoflines="5" language="typescript" data-language="typescript">const buf = Buffer.from("hello".repeat(100)); // Buffer extends Uint8Array
const compressed = Bun.gzipSync(buf);

buf; // =&gt; Uint8Array(500)
compressed; // =&gt; Uint8Array(30)
</pre> <span data-as="p">Optionally, pass a parameters object as the second argument:</span> <details><summary aria-controls="zlib-compression-options accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">zlib compression options</p></div></summary><div id="zlib-compression-options accordion children" role="region" aria-labelledby="zlib-compression-options" data-component-part="accordion-content"><pre numberoflines="68" language="typescript" data-language="typescript">export type ZlibCompressionOptions = {
  /**
   * The compression level to use. Must be between `-1` and `9`.
   * - A value of `-1` uses the default compression level (Currently `6`)
   * - A value of `0` gives no compression
   * - A value of `1` gives least compression, fastest speed
   * - A value of `9` gives best compression, slowest speed
   */
  level?: -1 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
  /**
   * How much memory should be allocated for the internal compression state.
   *
   * A value of `1` uses minimum memory but is slow and reduces compression ratio.
   *
   * A value of `9` uses maximum memory for optimal speed. The default is `8`.
   */
  memLevel?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
  /**
   * The base 2 logarithm of the window size (the size of the history buffer).
   *
   * Larger values of this parameter result in better compression at the expense of memory usage.
   *
   * The following value ranges are supported:
   * - `9..15`: The output will have a zlib header and footer (Deflate)
   * - `-9..-15`: The output will **not** have a zlib header or footer (Raw Deflate)
   * - `25..31` (16+`9..15`): The output will have a gzip header and footer (gzip)
   *
   * The gzip header will have no file name, no extra data, no comment, no modification time (set to zero) and no header CRC.
   */
  windowBits?:
    | -9
    | -10
    | -11
    | -12
    | -13
    | -14
    | -15
    | 9
    | 10
    | 11
    | 12
    | 13
    | 14
    | 15
    | 25
    | 26
    | 27
    | 28
    | 29
    | 30
    | 31;
  /**
   * Tunes the compression algorithm.
   *
   * - `Z_DEFAULT_STRATEGY`: For normal data **(Default)**
   * - `Z_FILTERED`: For data produced by a filter or predictor
   * - `Z_HUFFMAN_ONLY`: Force Huffman encoding only (no string match)
   * - `Z_RLE`: Limit match distances to one (run-length encoding)
   * - `Z_FIXED` prevents the use of dynamic Huffman codes
   *
   * `Z_RLE` is designed to be almost as fast as `Z_HUFFMAN_ONLY`, but give better compression for PNG image data.
   *
   * `Z_FILTERED` forces more Huffman coding and less string matching, it is
   * somewhat intermediate between `Z_DEFAULT_STRATEGY` and `Z_HUFFMAN_ONLY`.
   * Filtered data consists mostly of small values with a somewhat random distribution.
   */
  strategy?: number;
};
See all 68 lines</pre></div></details> <hr> <h2 id="bun-gunzipsync"><span><code>Bun.gunzipSync()</code></span></h2> <span data-as="p">Decompresses a <code>Uint8Array</code> using zlib’s GUNZIP algorithm.</span> <pre numberoflines="7" language="typescript" data-language="typescript">const buf = Buffer.from("hello".repeat(100)); // Buffer extends Uint8Array
const compressed = Bun.gzipSync(buf);

const dec = new TextDecoder();
const uncompressed = Bun.gunzipSync(compressed);
dec.decode(uncompressed);
// =&gt; "hellohellohello..."
</pre> <hr> <h2 id="bun-deflatesync"><span><code>Bun.deflateSync()</code></span></h2> <span data-as="p">Compresses a <code>Uint8Array</code> using zlib’s DEFLATE algorithm.</span> <pre numberoflines="5" language="typescript" data-language="typescript">const buf = Buffer.from("hello".repeat(100));
const compressed = Bun.deflateSync(buf);

buf; // =&gt; Buffer(500)
compressed; // =&gt; Uint8Array(12)
</pre> <span data-as="p">The second argument supports the same set of configuration options as <a href="#bun-gzipsync"><code>Bun.gzipSync</code></a>.</span> <hr> <h2 id="bun-inflatesync"><span><code>Bun.inflateSync()</code></span></h2> <span data-as="p">Decompresses a <code>Uint8Array</code> using zlib’s INFLATE algorithm.</span> <pre numberoflines="7" language="typescript" data-language="typescript">const buf = Buffer.from("hello".repeat(100));
const compressed = Bun.deflateSync(buf);

const dec = new TextDecoder();
const decompressed = Bun.inflateSync(compressed);
dec.decode(decompressed);
// =&gt; "hellohellohello..."
</pre> <hr> <h2 id="bun-zstdcompress-/-bun-zstdcompresssync"><span><code>Bun.zstdCompress()</code> / <code>Bun.zstdCompressSync()</code></span></h2> <span data-as="p">Compresses a <code>Uint8Array</code> using the Zstandard algorithm.</span> <pre numberoflines="9" language="typescript" data-language="typescript">const buf = Buffer.from("hello".repeat(100));

// Synchronous
const compressedSync = Bun.zstdCompressSync(buf);
// Asynchronous
const compressedAsync = await Bun.zstdCompress(buf);

// With compression level (1-22, default: 3)
const compressedLevel = Bun.zstdCompressSync(buf, { level: 6 });
</pre> <h2 id="bun-zstddecompress-/-bun-zstddecompresssync"><span><code>Bun.zstdDecompress()</code> / <code>Bun.zstdDecompressSync()</code></span></h2> <span data-as="p">Decompresses a <code>Uint8Array</code> using the Zstandard algorithm.</span> <pre numberoflines="11" language="typescript" data-language="typescript">const buf = Buffer.from("hello".repeat(100));
const compressed = Bun.zstdCompressSync(buf);

// Synchronous
const decompressedSync = Bun.zstdDecompressSync(compressed);
// Asynchronous
const decompressedAsync = await Bun.zstdDecompress(compressed);

const dec = new TextDecoder();
dec.decode(decompressedSync);
// =&gt; "hellohellohello..."
</pre> <hr> <h2 id="bun-inspect"><span><code>Bun.inspect()</code></span></h2> <span data-as="p">Serializes an object to a <code>string</code> exactly as it would be printed by <code>console.log</code>.</span> <pre numberoflines="7" language="typescript" data-language="typescript">const obj = { foo: "bar" };
const str = Bun.inspect(obj);
// =&gt; '{\nfoo: "bar" \n}'

const arr = new Uint8Array([1, 2, 3]);
const str = Bun.inspect(arr);
// =&gt; "Uint8Array(3) [ 1, 2, 3 ]"
</pre> <h3 id="bun-inspect-custom"><span><code>Bun.inspect.custom</code></span></h3> <span data-as="p">This is the symbol that Bun uses to implement <code>Bun.inspect</code>. You can override this to customize how your objects are printed. It is identical to <code>util.inspect.custom</code> in Node.js.</span> <pre numberoflines="8" language="typescript" data-language="typescript">class Foo {
  [Bun.inspect.custom]() {
    return "foo";
  }
}

const foo = new Foo();
console.log(foo); // =&gt; "foo"
</pre> <h3 id="bun-inspect-table-tabulardata,-properties,-options"><span><code>Bun.inspect.table(tabularData, properties, options)</code></span></h3> <span data-as="p">Format tabular data into a string. Like <a href="https://developer.mozilla.org/en-US/docs/Web/API/console/table_static" target="_blank" rel="noreferrer"><code>console.table</code></a>, except it returns a string rather than printing to the console.</span> <pre numberoflines="15" language="typescript" data-language="typescript">console.log(
  Bun.inspect.table([
    { a: 1, b: 2, c: 3 },
    { a: 4, b: 5, c: 6 },
    { a: 7, b: 8, c: 9 },
  ]),
);
//
// ┌───┬───┬───┬───┐
// │   │ a │ b │ c │
// ├───┼───┼───┼───┤
// │ 0 │ 1 │ 2 │ 3 │
// │ 1 │ 4 │ 5 │ 6 │
// │ 2 │ 7 │ 8 │ 9 │
// └───┴───┴───┴───┘
</pre> <span data-as="p">Additionally, you can pass an array of property names to display only a subset of properties.</span> <pre numberoflines="16" language="typescript" data-language="typescript">console.log(
  Bun.inspect.table(
    [
      { a: 1, b: 2, c: 3 },
      { a: 4, b: 5, c: 6 },
    ],
    ["a", "c"],
  ),
);
//
// ┌───┬───┬───┐
// │   │ a │ c │
// ├───┼───┼───┤
// │ 0 │ 1 │ 3 │
// │ 1 │ 4 │ 6 │
// └───┴───┴───┘
</pre> <span data-as="p">You can also conditionally enable ANSI colors by passing <code>{ colors: true }</code>.</span> <pre numberoflines="11" language="typescript" data-language="typescript">console.log(
  Bun.inspect.table(
    [
      { a: 1, b: 2, c: 3 },
      { a: 4, b: 5, c: 6 },
    ],
    {
      colors: true,
    },
  ),
);
</pre> <hr> <h2 id="bun-nanoseconds"><span><code>Bun.nanoseconds()</code></span></h2> <span data-as="p">Returns the number of nanoseconds since the current <code>bun</code> process started, as a <code>number</code>. Useful for high-precision timing and benchmarking.</span> <pre numberoflines="2" language="typescript" data-language="typescript">Bun.nanoseconds();
// =&gt; 7288958
</pre> <hr> <h2 id="bun-readablestreamto"><span><code>Bun.readableStreamTo*()</code></span></h2> <span data-as="p">Bun implements a set of convenience functions for asynchronously consuming the body of a <code>ReadableStream</code> and converting it to various binary formats.</span> <pre numberoflines="27" language="typescript" data-language="typescript">const stream = (await fetch("https://bun.com")).body;
stream; // =&gt; ReadableStream

await Bun.readableStreamToArrayBuffer(stream);
// =&gt; ArrayBuffer

await Bun.readableStreamToBytes(stream);
// =&gt; Uint8Array

await Bun.readableStreamToBlob(stream);
// =&gt; Blob

await Bun.readableStreamToJSON(stream);
// =&gt; object

await Bun.readableStreamToText(stream);
// =&gt; string

// returns all chunks as an array
await Bun.readableStreamToArray(stream);
// =&gt; unknown[]

// returns all chunks as a FormData object (encoded as x-www-form-urlencoded)
await Bun.readableStreamToFormData(stream);

// returns all chunks as a FormData object (encoded as multipart/form-data)
await Bun.readableStreamToFormData(stream, multipartFormBoundary);
</pre> <hr> <h2 id="bun-resolvesync"><span><code>Bun.resolveSync()</code></span></h2> <span data-as="p">Resolves a file path or module specifier using Bun’s internal module resolution algorithm. The first argument is the path to resolve, and the second argument is the “root”. If no match is found, an <code>Error</code> is thrown.</span> <pre numberoflines="5" language="typescript" data-language="typescript">Bun.resolveSync("./foo.ts", "/path/to/project");
// =&gt; "/path/to/project/foo.ts"

Bun.resolveSync("zod", "/path/to/project");
// =&gt; "/path/to/project/node_modules/zod/index.ts"
</pre> <span data-as="p">To resolve relative to the current working directory, pass <code>process.cwd()</code> or <code>"."</code> as the root.</span> <pre numberoflines="2" language="typescript" data-language="typescript">Bun.resolveSync("./foo.ts", process.cwd());
Bun.resolveSync("./foo.ts", "/path/to/project");
</pre> <span data-as="p">To resolve relative to the directory containing the current file, pass <code>import.meta.dir</code>.</span> <pre numberoflines="1" language="typescript" data-language="typescript">Bun.resolveSync("./foo.ts", import.meta.dir);
</pre> <hr> <h2 id="bun-stripansi"><span><code>Bun.stripANSI()</code></span></h2> <div data-callout-type="note">

<div data-component-part="callout-content">~6-57x faster <code>strip-ansi</code> alternative</div>
</div> <span data-as="p"><code>Bun.stripANSI(text: string): string</code></span> <span data-as="p">Strip ANSI escape codes from a string. This is useful for removing colors and formatting from terminal output.</span> <pre numberoflines="7" language="typescript" data-language="typescript">const coloredText = "\u001b[31mHello\u001b[0m \u001b[32mWorld\u001b[0m";
const plainText = Bun.stripANSI(coloredText);
console.log(plainText); // =&gt; "Hello World"

// Works with various ANSI codes
const formatted = "\u001b[1m\u001b[4mBold and underlined\u001b[0m";
console.log(Bun.stripANSI(formatted)); // =&gt; "Bold and underlined"
</pre> <span data-as="p"><code>Bun.stripANSI</code> is significantly faster than the popular <a href="https://www.npmjs.com/package/strip-ansi" target="_blank" rel="noreferrer"><code>strip-ansi</code></a> npm package:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun bench/snippets/strip-ansi.mjs
</pre> <pre numberoflines="17" language="text" data-language="typescript">cpu: Apple M3 Max
runtime: bun 1.2.21 (arm64-darwin)

benchmark                               avg (min … max) p75 / p99
------------------------------------------------------- ----------
Bun.stripANSI      11 chars no-ansi        8.13 ns/iter   8.27 ns
                                   (7.45 ns … 33.59 ns)  10.29 ns

Bun.stripANSI      13 chars ansi          51.68 ns/iter  52.51 ns
                                 (46.16 ns … 113.71 ns)  57.71 ns

Bun.stripANSI  16,384 chars long-no-ansi 298.39 ns/iter 305.44 ns
                                (281.50 ns … 331.65 ns) 320.70 ns

Bun.stripANSI 212,992 chars long-ansi    227.65 µs/iter 234.50 µs
                                (216.46 µs … 401.92 µs) 262.25 µs
</pre> <pre numberoflines="1" language="shellscript" data-language="typescript">node bench/snippets/strip-ansi.mjs
</pre> <pre numberoflines="18" language="text" data-language="typescript">cpu: Apple M3 Max
runtime: node 24.6.0 (arm64-darwin)

benchmark                                avg (min … max) p75 / p99
-------------------------------------------------------- ---------
npm/strip-ansi      11 chars no-ansi      466.79 ns/iter 468.67 ns
                                 (454.08 ns … 570.67 ns) 543.67 ns

npm/strip-ansi      13 chars ansi         546.77 ns/iter 550.23 ns
                                 (532.74 ns … 651.08 ns) 590.35 ns

npm/strip-ansi  16,384 chars long-no-ansi   4.85 µs/iter   4.89 µs
                                     (4.71 µs … 5.00 µs)   4.98 µs

npm/strip-ansi 212,992 chars long-ansi      1.36 ms/iter   1.38 ms
                                     (1.27 ms … 1.73 ms)   1.49 ms

</pre> <hr> <h2 id="serialize-&amp;-deserialize-in-bun:jsc"><span><code>serialize</code> &amp; <code>deserialize</code> in <code>bun:jsc</code></span></h2> <span data-as="p">To save a JavaScript value into an ArrayBuffer &amp; back, use <code>serialize</code> and <code>deserialize</code> from the <code>"bun:jsc"</code> module.</span> <pre numberoflines="5" language="javascript" data-language="typescript">import { serialize, deserialize } from "bun:jsc";

const buf = serialize({ foo: "bar" });
const obj = deserialize(buf);
console.log(obj); // =&gt; { foo: "bar" }
</pre> <span data-as="p">Internally, <a href="https://developer.mozilla.org/en-US/docs/Web/API/structuredClone" target="_blank" rel="noreferrer"><code>structuredClone</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" target="_blank" rel="noreferrer"><code>postMessage</code></a> serialize and deserialize the same way. This exposes the underlying <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm" target="_blank" rel="noreferrer">HTML Structured Clone Algorithm</a> to JavaScript as an ArrayBuffer.</span> <hr> <h2 id="estimateshallowmemoryusageof-in-bun:jsc"><span><code>estimateShallowMemoryUsageOf</code> in <code>bun:jsc</code></span></h2> <span data-as="p">The <code>estimateShallowMemoryUsageOf</code> function returns a best-effort estimate of the memory usage of an object in bytes, excluding the memory usage of properties or other objects it references. For accurate per-object memory usage, use <code>Bun.generateHeapSnapshot</code>.</span> <pre numberoflines="18" language="javascript" data-language="typescript">import { estimateShallowMemoryUsageOf } from "bun:jsc";

const obj = { foo: "bar" };
const usage = estimateShallowMemoryUsageOf(obj);
console.log(usage); // =&gt; 16

const buffer = Buffer.alloc(1024 * 1024);
estimateShallowMemoryUsageOf(buffer);
// =&gt; 1048624

const req = new Request("https://bun.com");
estimateShallowMemoryUsageOf(req);
// =&gt; 167

const array = Array(1024).fill({ a: 1 });
// Arrays are usually not stored contiguously in memory, so this will not return a useful value (which isn't a bug).
estimateShallowMemoryUsageOf(array);
// =&gt; 16
</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/utils" class="_attribution-link">https://bun.com/docs/runtime/utils</a>
  </p>
</div>
