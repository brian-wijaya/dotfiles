<h1 id="header">YAML</h1>
<div data-page-title="YAML" data-page-href="/runtime/yaml" id="content">
<span data-as="p">In Bun, YAML is a first-class citizen alongside JSON and TOML. You can:</span> <ul> <li>Parse YAML strings with <code>Bun.YAML.parse</code>
</li> <li>
<code>import</code> &amp; <code>require</code> YAML files as modules at runtime (including hot reloading &amp; watch mode support)</li> <li>
<code>import</code> &amp; <code>require</code> YAML files in frontend apps via bun’s bundler</li> </ul> <hr> <h2 id="conformance"><span>Conformance</span></h2> <span data-as="p">Bun’s YAML parser currently passes over 90% of the official YAML test suite. While we’re actively working on reaching 100% conformance, the current implementation covers the vast majority of real-world use cases. The parser is written in Zig for optimal performance and is continuously being improved.</span> <hr> <h2 id="runtime-api"><span>Runtime API</span></h2> <h3 id="bun-yaml-parse"><span><code>Bun.YAML.parse()</code></span></h3> <span data-as="p">Parse a YAML string into a JavaScript object.</span> <pre numberoflines="19" language="typescript" data-language="typescript">import { YAML } from "bun";
const text = `
name: John Doe
age: 30
email: john@example.com
hobbies:
  - reading
  - coding
  - hiking
`;

const data = YAML.parse(text);
console.log(data);
// {
//   name: "John Doe",
//   age: 30,
//   email: "john@example.com",
//   hobbies: ["reading", "coding", "hiking"]
// }
</pre> <h4 id="multi-document-yaml"><span>Multi-document YAML</span></h4> <span data-as="p">When parsing YAML with multiple documents (separated by <code>---</code>), <code>Bun.YAML.parse()</code> returns an array:</span> <pre numberoflines="16" language="typescript" data-language="typescript">const multiDoc = `
---
name: Document 1
---
name: Document 2
---
name: Document 3
`;

const docs = Bun.YAML.parse(multiDoc);
console.log(docs);
// [
//   { name: "Document 1" },
//   { name: "Document 2" },
//   { name: "Document 3" }
// ]
</pre> <h4 id="supported-yaml-features"><span>Supported YAML Features</span></h4> <span data-as="p">Bun’s YAML parser supports the full YAML 1.2 specification, including:</span> <ul> <li>
<strong>Scalars</strong>: strings, numbers, booleans, null values</li> <li>
<strong>Collections</strong>: sequences (arrays) and mappings (objects)</li> <li>
<strong>Anchors and Aliases</strong>: reusable nodes with <code>&amp;</code> and <code>*</code>
</li> <li>
<strong>Tags</strong>: type hints like <code>!!str</code>, <code>!!int</code>, <code>!!float</code>, <code>!!bool</code>, <code>!!null</code>
</li> <li>
<strong>Multi-line strings</strong>: literal (<code>|</code>) and folded (<code>&gt;</code>) scalars</li> <li>
<strong>Comments</strong>: using <code>#</code>
</li> <li>
<strong>Directives</strong>: <code>%YAML</code> and <code>%TAG</code>
</li> </ul> <pre numberoflines="26" language="typescript" data-language="typescript">const yaml = `
# Employee record
employee: &amp;emp
  name: Jane Smith
  department: Engineering
  skills:
    - JavaScript
    - TypeScript
    - React

manager: *emp  # Reference to employee

config: !!str 123  # Explicit string type

description: |
  This is a multi-line
  literal string that preserves
  line breaks and spacing.

summary: &gt;
  This is a folded string
  that joins lines with spaces
  unless there are blank lines.
`;

const data = Bun.YAML.parse(yaml);
</pre> <h4 id="error-handling"><span>Error Handling</span></h4> <span data-as="p"><code>Bun.YAML.parse()</code> throws a <code>SyntaxError</code> if the YAML is invalid:</span> <pre numberoflines="5" language="typescript" data-language="typescript">try {
  Bun.YAML.parse("invalid: yaml: content:");
} catch (error) {
  console.error("Failed to parse YAML:", error.message);
}
</pre> <hr> <h2 id="module-import"><span>Module Import</span></h2> <h3 id="es-modules"><span>ES Modules</span></h3> <span data-as="p">You can import YAML files directly as ES modules. The YAML content is parsed and made available as both default and named exports:</span> <pre numberoflines="13" language="yaml" data-language="typescript">database:
  host: localhost
  port: 5432
  name: myapp

redis:
  host: localhost
  port: 6379

features:
  auth: true
  rateLimit: true
  analytics: false
</pre> <h4 id="default-import"><span>Default Import</span></h4> <pre numberoflines="4" language="typescript" data-language="typescript">import config from "./config.yaml";

console.log(config.database.host); // "localhost"
console.log(config.redis.port); // 6379
</pre> <h4 id="named-imports"><span>Named Imports</span></h4> <span data-as="p">You can destructure top-level YAML properties as named imports:</span> <pre numberoflines="5" language="typescript" data-language="typescript">import { database, redis, features } from "./config.yaml";

console.log(database.host); // "localhost"
console.log(redis.port); // 6379
console.log(features.auth); // true
</pre> <span data-as="p">Or combine both:</span> <pre numberoflines="9" language="typescript" data-language="typescript">import config, { database, features } from "./config.yaml";

// Use the full config object
console.log(config);

// Or use specific parts
if (features.rateLimit) {
  setupRateLimiting(database);
}
</pre> <h3 id="commonjs"><span>CommonJS</span></h3> <span data-as="p">YAML files can also be required in CommonJS:</span> <pre numberoflines="6" language="typescript" data-language="typescript">const config = require("./config.yaml");
console.log(config.database.name); // "myapp"

// Destructuring also works
const { database, redis } = require("./config.yaml");
console.log(database.port); // 5432
</pre> <hr> <h2 id="hot-reloading-with-yaml"><span>Hot Reloading with YAML</span></h2> <span data-as="p">One of the most powerful features of Bun’s YAML support is hot reloading. When you run your application with <code>bun --hot</code>, changes to YAML files are automatically detected and reloaded without closing connections</span> <h3 id="configuration-hot-reloading"><span>Configuration Hot Reloading</span></h3> <pre numberoflines="7" language="yaml" data-language="typescript">server:
  port: 3000
  host: localhost

features:
  debug: true
  verbose: false
</pre> <pre numberoflines="19" language="typescript" data-language="typescript">import { server, features } from "./config.yaml";

console.log(`Starting server on ${server.host}:${server.port}`);

if (features.debug) {
  console.log("Debug mode enabled");
}

// Your server code here
Bun.serve({
  port: server.port,
  hostname: server.host,
  fetch(req) {
    if (features.verbose) {
      console.log(`${req.method} ${req.url}`);
    }
    return new Response("Hello World");
  },
});
</pre> <span data-as="p">Run with hot reloading:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun --hot server.ts
</pre> <span data-as="p">Now when you modify <code>config.yaml</code>, the changes are immediately reflected in your running application. This is perfect for:</span> <ul> <li>Adjusting configuration during development</li> <li>Testing different settings without restarts</li> <li>Live debugging with configuration changes</li> <li>Feature flag toggling</li> </ul> <hr> <h2 id="configuration-management"><span>Configuration Management</span></h2> <h3 id="environment-based-configuration"><span>Environment-Based Configuration</span></h3> <span data-as="p">YAML excels at managing configuration across different environments:</span> <pre numberoflines="36" language="yaml" data-language="typescript">defaults: &amp;defaults
  timeout: 5000
  retries: 3
  cache:
    enabled: true
    ttl: 3600

development:
  &lt;&lt;: *defaults
  api:
    url: http://localhost:4000
    key: dev_key_12345
  logging:
    level: debug
    pretty: true

staging:
  &lt;&lt;: *defaults
  api:
    url: https://staging-api.example.com
    key: ${STAGING_API_KEY}
  logging:
    level: info
    pretty: false

production:
  &lt;&lt;: *defaults
  api:
    url: https://api.example.com
    key: ${PROD_API_KEY}
  cache:
    enabled: true
    ttl: 86400
  logging:
    level: error
    pretty: false
</pre> <pre numberoflines="19" language="typescript" data-language="typescript">import configs from "./config.yaml";

const env = process.env.NODE_ENV || "development";
const config = configs[env];

// Environment variables in YAML values can be interpolated
function interpolateEnvVars(obj: any): any {
  if (typeof obj === "string") {
    return obj.replace(/\${(\w+)}/g, (_, key) =&gt; process.env[key] || "");
  }
  if (typeof obj === "object") {
    for (const key in obj) {
      obj[key] = interpolateEnvVars(obj[key]);
    }
  }
  return obj;
}

export default interpolateEnvVars(config);
</pre> <h3 id="feature-flags-configuration"><span>Feature Flags Configuration</span></h3> <pre numberoflines="17" language="yaml" data-language="typescript">features:
  newDashboard:
    enabled: true
    rolloutPercentage: 50
    allowedUsers:
      - admin@example.com
      - beta@example.com

  experimentalAPI:
    enabled: false
    endpoints:
      - /api/v2/experimental
      - /api/v2/beta

  darkMode:
    enabled: true
    default: auto # auto, light, dark
</pre> <pre numberoflines="31" language="typescript" data-language="typescript">import { features } from "./features.yaml";

export function isFeatureEnabled(featureName: string, userEmail?: string): boolean {
  const feature = features[featureName];

  if (!feature?.enabled) {
    return false;
  }

  // Check rollout percentage
  if (feature.rolloutPercentage &lt; 100) {
    const hash = hashCode(userEmail || "anonymous");
    if (hash % 100 &gt;= feature.rolloutPercentage) {
      return false;
    }
  }

  // Check allowed users
  if (feature.allowedUsers &amp;&amp; userEmail) {
    return feature.allowedUsers.includes(userEmail);
  }

  return true;
}

// Use with hot reloading to toggle features in real-time
if (isFeatureEnabled("newDashboard", user.email)) {
  renderNewDashboard();
} else {
  renderLegacyDashboard();
}
</pre> <h3 id="database-configuration"><span>Database Configuration</span></h3> <pre numberoflines="33" language="yaml" data-language="typescript">connections:
  primary:
    type: postgres
    host: ${DB_HOST:-localhost}
    port: ${DB_PORT:-5432}
    database: ${DB_NAME:-myapp}
    username: ${DB_USER:-postgres}
    password: ${DB_PASS}
    pool:
      min: 2
      max: 10
      idleTimeout: 30000

  cache:
    type: redis
    host: ${REDIS_HOST:-localhost}
    port: ${REDIS_PORT:-6379}
    password: ${REDIS_PASS}
    db: 0

  analytics:
    type: clickhouse
    host: ${ANALYTICS_HOST:-localhost}
    port: 8123
    database: analytics

migrations:
  autoRun: ${AUTO_MIGRATE:-false}
  directory: ./migrations

seeds:
  enabled: ${SEED_DB:-false}
  directory: ./seeds
</pre> <pre numberoflines="23" language="typescript" data-language="typescript">import { connections, migrations } from "./database.yaml";
import { createConnection } from "./database-driver";

// Parse environment variables with defaults
function parseConfig(config: any) {
  return JSON.parse(
    JSON.stringify(config).replace(
      /\${([^:-]+)(?::([^}]+))?}/g,
      (_, key, defaultValue) =&gt; process.env[key] || defaultValue || "",
    ),
  );
}

const dbConfig = parseConfig(connections);

export const db = await createConnection(dbConfig.primary);
export const cache = await createConnection(dbConfig.cache);
export const analytics = await createConnection(dbConfig.analytics);

// Auto-run migrations if configured
if (parseConfig(migrations).autoRun === "true") {
  await runMigrations(db, migrations.directory);
}
</pre> <h3 id="bundler-integration"><span>Bundler Integration</span></h3> <span data-as="p">When you import YAML files in your application and bundle it with Bun, the YAML is parsed at build time and included as a JavaScript module:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun build app.ts --outdir=dist
</pre> <span data-as="p">This means:</span> <ul> <li>Zero runtime YAML parsing overhead in production</li> <li>Smaller bundle sizes</li> <li>Tree-shaking support for unused configuration (named imports)</li> </ul> <h3 id="dynamic-imports"><span>Dynamic Imports</span></h3> <span data-as="p">YAML files can be dynamically imported, useful for loading configuration on demand:</span> <pre numberoflines="12" language="typescript" data-language="typescript">const env = process.env.NODE_ENV || "development";
const config = await import(`./configs/${env}.yaml`);

// Load user-specific settings
async function loadUserSettings(userId: string) {
  try {
    const settings = await import(`./users/${userId}/settings.yaml`);
    return settings.default;
  } catch {
    return await import("./users/default-settings.yaml");
  }
}
</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/yaml" class="_attribution-link">https://bun.com/docs/runtime/yaml</a>
  </p>
</div>
