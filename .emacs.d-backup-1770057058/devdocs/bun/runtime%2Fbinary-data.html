<h1 id="header">Binary Data</h1>
<div data-page-title="Binary Data" data-page-href="/runtime/binary-data" id="content">
<span data-as="p">This page is intended as an introduction to working with binary data in JavaScript. Bun implements a number of data types and utilities for working with binary data, most of which are Web-standard. Any Bun-specific APIs will be noted as such.</span> <span data-as="p">Below is a quick “cheat sheet” that doubles as a table of contents. Click an item in the left column to jump to that section.</span> <div data-table-wrapper="true"><div><table> <thead><tr>
<th>Class</th>
<th>Description</th>
</tr></thead> <tbody>
<tr>
<td><a href="#typedarray"><code>TypedArray</code></a></td>
<td>A family of classes that provide an <code>Array</code>-like interface for interacting with binary data. Includes <code>Uint8Array</code>, <code>Uint16Array</code>, <code>Int8Array</code>, and more.</td>
</tr>
<tr>
<td><a href="#buffer"><code>Buffer</code></a></td>
<td>A subclass of <code>Uint8Array</code> that implements a wide range of convenience methods. Unlike the other elements in this table, this is a Node.js API (which Bun implements). It can’t be used in the browser.</td>
</tr>
<tr>
<td><a href="#dataview"><code>DataView</code></a></td>
<td>A class that provides a <code>get/set</code> API for writing some number of bytes to an <code>ArrayBuffer</code> at a particular byte offset. Often used reading or writing binary protocols.</td>
</tr>
<tr>
<td><a href="#blob"><code>Blob</code></a></td>
<td>A readonly blob of binary data usually representing a file. Has a MIME <code>type</code>, a <code>size</code>, and methods for converting to <code>ArrayBuffer</code>, <code>ReadableStream</code>, and string.</td>
</tr>
<tr>
<td><a href="#file"><code>File</code></a></td>
<td>A subclass of <code>Blob</code> that represents a file. Has a <code>name</code> and <code>lastModified</code> timestamp. There is experimental support in Node.js v20.</td>
</tr>
<tr>
<td><a href="#bunfile"><code>BunFile</code></a></td>
<td>
<em>Bun only</em>. A subclass of <code>Blob</code> that represents a lazily-loaded file on disk. Created with <code>Bun.file(path)</code>.</td>
</tr>
</tbody> </table></div></div> <hr> <h2 id="arraybuffer-and-views"><span><code>ArrayBuffer</code> and views</span></h2> <span data-as="p">Until 2009, there was no language-native way to store and manipulate binary data in JavaScript. ECMAScript v5 introduced a range of new mechanisms for this. The most fundamental building block is <code>ArrayBuffer</code>, a simple data structure that represents a sequence of bytes in memory.</span> <pre numberoflines="2" language="typescript" data-language="typescript">// this buffer can store 8 bytes
const buf = new ArrayBuffer(8);
</pre> <span data-as="p">Despite the name, it isn’t an array and supports none of the array methods and operators one might expect. In fact, there is no way to directly read or write values from an <code>ArrayBuffer</code>. There’s very little you can do with one except check its size and create “slices” from it.</span> <pre numberoflines="5" language="typescript" data-language="typescript">const buf = new ArrayBuffer(8);
buf.byteLength; // =&gt; 8

const slice = buf.slice(0, 4); // returns new ArrayBuffer
slice.byteLength; // =&gt; 4
</pre> <span data-as="p">To do anything interesting we need a construct known as a “view”. A view is a class that <em>wraps</em> an <code>ArrayBuffer</code> instance and lets you read and manipulate the underlying data. There are two types of views: <em>typed arrays</em> and <code>DataView</code>.</span> <h3 id="dataview"><span><code>DataView</code></span></h3> <span data-as="p">The <code>DataView</code> class is a lower-level interface for reading and manipulating the data in an <code>ArrayBuffer</code>.</span> <span data-as="p">Below we create a new <code>DataView</code> and set the first byte to 3.</span> <pre numberoflines="7" language="typescript" data-language="typescript">const buf = new ArrayBuffer(4);
// [0b00000000, 0b00000000, 0b00000000, 0b00000000]

const dv = new DataView(buf);
dv.setUint8(0, 3); // write value 3 at byte offset 0
dv.getUint8(0); // =&gt; 3
// [0b00000011, 0b00000000, 0b00000000, 0b00000000]
</pre> <span data-as="p">Now let’s write a <code>Uint16</code> at byte offset <code>1</code>. This requires two bytes. We’re using the value <code>513</code>, which is <code>2 * 256 + 1</code>; in bytes, that’s <code>00000010 00000001</code>.</span> <pre numberoflines="4" language="typescript" data-language="typescript">dv.setUint16(1, 513);
// [0b00000011, 0b00000010, 0b00000001, 0b00000000]

console.log(dv.getUint16(1)); // =&gt; 513
</pre> <span data-as="p">We’ve now assigned a value to the first three bytes in our underlying <code>ArrayBuffer</code>. Even though the second and third bytes were created using <code>setUint16()</code>, we can still read each of its component bytes using <code>getUint8()</code>.</span> <pre numberoflines="2" language="typescript" data-language="typescript">console.log(dv.getUint8(1)); // =&gt; 2
console.log(dv.getUint8(2)); // =&gt; 1
</pre> <span data-as="p">Attempting to write a value that requires more space than is available in the underlying <code>ArrayBuffer</code> will cause an error. Below we attempt to write a <code>Float64</code> (which requires 8 bytes) at byte offset <code>0</code>, but there are only four total bytes in the buffer.</span> <pre numberoflines="2" language="typescript" data-language="typescript">dv.setFloat64(0, 3.1415);
// ^ RangeError: Out of bounds access
</pre> <span data-as="p">The following methods are available on <code>DataView</code>:</span> <div data-table-wrapper="true"><div><table> <thead><tr>
<th>Getters</th>
<th>Setters</th>
</tr></thead> <tbody>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getBigInt64" target="_blank" rel="noreferrer"><code>getBigInt64()</code></a></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setBigInt64" target="_blank" rel="noreferrer"><code>setBigInt64()</code></a></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getBigUint64" target="_blank" rel="noreferrer"><code>getBigUint64()</code></a></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setBigUint64" target="_blank" rel="noreferrer"><code>setBigUint64()</code></a></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getFloat32" target="_blank" rel="noreferrer"><code>getFloat32()</code></a></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setFloat32" target="_blank" rel="noreferrer"><code>setFloat32()</code></a></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getFloat64" target="_blank" rel="noreferrer"><code>getFloat64()</code></a></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setFloat64" target="_blank" rel="noreferrer"><code>setFloat64()</code></a></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getInt16" target="_blank" rel="noreferrer"><code>getInt16()</code></a></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setInt16" target="_blank" rel="noreferrer"><code>setInt16()</code></a></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getInt32" target="_blank" rel="noreferrer"><code>getInt32()</code></a></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setInt32" target="_blank" rel="noreferrer"><code>setInt32()</code></a></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getInt8" target="_blank" rel="noreferrer"><code>getInt8()</code></a></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setInt8" target="_blank" rel="noreferrer"><code>setInt8()</code></a></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint16" target="_blank" rel="noreferrer"><code>getUint16()</code></a></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setUint16" target="_blank" rel="noreferrer"><code>setUint16()</code></a></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint32" target="_blank" rel="noreferrer"><code>getUint32()</code></a></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setUint32" target="_blank" rel="noreferrer"><code>setUint32()</code></a></td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint8" target="_blank" rel="noreferrer"><code>getUint8()</code></a></td>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setUint8" target="_blank" rel="noreferrer"><code>setUint8()</code></a></td>
</tr>
</tbody> </table></div></div> <h3 id="typedarray"><span><code>TypedArray</code></span></h3> <span data-as="p">Typed arrays are a family of classes that provide an <code>Array</code>-like interface for interacting with data in an <code>ArrayBuffer</code>. Whereas a <code>DataView</code> lets you write numbers of varying size at a particular offset, a <code>TypedArray</code> interprets the underlying bytes as an array of numbers, each of a fixed size.</span> <div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p">It’s common to refer to this family of classes collectively by their shared superclass <code>TypedArray</code>. This class as <em>internal</em> to JavaScript; you can’t directly create instances of it, and <code>TypedArray</code> is not defined in the global scope. Think of it as an <code>interface</code> or an abstract class.</span></div>
</div> <pre numberoflines="11" language="typescript" data-language="typescript">const buffer = new ArrayBuffer(3);
const arr = new Uint8Array(buffer);

// contents are initialized to zero
console.log(arr); // Uint8Array(3) [0, 0, 0]

// assign values like an array
arr[0] = 0;
arr[1] = 10;
arr[2] = 255;
arr[3] = 255; // no-op, out of bounds
</pre> <span data-as="p">While an <code>ArrayBuffer</code> is a generic sequence of bytes, these typed array classes interpret the bytes as an array of numbers of a given byte size. The top row contains the raw bytes, and the later rows contain how these bytes will be interpreted when <em>viewed</em> using different typed array classes.</span> <span data-as="p">The following classes are typed arrays, along with a description of how they interpret the bytes in an <code>ArrayBuffer</code>:</span> <span data-as="p">Here’s the first table formatted as a markdown table:</span> <div data-table-wrapper="true"><div><table> <thead><tr>
<th>Class</th>
<th>Description</th>
</tr></thead> <tbody>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" target="_blank" rel="noreferrer"><code>Uint8Array</code></a></td>
<td>Every one (1) byte is interpreted as an unsigned 8-bit integer. Range 0 to 255.</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array" target="_blank" rel="noreferrer"><code>Uint16Array</code></a></td>
<td>Every two (2) bytes are interpreted as an unsigned 16-bit integer. Range 0 to 65535.</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array" target="_blank" rel="noreferrer"><code>Uint32Array</code></a></td>
<td>Every four (4) bytes are interpreted as an unsigned 32-bit integer. Range 0 to 4294967295.</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array" target="_blank" rel="noreferrer"><code>Int8Array</code></a></td>
<td>Every one (1) byte is interpreted as a signed 8-bit integer. Range -128 to 127.</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array" target="_blank" rel="noreferrer"><code>Int16Array</code></a></td>
<td>Every two (2) bytes are interpreted as a signed 16-bit integer. Range -32768 to 32767.</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array" target="_blank" rel="noreferrer"><code>Int32Array</code></a></td>
<td>Every four (4) bytes are interpreted as a signed 32-bit integer. Range -2147483648 to 2147483647.</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float16Array" target="_blank" rel="noreferrer"><code>Float16Array</code></a></td>
<td>Every two (2) bytes are interpreted as a 16-bit floating point number. Range -6.104e5 to 6.55e4.</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array" target="_blank" rel="noreferrer"><code>Float32Array</code></a></td>
<td>Every four (4) bytes are interpreted as a 32-bit floating point number. Range -3.4e38 to 3.4e38.</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array" target="_blank" rel="noreferrer"><code>Float64Array</code></a></td>
<td>Every eight (8) bytes are interpreted as a 64-bit floating point number. Range -1.7e308 to 1.7e308.</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt64Array" target="_blank" rel="noreferrer"><code>BigInt64Array</code></a></td>
<td>Every eight (8) bytes are interpreted as a signed <code>BigInt</code>. Range -9223372036854775808 to 9223372036854775807 (though <code>BigInt</code> is capable of representing larger numbers).</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array" target="_blank" rel="noreferrer"><code>BigUint64Array</code></a></td>
<td>Every eight (8) bytes are interpreted as an unsigned <code>BigInt</code>. Range 0 to 18446744073709551615 (though <code>BigInt</code> is capable of representing larger numbers).</td>
</tr>
<tr>
<td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray" target="_blank" rel="noreferrer"><code>Uint8ClampedArray</code></a></td>
<td>Same as <code>Uint8Array</code>, but automatically “clamps” to the range 0-255 when assigning a value to an element.</td>
</tr>
</tbody> </table></div></div> <span data-as="p">The table below demonstrates how the bytes in an <code>ArrayBuffer</code> are interpreted when viewed using different typed array classes.</span> <div data-table-wrapper="true"><div><table> <thead><tr>
<th></th>
<th>Byte 0</th>
<th>Byte 1</th>
<th>Byte 2</th>
<th>Byte 3</th>
<th>Byte 4</th>
<th>Byte 5</th>
<th>Byte 6</th>
<th>Byte 7</th>
</tr></thead> <tbody>
<tr>
<td><code>ArrayBuffer</code></td>
<td><code>00000000</code></td>
<td><code>00000001</code></td>
<td><code>00000010</code></td>
<td><code>00000011</code></td>
<td><code>00000100</code></td>
<td><code>00000101</code></td>
<td><code>00000110</code></td>
<td><code>00000111</code></td>
</tr>
<tr>
<td><code>Uint8Array</code></td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td><code>Uint16Array</code></td>
<td>256 (<code>1 * 256 + 0</code>)</td>
<td></td>
<td>770 (<code>3 * 256 + 2</code>)</td>
<td></td>
<td>1284 (<code>5 * 256 + 4</code>)</td>
<td></td>
<td>1798 (<code>7 * 256 + 6</code>)</td>
<td></td>
</tr>
<tr>
<td><code>Uint32Array</code></td>
<td>50462976</td>
<td></td>
<td></td>
<td></td>
<td>117835012</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>BigUint64Array</code></td>
<td>506097522914230528n</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody> </table></div></div> <span data-as="p">To create a typed array from a pre-defined <code>ArrayBuffer</code>:</span> <pre numberoflines="9" language="typescript" data-language="typescript">// create typed array from ArrayBuffer
const buf = new ArrayBuffer(10);
const arr = new Uint8Array(buf);

arr[0] = 30;
arr[1] = 60;

// all elements are initialized to zero
console.log(arr); // =&gt; Uint8Array(10) [ 30, 60, 0, 0, 0, 0, 0, 0, 0, 0 ];
</pre> <span data-as="p">If we tried to instantiate a <code>Uint32Array</code> from this same <code>ArrayBuffer</code>, we’d get an error.</span> <pre numberoflines="4" language="typescript" data-language="typescript">const buf = new ArrayBuffer(10);
const arr = new Uint32Array(buf);
//          ^  RangeError: ArrayBuffer length minus the byteOffset
//             is not a multiple of the element size
</pre> <span data-as="p">A <code>Uint32</code> value requires four bytes (16 bits). Because the <code>ArrayBuffer</code> is 10 bytes long, there’s no way to cleanly divide its contents into 4-byte chunks.</span> <span data-as="p">To fix this, we can create a typed array over a particular “slice” of an <code>ArrayBuffer</code>. The <code>Uint16Array</code> below only “views” the <em>first</em> 8 bytes of the underlying <code>ArrayBuffer</code>. To achieve these, we specify a <code>byteOffset</code> of <code>0</code> and a <code>length</code> of <code>2</code>, which indicates the number of <code>Uint32</code> numbers we want our array to hold.</span> <pre numberoflines="11" language="typescript" data-language="typescript">// create typed array from ArrayBuffer slice
const buf = new ArrayBuffer(10);
const arr = new Uint32Array(buf, 0, 2);

/*
  buf    _ _ _ _ _ _ _ _ _ _    10 bytes
  arr   [_______,_______]       2 4-byte elements
*/

arr.byteOffset; // 0
arr.length; // 2
</pre> <span data-as="p">You don’t need to explicitly create an <code>ArrayBuffer</code> instance; you can instead directly specify a length in the typed array constructor:</span> <pre numberoflines="4" language="typescript" data-language="typescript">const arr2 = new Uint8Array(5);

// all elements are initialized to zero
// =&gt; Uint8Array(5) [0, 0, 0, 0, 0]
</pre> <span data-as="p">Typed arrays can also be instantiated directly from an array of numbers, or another typed array:</span> <pre numberoflines="7" language="typescript" data-language="typescript">// from an array of numbers
const arr1 = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7]);
arr1[0]; // =&gt; 0;
arr1[7]; // =&gt; 7;

// from another typed array
const arr2 = new Uint8Array(arr);
</pre> <span data-as="p">Broadly speaking, typed arrays provide the same methods as regular arrays, with a few exceptions. For example, <code>push</code> and <code>pop</code> are not available on typed arrays, because they would require resizing the underlying <code>ArrayBuffer</code>.</span> <pre numberoflines="11" language="typescript" data-language="typescript">const arr = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7]);

// supports common array methods
arr.filter(n =&gt; n &gt; 128); // Uint8Array(1) [255]
arr.map(n =&gt; n * 2); // Uint8Array(8) [0, 2, 4, 6, 8, 10, 12, 14]
arr.reduce((acc, n) =&gt; acc + n, 0); // 28
arr.forEach(n =&gt; console.log(n)); // 0 1 2 3 4 5 6 7
arr.every(n =&gt; n &lt; 10); // true
arr.find(n =&gt; n &gt; 5); // 6
arr.includes(5); // true
arr.indexOf(5); // 5
</pre> <span data-as="p">Refer to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" target="_blank" rel="noreferrer">MDN documentation</a> for more information on the properties and methods of typed arrays.</span> <h3 id="uint8array"><span><code>Uint8Array</code></span></h3> <span data-as="p">It’s worth specifically highlighting <code>Uint8Array</code>, as it represents a classic “byte array”—a sequence of 8-bit unsigned integers between 0 and 255. This is the most common typed array you’ll encounter in JavaScript.</span> <span data-as="p">In Bun, and someday in other JavaScript engines, it has methods available for converting between byte arrays and serialized representations of those arrays as base64 or hex strings.</span> <pre numberoflines="5" language="typescript" data-language="typescript">new Uint8Array([1, 2, 3, 4, 5]).toBase64(); // "AQIDBA=="
Uint8Array.fromBase64("AQIDBA=="); // Uint8Array(4) [1, 2, 3, 4, 5]

new Uint8Array([255, 254, 253, 252, 251]).toHex(); // "fffefdfcfb=="
Uint8Array.fromHex("fffefdfcfb"); // Uint8Array(5) [255, 254, 253, 252, 251]
</pre> <span data-as="p">It is the return value of <a href="https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder" target="_blank" rel="noreferrer"><code>TextEncoder#encode</code></a>, and the input type of <a href="https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder" target="_blank" rel="noreferrer"><code>TextDecoder#decode</code></a>, two utility classes designed to translate strings and various binary encodings, most notably <code>"utf-8"</code>.</span> <pre numberoflines="7" language="typescript" data-language="typescript">const encoder = new TextEncoder();
const bytes = encoder.encode("hello world");
// =&gt; Uint8Array(11) [ 104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100 ]

const decoder = new TextDecoder();
const text = decoder.decode(bytes);
// =&gt; hello world
</pre> <h3 id="buffer"><span><code>Buffer</code></span></h3> <span data-as="p">Bun implements <code>Buffer</code>, a Node.js API for working with binary data that pre-dates the introduction of typed arrays in the JavaScript spec. It has since been re-implemented as a subclass of <code>Uint8Array</code>. It provides a wide range of methods, including several Array-like and <code>DataView</code>-like methods.</span> <pre numberoflines="9" language="typescript" data-language="typescript">const buf = Buffer.from("hello world");
// =&gt; Buffer(11) [ 104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100 ]

buf.length; // =&gt; 11
buf[0]; // =&gt; 104, ascii for 'h'
buf.writeUInt8(72, 0); // =&gt; ascii for 'H'

console.log(buf.toString());
// =&gt; Hello world
</pre> <span data-as="p">For complete documentation, refer to the <a href="https://nodejs.org/api/buffer.html" target="_blank" rel="noreferrer">Node.js documentation</a>.</span> <h2 id="blob"><span><code>Blob</code></span></h2> <span data-as="p"><code>Blob</code> is a Web API commonly used for representing files. <code>Blob</code> was initially implemented in browsers (unlike <code>ArrayBuffer</code> which is part of JavaScript itself), but it is now supported in Node and Bun.</span> <span data-as="p">It isn’t common to directly create <code>Blob</code> instances. More often, you’ll receive instances of <code>Blob</code> from an external source (like an <code>&lt;input type="file"&gt;</code> element in the browser) or library. That said, it is possible to create a <code>Blob</code> from one or more string or binary “blob parts”.</span> <pre numberoflines="6" language="typescript" data-language="typescript">const blob = new Blob(["&lt;html&gt;Hello&lt;/html&gt;"], {
  type: "text/html",
});

blob.type; // =&gt; text/html
blob.size; // =&gt; 19
</pre> <span data-as="p">These parts can be <code>string</code>, <code>ArrayBuffer</code>, <code>TypedArray</code>, <code>DataView</code>, or other <code>Blob</code> instances. The blob parts are concatenated together in the order they are provided.</span> <pre numberoflines="6" language="typescript" data-language="typescript">const blob = new Blob([
  "&lt;html&gt;",
  new Blob(["&lt;body&gt;"]),
  new Uint8Array([104, 101, 108, 108, 111]), // "hello" in binary
  "&lt;/body&gt;&lt;/html&gt;",
]);
</pre> <span data-as="p">The contents of a <code>Blob</code> can be asynchronously read in various formats.</span> <pre numberoflines="4" language="typescript" data-language="typescript">await blob.text(); // =&gt; &lt;html&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;
await blob.bytes(); // =&gt; Uint8Array (copies contents)
await blob.arrayBuffer(); // =&gt; ArrayBuffer (copies contents)
await blob.stream(); // =&gt; ReadableStream
</pre> <h3 id="bunfile"><span><code>BunFile</code></span></h3> <span data-as="p"><code>BunFile</code> is a subclass of <code>Blob</code> used to represent a lazily-loaded file on disk. Like <code>File</code>, it adds a <code>name</code> and <code>lastModified</code> property. Unlike <code>File</code>, it does not require the file to be loaded into memory.</span> <pre numberoflines="2" language="typescript" data-language="typescript">const file = Bun.file("index.txt");
// =&gt; BunFile
</pre> <h3 id="file"><span><code>File</code></span></h3> <div data-callout-type="warning">

<div data-component-part="callout-content">Browser only. Experimental support in Node.js 20.</div>
</div> <span data-as="p"><a href="https://developer.mozilla.org/en-US/docs/Web/API/File" target="_blank" rel="noreferrer"><code>File</code></a> is a subclass of <code>Blob</code> that adds a <code>name</code> and <code>lastModified</code> property. It’s commonly used in the browser to represent files uploaded via a <code>&lt;input type="file"&gt;</code> element. Node.js and Bun implement <code>File</code>.</span> <pre numberoflines="5" language="typescript" data-language="typescript">// on browser!
// &lt;input type="file" id="file" /&gt;

const files = document.getElementById("file").files;
// =&gt; File[]
</pre> <pre numberoflines="3" language="typescript" data-language="typescript">const file = new File(["&lt;html&gt;Hello&lt;/html&gt;"], "index.html", {
  type: "text/html",
});
</pre> <span data-as="p">Refer to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="noreferrer">MDN documentation</a> for complete docs information.</span> <hr> <h2 id="streams"><span>Streams</span></h2> <span data-as="p">Streams are an important abstraction for working with binary data without loading it all into memory at once. They are commonly used for reading and writing files, sending and receiving network requests, and processing large amounts of data.</span> <span data-as="p">Bun implements the Web APIs <a href="https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream" target="_blank" rel="noreferrer"><code>ReadableStream</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream" target="_blank" rel="noreferrer"><code>WritableStream</code></a>.</span> <div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p">Bun also implements the <code>node:stream</code> module, including <a href="https://nodejs.org/api/stream.html#stream_readable_streams" target="_blank" rel="noreferrer"><code>Readable</code></a>, <a href="https://nodejs.org/api/stream.html#stream_writable_streams" target="_blank" rel="noreferrer"><code>Writable</code></a>, and <a href="https://nodejs.org/api/stream.html#stream_duplex_and_transform_streams" target="_blank" rel="noreferrer"><code>Duplex</code></a>. For complete documentation, refer to the Node.js docs.</span></div>
</div> <span data-as="p">To create a simple readable stream:</span> <pre numberoflines="7" language="typescript" data-language="typescript">const stream = new ReadableStream({
  start(controller) {
    controller.enqueue("hello");
    controller.enqueue("world");
    controller.close();
  },
});
</pre> <span data-as="p">The contents of this stream can be read chunk-by-chunk with <code>for await</code> syntax.</span> <pre numberoflines="6" language="typescript" data-language="typescript">for await (const chunk of stream) {
  console.log(chunk);
}

// =&gt; "hello"
// =&gt; "world"
</pre> <span data-as="p">For a more complete discussion of streams in Bun, see <a href="streams">API &gt; Streams</a>.</span> <hr> <h2 id="conversion"><span>Conversion</span></h2> <span data-as="p">Converting from one binary format to another is a common task. This section is intended as a reference.</span> <h3 id="from-arraybuffer"><span>From <code>ArrayBuffer</code></span></h3> <span data-as="p">Since <code>ArrayBuffer</code> stores the data that underlies other binary structures like <code>TypedArray</code>, the snippets below are not <em>converting</em> from <code>ArrayBuffer</code> to another format. Instead, they are <em>creating</em> a new instance using the data stored underlying data.</span> <h4 id="to-typedarray"><span>To <code>TypedArray</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">new Uint8Array(buf);
</pre> <h4 id="to-dataview"><span>To <code>DataView</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">new DataView(buf);
</pre> <h4 id="to-buffer"><span>To <code>Buffer</code></span></h4> <pre numberoflines="5" language="typescript" data-language="typescript">// create Buffer over entire ArrayBuffer
Buffer.from(buf);

// create Buffer over a slice of the ArrayBuffer
Buffer.from(buf, 0, 10);
</pre> <h4 id="to-string"><span>To <code>string</code></span></h4> <span data-as="p">As UTF-8:</span> <pre numberoflines="1" language="typescript" data-language="typescript">new TextDecoder().decode(buf);
</pre> <h4 id="to-number[]"><span>To <code>number[]</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">Array.from(new Uint8Array(buf));
</pre> <h4 id="to-blob"><span>To <code>Blob</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">new Blob([buf], { type: "text/plain" });
</pre> <h4 id="to-readablestream"><span>To <code>ReadableStream</code></span></h4> <span data-as="p">The following snippet creates a <code>ReadableStream</code> and enqueues the entire <code>ArrayBuffer</code> as a single chunk.</span> <pre numberoflines="6" language="typescript" data-language="typescript">new ReadableStream({
  start(controller) {
    controller.enqueue(buf);
    controller.close();
  },
});
</pre> <details><summary aria-controls="with-chunking accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">With chunking</p></div></summary><div id="with-chunking accordion children" role="region" aria-labelledby="with-chunking" data-component-part="accordion-content">
<span data-as="p">To stream the <code>ArrayBuffer</code> in chunks, use a <code>Uint8Array</code> view and enqueue each chunk.</span><pre numberoflines="11" language="typescript" data-language="typescript">const view = new Uint8Array(buf);
const chunkSize = 1024;

new ReadableStream({
  start(controller) {
    for (let i = 0; i &lt; view.length; i += chunkSize) {
      controller.enqueue(view.slice(i, i + chunkSize));
    }
    controller.close();
  },
});
</pre>
</div></details> <h3 id="from-typedarray"><span>From <code>TypedArray</code></span></h3> <h4 id="to-arraybuffer"><span>To <code>ArrayBuffer</code></span></h4> <span data-as="p">This retrieves the underlying <code>ArrayBuffer</code>. Note that a <code>TypedArray</code> can be a view of a <em>slice</em> of the underlying buffer, so the sizes may differ.</span> <pre numberoflines="1" language="typescript" data-language="typescript">arr.buffer;
</pre> <h4 id="to-dataview-2"><span>To <code>DataView</code></span></h4> <span data-as="p">To creates a <code>DataView</code> over the same byte range as the TypedArray.</span> <pre numberoflines="1" language="typescript" data-language="typescript">new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
</pre> <h4 id="to-buffer-2"><span>To <code>Buffer</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">Buffer.from(arr);
</pre> <h4 id="to-string-2"><span>To <code>string</code></span></h4> <span data-as="p">As UTF-8:</span> <pre numberoflines="1" language="typescript" data-language="typescript">new TextDecoder().decode(arr);
</pre> <h4 id="to-number[]-2"><span>To <code>number[]</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">Array.from(arr);
</pre> <h4 id="to-blob-2"><span>To <code>Blob</code></span></h4> <pre numberoflines="2" language="typescript" data-language="typescript">// only if arr is a view of its entire backing TypedArray
new Blob([arr.buffer], { type: "text/plain" });
</pre> <h4 id="to-readablestream-2"><span>To <code>ReadableStream</code></span></h4> <pre numberoflines="6" language="typescript" data-language="typescript">new ReadableStream({
  start(controller) {
    controller.enqueue(arr);
    controller.close();
  },
});
</pre> <details><summary aria-controls="with-chunking accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">With chunking</p></div></summary><div id="with-chunking accordion children" role="region" aria-labelledby="with-chunking" data-component-part="accordion-content">
<span data-as="p">To stream the <code>ArrayBuffer</code> in chunks, split the <code>TypedArray</code> into chunks and enqueue each one individually.</span><pre numberoflines="8" language="typescript" data-language="typescript">new ReadableStream({
  start(controller) {
    for (let i = 0; i &lt; arr.length; i += chunkSize) {
      controller.enqueue(arr.slice(i, i + chunkSize));
    }
    controller.close();
  },
});
</pre>
</div></details> <h3 id="from-dataview"><span>From <code>DataView</code></span></h3> <h4 id="to-arraybuffer-2"><span>To <code>ArrayBuffer</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">view.buffer;
</pre> <h4 id="to-typedarray-2"><span>To <code>TypedArray</code></span></h4> <span data-as="p">Only works if the <code>byteLength</code> of the <code>DataView</code> is a multiple of the <code>BYTES_PER_ELEMENT</code> of the <code>TypedArray</code> subclass.</span> <pre numberoflines="4" language="typescript" data-language="typescript">new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
new Uint16Array(view.buffer, view.byteOffset, view.byteLength / 2);
new Uint32Array(view.buffer, view.byteOffset, view.byteLength / 4);
// etc...
</pre> <h4 id="to-buffer-3"><span>To <code>Buffer</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">Buffer.from(view.buffer, view.byteOffset, view.byteLength);
</pre> <h4 id="to-string-3"><span>To <code>string</code></span></h4> <span data-as="p">As UTF-8:</span> <pre numberoflines="1" language="typescript" data-language="typescript">new TextDecoder().decode(view);
</pre> <h4 id="to-number[]-3"><span>To <code>number[]</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">Array.from(view);
</pre> <h4 id="to-blob-3"><span>To <code>Blob</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">new Blob([view.buffer], { type: "text/plain" });
</pre> <h4 id="to-readablestream-3"><span>To <code>ReadableStream</code></span></h4> <pre numberoflines="6" language="typescript" data-language="typescript">new ReadableStream({
  start(controller) {
    controller.enqueue(view.buffer);
    controller.close();
  },
});
</pre> <details><summary aria-controls="with-chunking accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">With chunking</p></div></summary><div id="with-chunking accordion children" role="region" aria-labelledby="with-chunking" data-component-part="accordion-content">
<span data-as="p">To stream the <code>ArrayBuffer</code> in chunks, split the <code>DataView</code> into chunks and enqueue each one individually.</span><pre numberoflines="8" language="typescript" data-language="typescript">new ReadableStream({
  start(controller) {
    for (let i = 0; i &lt; view.byteLength; i += chunkSize) {
      controller.enqueue(view.buffer.slice(i, i + chunkSize));
    }
    controller.close();
  },
});
</pre>
</div></details> <h3 id="from-buffer"><span>From <code>Buffer</code></span></h3> <h4 id="to-arraybuffer-3"><span>To <code>ArrayBuffer</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">buf.buffer;
</pre> <h4 id="to-typedarray-3"><span>To <code>TypedArray</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">new Uint8Array(buf);
</pre> <h4 id="to-dataview-3"><span>To <code>DataView</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
</pre> <h4 id="to-string-4"><span>To <code>string</code></span></h4> <span data-as="p">As UTF-8:</span> <pre numberoflines="1" language="typescript" data-language="typescript">buf.toString();
</pre> <span data-as="p">As base64:</span> <pre numberoflines="1" language="typescript" data-language="typescript">buf.toString("base64");
</pre> <span data-as="p">As hex:</span> <pre numberoflines="1" language="typescript" data-language="typescript">buf.toString("hex");
</pre> <h4 id="to-number[]-4"><span>To <code>number[]</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">Array.from(buf);
</pre> <h4 id="to-blob-4"><span>To <code>Blob</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">new Blob([buf], { type: "text/plain" });
</pre> <h4 id="to-readablestream-4"><span>To <code>ReadableStream</code></span></h4> <pre numberoflines="6" language="typescript" data-language="typescript">new ReadableStream({
  start(controller) {
    controller.enqueue(buf);
    controller.close();
  },
});
</pre> <details><summary aria-controls="with-chunking accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">With chunking</p></div></summary><div id="with-chunking accordion children" role="region" aria-labelledby="with-chunking" data-component-part="accordion-content">
<span data-as="p">To stream the <code>ArrayBuffer</code> in chunks, split the <code>Buffer</code> into chunks and enqueue each one individually.</span><pre numberoflines="8" language="typescript" data-language="typescript">new ReadableStream({
  start(controller) {
    for (let i = 0; i &lt; buf.length; i += chunkSize) {
      controller.enqueue(buf.slice(i, i + chunkSize));
    }
    controller.close();
  },
});
</pre>
</div></details> <h3 id="from-blob"><span>From <code>Blob</code></span></h3> <h4 id="to-arraybuffer-4"><span>To <code>ArrayBuffer</code></span></h4> <span data-as="p">The <code>Blob</code> class provides a convenience method for this purpose.</span> <pre numberoflines="1" language="typescript" data-language="typescript">await blob.arrayBuffer();
</pre> <h4 id="to-typedarray-4"><span>To <code>TypedArray</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">await blob.bytes();
</pre> <h4 id="to-dataview-4"><span>To <code>DataView</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">new DataView(await blob.arrayBuffer());
</pre> <h4 id="to-buffer-4"><span>To <code>Buffer</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">Buffer.from(await blob.arrayBuffer());
</pre> <h4 id="to-string-5"><span>To <code>string</code></span></h4> <span data-as="p">As UTF-8:</span> <pre numberoflines="1" language="typescript" data-language="typescript">await blob.text();
</pre> <h4 id="to-number[]-5"><span>To <code>number[]</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">Array.from(await blob.bytes());
</pre> <h4 id="to-readablestream-5"><span>To <code>ReadableStream</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">blob.stream();
</pre> <h3 id="from-readablestream"><span>From <code>ReadableStream</code></span></h3> <span data-as="p">It’s common to use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response" target="_blank" rel="noreferrer"><code>Response</code></a> as a convenient intermediate representation to make it easier to convert <code>ReadableStream</code> to other formats.</span> <pre numberoflines="3" language="typescript" data-language="typescript">stream; // ReadableStream

const buffer = new Response(stream).arrayBuffer();
</pre> <span data-as="p">However this approach is verbose and adds overhead that slows down overall performance unnecessarily. Bun implements a set of optimized convenience functions for converting <code>ReadableStream</code> various binary formats.</span> <h4 id="to-arraybuffer-5"><span>To <code>ArrayBuffer</code></span></h4> <pre numberoflines="5" language="typescript" data-language="typescript">// with Response
new Response(stream).arrayBuffer();

// with Bun function
Bun.readableStreamToArrayBuffer(stream);
</pre> <h4 id="to-uint8array"><span>To <code>Uint8Array</code></span></h4> <pre numberoflines="5" language="typescript" data-language="typescript">// with Response
new Response(stream).bytes();

// with Bun function
Bun.readableStreamToBytes(stream);
</pre> <h4 id="to-typedarray-5"><span>To <code>TypedArray</code></span></h4> <pre numberoflines="6" language="typescript" data-language="typescript">// with Response
const buf = await new Response(stream).arrayBuffer();
new Int8Array(buf);

// with Bun function
new Int8Array(Bun.readableStreamToArrayBuffer(stream));
</pre> <h4 id="to-dataview-5"><span>To <code>DataView</code></span></h4> <pre numberoflines="6" language="typescript" data-language="typescript">// with Response
const buf = await new Response(stream).arrayBuffer();
new DataView(buf);

// with Bun function
new DataView(Bun.readableStreamToArrayBuffer(stream));
</pre> <h4 id="to-buffer-5"><span>To <code>Buffer</code></span></h4> <pre numberoflines="6" language="typescript" data-language="typescript">// with Response
const buf = await new Response(stream).arrayBuffer();
Buffer.from(buf);

// with Bun function
Buffer.from(Bun.readableStreamToArrayBuffer(stream));
</pre> <h4 id="to-string-6"><span>To <code>string</code></span></h4> <span data-as="p">As UTF-8:</span> <pre numberoflines="5" language="typescript" data-language="typescript">// with Response
await new Response(stream).text();

// with Bun function
await Bun.readableStreamToText(stream);
</pre> <h4 id="to-number[]-6"><span>To <code>number[]</code></span></h4> <pre numberoflines="6" language="typescript" data-language="typescript">// with Response
const arr = await new Response(stream).bytes();
Array.from(arr);

// with Bun function
Array.from(new Uint8Array(Bun.readableStreamToArrayBuffer(stream)));
</pre> <span data-as="p">Bun provides a utility for resolving a <code>ReadableStream</code> to an array of its chunks. Each chunk may be a string, typed array, or <code>ArrayBuffer</code>.</span> <pre numberoflines="2" language="typescript" data-language="typescript">// with Bun function
Bun.readableStreamToArray(stream);
</pre> <h4 id="to-blob-5"><span>To <code>Blob</code></span></h4> <pre numberoflines="1" language="typescript" data-language="typescript">new Response(stream).blob();
</pre> <h4 id="to-readablestream-6"><span>To <code>ReadableStream</code></span></h4> <span data-as="p">To split a <code>ReadableStream</code> into two streams that can be consumed independently:</span> <pre numberoflines="1" language="typescript" data-language="typescript">const [a, b] = stream.tee();
</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/binary-data" class="_attribution-link">https://bun.com/docs/runtime/binary-data</a>
  </p>
</div>
