<h1 id="header">Spawn</h1>
<div data-page-title="Spawn" data-page-href="/runtime/child-process" id="content">
<h2 id="spawn-a-process-bun-spawn"><span>Spawn a process (<code>Bun.spawn()</code>)</span></h2> <span data-as="p">Provide a command as an array of strings. The result of <code>Bun.spawn()</code> is a <code>Bun.Subprocess</code> object.</span> <pre numberoflines="2" language="typescript" data-language="typescript">const proc = Bun.spawn(["bun", "--version"]);
console.log(await proc.exited); // 0
</pre> <span data-as="p">The second argument to <code>Bun.spawn</code> is a parameters object that can be used to configure the subprocess.</span> <pre numberoflines="9" language="typescript" data-language="typescript">const proc = Bun.spawn(["bun", "--version"], {
  cwd: "./path/to/subdir", // specify a working directory
  env: { ...process.env, FOO: "bar" }, // specify environment variables
  onExit(proc, exitCode, signalCode, error) {
    // exit handler
  },
});

proc.pid; // process ID of subprocess
</pre> <h2 id="input-stream"><span>Input stream</span></h2> <span data-as="p">By default, the input stream of the subprocess is undefined; it can be configured with the <code>stdin</code> parameter.</span> <pre numberoflines="6" language="typescript" data-language="typescript">const proc = Bun.spawn(["cat"], {
  stdin: await fetch("https://raw.githubusercontent.com/oven-sh/bun/main/examples/hashing.js"),
});

const text = await proc.stdout.text();
console.log(text); // "const input = "hello world".repeat(400); ..."
</pre> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Value</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code>null</code></td>
<td>
<strong>Default.</strong> Provide no input to the subprocess</td>
</tr>
<tr>
<td><code>"pipe"</code></td>
<td>Return a <code>FileSink</code> for fast incremental writing</td>
</tr>
<tr>
<td><code>"inherit"</code></td>
<td>Inherit the <code>stdin</code> of the parent process</td>
</tr>
<tr>
<td><code>Bun.file()</code></td>
<td>Read from the specified file</td>
</tr>
<tr>
<td><code>TypedArray | DataView</code></td>
<td>Use a binary buffer as input</td>
</tr>
<tr>
<td><code>Response</code></td>
<td>Use the response <code>body</code> as input</td>
</tr>
<tr>
<td><code>Request</code></td>
<td>Use the request <code>body</code> as input</td>
</tr>
<tr>
<td><code>ReadableStream</code></td>
<td>Use a readable stream as input</td>
</tr>
<tr>
<td><code>Blob</code></td>
<td>Use a blob as input</td>
</tr>
<tr>
<td><code>number</code></td>
<td>Read from the file with a given file descriptor</td>
</tr>
</tbody>
</table></div></div> <span data-as="p">The <code>"pipe"</code> option lets incrementally write to the subprocess‚Äôs input stream from the parent process.</span> <pre numberoflines="16" language="typescript" data-language="typescript">const proc = Bun.spawn(["cat"], {
  stdin: "pipe", // return a FileSink for writing
});

// enqueue string data
proc.stdin.write("hello");

// enqueue binary data
const enc = new TextEncoder();
proc.stdin.write(enc.encode(" world!"));

// send buffered data
proc.stdin.flush();

// close the input stream
proc.stdin.end();
</pre> <span data-as="p">Passing a <code>ReadableStream</code> to <code>stdin</code> lets you pipe data from a JavaScript <code>ReadableStream</code> directly to the subprocess‚Äôs input:</span> <pre numberoflines="15" language="typescript" data-language="typescript">const stream = new ReadableStream({
  start(controller) {
    controller.enqueue("Hello from ");
    controller.enqueue("ReadableStream!");
    controller.close();
  },
});

const proc = Bun.spawn(["cat"], {
  stdin: stream,
  stdout: "pipe",
});

const output = await proc.stdout.text();
console.log(output); // "Hello from ReadableStream!"
</pre> <h2 id="output-streams"><span>Output streams</span></h2> <span data-as="p">You can read results from the subprocess via the <code>stdout</code> and <code>stderr</code> properties. By default these are instances of <code>ReadableStream</code>.</span> <pre numberoflines="3" language="typescript" data-language="typescript">const proc = Bun.spawn(["bun", "--version"]);
const text = await proc.stdout.text();
console.log(text); // =&gt; "1.3.3\n"
</pre> <span data-as="p">Configure the output stream by passing one of the following values to <code>stdout/stderr</code>:</span> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Value</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code>"pipe"</code></td>
<td>
<strong>Default for <code>stdout</code>.</strong> Pipe the output to a <code>ReadableStream</code> on the returned <code>Subprocess</code> object</td>
</tr>
<tr>
<td><code>"inherit"</code></td>
<td>
<strong>Default for <code>stderr</code>.</strong> Inherit from the parent process</td>
</tr>
<tr>
<td><code>"ignore"</code></td>
<td>Discard the output</td>
</tr>
<tr>
<td><code>Bun.file()</code></td>
<td>Write to the specified file</td>
</tr>
<tr>
<td><code>number</code></td>
<td>Write to the file with the given file descriptor</td>
</tr>
</tbody>
</table></div></div> <h2 id="exit-handling"><span>Exit handling</span></h2> <span data-as="p">Use the <code>onExit</code> callback to listen for the process exiting or being killed.</span> <pre numberoflines="5" language="typescript" data-language="typescript">const proc = Bun.spawn(["bun", "--version"], {
  onExit(proc, exitCode, signalCode, error) {
    // exit handler
  },
});
</pre> <span data-as="p">For convenience, the <code>exited</code> property is a <code>Promise</code> that resolves when the process exits.</span> <pre numberoflines="6" language="typescript" data-language="typescript">const proc = Bun.spawn(["bun", "--version"]);

await proc.exited; // resolves when process exit
proc.killed; // boolean ‚Äî was the process killed?
proc.exitCode; // null | number
proc.signalCode; // null | "SIGABRT" | "SIGALRM" | ...
</pre> <span data-as="p">To kill a process:</span> <pre numberoflines="6" language="typescript" data-language="typescript">const proc = Bun.spawn(["bun", "--version"]);
proc.kill();
proc.killed; // true

proc.kill(15); // specify a signal code
proc.kill("SIGTERM"); // specify a signal name
</pre> <span data-as="p">The parent <code>bun</code> process will not terminate until all child processes have exited. Use <code>proc.unref()</code> to detach the child process from the parent.</span> <pre numberoflines="2" language="typescript" data-language="typescript">const proc = Bun.spawn(["bun", "--version"]);
proc.unref();
</pre> <h2 id="resource-usage"><span>Resource usage</span></h2> <span data-as="p">You can get information about the process‚Äôs resource usage after it has exited:</span> <pre numberoflines="7" language="typescript" data-language="typescript">const proc = Bun.spawn(["bun", "--version"]);
await proc.exited;

const usage = proc.resourceUsage();
console.log(`Max memory used: ${usage.maxRSS} bytes`);
console.log(`CPU time (user): ${usage.cpuTime.user} ¬µs`);
console.log(`CPU time (system): ${usage.cpuTime.system} ¬µs`);
</pre> <h2 id="using-abortsignal"><span>Using AbortSignal</span></h2> <span data-as="p">You can abort a subprocess using an <code>AbortSignal</code>:</span> <pre numberoflines="10" language="typescript" data-language="typescript">const controller = new AbortController();
const { signal } = controller;

const proc = Bun.spawn({
  cmd: ["sleep", "100"],
  signal,
});

// Later, to abort the process:
controller.abort();
</pre> <h2 id="using-timeout-and-killsignal"><span>Using timeout and killSignal</span></h2> <span data-as="p">You can set a timeout for a subprocess to automatically terminate after a specific duration:</span> <pre numberoflines="7" language="typescript" data-language="typescript">// Kill the process after 5 seconds
const proc = Bun.spawn({
  cmd: ["sleep", "10"],
  timeout: 5000, // 5 seconds in milliseconds
});

await proc.exited; // Will resolve after 5 seconds
</pre> <span data-as="p">By default, timed-out processes are killed with the <code>SIGTERM</code> signal. You can specify a different signal with the <code>killSignal</code> option:</span> <pre numberoflines="6" language="typescript" data-language="typescript">// Kill the process with SIGKILL after 5 seconds
const proc = Bun.spawn({
  cmd: ["sleep", "10"],
  timeout: 5000,
  killSignal: "SIGKILL", // Can be string name or signal number
});
</pre> <span data-as="p">The <code>killSignal</code> option also controls which signal is sent when an AbortSignal is aborted.</span> <h2 id="using-maxbuffer"><span>Using maxBuffer</span></h2> <span data-as="p">For spawnSync, you can limit the maximum number of bytes of output before the process is killed:</span> <pre numberoflines="6" language="typescript" data-language="typescript">// Kill 'yes' after it emits over 100 bytes of output
const result = Bun.spawnSync({
  cmd: ["yes"], // or ["bun", "exec", "yes"] on Windows
  maxBuffer: 100,
});
// process exits
</pre> <h2 id="inter-process-communication-ipc"><span>Inter-process communication (IPC)</span></h2> <span data-as="p">Bun supports direct inter-process communication channel between two <code>bun</code> processes. To receive messages from a spawned Bun subprocess, specify an <code>ipc</code> handler.</span> <pre numberoflines="7" language="typescript" data-language="typescript">const child = Bun.spawn(["bun", "child.ts"], {
  ipc(message) {
    /**
     * The message received from the sub process
     **/
  },
});
</pre> <span data-as="p">The parent process can send messages to the subprocess using the <code>.send()</code> method on the returned <code>Subprocess</code> instance. A reference to the sending subprocess is also available as the second argument in the <code>ipc</code> handler.</span> <pre numberoflines="10" language="typescript" data-language="typescript">const childProc = Bun.spawn(["bun", "child.ts"], {
  ipc(message, childProc) {
    /**
     * The message received from the sub process
     **/
    childProc.send("Respond to child");
  },
});

childProc.send("I am your father"); // The parent can send messages to the child as well
</pre> <span data-as="p">Meanwhile the child process can send messages to its parent using with <code>process.send()</code> and receive messages with <code>process.on("message")</code>. This is the same API used for <code>child_process.fork()</code> in Node.js.</span> <pre numberoflines="7" language="typescript" data-language="typescript">process.send("Hello from child as string");
process.send({ message: "Hello from child as object" });

process.on("message", message =&gt; {
  // print message from parent
  console.log(message);
});
</pre> <pre numberoflines="5" language="typescript" data-language="typescript">// send a string
process.send("Hello from child as string");

// send an object
process.send({ message: "Hello from child as object" });
</pre> <span data-as="p">The <code>serialization</code> option controls the underlying communication format between the two processes:</span> <ul> <li>
<code>advanced</code>: (default) Messages are serialized using the JSC <code>serialize</code> API, which supports cloning <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm" target="_blank" rel="noreferrer">everything <code>structuredClone</code> supports</a>. This does not support transferring ownership of objects.</li> <li>
<code>json</code>: Messages are serialized using <code>JSON.stringify</code> and <code>JSON.parse</code>, which does not support as many object types as <code>advanced</code> does.</li> </ul> <span data-as="p">To disconnect the IPC channel from the parent process, call:</span> <pre numberoflines="1" language="typescript" data-language="typescript">childProc.disconnect();
</pre> <h3 id="ipc-between-bun-&amp;-node-js"><span>IPC between Bun &amp; Node.js</span></h3> <span data-as="p">To use IPC between a <code>bun</code> process and a Node.js process, set <code>serialization: "json"</code> in <code>Bun.spawn</code>. This is because Node.js and Bun use different JavaScript engines with different object serialization formats.</span> <pre numberoflines="21" language="javascript" data-language="typescript">if (typeof Bun !== "undefined") {
  const prefix = `[bun ${process.versions.bun} üêá]`;
  const node = Bun.spawn({
    cmd: ["node", __filename],
    ipc({ message }) {
      console.log(message);
      node.send({ message: `${prefix} üëã hey node` });
      node.kill();
    },
    stdio: ["inherit", "inherit", "inherit"],
    serialization: "json",
  });

  node.send({ message: `${prefix} üëã hey node` });
} else {
  const prefix = `[node ${process.version}]`;
  process.on("message", ({ message }) =&gt; {
    console.log(message);
    process.send({ message: `${prefix} üëã hey bun` });
  });
}
</pre> <hr> <h2 id="terminal-pty-support"><span>Terminal (PTY) support</span></h2> <span data-as="p">For interactive terminal applications, you can spawn a subprocess with a pseudo-terminal (PTY) attached using the <code>terminal</code> option. This makes the subprocess think it‚Äôs running in a real terminal, enabling features like colored output, cursor movement, and interactive prompts.</span> <pre numberoflines="19" language="typescript" data-language="typescript">const proc = Bun.spawn(["bash"], {
  terminal: {
    cols: 80,
    rows: 24,
    data(terminal, data) {
      // Called when data is received from the terminal
      process.stdout.write(data);
    },
  },
});

// Write to the terminal
proc.terminal.write("echo hello\n");

// Wait for the process to exit
await proc.exited;

// Close the terminal
proc.terminal.close();
</pre> <span data-as="p">When the <code>terminal</code> option is provided:</span> <ul> <li>The subprocess sees <code>process.stdout.isTTY</code> as <code>true</code>
</li> <li>
<code>stdin</code>, <code>stdout</code>, and <code>stderr</code> are all connected to the terminal</li> <li>
<code>proc.stdin</code>, <code>proc.stdout</code>, and <code>proc.stderr</code> return <code>null</code> ‚Äî use the terminal instead</li> <li>Access the terminal via <code>proc.terminal</code>
</li> </ul> <h3 id="terminal-options"><span>Terminal options</span></h3> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Option</th>
<th>Description</th>
<th>Default</th>
</tr></thead>
<tbody>
<tr>
<td><code>cols</code></td>
<td>Number of columns</td>
<td data-numeric="true"><code>80</code></td>
</tr>
<tr>
<td><code>rows</code></td>
<td>Number of rows</td>
<td data-numeric="true"><code>24</code></td>
</tr>
<tr>
<td><code>name</code></td>
<td>Terminal type for PTY configuration (set <code>TERM</code> env var separately via <code>env</code> option)</td>
<td><code>"xterm-256color"</code></td>
</tr>
<tr>
<td><code>data</code></td>
<td>Callback when data is received <code>(terminal, data) =&gt; void</code>
</td>
<td>‚Äî</td>
</tr>
<tr>
<td><code>exit</code></td>
<td>Callback when PTY stream closes (EOF or error). <code>exitCode</code> is PTY lifecycle status (0=EOF, 1=error), not subprocess exit code. Use <code>proc.exited</code> for process exit.</td>
<td>‚Äî</td>
</tr>
<tr>
<td><code>drain</code></td>
<td>Callback when ready for more data <code>(terminal) =&gt; void</code>
</td>
<td>‚Äî</td>
</tr>
</tbody>
</table></div></div> <h3 id="terminal-methods"><span>Terminal methods</span></h3> <span data-as="p">The <code>Terminal</code> object returned by <code>proc.terminal</code> has the following methods:</span> <pre numberoflines="15" language="typescript" data-language="typescript">// Write data to the terminal
proc.terminal.write("echo hello\n");

// Resize the terminal
proc.terminal.resize(120, 40);

// Set raw mode (disable line buffering and echo)
proc.terminal.setRawMode(true);

// Keep event loop alive while terminal is open
proc.terminal.ref();
proc.terminal.unref();

// Close the terminal
proc.terminal.close();
</pre> <h3 id="reusable-terminal"><span>Reusable Terminal</span></h3> <span data-as="p">You can create a terminal independently and reuse it across multiple subprocesses:</span> <pre numberoflines="17" language="typescript" data-language="typescript">await using terminal = new Bun.Terminal({
  cols: 80,
  rows: 24,
  data(term, data) {
    process.stdout.write(data);
  },
});

// Spawn first process
const proc1 = Bun.spawn(["echo", "first"], { terminal });
await proc1.exited;

// Reuse terminal for another process
const proc2 = Bun.spawn(["echo", "second"], { terminal });
await proc2.exited;

// Terminal is closed automatically by `await using`
</pre> <span data-as="p">When passing an existing <code>Terminal</code> object:</span> <ul> <li>The terminal can be reused across multiple spawns</li> <li>You control when to close the terminal</li> <li>The <code>exit</code> callback fires when you call <code>terminal.close()</code>, not when each subprocess exits</li> <li>Use <code>proc.exited</code> to detect individual subprocess exits</li> </ul> <span data-as="p">This is useful for running multiple commands in sequence through the same terminal session.</span> <div data-callout-type="note">

<div data-component-part="callout-content">Terminal support is only available on POSIX systems (Linux, macOS). It is not available on Windows.</div>
</div> <hr> <h2 id="blocking-api-bun-spawnsync"><span>Blocking API (<code>Bun.spawnSync()</code>)</span></h2> <span data-as="p">Bun provides a synchronous equivalent of <code>Bun.spawn</code> called <code>Bun.spawnSync</code>. This is a blocking API that supports the same inputs and parameters as <code>Bun.spawn</code>. It returns a <code>SyncSubprocess</code> object, which differs from <code>Subprocess</code> in a few ways.</span> <ol> <li>It contains a <code>success</code> property that indicates whether the process exited with a zero exit code.</li> <li>The <code>stdout</code> and <code>stderr</code> properties are instances of <code>Buffer</code> instead of <code>ReadableStream</code>.</li> <li>There is no <code>stdin</code> property. Use <code>Bun.spawn</code> to incrementally write to the subprocess‚Äôs input stream.</li> </ol> <pre numberoflines="4" language="typescript" data-language="typescript">const proc = Bun.spawnSync(["echo", "hello"]);

console.log(proc.stdout.toString());
// =&gt; "hello\n"
</pre> <span data-as="p">As a rule of thumb, the asynchronous <code>Bun.spawn</code> API is better for HTTP servers and apps, and <code>Bun.spawnSync</code> is better for building command-line tools.</span> <hr> <h2 id="benchmarks"><span>Benchmarks</span></h2> <div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p">‚ö°Ô∏è Under the hood, <code>Bun.spawn</code> and <code>Bun.spawnSync</code> use <a href="https://man7.org/linux/man-pages/man3/posix_spawn.3.html" target="_blank" rel="noreferrer"><code>posix_spawn(3)</code></a>.</span></div>
</div> <span data-as="p">Bun‚Äôs <code>spawnSync</code> spawns processes 60% faster than the Node.js <code>child_process</code> module.</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun spawn.mjs
</pre> <pre numberoflines="7" language="text" data-language="typescript">cpu: Apple M1 Max
runtime: bun 1.x (arm64-darwin)

benchmark              time (avg)             (min ‚Ä¶ max)       p75       p99      p995
--------------------------------------------------------- -----------------------------
spawnSync echo hi  888.14 ¬µs/iter    (821.83 ¬µs ‚Ä¶ 1.2 ms) 905.92 ¬µs      1 ms   1.03 ms
</pre> <pre numberoflines="1" language="shellscript" data-language="typescript">node spawn.node.mjs
</pre> <pre numberoflines="7" language="text" data-language="typescript">cpu: Apple M1 Max
runtime: node v18.9.1 (arm64-darwin)

benchmark              time (avg)             (min ‚Ä¶ max)       p75       p99      p995
--------------------------------------------------------- -----------------------------
spawnSync echo hi    1.47 ms/iter     (1.14 ms ‚Ä¶ 2.64 ms)   1.57 ms   2.37 ms   2.52 ms
</pre> <hr> <h2 id="reference"><span>Reference</span></h2> <span data-as="p">A reference of the Spawn API and types are shown below. The real types have complex generics to strongly type the <code>Subprocess</code> streams with the options passed to <code>Bun.spawn</code> and <code>Bun.spawnSync</code>. For full details, find these types as defined <a href="https://github.com/oven-sh/bun/blob/main/packages/bun-types/bun.d.ts" target="_blank" rel="noreferrer">bun.d.ts</a>.</span> <pre numberoflines="177" language="typescript" data-language="typescript">interface Bun {
  spawn(command: string[], options?: SpawnOptions.OptionsObject): Subprocess;
  spawnSync(command: string[], options?: SpawnOptions.OptionsObject): SyncSubprocess;

  spawn(options: { cmd: string[] } &amp; SpawnOptions.OptionsObject): Subprocess;
  spawnSync(options: { cmd: string[] } &amp; SpawnOptions.OptionsObject): SyncSubprocess;
}

namespace SpawnOptions {
  interface OptionsObject {
    cwd?: string;
    env?: Record&lt;string, string | undefined&gt;;
    stdio?: [Writable, Readable, Readable];
    stdin?: Writable;
    stdout?: Readable;
    stderr?: Readable;
    onExit?(
      subprocess: Subprocess,
      exitCode: number | null,
      signalCode: number | null,
      error?: ErrorLike,
    ): void | Promise&lt;void&gt;;
    ipc?(message: any, subprocess: Subprocess): void;
    serialization?: "json" | "advanced";
    windowsHide?: boolean;
    windowsVerbatimArguments?: boolean;
    argv0?: string;
    signal?: AbortSignal;
    timeout?: number;
    killSignal?: string | number;
    maxBuffer?: number;
    terminal?: TerminalOptions; // PTY support (POSIX only)
  }

  type Readable =
    | "pipe"
    | "inherit"
    | "ignore"
    | null // equivalent to "ignore"
    | undefined // to use default
    | BunFile
    | ArrayBufferView
    | number;

  type Writable =
    | "pipe"
    | "inherit"
    | "ignore"
    | null // equivalent to "ignore"
    | undefined // to use default
    | BunFile
    | ArrayBufferView
    | number
    | ReadableStream
    | Blob
    | Response
    | Request;
}

interface Subprocess extends AsyncDisposable {
  readonly stdin: FileSink | number | undefined | null;
  readonly stdout: ReadableStream&lt;Uint8Array&lt;ArrayBuffer&gt;&gt; | number | undefined | null;
  readonly stderr: ReadableStream&lt;Uint8Array&lt;ArrayBuffer&gt;&gt; | number | undefined | null;
  readonly readable: ReadableStream&lt;Uint8Array&lt;ArrayBuffer&gt;&gt; | number | undefined | null;
  readonly terminal: Terminal | undefined;
  readonly pid: number;
  readonly exited: Promise&lt;number&gt;;
  readonly exitCode: number | null;
  readonly signalCode: NodeJS.Signals | null;
  readonly killed: boolean;

  kill(exitCode?: number | NodeJS.Signals): void;
  ref(): void;
  unref(): void;

  send(message: any): void;
  disconnect(): void;
  resourceUsage(): ResourceUsage | undefined;
}

interface SyncSubprocess {
  stdout: Buffer | undefined;
  stderr: Buffer | undefined;
  exitCode: number;
  success: boolean;
  resourceUsage: ResourceUsage;
  signalCode?: string;
  exitedDueToTimeout?: true;
  pid: number;
}

interface TerminalOptions {
  cols?: number;
  rows?: number;
  name?: string;
  data?: (terminal: Terminal, data: Uint8Array&lt;ArrayBuffer&gt;) =&gt; void;
  /** Called when PTY stream closes (EOF or error). exitCode is PTY lifecycle status (0=EOF, 1=error), not subprocess exit code. */
  exit?: (terminal: Terminal, exitCode: number, signal: string | null) =&gt; void;
  drain?: (terminal: Terminal) =&gt; void;
}

interface Terminal extends AsyncDisposable {
  readonly stdin: number;
  readonly stdout: number;
  readonly closed: boolean;
  write(data: string | BufferSource): number;
  resize(cols: number, rows: number): void;
  setRawMode(enabled: boolean): void;
  ref(): void;
  unref(): void;
  close(): void;
}

interface ResourceUsage {
  contextSwitches: {
    voluntary: number;
    involuntary: number;
  };

  cpuTime: {
    user: number;
    system: number;
    total: number;
  };
  maxRSS: number;

  messages: {
    sent: number;
    received: number;
  };
  ops: {
    in: number;
    out: number;
  };
  shmSize: number;
  signalCount: number;
  swapCount: number;
}

type Signal =
  | "SIGABRT"
  | "SIGALRM"
  | "SIGBUS"
  | "SIGCHLD"
  | "SIGCONT"
  | "SIGFPE"
  | "SIGHUP"
  | "SIGILL"
  | "SIGINT"
  | "SIGIO"
  | "SIGIOT"
  | "SIGKILL"
  | "SIGPIPE"
  | "SIGPOLL"
  | "SIGPROF"
  | "SIGPWR"
  | "SIGQUIT"
  | "SIGSEGV"
  | "SIGSTKFLT"
  | "SIGSTOP"
  | "SIGSYS"
  | "SIGTERM"
  | "SIGTRAP"
  | "SIGTSTP"
  | "SIGTTIN"
  | "SIGTTOU"
  | "SIGUNUSED"
  | "SIGURG"
  | "SIGUSR1"
  | "SIGUSR2"
  | "SIGVTALRM"
  | "SIGWINCH"
  | "SIGXCPU"
  | "SIGXFSZ"
  | "SIGBREAK"
  | "SIGLOST"
  | "SIGINFO";
See all 177 lines</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/child-process" class="_attribution-link">https://bun.com/docs/runtime/child-process</a>
  </p>
</div>
