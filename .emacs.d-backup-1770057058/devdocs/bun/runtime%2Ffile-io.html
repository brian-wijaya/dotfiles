<h1 id="header">File I/O</h1>
<div data-page-title="File I/O" data-page-href="/runtime/file-io" id="content">
<div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p">The <code>Bun.file</code> and <code>Bun.write</code> APIs documented on this page are heavily optimized and represent the recommended way to perform file-system tasks using Bun. For operations that are not yet available with <code>Bun.file</code>, such as <code>mkdir</code> or <code>readdir</code>, you can use Bun’s <a href="nodejs-compat#node-fs">nearly complete</a> implementation of the <a href="https://nodejs.org/api/fs.html" target="_blank" rel="noreferrer"><code>node:fs</code></a> module.</span></div>
</div> <hr> <h2 id="reading-files-bun-file"><span>Reading files (<code>Bun.file()</code>)</span></h2> <span data-as="p"><code>Bun.file(path): BunFile</code></span> <span data-as="p">Create a <code>BunFile</code> instance with the <code>Bun.file(path)</code> function. A <code>BunFile</code> represents a lazily-loaded file; initializing it does not actually read the file from disk.</span> <pre numberoflines="3" language="typescript" data-language="typescript">const foo = Bun.file("foo.txt"); // relative to cwd
foo.size; // number of bytes
foo.type; // MIME type
</pre> <span data-as="p">The reference conforms to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="noreferrer"><code>Blob</code></a> interface, so the contents can be read in various formats.</span> <pre numberoflines="7" language="typescript" data-language="typescript">const foo = Bun.file("foo.txt");

await foo.text(); // contents as a string
await foo.json(); // contents as a JSON object
await foo.stream(); // contents as ReadableStream
await foo.arrayBuffer(); // contents as ArrayBuffer
await foo.bytes(); // contents as Uint8Array
</pre> <span data-as="p">File references can also be created using numerical <a href="https://en.wikipedia.org/wiki/File_descriptor" target="_blank" rel="noreferrer">file descriptors</a> or <code>file://</code> URLs.</span> <pre numberoflines="2" language="typescript" data-language="typescript">Bun.file(1234);
Bun.file(new URL(import.meta.url)); // reference to the current file
</pre> <span data-as="p">A <code>BunFile</code> can point to a location on disk where a file does not exist.</span> <pre numberoflines="4" language="typescript" data-language="typescript">const notreal = Bun.file("notreal.txt");
notreal.size; // 0
notreal.type; // "text/plain;charset=utf-8"
const exists = await notreal.exists(); // false
</pre> <span data-as="p">The default MIME type is <code>text/plain;charset=utf-8</code>, but it can be overridden by passing a second argument to <code>Bun.file</code>.</span> <pre numberoflines="2" language="typescript" data-language="typescript">const notreal = Bun.file("notreal.json", { type: "application/json" });
notreal.type; // =&gt; "application/json;charset=utf-8"
</pre> <span data-as="p">For convenience, Bun exposes <code>stdin</code>, <code>stdout</code> and <code>stderr</code> as instances of <code>BunFile</code>.</span> <pre numberoflines="3" language="typescript" data-language="typescript">Bun.stdin; // readonly
Bun.stdout;
Bun.stderr;
</pre> <h3 id="deleting-files-file-delete"><span>Deleting files (<code>file.delete()</code>)</span></h3> <span data-as="p">You can delete a file by calling the <code>.delete()</code> function.</span> <pre numberoflines="1" language="typescript" data-language="typescript">await Bun.file("logs.json").delete();
</pre> <hr> <h2 id="writing-files-bun-write"><span>Writing files (<code>Bun.write()</code>)</span></h2> <span data-as="p"><code>Bun.write(destination, data): Promise&lt;number&gt;</code></span> <span data-as="p">The <code>Bun.write</code> function is a multi-tool for writing payloads of all kinds to disk.</span> <span data-as="p">The first argument is the <code>destination</code> which can have any of the following types:</span> <ul> <li>
<code>string</code>: A path to a location on the file system. Use the <code>"path"</code> module to manipulate paths.</li> <li>
<code>URL</code>: A <code>file://</code> descriptor.</li> <li>
<code>BunFile</code>: A file reference.</li> </ul> <span data-as="p">The second argument is the data to be written. It can be any of the following:</span> <ul> <li><code>string</code></li> <li>
<code>Blob</code> (including <code>BunFile</code>)</li> <li>
<code>ArrayBuffer</code> or <code>SharedArrayBuffer</code>
</li> <li>
<code>TypedArray</code> (<code>Uint8Array</code>, et. al.)</li> <li><code>Response</code></li> </ul> <span data-as="p">All possible permutations are handled using the fastest available system calls on the current platform.</span> <details><summary aria-controls="see-syscalls accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">See syscalls</p></div></summary><div id="see-syscalls accordion children" role="region" aria-labelledby="see-syscalls" data-component-part="accordion-content"><div data-table-wrapper="true"><div><table> <thead><tr>
<th>Output</th>
<th>Input</th>
<th>System call</th>
<th>Platform</th>
</tr></thead> <tbody>
<tr>
<td>file</td>
<td>file</td>
<td>copy_file_range</td>
<td>Linux</td>
</tr>
<tr>
<td>file</td>
<td>pipe</td>
<td>sendfile</td>
<td>Linux</td>
</tr>
<tr>
<td>pipe</td>
<td>pipe</td>
<td>splice</td>
<td>Linux</td>
</tr>
<tr>
<td>terminal</td>
<td>file</td>
<td>sendfile</td>
<td>Linux</td>
</tr>
<tr>
<td>terminal</td>
<td>terminal</td>
<td>sendfile</td>
<td>Linux</td>
</tr>
<tr>
<td>socket</td>
<td>file or pipe</td>
<td>sendfile (if http, not https)</td>
<td>Linux</td>
</tr>
<tr>
<td>file (doesn’t exist)</td>
<td>file (path)</td>
<td>clonefile</td>
<td>macOS</td>
</tr>
<tr>
<td>file (exists)</td>
<td>file</td>
<td>fcopyfile</td>
<td>macOS</td>
</tr>
<tr>
<td>file</td>
<td>Blob or string</td>
<td>write</td>
<td>macOS</td>
</tr>
<tr>
<td>file</td>
<td>Blob or string</td>
<td>write</td>
<td>Linux</td>
</tr>
</tbody> </table></div></div></div></details> <span data-as="p">To write a string to disk:</span> <pre numberoflines="2" language="typescript" data-language="typescript">const data = `It was the best of times, it was the worst of times.`;
await Bun.write("output.txt", data);
</pre> <span data-as="p">To copy a file to another location on disk:</span> <pre numberoflines="3" language="typescript" data-language="typescript">const input = Bun.file("input.txt");
const output = Bun.file("output.txt"); // doesn't exist yet!
await Bun.write(output, input);
</pre> <span data-as="p">To write a byte array to disk:</span> <pre numberoflines="3" language="typescript" data-language="typescript">const encoder = new TextEncoder();
const data = encoder.encode("datadatadata"); // Uint8Array
await Bun.write("output.txt", data);
</pre> <span data-as="p">To write a file to <code>stdout</code>:</span> <pre numberoflines="2" language="typescript" data-language="typescript">const input = Bun.file("input.txt");
await Bun.write(Bun.stdout, input);
</pre> <span data-as="p">To write the body of an HTTP response to disk:</span> <pre numberoflines="2" language="typescript" data-language="typescript">const response = await fetch("https://bun.com");
await Bun.write("index.html", response);
</pre> <hr> <h2 id="incremental-writing-with-filesink"><span>Incremental writing with <code>FileSink</code></span></h2> <span data-as="p">Bun provides a native incremental file writing API called <code>FileSink</code>. To retrieve a <code>FileSink</code> instance from a <code>BunFile</code>:</span> <pre numberoflines="2" language="typescript" data-language="typescript">const file = Bun.file("output.txt");
const writer = file.writer();
</pre> <span data-as="p">To incrementally write to the file, call <code>.write()</code>.</span> <pre numberoflines="5" language="typescript" data-language="typescript">const file = Bun.file("output.txt");
const writer = file.writer();

writer.write("it was the best of times\n");
writer.write("it was the worst of times\n");
</pre> <span data-as="p">These chunks will be buffered internally. To flush the buffer to disk, use <code>.flush()</code>. This returns the number of flushed bytes.</span> <pre numberoflines="1" language="typescript" data-language="typescript">writer.flush(); // write buffer to disk
</pre> <span data-as="p">The buffer will also auto-flush when the <code>FileSink</code>’s <em>high water mark</em> is reached; that is, when its internal buffer is full. This value can be configured.</span> <pre numberoflines="2" language="typescript" data-language="typescript">const file = Bun.file("output.txt");
const writer = file.writer({ highWaterMark: 1024 * 1024 }); // 1MB
</pre> <span data-as="p">To flush the buffer and close the file:</span> <pre numberoflines="1" language="typescript" data-language="typescript">writer.end();
</pre> <span data-as="p">Note that, by default, the <code>bun</code> process will stay alive until this <code>FileSink</code> is explicitly closed with <code>.end()</code>. To opt out of this behavior, you can “unref” the instance.</span> <pre numberoflines="4" language="typescript" data-language="typescript">writer.unref();

// to "re-ref" it later
writer.ref();
</pre> <hr> <h2 id="directories"><span>Directories</span></h2> <span data-as="p">Bun’s implementation of <code>node:fs</code> is fast, and we haven’t implemented a Bun-specific API for reading directories just yet. For now, you should use <code>node:fs</code> for working with directories in Bun.</span> <h3 id="reading-directories-readdir"><span>Reading directories (readdir)</span></h3> <span data-as="p">To read a directory in Bun, use <code>readdir</code> from <code>node:fs</code>.</span> <pre numberoflines="4" language="typescript" data-language="typescript">import { readdir } from "node:fs/promises";

// read all the files in the current directory
const files = await readdir(import.meta.dir);
</pre> <h4 id="reading-directories-recursively"><span>Reading directories recursively</span></h4> <span data-as="p">To recursively read a directory in Bun, use <code>readdir</code> with <code>recursive: true</code>.</span> <pre numberoflines="4" language="typescript" data-language="typescript">import { readdir } from "node:fs/promises";

// read all the files in the current directory, recursively
const files = await readdir("../", { recursive: true });
</pre> <h3 id="creating-directories-mkdir"><span>Creating directories (mkdir)</span></h3> <span data-as="p">To recursively create a directory, use <code>mkdir</code> in <code>node:fs</code>:</span> <pre numberoflines="3" language="typescript" data-language="typescript">import { mkdir } from "node:fs/promises";

await mkdir("path/to/dir", { recursive: true });
</pre> <hr> <h2 id="benchmarks"><span>Benchmarks</span></h2> <span data-as="p">The following is a 3-line implementation of the Linux <code>cat</code> command.</span> <pre numberoflines="7" language="typescript" data-language="typescript">// Usage
// bun ./cat.ts ./path-to-file

import { resolve } from "path";

const path = resolve(process.argv.at(-1));
await Bun.write(Bun.stdout, Bun.file(path));
</pre> <span data-as="p">To run the file:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun ./cat.ts ./path-to-file
</pre> <span data-as="p">It runs 2x faster than GNU <code>cat</code> for large files on Linux.</span>  <hr> <h2 id="reference"><span>Reference</span></h2> <pre numberoflines="33" language="typescript" data-language="typescript">interface Bun {
  stdin: BunFile;
  stdout: BunFile;
  stderr: BunFile;

  file(path: string | number | URL, options?: { type?: string }): BunFile;

  write(
    destination: string | number | BunFile | URL,
    input: string | Blob | ArrayBuffer | SharedArrayBuffer | TypedArray | Response,
  ): Promise&lt;number&gt;;
}

interface BunFile {
  readonly size: number;
  readonly type: string;

  text(): Promise&lt;string&gt;;
  stream(): ReadableStream;
  arrayBuffer(): Promise&lt;ArrayBuffer&gt;;
  json(): Promise&lt;any&gt;;
  writer(params: { highWaterMark?: number }): FileSink;
  exists(): Promise&lt;boolean&gt;;
}

export interface FileSink {
  write(chunk: string | ArrayBufferView | ArrayBuffer | SharedArrayBuffer): number;
  flush(): number | Promise&lt;number&gt;;
  end(error?: Error): number | Promise&lt;number&gt;;
  start(options?: { highWaterMark?: number }): void;
  ref(): void;
  unref(): void;
}
</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/file-io" class="_attribution-link">https://bun.com/docs/runtime/file-io</a>
  </p>
</div>
