<h1 id="header">Hashing</h1>
<div data-page-title="Hashing" data-page-href="/runtime/hashing" id="content">
<div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p">Bun implements the <code>createHash</code> and <code>createHmac</code> functions from <a href="https://nodejs.org/api/crypto.html" target="_blank" rel="noreferrer"><code>node:crypto</code></a> in addition to the Bun-native APIs documented below.</span></div>
</div> <hr> <h2 id="bun-password"><span><code>Bun.password</code></span></h2> <span data-as="p"><code>Bun.password</code> is a collection of utility functions for hashing and verifying passwords with various cryptographically secure algorithms.</span> <pre numberoflines="7" language="typescript" data-language="typescript">const password = "super-secure-pa$$word";

const hash = await Bun.password.hash(password);
// =&gt; $argon2id$v=19$m=65536,t=2,p=1$tFq+9AVr1bfPxQdh6E8DQRhEXg/M/SqYCNu6gVdRRNs$GzJ8PuBi+K+BVojzPfS5mjnC8OpLGtv8KJqF99eP6a4

const isMatch = await Bun.password.verify(password, hash);
// =&gt; true
</pre> <span data-as="p">The second argument to <code>Bun.password.hash</code> accepts a params object that lets you pick and configure the hashing algorithm.</span> <pre numberoflines="14" language="typescript" data-language="typescript">const password = "super-secure-pa$$word";

// use argon2 (default)
const argonHash = await Bun.password.hash(password, {
  algorithm: "argon2id", // "argon2id" | "argon2i" | "argon2d"
  memoryCost: 4, // memory usage in kibibytes
  timeCost: 3, // the number of iterations
});

// use bcrypt
const bcryptHash = await Bun.password.hash(password, {
  algorithm: "bcrypt",
  cost: 4, // number between 4-31
});
</pre> <span data-as="p">The algorithm used to create the hash is stored in the hash itself. When using <code>bcrypt</code>, the returned hash is encoded in <a href="https://passlib.readthedocs.io/en/stable/modular_crypt_format.html" target="_blank" rel="noreferrer">Modular Crypt Format</a> for compatibility with most existing <code>bcrypt</code> implementations; with <code>argon2</code> the result is encoded in the newer <a href="https://github.com/P-H-C/phc-string-format/blob/master/phc-sf-spec" target="_blank" rel="noreferrer">PHC format</a>.</span> <span data-as="p">The <code>verify</code> function automatically detects the algorithm based on the input hash and use the correct verification method. It can correctly infer the algorithm from both PHC- or MCF-encoded hashes.</span> <pre numberoflines="8" language="typescript" data-language="typescript">const password = "super-secure-pa$$word";

const hash = await Bun.password.hash(password, {
  /* config */
});

const isMatch = await Bun.password.verify(password, hash);
// =&gt; true
</pre> <span data-as="p">Synchronous versions of all functions are also available. Keep in mind that these functions are computationally expensive, so using a blocking API may degrade application performance.</span> <pre numberoflines="8" language="typescript" data-language="typescript">const password = "super-secure-pa$$word";

const hash = Bun.password.hashSync(password, {
  /* config */
});

const isMatch = Bun.password.verifySync(password, hash);
// =&gt; true
</pre> <h3 id="salt"><span>Salt</span></h3> <span data-as="p">When you use <code>Bun.password.hash</code>, a salt is automatically generated and included in the hash.</span> <h3 id="bcrypt-modular-crypt-format"><span>bcrypt - Modular Crypt Format</span></h3> <span data-as="p">In the following <a href="https://passlib.readthedocs.io/en/stable/modular_crypt_format.html" target="_blank" rel="noreferrer">Modular Crypt Format</a> hash (used by <code>bcrypt</code>):</span> <span data-as="p">Input:</span> <pre numberoflines="3" language="typescript" data-language="typescript">await Bun.password.hash("hello", {
  algorithm: "bcrypt",
});
</pre> <span data-as="p">Output:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">$2b$10$Lyj9kHYZtiyfxh2G60TEfeqs7xkkGiEFFDi3iJGc50ZG/XJ1sxIFi;
</pre> <span data-as="p">The format is composed of:</span> <ul> <li>
<code>bcrypt</code>: <code>$2b</code>
</li> <li>
<code>rounds</code>: <code>$10</code> - rounds (log10 of the actual number of rounds)</li> <li>
<code>salt</code>: <code>$Lyj9kHYZtiyfxh2G60TEfeqs7xkkGiEFFDi3iJGc50ZG/XJ1sxIFi</code>
</li> <li>
<code>hash</code>: <code>$GzJ8PuBi+K+BVojzPfS5mjnC8OpLGtv8KJqF99eP6a4</code>
</li> </ul> <span data-as="p">By default, the bcrypt library truncates passwords longer than 72 bytes. In Bun, if you pass <code>Bun.password.hash</code> a password longer than 72 bytes and use the <code>bcrypt</code> algorithm, the password will be hashed via SHA-512 before being passed to bcrypt.</span> <pre numberoflines="3" language="typescript" data-language="typescript">await Bun.password.hash("hello".repeat(100), {
  algorithm: "bcrypt",
});
</pre> <span data-as="p">So instead of sending bcrypt a 500-byte password silently truncated to 72 bytes, Bun will hash the password using SHA-512 and send the hashed password to bcrypt (only if it exceeds 72 bytes). This is a more secure default behavior.</span> <h3 id="argon2-phc-format"><span>argon2 - PHC format</span></h3> <span data-as="p">In the following <a href="https://github.com/P-H-C/phc-string-format/blob/master/phc-sf-spec" target="_blank" rel="noreferrer">PHC format</a> hash (used by <code>argon2</code>):</span> <span data-as="p">Input:</span> <pre numberoflines="3" language="typescript" data-language="typescript">await Bun.password.hash("hello", {
  algorithm: "argon2id",
});
</pre> <span data-as="p">Output:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">$argon2id$v=19$m=65536,t=2,p=1$xXnlSvPh4ym5KYmxKAuuHVlDvy2QGHBNuI6bJJrRDOs$2YY6M48XmHn+s5NoBaL+ficzXajq2Yj8wut3r0vnrwI
</pre> <span data-as="p">The format is composed of:</span> <ul> <li>
<code>algorithm</code>: <code>$argon2id</code>
</li> <li>
<code>version</code>: <code>$v=19</code>
</li> <li>
<code>memory cost</code>: <code>65536</code>
</li> <li>
<code>iterations</code>: <code>t=2</code>
</li> <li>
<code>parallelism</code>: <code>p=1</code>
</li> <li>
<code>salt</code>: <code>$xXnlSvPh4ym5KYmxKAuuHVlDvy2QGHBNuI6bJJrRDOs</code>
</li> <li>
<code>hash</code>: <code>$2YY6M48XmHn+s5NoBaL+ficzXajq2Yj8wut3r0vnrwI</code>
</li> </ul> <hr> <h2 id="bun-hash"><span><code>Bun.hash</code></span></h2> <span data-as="p"><code>Bun.hash</code> is a collection of utilities for <em>non-cryptographic</em> hashing. Non-cryptographic hashing algorithms are optimized for speed of computation over collision-resistance or security.</span> <span data-as="p">The standard <code>Bun.hash</code> functions uses <a href="https://github.com/wangyi-fudan/wyhash" target="_blank" rel="noreferrer">Wyhash</a> to generate a 64-bit hash from an input of arbitrary size.</span> <pre numberoflines="2" language="typescript" data-language="typescript">Bun.hash("some data here");
// 11562320457524636935n
</pre> <span data-as="p">The input can be a string, <code>TypedArray</code>, <code>DataView</code>, <code>ArrayBuffer</code>, or <code>SharedArrayBuffer</code>.</span> <pre numberoflines="6" language="typescript" data-language="typescript">const arr = new Uint8Array([1, 2, 3, 4]);

Bun.hash("some data here");
Bun.hash(arr);
Bun.hash(arr.buffer);
Bun.hash(new DataView(arr.buffer));
</pre> <span data-as="p">Optionally, an integer seed can be specified as the second parameter. For 64-bit hashes seeds above <code>Number.MAX_SAFE_INTEGER</code> should be given as BigInt to avoid loss of precision.</span> <pre numberoflines="2" language="typescript" data-language="typescript">Bun.hash("some data here", 1234);
// 15724820720172937558n
</pre> <span data-as="p">Additional hashing algorithms are available as properties on <code>Bun.hash</code>. The API is the same for each, only changing the return type from number for 32-bit hashes to bigint for 64-bit hashes.</span> <pre numberoflines="12" language="typescript" data-language="typescript">Bun.hash.wyhash("data", 1234); // equivalent to Bun.hash()
Bun.hash.crc32("data", 1234);
Bun.hash.adler32("data", 1234);
Bun.hash.cityHash32("data", 1234);
Bun.hash.cityHash64("data", 1234);
Bun.hash.xxHash32("data", 1234);
Bun.hash.xxHash64("data", 1234);
Bun.hash.xxHash3("data", 1234);
Bun.hash.murmur32v3("data", 1234);
Bun.hash.murmur32v2("data", 1234);
Bun.hash.murmur64v2("data", 1234);
Bun.hash.rapidhash("data", 1234);
</pre> <hr> <h2 id="bun-cryptohasher"><span><code>Bun.CryptoHasher</code></span></h2> <span data-as="p"><code>Bun.CryptoHasher</code> is a general-purpose utility class that lets you incrementally compute a hash of string or binary data using a range of cryptographic hash algorithms. The following algorithms are supported:</span> <ul> <li><code>"blake2b256"</code></li> <li><code>"blake2b512"</code></li> <li><code>"md4"</code></li> <li><code>"md5"</code></li> <li><code>"ripemd160"</code></li> <li><code>"sha1"</code></li> <li><code>"sha224"</code></li> <li><code>"sha256"</code></li> <li><code>"sha384"</code></li> <li><code>"sha512"</code></li> <li><code>"sha512-224"</code></li> <li><code>"sha512-256"</code></li> <li><code>"sha3-224"</code></li> <li><code>"sha3-256"</code></li> <li><code>"sha3-384"</code></li> <li><code>"sha3-512"</code></li> <li><code>"shake128"</code></li> <li><code>"shake256"</code></li> </ul> <pre numberoflines="4" language="typescript" data-language="typescript">const hasher = new Bun.CryptoHasher("sha256");
hasher.update("hello world");
hasher.digest();
// Uint8Array(32) [ &lt;byte&gt;, &lt;byte&gt;, ... ]
</pre> <span data-as="p">Once initialized, data can be incrementally fed to to the hasher using <code>.update()</code>. This method accepts <code>string</code>, <code>TypedArray</code>, and <code>ArrayBuffer</code>.</span> <pre numberoflines="5" language="typescript" data-language="typescript">const hasher = new Bun.CryptoHasher("sha256");

hasher.update("hello world");
hasher.update(new Uint8Array([1, 2, 3]));
hasher.update(new ArrayBuffer(10));
</pre> <span data-as="p">If a <code>string</code> is passed, an optional second parameter can be used to specify the encoding (default <code>'utf-8'</code>). The following encodings are supported:</span> <div data-table-wrapper="true"><div><table> <thead><tr>
<th>Category</th>
<th>Encodings</th>
</tr></thead> <tbody>
<tr>
<td>Binary encodings</td>
<td>
<code>"base64"</code> <code>"base64url"</code> <code>"hex"</code> <code>"binary"</code>
</td>
</tr>
<tr>
<td>Character encodings</td>
<td>
<code>"utf8"</code> <code>"utf-8"</code> <code>"utf16le"</code> <code>"latin1"</code>
</td>
</tr>
<tr>
<td>Legacy character encodings</td>
<td>
<code>"ascii"</code> <code>"binary"</code> <code>"ucs2"</code> <code>"ucs-2"</code>
</td>
</tr>
</tbody> </table></div></div> <pre numberoflines="4" language="typescript" data-language="typescript">hasher.update("hello world"); // defaults to utf8
hasher.update("hello world", "hex");
hasher.update("hello world", "base64");
hasher.update("hello world", "latin1");
</pre> <span data-as="p">After the data has been feed into the hasher, a final hash can be computed using <code>.digest()</code>. By default, this method returns a <code>Uint8Array</code> containing the hash.</span> <pre numberoflines="5" language="typescript" data-language="typescript">const hasher = new Bun.CryptoHasher("sha256");
hasher.update("hello world");

hasher.digest();
// =&gt; Uint8Array(32) [ 185, 77, 39, 185, 147, ... ]
</pre> <span data-as="p">The <code>.digest()</code> method can optionally return the hash as a string. To do so, specify an encoding:</span> <pre numberoflines="5" language="typescript" data-language="typescript">hasher.digest("base64");
// =&gt; "uU0nuZNNPgilLlLX2n2r+sSE7+N6U4DukIj3rOLvzek="

hasher.digest("hex");
// =&gt; "b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9"
</pre> <span data-as="p">Alternatively, the method can write the hash into a pre-existing <code>TypedArray</code> instance. This may be desirable in some performance-sensitive applications.</span> <pre numberoflines="6" language="typescript" data-language="typescript">const arr = new Uint8Array(32);

hasher.digest(arr);

console.log(arr);
// =&gt; Uint8Array(32) [ 185, 77, 39, 185, 147, ... ]
</pre> <h3 id="hmac-in-bun-cryptohasher"><span>HMAC in <code>Bun.CryptoHasher</code></span></h3> <span data-as="p"><code>Bun.CryptoHasher</code> can be used to compute HMAC digests. To do so, pass the key to the constructor.</span> <pre numberoflines="4" language="typescript" data-language="typescript">const hasher = new Bun.CryptoHasher("sha256", "secret-key");
hasher.update("hello world");
console.log(hasher.digest("hex"));
// =&gt; "095d5a21fe6d0646db223fdf3de6436bb8dfb2fab0b51677ecf6441fcf5f2a67"
</pre> <span data-as="p">When using HMAC, a more limited set of algorithms are supported:</span> <ul> <li><code>"blake2b512"</code></li> <li><code>"md5"</code></li> <li><code>"sha1"</code></li> <li><code>"sha224"</code></li> <li><code>"sha256"</code></li> <li><code>"sha384"</code></li> <li><code>"sha512-224"</code></li> <li><code>"sha512-256"</code></li> <li><code>"sha512"</code></li> </ul> <span data-as="p">Unlike the non-HMAC <code>Bun.CryptoHasher</code>, the HMAC <code>Bun.CryptoHasher</code> instance is not reset after <code>.digest()</code> is called, and attempting to use the same instance again will throw an error.</span> <span data-as="p">Other methods like <code>.copy()</code> and <code>.update()</code> are supported (as long as itâ€™s before <code>.digest()</code>), but methods like <code>.digest()</code> that finalize the hasher are not.</span> <pre numberoflines="10" language="typescript" data-language="typescript">const hasher = new Bun.CryptoHasher("sha256", "secret-key");
hasher.update("hello world");

const copy = hasher.copy();
copy.update("!");
console.log(copy.digest("hex"));
// =&gt; "3840176c3d8923f59ac402b7550404b28ab11cb0ef1fa199130a5c37864b5497"

console.log(hasher.digest("hex"));
// =&gt; "095d5a21fe6d0646db223fdf3de6436bb8dfb2fab0b51677ecf6441fcf5f2a67"
</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/hashing" class="_attribution-link">https://bun.com/docs/runtime/hashing</a>
  </p>
</div>
