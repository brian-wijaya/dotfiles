<h1 id="header">Mocks</h1>
<div data-page-title="Mocks" data-page-href="/test/mocks" id="content">
<span data-as="p">Mocking is essential for testing by allowing you to replace dependencies with controlled implementations. Bun provides comprehensive mocking capabilities including function mocks, spies, and module mocks.</span> <h2 id="basic-function-mocks"><span>Basic Function Mocks</span></h2> <span data-as="p">Create mocks with the <code>mock</code> function.</span> <pre numberoflines="10" language="typescript" data-language="typescript">import { test, expect, mock } from "bun:test";

const random = mock(() =&gt; Math.random());

test("random", () =&gt; {
  const val = random();
  expect(val).toBeGreaterThan(0);
  expect(random).toHaveBeenCalled();
  expect(random).toHaveBeenCalledTimes(1);
});
</pre> <h3 id="jest-compatibility"><span>Jest Compatibility</span></h3> <span data-as="p">Alternatively, you can use the <code>jest.fn()</code> function, as in Jest. It behaves identically.</span> <pre numberoflines="10" language="typescript" data-language="typescript">import { test, expect, jest } from "bun:test";

const random = jest.fn(() =&gt; Math.random());

test("random", () =&gt; {
  const val = random();
  expect(val).toBeGreaterThan(0);
  expect(random).toHaveBeenCalled();
  expect(random).toHaveBeenCalledTimes(1);
});
</pre> <h2 id="mock-function-properties"><span>Mock Function Properties</span></h2> <span data-as="p">The result of <code>mock()</code> is a new function that’s been decorated with some additional properties.</span> <pre numberoflines="15" language="typescript" data-language="typescript">import { mock } from "bun:test";

const random = mock((multiplier: number) =&gt; multiplier * Math.random());

random(2);
random(10);

random.mock.calls;
// [[ 2 ], [ 10 ]]

random.mock.results;
//  [
//    { type: "return", value: 0.6533907460954099 },
//    { type: "return", value: 0.6452713933037312 }
//  ]
</pre> <h3 id="available-properties-and-methods"><span>Available Properties and Methods</span></h3> <span data-as="p">The following properties and methods are implemented on mock functions:</span> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Property/Method</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code>mockFn.getMockName()</code></td>
<td>Returns the mock name</td>
</tr>
<tr>
<td><code>mockFn.mock.calls</code></td>
<td>Array of call arguments for each invocation</td>
</tr>
<tr>
<td><code>mockFn.mock.results</code></td>
<td>Array of return values for each invocation</td>
</tr>
<tr>
<td><code>mockFn.mock.instances</code></td>
<td>Array of <code>this</code> contexts for each invocation</td>
</tr>
<tr>
<td><code>mockFn.mock.contexts</code></td>
<td>Array of <code>this</code> contexts for each invocation</td>
</tr>
<tr>
<td><code>mockFn.mock.lastCall</code></td>
<td>Arguments of the most recent call</td>
</tr>
<tr>
<td><code>mockFn.mockClear()</code></td>
<td>Clears call history</td>
</tr>
<tr>
<td><code>mockFn.mockReset()</code></td>
<td>Clears call history and removes implementation</td>
</tr>
<tr>
<td><code>mockFn.mockRestore()</code></td>
<td>Restores original implementation</td>
</tr>
<tr>
<td><code>mockFn.mockImplementation(fn)</code></td>
<td>Sets a new implementation</td>
</tr>
<tr>
<td><code>mockFn.mockImplementationOnce(fn)</code></td>
<td>Sets implementation for next call only</td>
</tr>
<tr>
<td><code>mockFn.mockName(name)</code></td>
<td>Sets the mock name</td>
</tr>
<tr>
<td><code>mockFn.mockReturnThis()</code></td>
<td>Sets the return value to <code>this</code>
</td>
</tr>
<tr>
<td><code>mockFn.mockReturnValue(value)</code></td>
<td>Sets a return value</td>
</tr>
<tr>
<td><code>mockFn.mockReturnValueOnce(value)</code></td>
<td>Sets return value for next call only</td>
</tr>
<tr>
<td><code>mockFn.mockResolvedValue(value)</code></td>
<td>Sets a resolved Promise value</td>
</tr>
<tr>
<td><code>mockFn.mockResolvedValueOnce(value)</code></td>
<td>Sets resolved Promise for next call only</td>
</tr>
<tr>
<td><code>mockFn.mockRejectedValue(value)</code></td>
<td>Sets a rejected Promise value</td>
</tr>
<tr>
<td><code>mockFn.mockRejectedValueOnce(value)</code></td>
<td>Sets rejected Promise for next call only</td>
</tr>
<tr>
<td><code>mockFn.withImplementation(fn, callback)</code></td>
<td>Temporarily changes implementation</td>
</tr>
</tbody>
</table></div></div> <h3 id="practical-examples"><span>Practical Examples</span></h3> <h4 id="basic-mock-usage"><span>Basic Mock Usage</span></h4> <pre numberoflines="25" language="typescript" data-language="typescript">import { test, expect, mock } from "bun:test";

test("mock function behavior", () =&gt; {
  const mockFn = mock((x: number) =&gt; x * 2);

  // Call the mock
  const result1 = mockFn(5);
  const result2 = mockFn(10);

  // Verify calls
  expect(mockFn).toHaveBeenCalledTimes(2);
  expect(mockFn).toHaveBeenCalledWith(5);
  expect(mockFn).toHaveBeenLastCalledWith(10);

  // Check results
  expect(result1).toBe(10);
  expect(result2).toBe(20);

  // Inspect call history
  expect(mockFn.mock.calls).toEqual([[5], [10]]);
  expect(mockFn.mock.results).toEqual([
    { type: "return", value: 10 },
    { type: "return", value: 20 },
  ]);
});
</pre> <h4 id="dynamic-mock-implementations"><span>Dynamic Mock Implementations</span></h4> <pre numberoflines="15" language="typescript" data-language="typescript">import { test, expect, mock } from "bun:test";

test("dynamic mock implementations", () =&gt; {
  const mockFn = mock();

  // Set different implementations
  mockFn.mockImplementationOnce(() =&gt; "first");
  mockFn.mockImplementationOnce(() =&gt; "second");
  mockFn.mockImplementation(() =&gt; "default");

  expect(mockFn()).toBe("first");
  expect(mockFn()).toBe("second");
  expect(mockFn()).toBe("default");
  expect(mockFn()).toBe("default"); // Uses default implementation
});
</pre> <h4 id="async-mocks"><span>Async Mocks</span></h4> <pre numberoflines="18" language="typescript" data-language="typescript">import { test, expect, mock } from "bun:test";

test("async mock functions", async () =&gt; {
  const asyncMock = mock();

  // Mock resolved values
  asyncMock.mockResolvedValueOnce("first result");
  asyncMock.mockResolvedValue("default result");

  expect(await asyncMock()).toBe("first result");
  expect(await asyncMock()).toBe("default result");

  // Mock rejected values
  const rejectMock = mock();
  rejectMock.mockRejectedValue(new Error("Mock error"));

  await expect(rejectMock()).rejects.toThrow("Mock error");
});
</pre> <h2 id="spies-with-spyon"><span>Spies with spyOn()</span></h2> <span data-as="p">It’s possible to track calls to a function without replacing it with a mock. Use <code>spyOn()</code> to create a spy; these spies can be passed to <code>.toHaveBeenCalled()</code> and <code>.toHaveBeenCalledTimes()</code>.</span> <pre numberoflines="16" language="typescript" data-language="typescript">import { test, expect, spyOn } from "bun:test";

const ringo = {
  name: "Ringo",
  sayHi() {
    console.log(`Hello I'm ${this.name}`);
  },
};

const spy = spyOn(ringo, "sayHi");

test("spyon", () =&gt; {
  expect(spy).toHaveBeenCalledTimes(0);
  ringo.sayHi();
  expect(spy).toHaveBeenCalledTimes(1);
});
</pre> <h3 id="advanced-spy-usage"><span>Advanced Spy Usage</span></h3> <pre numberoflines="47" language="typescript" data-language="typescript">import { test, expect, spyOn, afterEach } from "bun:test";

class UserService {
  async getUser(id: string) {
    // Original implementation
    return { id, name: `User ${id}` };
  }

  async saveUser(user: any) {
    // Original implementation
    return { ...user, saved: true };
  }
}

const userService = new UserService();

afterEach(() =&gt; {
  // Restore all spies after each test
  jest.restoreAllMocks();
});

test("spy on service methods", async () =&gt; {
  // Spy without changing implementation
  const getUserSpy = spyOn(userService, "getUser");
  const saveUserSpy = spyOn(userService, "saveUser");

  // Use the service normally
  const user = await userService.getUser("123");
  await userService.saveUser(user);

  // Verify calls
  expect(getUserSpy).toHaveBeenCalledWith("123");
  expect(saveUserSpy).toHaveBeenCalledWith(user);
});

test("spy with mock implementation", async () =&gt; {
  // Spy and override implementation
  const getUserSpy = spyOn(userService, "getUser").mockResolvedValue({
    id: "123",
    name: "Mocked User",
  });

  const result = await userService.getUser("123");

  expect(result.name).toBe("Mocked User");
  expect(getUserSpy).toHaveBeenCalledWith("123");
});
</pre> <h2 id="module-mocks-with-mock-module"><span>Module Mocks with mock.module()</span></h2> <span data-as="p">Module mocking lets you override the behavior of a module. Use <code>mock.module(path: string, callback: () =&gt; Object)</code> to mock a module.</span> <pre numberoflines="15" language="typescript" data-language="typescript">import { test, expect, mock } from "bun:test";

mock.module("./module", () =&gt; {
  return {
    foo: "bar",
  };
});

test("mock.module", async () =&gt; {
  const esm = await import("./module");
  expect(esm.foo).toBe("bar");

  const cjs = require("./module");
  expect(cjs.foo).toBe("bar");
});
</pre> <span data-as="p">Like the rest of Bun, module mocks support both <code>import</code> and <code>require</code>.</span> <h3 id="overriding-already-imported-modules"><span>Overriding Already Imported Modules</span></h3> <span data-as="p">If you need to override a module that’s already been imported, there’s nothing special you need to do. Just call <code>mock.module()</code> and the module will be overridden.</span> <pre numberoflines="23" language="typescript" data-language="typescript">import { test, expect, mock } from "bun:test";

// The module we're going to mock is here:
import { foo } from "./module";

test("mock.module", async () =&gt; {
  const cjs = require("./module");
  expect(foo).toBe("bar");
  expect(cjs.foo).toBe("bar");

  // We update it here:
  mock.module("./module", () =&gt; {
    return {
      foo: "baz",
    };
  });

  // And the live bindings are updated.
  expect(foo).toBe("baz");

  // The module is also updated for CJS.
  expect(cjs.foo).toBe("baz");
});
</pre> <h3 id="hoisting-&amp;-preloading"><span>Hoisting &amp; Preloading</span></h3> <span data-as="p">If you need to ensure a module is mocked before it’s imported, you should use <code>--preload</code> to load your mocks before your tests run.</span> <pre numberoflines="7" language="typescript" data-language="typescript">import { mock } from "bun:test";

mock.module("./module", () =&gt; {
  return {
    foo: "bar",
  };
});
</pre> <pre numberoflines="1" language="shellscript" data-language="typescript">bun test --preload ./my-preload
</pre> <span data-as="p">To make your life easier, you can put preload in your <code>bunfig.toml</code>:</span> <pre numberoflines="3" language="toml" data-language="typescript">[test]
# Load these modules before running tests.
preload = ["./my-preload"]
</pre> <h3 id="module-mock-best-practices"><span>Module Mock Best Practices</span></h3> <h4 id="when-to-use-preload"><span>When to Use Preload</span></h4> <span data-as="p"><strong>What happens if I mock a module that’s already been imported?</strong></span> <span data-as="p">If you mock a module that’s already been imported, the module will be updated in the module cache. This means that any modules that import the module will get the mocked version, BUT the original module will still have been evaluated. That means that any side effects from the original module will still have happened.</span> <span data-as="p">If you want to prevent the original module from being evaluated, you should use <code>--preload</code> to load your mocks before your tests run.</span> <h4 id="practical-module-mock-examples"><span>Practical Module Mock Examples</span></h4> <pre numberoflines="19" language="typescript" data-language="typescript">import { test, expect, mock, beforeEach } from "bun:test";

// Mock the API client module
mock.module("./api-client", () =&gt; ({
  fetchUser: mock(async (id: string) =&gt; ({ id, name: `User ${id}` })),
  createUser: mock(async (user: any) =&gt; ({ ...user, id: "new-id" })),
  updateUser: mock(async (id: string, user: any) =&gt; ({ ...user, id })),
}));

test("user service with mocked API", async () =&gt; {
  const { fetchUser } = await import("./api-client");
  const { UserService } = await import("./user-service");

  const userService = new UserService();
  const user = await userService.getUser("123");

  expect(fetchUser).toHaveBeenCalledWith("123");
  expect(user.name).toBe("User 123");
});
</pre> <h4 id="mocking-external-dependencies"><span>Mocking External Dependencies</span></h4> <pre numberoflines="23" language="typescript" data-language="typescript">import { test, expect, mock } from "bun:test";

// Mock external database library
mock.module("pg", () =&gt; ({
  Client: mock(function () {
    return {
      connect: mock(async () =&gt; {}),
      query: mock(async (sql: string) =&gt; ({
        rows: [{ id: 1, name: "Test User" }],
      })),
      end: mock(async () =&gt; {}),
    };
  }),
}));

test("database operations", async () =&gt; {
  const { Database } = await import("./database");
  const db = new Database();

  const users = await db.getUsers();
  expect(users).toHaveLength(1);
  expect(users[0].name).toBe("Test User");
});
</pre> <h2 id="global-mock-functions"><span>Global Mock Functions</span></h2> <h3 id="clear-all-mocks"><span>Clear All Mocks</span></h3> <span data-as="p">Reset all mock function state (calls, results, etc.) without restoring their original implementation:</span> <pre numberoflines="21" language="typescript" data-language="typescript">import { expect, mock, test } from "bun:test";

const random1 = mock(() =&gt; Math.random());
const random2 = mock(() =&gt; Math.random());

test("clearing all mocks", () =&gt; {
  random1();
  random2();

  expect(random1).toHaveBeenCalledTimes(1);
  expect(random2).toHaveBeenCalledTimes(1);

  mock.clearAllMocks();

  expect(random1).toHaveBeenCalledTimes(0);
  expect(random2).toHaveBeenCalledTimes(0);

  // Note: implementations are preserved
  expect(typeof random1()).toBe("number");
  expect(typeof random2()).toBe("number");
});
</pre> <span data-as="p">This resets the <code>.mock.calls</code>, <code>.mock.instances</code>, <code>.mock.contexts</code>, and <code>.mock.results</code> properties of all mocks, but unlike <code>mock.restore()</code>, it does not restore the original implementation.</span> <h3 id="restore-all-mocks"><span>Restore All Mocks</span></h3> <span data-as="p">Instead of manually restoring each mock individually with <code>mockFn.mockRestore()</code>, restore all mocks with one command by calling <code>mock.restore()</code>. Doing so does not reset the value of modules overridden with <code>mock.module()</code>.</span> <pre numberoflines="32" language="typescript" data-language="typescript">import { expect, mock, spyOn, test } from "bun:test";

import * as fooModule from "./foo.ts";
import * as barModule from "./bar.ts";
import * as bazModule from "./baz.ts";

test("foo, bar, baz", () =&gt; {
  const fooSpy = spyOn(fooModule, "foo");
  const barSpy = spyOn(barModule, "bar");
  const bazSpy = spyOn(bazModule, "baz");

  // Original implementations still work
  expect(fooModule.foo()).toBe("foo");
  expect(barModule.bar()).toBe("bar");
  expect(bazModule.baz()).toBe("baz");

  // Mock implementations
  fooSpy.mockImplementation(() =&gt; 42);
  barSpy.mockImplementation(() =&gt; 43);
  bazSpy.mockImplementation(() =&gt; 44);

  expect(fooModule.foo()).toBe(42);
  expect(barModule.bar()).toBe(43);
  expect(bazModule.baz()).toBe(44);

  // Restore all
  mock.restore();

  expect(fooModule.foo()).toBe("foo");
  expect(barModule.bar()).toBe("bar");
  expect(bazModule.baz()).toBe("baz");
});
</pre> <span data-as="p">Using <code>mock.restore()</code> can reduce the amount of code in your tests by adding it to <code>afterEach</code> blocks in each test file or even in your test preload code.</span> <h2 id="vitest-compatibility"><span>Vitest Compatibility</span></h2> <span data-as="p">For added compatibility with tests written for Vitest, Bun provides the <code>vi</code> object as an alias for parts of the Jest mocking API:</span> <pre numberoflines="16" language="typescript" data-language="typescript">import { test, expect, vi } from "bun:test";

// Using the 'vi' alias similar to Vitest
test("vitest compatibility", () =&gt; {
  const mockFn = vi.fn(() =&gt; 42);

  mockFn();
  expect(mockFn).toHaveBeenCalled();

  // The following functions are available on the vi object:
  // vi.fn
  // vi.spyOn
  // vi.mock
  // vi.restoreAllMocks
  // vi.clearAllMocks
});
</pre> <span data-as="p">This makes it easier to port tests from Vitest to Bun without having to rewrite all your mocks.</span> <h2 id="implementation-details"><span>Implementation Details</span></h2> <span data-as="p">Understanding how <code>mock.module()</code> works helps you use it more effectively:</span> <h3 id="cache-interaction"><span>Cache Interaction</span></h3> <span data-as="p">Module mocks interact with both ESM and CommonJS module caches.</span> <h3 id="lazy-evaluation"><span>Lazy Evaluation</span></h3> <span data-as="p">The mock factory callback is only evaluated when the module is actually imported or required.</span> <h3 id="path-resolution"><span>Path Resolution</span></h3> <span data-as="p">Bun automatically resolves the module specifier as though you were doing an import, supporting:</span> <ul> <li>Relative paths (<code>'./module'</code>)</li> <li>Absolute paths (<code>'/path/to/module'</code>)</li> <li>Package names (<code>'lodash'</code>)</li> </ul> <h3 id="import-timing-effects"><span>Import Timing Effects</span></h3> <ul> <li>
<strong>When mocking before first import</strong>: No side effects from the original module occur</li> <li>
<strong>When mocking after import</strong>: The original module’s side effects have already happened</li> </ul> <span data-as="p">For this reason, using <code>--preload</code> is recommended for mocks that need to prevent side effects.</span> <h3 id="live-bindings"><span>Live Bindings</span></h3> <span data-as="p">Mocked ESM modules maintain live bindings, so changing the mock will update all existing imports.</span> <h2 id="advanced-patterns"><span>Advanced Patterns</span></h2> <h3 id="factory-functions"><span>Factory Functions</span></h3> <pre numberoflines="16" language="typescript" data-language="typescript">import { mock } from "bun:test";

function createMockUser(overrides = {}) {
  return {
    id: "mock-id",
    name: "Mock User",
    email: "mock@example.com",
    ...overrides,
  };
}

const mockUserService = {
  getUser: mock(async (id: string) =&gt; createMockUser({ id })),
  createUser: mock(async (data: any) =&gt; createMockUser(data)),
  updateUser: mock(async (id: string, data: any) =&gt; createMockUser({ id, ...data })),
};
</pre> <h3 id="conditional-mocking"><span>Conditional Mocking</span></h3> <pre numberoflines="18" language="typescript" data-language="typescript">import { test, expect, mock } from "bun:test";

const shouldUseMockApi = process.env.NODE_ENV === "test";

if (shouldUseMockApi) {
  mock.module("./api", () =&gt; ({
    fetchData: mock(async () =&gt; ({ data: "mocked" })),
  }));
}

test("conditional API usage", async () =&gt; {
  const { fetchData } = await import("./api");
  const result = await fetchData();

  if (shouldUseMockApi) {
    expect(result.data).toBe("mocked");
  }
});
</pre> <h3 id="mock-cleanup-patterns"><span>Mock Cleanup Patterns</span></h3> <pre numberoflines="16" language="typescript" data-language="typescript">import { afterEach, beforeEach } from "bun:test";

beforeEach(() =&gt; {
  // Set up common mocks
  mock.module("./logger", () =&gt; ({
    log: mock(() =&gt; {}),
    error: mock(() =&gt; {}),
    warn: mock(() =&gt; {}),
  }));
});

afterEach(() =&gt; {
  // Clean up all mocks
  mock.restore();
  mock.clearAllMocks();
});
</pre> <h2 id="best-practices"><span>Best Practices</span></h2> <h3 id="keep-mocks-simple"><span>Keep Mocks Simple</span></h3> <pre numberoflines="14" language="typescript" data-language="typescript">// Good: Simple, focused mock
const mockUserApi = {
  getUser: mock(async id =&gt; ({ id, name: "Test User" })),
};

// Avoid: Overly complex mock behavior
const complexMock = mock(input =&gt; {
  if (input.type === "A") {
    return processTypeA(input);
  } else if (input.type === "B") {
    return processTypeB(input);
  }
  // ... lots of complex logic
});
</pre> <h3 id="use-type-safe-mocks"><span>Use Type-Safe Mocks</span></h3> <pre numberoflines="9" language="typescript" data-language="typescript">interface UserService {
  getUser(id: string): Promise&lt;User&gt;;
  createUser(data: CreateUserData): Promise&lt;User&gt;;
}

const mockUserService: UserService = {
  getUser: mock(async (id: string) =&gt; ({ id, name: "Test User" })),
  createUser: mock(async data =&gt; ({ id: "new-id", ...data })),
};
</pre> <h3 id="test-mock-behavior"><span>Test Mock Behavior</span></h3> <pre numberoflines="10" language="typescript" data-language="typescript">test("service calls API correctly", async () =&gt; {
  const mockApi = { fetchUser: mock(async () =&gt; ({ id: "1" })) };

  const service = new UserService(mockApi);
  await service.getUser("123");

  // Verify the mock was called correctly
  expect(mockApi.fetchUser).toHaveBeenCalledWith("123");
  expect(mockApi.fetchUser).toHaveBeenCalledTimes(1);
});
</pre> <h2 id="notes"><span>Notes</span></h2> <h3 id="auto-mocking"><span>Auto-mocking</span></h3> <span data-as="p"><code>__mocks__</code> directory and auto-mocking are not supported yet. If this is blocking you from switching to Bun, please <a href="https://github.com/oven-sh/bun/issues" target="_blank" rel="noreferrer">file an issue</a>.</span> <h3 id="esm-vs-commonjs"><span>ESM vs CommonJS</span></h3> <span data-as="p">Module mocks have different implementations for ESM and CommonJS modules. For ES Modules, Bun has added patches to JavaScriptCore that allow Bun to override export values at runtime and update live bindings recursively.</span>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/test/mocks" class="_attribution-link">https://bun.com/docs/test/mocks</a>
  </p>
</div>
