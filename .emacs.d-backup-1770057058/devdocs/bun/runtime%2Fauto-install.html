<h1 id="header">Auto-install</h1>
<div data-page-title="Auto-install" data-page-href="/runtime/auto-install" id="content">
<span data-as="p">If no <code>node_modules</code> directory is found in the working directory or higher, Bun will abandon Node.js-style module resolution in favor of the <strong>Bun module resolution algorithm</strong>.</span> <span data-as="p">Under Bun-style module resolution, all imported packages are auto-installed on the fly into a <a href="../pm/global-cache">global module cache</a> during execution (the same cache used by <a href="../pm/cli/install"><code>bun install</code></a>).</span> <pre numberoflines="3" language="typescript" data-language="typescript">import { foo } from "foo"; // install `latest` version

foo();
</pre> <span data-as="p">The first time you run this script, Bun will auto-install <code>"foo"</code> and cache it. The next time you run the script, it will use the cached version.</span> <hr> <h2 id="version-resolution"><span>Version resolution</span></h2> <span data-as="p">To determine which version to install, Bun follows the following algorithm:</span> <ol> <li>Check for a <code>bun.lock</code> file in the project root. If it exists, use the version specified in the lockfile.</li> <li>Otherwise, scan up the tree for a <code>package.json</code> that includes <code>"foo"</code> as a dependency. If found, use the specified semver version or version range.</li> <li>Otherwise, use <code>latest</code>.</li> </ol> <hr> <h2 id="cache-behavior"><span>Cache behavior</span></h2> <span data-as="p">Once a version or version range has been determined, Bun will:</span> <ol> <li>Check the module cache for a compatible version. If one exists, use it.</li> <li>When resolving <code>latest</code>, Bun will check if <code>package@latest</code> has been downloaded and cached in the last <em>24 hours</em>. If so, use it.</li> <li>Otherwise, download and install the appropriate version from the <code>npm</code> registry.</li> </ol> <hr> <h2 id="installation"><span>Installation</span></h2> <span data-as="p">Packages are installed and cached into <code>&lt;cache&gt;/&lt;pkg&gt;@&lt;version&gt;</code>, so multiple versions of the same package can be cached at once. Additionally, a symlink is created under <code>&lt;cache&gt;/&lt;pkg&gt;/&lt;version&gt;</code> to make it faster to look up all versions of a package that exist in the cache.</span> <hr> <h2 id="version-specifiers"><span>Version specifiers</span></h2> <span data-as="p">This entire resolution algorithm can be short-circuited by specifying a version or version range directly in your import statement.</span> <pre numberoflines="3" language="typescript" data-language="typescript">import { z } from "zod@3.0.0"; // specific version
import { z } from "zod@next"; // npm tag
import { z } from "zod@^3.20.0"; // semver range
</pre> <hr> <h2 id="benefits"><span>Benefits</span></h2> <span data-as="p">This auto-installation approach is useful for a few reasons:</span> <ul> <li>
<strong>Space efficiency</strong> — Each version of a dependency only exists in one place on disk. This is a huge space and time savings compared to redundant per-project installations.</li> <li>
<strong>Portability</strong> — To share simple scripts and gists, your source file is <em>self-contained</em>. No need to <code>zip</code> together a directory containing your code and config files. With version specifiers in <code>import</code> statements, even a <code>package.json</code> isn’t necessary.</li> <li>
<strong>Convenience</strong> — There’s no need to run <code>npm install</code> or <code>bun install</code> before running a file or script. Just <code>bun run</code> it.</li> <li>
<strong>Backwards compatibility</strong> — Because Bun still respects the versions specified in <code>package.json</code> if one exists, you can switch to Bun-style resolution with a single command: <code>rm -rf node_modules</code>.</li> </ul> <hr> <h2 id="limitations"><span>Limitations</span></h2> <ul> <li>No Intellisense. TypeScript auto-completion in IDEs relies on the existence of type declaration files inside <code>node_modules</code>. We are investigating various solutions to this.</li> <li>No <a href="https://github.com/ds300/patch-package" target="_blank" rel="noreferrer">patch-package</a> support</li> </ul> <hr> <h2 id="faq"><span>FAQ</span></h2> <div>
<details><summary aria-controls="how-is-this-different-from-what-pnpm-does accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">How is this different from what pnpm does?</p></div></summary><div id="how-is-this-different-from-what-pnpm-does accordion children" role="region" aria-labelledby="how-is-this-different-from-what-pnpm-does" data-component-part="accordion-content"><span data-as="p">With pnpm, you have to run <code>pnpm install</code>, which creates a <code>node_modules</code> folder of symlinks for the runtime to resolve. By contrast, Bun resolves dependencies on the fly when you run a file; there’s no need to run any <code>install</code> command ahead of time. Bun also doesn’t create a <code>node_modules</code> folder.</span></div></details><details><summary aria-controls="how-is-this-different-from-yarn-plug-n-play-does accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">How is this different from Yarn Plug'N'Play does?</p></div></summary><div id="how-is-this-different-from-yarn-plug-n-play-does accordion children" role="region" aria-labelledby="how-is-this-different-from-yarn-plug-n-play-does" data-component-part="accordion-content">
<span data-as="p">With Yarn, you must run <code>yarn install</code> before you run a script. By contrast, Bun resolves dependencies on the fly when you run a file; there’s no need to run any <code>install</code> command ahead of time.</span><span data-as="p">Yarn Plug’N’Play also uses zip files to store dependencies. This makes dependency loading <a href="https://twitter.com/jarredsumner/status/1458207919636287490" target="_blank" rel="noreferrer">slower at runtime</a>, as random access reads on zip files tend to be slower than the equivalent disk lookup.</span>
</div></details><details><summary aria-controls="how-is-this-different-from-what-deno-does accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">How is this different from what Deno does?</p></div></summary><div id="how-is-this-different-from-what-deno-does accordion children" role="region" aria-labelledby="how-is-this-different-from-what-deno-does" data-component-part="accordion-content"><span data-as="p">Deno requires an <code>npm:</code> specifier before each npm <code>import</code>, lacks support for import maps via <code>compilerOptions.paths</code> in <code>tsconfig.json</code>, and has incomplete support for <code>package.json</code> settings. Unlike Deno, Bun does not currently support URL imports.</span></div></details>
</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/auto-install" class="_attribution-link">https://bun.com/docs/runtime/auto-install</a>
  </p>
</div>
