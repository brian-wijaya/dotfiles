<h1 id="header">Containerize a Bun application with Docker</h1>
<div data-page-title="Containerize a Bun application with Docker" data-page-href="/guides/ecosystem/docker" id="content">
<div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p">This guide assumes you already have <a href="https://www.docker.com/products/docker-desktop/" target="_blank" rel="noreferrer">Docker Desktop</a> installed.</span></div>
</div> <span data-as="p"><a href="https://www.docker.com" target="_blank" rel="noreferrer">Docker</a> is a platform for packaging and running an application as a lightweight, portable <em>container</em> that encapsulates all the necessary dependencies.</span> <hr> <span data-as="p">To <em>containerize</em> our application, we define a <code>Dockerfile</code>. This file contains a list of instructions to initialize the container, copy our local project files into it, install dependencies, and starts the application.</span> <pre numberoflines="38" language="docker" data-language="typescript"># use the official Bun image
# see all versions at https://hub.docker.com/r/oven/bun/tags
FROM oven/bun:1 AS base
WORKDIR /usr/src/app

# install dependencies into temp directory
# this will cache them and speed up future builds
FROM base AS install
RUN mkdir -p /temp/dev
COPY package.json bun.lock /temp/dev/
RUN cd /temp/dev &amp;&amp; bun install --frozen-lockfile

# install with --production (exclude devDependencies)
RUN mkdir -p /temp/prod
COPY package.json bun.lock /temp/prod/
RUN cd /temp/prod &amp;&amp; bun install --frozen-lockfile --production

# copy node_modules from temp directory
# then copy all (non-ignored) project files into the image
FROM base AS prerelease
COPY --from=install /temp/dev/node_modules node_modules
COPY . .

# [optional] tests &amp; build
ENV NODE_ENV=production
RUN bun test
RUN bun run build

# copy production dependencies and source code into final image
FROM base AS release
COPY --from=install /temp/prod/node_modules node_modules
COPY --from=prerelease /usr/src/app/index.ts .
COPY --from=prerelease /usr/src/app/package.json .

# run the app
USER bun
EXPOSE 3000/tcp
ENTRYPOINT [ "bun", "run", "index.ts" ]
</pre> <hr> <span data-as="p">Now that you have your docker image, let’s look at <code>.dockerignore</code> which has the same syntax as <code>.gitignore</code>, here you need to specify the files/directories that must not go in any stage of the docker build. An example for a ignore file is</span> <pre numberoflines="16" language="text" data-language="typescript">node_modules
Dockerfile*
docker-compose*
.dockerignore
.git
.gitignore
README.md
LICENSE
.vscode
Makefile
helm-charts
.env
.editorconfig
.idea
coverage*
</pre> <hr> <span data-as="p">We’ll now use <code>docker build</code> to convert this <code>Dockerfile</code> into a <em>Docker image</em>, a self-contained template containing all the dependencies and configuration required to run the application.</span> <span data-as="p">The <code>-t</code> flag lets us specify a name for the image, and <code>--pull</code> tells Docker to automatically download the latest version of the base image (<code>oven/bun</code>). The initial build will take longer, as Docker will download all the base images and dependencies.</span> <pre numberoflines="1" language="shellscript" data-language="typescript">docker build --pull -t bun-hello-world .
</pre> <pre numberoflines="16" language="text" data-language="typescript">[+] Building 0.9s (21/21) FINISHED
 =&gt; [internal] load build definition from Dockerfile                                                                                     0.0s
 =&gt; =&gt; transferring dockerfile: 37B                                                                                                      0.0s
 =&gt; [internal] load .dockerignore                                                                                                        0.0s
 =&gt; =&gt; transferring context: 35B                                                                                                         0.0s
 =&gt; [internal] load metadata for docker.io/oven/bun:1                                                                                    0.8s
 =&gt; [auth] oven/bun:pull token for registry-1.docker.io                                                                                  0.0s
 =&gt; [base 1/2] FROM docker.io/oven/bun:1@sha256:373265748d3cd3624cb3f3ee6004f45b1fc3edbd07a622aeeec17566d2756997                         0.0s
 =&gt; [internal] load build context                                                                                                        0.0s
 =&gt; =&gt; transferring context: 155B                                                                                                        0.0s
 # ...lots of commands...
 =&gt; exporting to image                                                                                                                   0.0s
 =&gt; =&gt; exporting layers                                                                                                                  0.0s
 =&gt; =&gt; writing image sha256:360663f7fdcd6f11e8e94761d5592e2e4dfc8d167f034f15cd5a863d5dc093c4                                             0.0s
 =&gt; =&gt; naming to docker.io/library/bun-hello-world                                                                                       0.0s
</pre> <hr> <span data-as="p">We’ve built a new <em>Docker image</em>. Now let’s use that image to spin up an actual, running <em>container</em>.</span> <span data-as="p">We’ll use <code>docker run</code> to start a new container using the <code>bun-hello-world</code> image. It will be run in <em>detached</em> mode (<code>-d</code>) and we’ll map the container’s port 3000 to our local machine’s port 3000 (<code>-p 3000:3000</code>).</span> <span data-as="p">The <code>run</code> command prints a string representing the <em>container ID</em>.</span> <pre numberoflines="1" language="shellscript" data-language="typescript">docker run -d -p 3000:3000 bun-hello-world
</pre> <pre numberoflines="2" language="text" data-language="typescript">7f03e212a15ede8644379bce11a13589f563d3909a9640446c5bbefce993678d
</pre> <hr> <span data-as="p">The container is now running in the background. Visit <a href="http://localhost:3000" target="_blank" rel="noreferrer">localhost:3000</a>. You should see a <code>Hello, World!</code> message.</span> <hr> <span data-as="p">To stop the container, we’ll use <code>docker stop &lt;container-id&gt;</code>.</span> <pre numberoflines="1" language="shellscript" data-language="typescript">docker stop 7f03e212a15ede8644379bce11a13589f563d3909a9640446c5bbefce993678d
</pre> <hr> <span data-as="p">If you can’t find the container ID, you can use <code>docker ps</code> to list all running containers.</span> <pre numberoflines="1" language="shellscript" data-language="typescript">docker ps
</pre> <pre numberoflines="3" language="text" data-language="typescript">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
7f03e212a15e        bun-hello-world     "bun run index.ts"       2 minutes ago       Up 2 minutes        0.0.0.0:3000-&gt;3000/tcp   flamboyant_cerf
</pre> <hr> <span data-as="p">That’s it! Refer to the <a href="https://docs.docker.com/" target="_blank" rel="noreferrer">Docker documentation</a> for more advanced usage.</span>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/guides/ecosystem/docker" class="_attribution-link">https://bun.com/docs/guides/ecosystem/docker</a>
  </p>
</div>
