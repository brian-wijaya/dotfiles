<h1 id="header">SQL</h1>
<div data-page-title="SQL" data-page-href="/runtime/sql" id="content">
<span data-as="p">The interface is designed to be simple and performant, using tagged template literals for queries and offering features like connection pooling, transactions, and prepared statements.</span> <pre numberoflines="22" language="typescript" data-language="typescript">import { sql, SQL } from "bun";

// PostgreSQL (default)
const users = await sql`
  SELECT * FROM users
  WHERE active = ${true}
  LIMIT ${10}
`;

// With MySQL
const mysql = new SQL("mysql://user:pass@localhost:3306/mydb");
const mysqlResults = await mysql`
  SELECT * FROM users 
  WHERE active = ${true}
`;

// With SQLite
const sqlite = new SQL("sqlite://myapp.db");
const sqliteResults = await sqlite`
  SELECT * FROM users 
  WHERE active = ${1}
`;
</pre> <h3 id="features"><span>Features</span></h3> <ul> <li>Tagged template literals to protect against SQL injection</li> <li>Transactions</li> <li>Named &amp; positional parameters</li> <li>Connection pooling</li> <li>
<code>BigInt</code> support</li> <li>SASL Auth support (SCRAM-SHA-256), MD5, and Clear Text</li> <li>Connection timeouts</li> <li>Returning rows as data objects, arrays of arrays, or Buffer</li> <li>Binary protocol support makes it faster</li> <li>TLS support (and auth mode)</li> <li>Automatic configuration with environment variable</li> </ul> <hr> <h2 id="database-support"><span>Database Support</span></h2> <span data-as="p"><code>Bun.SQL</code> provides a unified API for multiple database systems:</span> <h3 id="postgresql"><span>PostgreSQL</span></h3> <span data-as="p">PostgreSQL is used when:</span> <ul> <li>The connection string doesn’t match SQLite or MySQL patterns (it’s the fallback adapter)</li> <li>The connection string explicitly uses <code>postgres://</code> or <code>postgresql://</code> protocols</li> <li>No connection string is provided and environment variables point to PostgreSQL</li> </ul> <pre numberoflines="7" language="typescript" data-language="typescript">import { sql } from "bun";
// Uses PostgreSQL if DATABASE_URL is not set or is a PostgreSQL URL
await sql`SELECT ...`;

import { SQL } from "bun";
const pg = new SQL("postgres://user:pass@localhost:5432/mydb");
await pg`SELECT ...`;
</pre> <h3 id="mysql"><span>MySQL</span></h3> <span data-as="p">MySQL support is built into Bun.SQL, providing the same tagged template literal interface with full compatibility for MySQL 5.7+ and MySQL 8.0+:</span> <pre numberoflines="31" language="typescript" data-language="typescript">import { SQL } from "bun";

// MySQL connection
const mysql = new SQL("mysql://user:password@localhost:3306/database");
const mysql2 = new SQL("mysql2://user:password@localhost:3306/database"); // mysql2 protocol also works

// Using options object
const mysql3 = new SQL({
  adapter: "mysql",
  hostname: "localhost",
  port: 3306,
  database: "myapp",
  username: "dbuser",
  password: "secretpass",
});

// Works with parameters - automatically uses prepared statements
const users = await mysql`SELECT * FROM users WHERE id = ${userId}`;

// Transactions work the same as PostgreSQL
await mysql.begin(async tx =&gt; {
  await tx`INSERT INTO users (name) VALUES (${"Alice"})`;
  await tx`UPDATE accounts SET balance = balance - 100 WHERE user_id = ${userId}`;
});

// Bulk inserts
const newUsers = [
  { name: "Alice", email: "alice@example.com" },
  { name: "Bob", email: "bob@example.com" },
];
await mysql`INSERT INTO users ${mysql(newUsers)}`;
</pre> <details><summary aria-controls="mysql-connection-string-formats accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">MySQL Connection String Formats</p></div></summary><div id="mysql-connection-string-formats accordion children" role="region" aria-labelledby="mysql-connection-string-formats" data-component-part="accordion-content">
<span data-as="p">MySQL accepts various URL formats for connection strings:</span><pre numberoflines="12" language="typescript" data-language="typescript">// Standard mysql:// protocol
new SQL("mysql://user:pass@localhost:3306/database");
new SQL("mysql://user:pass@localhost/database"); // Default port 3306

// mysql2:// protocol (compatibility with mysql2 npm package)
new SQL("mysql2://user:pass@localhost:3306/database");

// With query parameters
new SQL("mysql://user:pass@localhost/db?ssl=true");

// Unix socket connection
new SQL("mysql://user:pass@/database?socket=/var/run/mysqld/mysqld.sock");
</pre>
</div></details> <details><summary aria-controls="mysql-specific-features accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">MySQL-Specific Features</p></div></summary><div id="mysql-specific-features accordion children" role="region" aria-labelledby="mysql-specific-features" data-component-part="accordion-content">
<span data-as="p">MySQL databases support:</span><ul> <li>
<strong>Prepared statements</strong>: Automatically created for parameterized queries with statement caching</li> <li>
<strong>Binary protocol</strong>: For better performance with prepared statements and accurate type handling</li> <li>
<strong>Multiple result sets</strong>: Support for stored procedures returning multiple result sets</li> <li>
<strong>Authentication plugins</strong>: Support for mysql_native_password, caching_sha2_password (MySQL 8.0 default), and sha256_password</li> <li>
<strong>SSL/TLS connections</strong>: Configurable SSL modes similar to PostgreSQL</li> <li>
<strong>Connection attributes</strong>: Client information sent to server for monitoring</li> <li>
<strong>Query pipelining</strong>: Execute multiple prepared statements without waiting for responses</li> </ul>
</div></details> <h3 id="sqlite"><span>SQLite</span></h3> <span data-as="p">SQLite support is built into Bun.SQL, providing the same tagged template literal interface:</span> <pre numberoflines="17" language="typescript" data-language="typescript">import { SQL } from "bun";

// In-memory database
const memory = new SQL(":memory:");
const memory2 = new SQL("sqlite://:memory:");

// File-based database
const sql1 = new SQL("sqlite://myapp.db");

// Using options object
const sql2 = new SQL({
  adapter: "sqlite",
  filename: "./data/app.db",
});

// For simple filenames, specify adapter explicitly
const sql3 = new SQL("myapp.db", { adapter: "sqlite" });
</pre> <details><summary aria-controls="sqlite-connection-string-formats accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">SQLite Connection String Formats</p></div></summary><div id="sqlite-connection-string-formats accordion children" role="region" aria-labelledby="sqlite-connection-string-formats" data-component-part="accordion-content">
<span data-as="p">SQLite accepts various URL formats for connection strings:</span><pre numberoflines="22" language="typescript" data-language="typescript">// Standard sqlite:// protocol
new SQL("sqlite://path/to/database.db");
new SQL("sqlite:path/to/database.db"); // Without slashes

// file:// protocol (also recognized as SQLite)
new SQL("file://path/to/database.db");
new SQL("file:path/to/database.db");

// Special :memory: database
new SQL(":memory:");
new SQL("sqlite://:memory:");
new SQL("file://:memory:");

// Relative and absolute paths
new SQL("sqlite://./local.db"); // Relative to current directory
new SQL("sqlite://../parent/db.db"); // Parent directory
new SQL("sqlite:///absolute/path.db"); // Absolute path

// With query parameters
new SQL("sqlite://data.db?mode=ro"); // Read-only mode
new SQL("sqlite://data.db?mode=rw"); // Read-write mode (no create)
new SQL("sqlite://data.db?mode=rwc"); // Read-write-create mode (default)
</pre>
<div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p">Simple filenames without a protocol (like <code>"myapp.db"</code>) require explicitly specifying <code>{ adapter: "sqlite" }</code> to avoid ambiguity with PostgreSQL.</span></div>
</div>
</div></details> <details><summary aria-controls="sqlite-specific-options accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">SQLite-Specific Options</p></div></summary><div id="sqlite-specific-options accordion children" role="region" aria-labelledby="sqlite-specific-options" data-component-part="accordion-content">
<span data-as="p">SQLite databases support additional configuration options:</span><pre numberoflines="13" language="typescript" data-language="typescript">const sql = new SQL({
  adapter: "sqlite",
  filename: "app.db",

  // SQLite-specific options
  readonly: false, // Open in read-only mode
  create: true, // Create database if it doesn't exist
  readwrite: true, // Open for reading and writing

  // Additional Bun:sqlite options
  strict: true, // Enable strict mode
  safeIntegers: false, // Use JavaScript numbers for integers
});
</pre>
<span data-as="p">Query parameters in the URL are parsed to set these options:</span><ul> <li>
<code>?mode=ro</code> → <code>readonly: true</code>
</li> <li>
<code>?mode=rw</code> → <code>readonly: false, create: false</code>
</li> <li>
<code>?mode=rwc</code> → <code>readonly: false, create: true</code> (default)</li> </ul>
</div></details> <h2 id="inserting-data"><span>Inserting data</span></h2> <span data-as="p">You can pass JavaScript values directly to the SQL template literal and escaping will be handled for you.</span> <pre numberoflines="20" language="typescript" data-language="typescript">import { sql } from "bun";

// Basic insert with direct values
const [user] = await sql`
  INSERT INTO users (name, email) 
  VALUES (${name}, ${email})
  RETURNING *
`;

// Using object helper for cleaner syntax
const userData = {
  name: "Alice",
  email: "alice@example.com",
};

const [newUser] = await sql`
  INSERT INTO users ${sql(userData)}
  RETURNING *
`;
// Expands to: INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com')
</pre> <h3 id="bulk-insert"><span>Bulk Insert</span></h3> <span data-as="p">You can also pass arrays of objects to the SQL template literal and it will be expanded to a <code>INSERT INTO ... VALUES ...</code> statement.</span> <pre numberoflines="7" language="typescript" data-language="typescript">const users = [
  { name: "Alice", email: "alice@example.com" },
  { name: "Bob", email: "bob@example.com" },
  { name: "Charlie", email: "charlie@example.com" },
];

await sql`INSERT INTO users ${sql(users)}`;
</pre> <h3 id="picking-columns-to-insert"><span>Picking columns to insert</span></h3> <span data-as="p">You can use <code>sql(object, ...string)</code> to pick which columns to insert. Each of the columns must be defined on the object.</span> <pre numberoflines="8" language="typescript" data-language="typescript">const user = {
  name: "Alice",
  email: "alice@example.com",
  age: 25,
};

await sql`INSERT INTO users ${sql(user, "name", "email")}`;
// Only inserts name and email columns, ignoring other fields
</pre> <hr> <h2 id="query-results"><span>Query Results</span></h2> <span data-as="p">By default, Bun’s SQL client returns query results as arrays of objects, where each object represents a row with column names as keys. However, there are cases where you might want the data in a different format. The client provides two additional methods for this purpose.</span> <h3 id="sql``-values-format"><span><code>sql``.values()</code> format</span></h3> <span data-as="p">The <code>sql``.values()</code> method returns rows as arrays of values rather than objects. Each row becomes an array where the values are in the same order as the columns in your query.</span> <pre numberoflines="2" language="typescript" data-language="typescript">const rows = await sql`SELECT * FROM users`.values();
console.log(rows);
</pre> <span data-as="p">This returns something like:</span> <pre numberoflines="4" language="typescript" data-language="typescript">[
  ["Alice", "alice@example.com"],
  ["Bob", "bob@example.com"],
];
</pre> <span data-as="p"><code>sql``.values()</code> is especially useful if duplicate column names are returned in the query results. When using objects (the default), the last column name is used as the key in the object, which means duplicate column names overwrite each other — but when using <code>sql``.values()</code>, each column is present in the array so you can access the values of duplicate columns by index.</span> <h3 id="sql``-raw-format"><span><code>sql``.raw()</code> format</span></h3> <span data-as="p">The <code>.raw()</code> method returns rows as arrays of <code>Buffer</code> objects. This can be useful for working with binary data or for performance reasons.</span> <pre numberoflines="2" language="typescript" data-language="typescript">const rows = await sql`SELECT * FROM users`.raw();
console.log(rows); // [[Buffer, Buffer], [Buffer, Buffer], [Buffer, Buffer]]
</pre> <hr> <h2 id="sql-fragments"><span>SQL Fragments</span></h2> <span data-as="p">A common need in database applications is the ability to construct queries dynamically based on runtime conditions. Bun provides safe ways to do this without risking SQL injection.</span> <h3 id="dynamic-table-names"><span>Dynamic Table Names</span></h3> <span data-as="p">When you need to reference tables or schemas dynamically, use the <code>sql()</code> helper to ensure proper escaping:</span> <pre numberoflines="5" language="typescript" data-language="typescript">// Safely reference tables dynamically
await sql`SELECT * FROM ${sql("users")}`;

// With schema qualification
await sql`SELECT * FROM ${sql("public.users")}`;
</pre> <h3 id="conditional-queries"><span>Conditional Queries</span></h3> <span data-as="p">You can use the <code>sql()</code> helper to build queries with conditional clauses. This allows you to create flexible queries that adapt to your application’s needs:</span> <pre numberoflines="9" language="typescript" data-language="typescript">// Optional WHERE clauses
const filterAge = true;
const minAge = 21;
const ageFilter = sql`AND age &gt; ${minAge}`;
await sql`
  SELECT * FROM users
  WHERE active = ${true}
  ${filterAge ? ageFilter : sql``}
`;
</pre> <h3 id="dynamic-columns-in-updates"><span>Dynamic columns in updates</span></h3> <span data-as="p">You can use <code>sql(object, ...string)</code> to pick which columns to update. Each of the columns must be defined on the object. If the columns are not informed all keys will be used to update the row.</span> <pre numberoflines="3" language="typescript" data-language="typescript">await sql`UPDATE users SET ${sql(user, "name", "email")} WHERE id = ${user.id}`;
// uses all keys from the object to update the row
await sql`UPDATE users SET ${sql(user)} WHERE id = ${user.id}`;
</pre> <h3 id="dynamic-values-and-where-in"><span>Dynamic values and <code>where in</code></span></h3> <span data-as="p">Value lists can also be created dynamically, making where in queries simple too. Optionally you can pass a array of objects and inform what key to use to create the list.</span> <pre numberoflines="8" language="typescript" data-language="typescript">await sql`SELECT * FROM users WHERE id IN ${sql([1, 2, 3])}`;

const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 3, name: "Charlie" },
];
await sql`SELECT * FROM users WHERE id IN ${sql(users, "id")}`;
</pre> <h3 id="sql-array-helper"><span><code>sql.array</code> helper</span></h3> <span data-as="p">The <code>sql.array</code> helper creates PostgreSQL array literals from JavaScript arrays:</span> <pre numberoflines="7" language="typescript" data-language="typescript">// Create array literals for PostgreSQL
await sql`INSERT INTO tags (items) VALUES (${sql.array(["red", "blue", "green"])})`;
// Generates: INSERT INTO tags (items) VALUES (ARRAY['red', 'blue', 'green'])

// Works with numeric arrays too
await sql`SELECT * FROM products WHERE ids = ANY(${sql.array([1, 2, 3])})`;
// Generates: SELECT * FROM products WHERE ids = ANY(ARRAY[1, 2, 3])
</pre> <div data-callout-type="note">

<div data-component-part="callout-content">
<code>sql.array</code> is PostgreSQL-only. Multi-dimensional arrays and NULL elements may not be supported yet.</div>
</div> <hr> <h2 id="sql``-simple"><span><code>sql``.simple()</code></span></h2> <span data-as="p">The PostgreSQL wire protocol supports two types of queries: “simple” and “extended”. Simple queries can contain multiple statements but don’t support parameters, while extended queries (the default) support parameters but only allow one statement.</span> <span data-as="p">To run multiple statements in a single query, use <code>sql``.simple()</code>:</span> <pre numberoflines="5" language="typescript" data-language="typescript">// Multiple statements in one query
await sql`
  SELECT 1;
  SELECT 2;
`.simple();
</pre> <span data-as="p">Simple queries are often useful for database migrations and setup scripts.</span> <span data-as="p">Note that simple queries cannot use parameters (<code>${value}</code>). If you need parameters, you must split your query into separate statements.</span> <h3 id="queries-in-files"><span>Queries in files</span></h3> <span data-as="p">You can use the <code>sql.file</code> method to read a query from a file and execute it, if the file includes <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">1, </annotation></semantics></math></span><span aria-hidden="true"><span><span>1</span><span>,</span></span></span></span>2, etc you can pass parameters to the query. If no parameters are used it can execute multiple commands per file.</span> <pre numberoflines="1" language="typescript" data-language="typescript">const result = await sql.file("query.sql", [1, 2, 3]);
</pre> <h3 id="unsafe-queries"><span>Unsafe Queries</span></h3> <span data-as="p">You can use the <code>sql.unsafe</code> function to execute raw SQL strings. Use this with caution, as it will not escape user input. Executing more than one command per query is allowed if no parameters are used.</span> <pre numberoflines="8" language="typescript" data-language="typescript">// Multiple commands without parameters
const result = await sql.unsafe(`
  SELECT ${userColumns} FROM users;
  SELECT ${accountColumns} FROM accounts;
`);

// Using parameters (only one command is allowed)
const result = await sql.unsafe("SELECT " + dangerous + " FROM users WHERE id = $1", [id]);
</pre> <h3 id="execute-and-cancelling-queries"><span>Execute and Cancelling Queries</span></h3> <span data-as="p">Bun’s SQL is lazy, which means it will only start executing when awaited or executed with <code>.execute()</code>. You can cancel a query that is currently executing by calling the <code>cancel()</code> method on the query object.</span> <pre numberoflines="3" language="typescript" data-language="typescript">const query = sql`SELECT * FROM users`.execute();
setTimeout(() =&gt; query.cancel(), 100);
await query;
</pre> <hr> <h2 id="database-environment-variables"><span>Database Environment Variables</span></h2> <span data-as="p"><code>sql</code> connection parameters can be configured using environment variables. The client checks these variables in a specific order of precedence and automatically detects the database type based on the connection string format.</span> <h3 id="automatic-database-detection"><span>Automatic Database Detection</span></h3> <span data-as="p">When using <code>Bun.sql()</code> without arguments or <code>new SQL()</code> with a connection string, the adapter is automatically detected based on the URL format:</span> <h4 id="mysql-auto-detection"><span>MySQL Auto-Detection</span></h4> <span data-as="p">MySQL is automatically selected when the connection string matches these patterns:</span> <ul> <li>
<code>mysql://...</code> - MySQL protocol URLs</li> <li>
<code>mysql2://...</code> - MySQL2 protocol URLs (compatibility alias)</li> </ul> <pre numberoflines="7" language="typescript" data-language="typescript">// These all use MySQL automatically (no adapter needed)
const sql1 = new SQL("mysql://user:pass@localhost/mydb");
const sql2 = new SQL("mysql2://user:pass@localhost:3306/mydb");

// Works with DATABASE_URL environment variable
DATABASE_URL="mysql://user:pass@localhost/mydb" bun run app.js
DATABASE_URL="mysql2://user:pass@localhost:3306/mydb" bun run app.js
</pre> <h4 id="sqlite-auto-detection"><span>SQLite Auto-Detection</span></h4> <span data-as="p">SQLite is automatically selected when the connection string matches these patterns:</span> <ul> <li>
<code>:memory:</code> - In-memory database</li> <li>
<code>sqlite://...</code> - SQLite protocol URLs</li> <li>
<code>sqlite:...</code> - SQLite protocol without slashes</li> <li>
<code>file://...</code> - File protocol URLs</li> <li>
<code>file:...</code> - File protocol without slashes</li> </ul> <pre numberoflines="9" language="typescript" data-language="typescript">// These all use SQLite automatically (no adapter needed)
const sql1 = new SQL(":memory:");
const sql2 = new SQL("sqlite://app.db");
const sql3 = new SQL("file://./database.db");

// Works with DATABASE_URL environment variable
DATABASE_URL=":memory:" bun run app.js
DATABASE_URL="sqlite://myapp.db" bun run app.js
DATABASE_URL="file://./data/app.db" bun run app.js
</pre> <h4 id="postgresql-auto-detection"><span>PostgreSQL Auto-Detection</span></h4> <span data-as="p">PostgreSQL is the default for connection strings that don’t match MySQL or SQLite patterns:</span> <pre numberoflines="6" language="shellscript" data-language="typescript"># PostgreSQL is detected for these patterns
DATABASE_URL="postgres://user:pass@localhost:5432/mydb" bun run app.js
DATABASE_URL="postgresql://user:pass@localhost:5432/mydb" bun run app.js

# Or any URL that doesn't match MySQL or SQLite patterns
DATABASE_URL="localhost:5432/mydb" bun run app.js
</pre> <h3 id="mysql-environment-variables"><span>MySQL Environment Variables</span></h3> <span data-as="p">MySQL connections can be configured via environment variables:</span> <pre numberoflines="6" language="shellscript" data-language="typescript"># Primary connection URL (checked first)
MYSQL_URL="mysql://user:pass@localhost:3306/mydb"

# Alternative: DATABASE_URL with MySQL protocol
DATABASE_URL="mysql://user:pass@localhost:3306/mydb"
DATABASE_URL="mysql2://user:pass@localhost:3306/mydb"
</pre> <span data-as="p">If no connection URL is provided, MySQL checks these individual parameters:</span> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Environment Variable</th>
<th>Default Value</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code>MYSQL_HOST</code></td>
<td><code>localhost</code></td>
<td>Database host</td>
</tr>
<tr>
<td><code>MYSQL_PORT</code></td>
<td data-numeric="true"><code>3306</code></td>
<td>Database port</td>
</tr>
<tr>
<td><code>MYSQL_USER</code></td>
<td><code>root</code></td>
<td>Database user</td>
</tr>
<tr>
<td><code>MYSQL_PASSWORD</code></td>
<td>(empty)</td>
<td>Database password</td>
</tr>
<tr>
<td><code>MYSQL_DATABASE</code></td>
<td><code>mysql</code></td>
<td>Database name</td>
</tr>
<tr>
<td><code>MYSQL_URL</code></td>
<td>(empty)</td>
<td>Primary connection URL for MySQL</td>
</tr>
<tr>
<td><code>TLS_MYSQL_DATABASE_URL</code></td>
<td>(empty)</td>
<td>SSL/TLS-enabled connection URL</td>
</tr>
</tbody>
</table></div></div> <h3 id="postgresql-environment-variables"><span>PostgreSQL Environment Variables</span></h3> <span data-as="p">The following environment variables can be used to define the PostgreSQL connection:</span> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Environment Variable</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code>POSTGRES_URL</code></td>
<td>Primary connection URL for PostgreSQL</td>
</tr>
<tr>
<td><code>DATABASE_URL</code></td>
<td>Alternative connection URL (auto-detected)</td>
</tr>
<tr>
<td><code>PGURL</code></td>
<td>Alternative connection URL</td>
</tr>
<tr>
<td><code>PG_URL</code></td>
<td>Alternative connection URL</td>
</tr>
<tr>
<td><code>TLS_POSTGRES_DATABASE_URL</code></td>
<td>SSL/TLS-enabled connection URL</td>
</tr>
<tr>
<td><code>TLS_DATABASE_URL</code></td>
<td>Alternative SSL/TLS-enabled connection URL</td>
</tr>
</tbody>
</table></div></div> <span data-as="p">If no connection URL is provided, the system checks for the following individual parameters:</span> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Environment Variable</th>
<th>Fallback Variables</th>
<th>Default Value</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code>PGHOST</code></td>
<td data-numeric="true">-</td>
<td><code>localhost</code></td>
<td>Database host</td>
</tr>
<tr>
<td><code>PGPORT</code></td>
<td data-numeric="true">-</td>
<td data-numeric="true"><code>5432</code></td>
<td>Database port</td>
</tr>
<tr>
<td><code>PGUSERNAME</code></td>
<td>
<code>PGUSER</code>, <code>USER</code>, <code>USERNAME</code>
</td>
<td><code>postgres</code></td>
<td>Database user</td>
</tr>
<tr>
<td><code>PGPASSWORD</code></td>
<td data-numeric="true">-</td>
<td>(empty)</td>
<td>Database password</td>
</tr>
<tr>
<td><code>PGDATABASE</code></td>
<td data-numeric="true">-</td>
<td>username</td>
<td>Database name</td>
</tr>
</tbody>
</table></div></div> <h3 id="sqlite-environment-variables"><span>SQLite Environment Variables</span></h3> <span data-as="p">SQLite connections can be configured via <code>DATABASE_URL</code> when it contains a SQLite-compatible URL:</span> <pre numberoflines="4" language="shellscript" data-language="typescript"># These are all recognized as SQLite
DATABASE_URL=":memory:"
DATABASE_URL="sqlite://./app.db"
DATABASE_URL="file:///absolute/path/to/db.sqlite"
</pre> <span data-as="p"><strong>Note:</strong> PostgreSQL-specific environment variables (<code>POSTGRES_URL</code>, <code>PGHOST</code>, etc.) are ignored when using SQLite.</span> <hr> <h2 id="runtime-preconnection"><span>Runtime Preconnection</span></h2> <span data-as="p">Bun can preconnect to PostgreSQL at startup to improve performance by establishing database connections before your application code runs. This is useful for reducing connection latency on the first database query.</span> <pre numberoflines="8" language="shellscript" data-language="typescript"># Enable PostgreSQL preconnection
bun --sql-preconnect index.js

# Works with DATABASE_URL environment variable
DATABASE_URL=postgres://user:pass@localhost:5432/db bun --sql-preconnect index.js

# Can be combined with other runtime flags
bun --sql-preconnect --hot index.js
</pre> <span data-as="p">The <code>--sql-preconnect</code> flag will automatically establish a PostgreSQL connection using your configured environment variables at startup. If the connection fails, it won’t crash your application - the error will be handled gracefully.</span> <hr> <h2 id="connection-options"><span>Connection Options</span></h2> <span data-as="p">You can configure your database connection manually by passing options to the SQL constructor. Options vary depending on the database adapter:</span> <h3 id="mysql-options"><span>MySQL Options</span></h3> <pre numberoflines="43" language="typescript" data-language="typescript">import { SQL } from "bun";

const sql = new SQL({
  // Required for MySQL when using options object
  adapter: "mysql",

  // Connection details
  hostname: "localhost",
  port: 3306,
  database: "myapp",
  username: "dbuser",
  password: "secretpass",

  // Unix socket connection (alternative to hostname/port)
  // socket: "/var/run/mysqld/mysqld.sock",

  // Connection pool settings
  max: 20, // Maximum connections in pool (default: 10)
  idleTimeout: 30, // Close idle connections after 30s
  maxLifetime: 0, // Connection lifetime in seconds (0 = forever)
  connectionTimeout: 30, // Timeout when establishing new connections

  // SSL/TLS options
  ssl: "prefer", // or "disable", "require", "verify-ca", "verify-full"
  // tls: {
  //   rejectUnauthorized: true,
  //   ca: "path/to/ca.pem",
  //   key: "path/to/key.pem",
  //   cert: "path/to/cert.pem",
  // },

  // Callbacks
  onconnect: client =&gt; {
    console.log("Connected to MySQL");
  },
  onclose: (client, err) =&gt; {
    if (err) {
      console.error("MySQL connection error:", err);
    } else {
      console.log("MySQL connection closed");
    }
  },
});
</pre> <h3 id="postgresql-options"><span>PostgreSQL Options</span></h3> <pre numberoflines="40" language="typescript" data-language="typescript">import { SQL } from "bun";

const sql = new SQL({
  // Connection details (adapter is auto-detected as PostgreSQL)
  url: "postgres://user:pass@localhost:5432/dbname",

  // Alternative connection parameters
  hostname: "localhost",
  port: 5432,
  database: "myapp",
  username: "dbuser",
  password: "secretpass",

  // Connection pool settings
  max: 20, // Maximum connections in pool
  idleTimeout: 30, // Close idle connections after 30s
  maxLifetime: 0, // Connection lifetime in seconds (0 = forever)
  connectionTimeout: 30, // Timeout when establishing new connections

  // SSL/TLS options
  tls: true,
  // tls: {
  //   rejectUnauthorized: true,
  //   requestCert: true,
  //   ca: "path/to/ca.pem",
  //   key: "path/to/key.pem",
  //   cert: "path/to/cert.pem",
  //   checkServerIdentity(hostname, cert) {
  //     ...
  //   },
  // },

  // Callbacks
  onconnect: client =&gt; {
    console.log("Connected to PostgreSQL");
  },
  onclose: client =&gt; {
    console.log("PostgreSQL connection closed");
  },
});
</pre> <h3 id="sqlite-options"><span>SQLite Options</span></h3> <pre numberoflines="24" language="typescript" data-language="typescript">import { SQL } from "bun";

const sql = new SQL({
  // Required for SQLite
  adapter: "sqlite",
  filename: "./data/app.db", // or ":memory:" for in-memory database

  // SQLite-specific access modes
  readonly: false, // Open in read-only mode
  create: true, // Create database if it doesn't exist
  readwrite: true, // Allow read and write operations

  // SQLite data handling
  strict: true, // Enable strict mode for better type safety
  safeIntegers: false, // Use BigInt for integers exceeding JS number range

  // Callbacks
  onconnect: client =&gt; {
    console.log("SQLite database opened");
  },
  onclose: client =&gt; {
    console.log("SQLite database closed");
  },
});
</pre> <details><summary aria-controls="sqlite-connection-notes accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">SQLite Connection Notes</p></div></summary><div id="sqlite-connection-notes accordion children" role="region" aria-labelledby="sqlite-connection-notes" data-component-part="accordion-content"><ul> <li>
<strong>Connection Pooling</strong>: SQLite doesn’t use connection pooling as it’s a file-based database. Each <code>SQL</code> instance represents a single connection.</li> <li>
<strong>Transactions</strong>: SQLite supports nested transactions through savepoints, similar to PostgreSQL.</li> <li>
<strong>Concurrent Access</strong>: SQLite handles concurrent access through file locking. Use WAL mode for better concurrency.</li> <li>
<strong>Memory Databases</strong>: Using <code>:memory:</code> creates a temporary database that exists only for the connection lifetime.</li> </ul></div></details> <hr> <h2 id="dynamic-passwords"><span>Dynamic passwords</span></h2> <span data-as="p">When clients need to use alternative authentication schemes such as access tokens or connections to databases with rotating passwords, provide either a synchronous or asynchronous function that will resolve the dynamic password value at connection time.</span> <pre numberoflines="8" language="typescript" data-language="typescript">import { SQL } from "bun";

const sql = new SQL(url, {
  // Other connection config
  ...
  // Password function for the database user
  password: async () =&gt; await signer.getAuthToken(),
});
</pre> <hr> <h2 id="sqlite-specific-features"><span>SQLite-Specific Features</span></h2> <h3 id="query-execution"><span>Query Execution</span></h3> <span data-as="p">SQLite executes queries synchronously, unlike PostgreSQL which uses asynchronous I/O. However, the API remains consistent using Promises:</span> <pre numberoflines="7" language="typescript" data-language="typescript">const sqlite = new SQL("sqlite://app.db");

// Works the same as PostgreSQL, but executes synchronously under the hood
const users = await sqlite`SELECT * FROM users`;

// Parameters work identically
const user = await sqlite`SELECT * FROM users WHERE id = ${userId}`;
</pre> <h3 id="sqlite-pragmas"><span>SQLite Pragmas</span></h3> <span data-as="p">You can use PRAGMA statements to configure SQLite behavior:</span> <pre numberoflines="10" language="typescript" data-language="typescript">const sqlite = new SQL("sqlite://app.db");

// Enable foreign keys
await sqlite`PRAGMA foreign_keys = ON`;

// Set journal mode to WAL for better concurrency
await sqlite`PRAGMA journal_mode = WAL`;

// Check integrity
const integrity = await sqlite`PRAGMA integrity_check`;
</pre> <h3 id="data-type-differences"><span>Data Type Differences</span></h3> <span data-as="p">SQLite has a more flexible type system than PostgreSQL:</span> <pre numberoflines="15" language="typescript" data-language="typescript">// SQLite stores data in 5 storage classes: NULL, INTEGER, REAL, TEXT, BLOB
const sqlite = new SQL("sqlite://app.db");

// SQLite is more lenient with types
await sqlite`
  CREATE TABLE flexible (
    id INTEGER PRIMARY KEY,
    data TEXT,        -- Can store numbers as strings
    value NUMERIC,    -- Can store integers, reals, or text
    blob BLOB         -- Binary data
  )
`;

// JavaScript values are automatically converted
await sqlite`INSERT INTO flexible VALUES (${1}, ${"text"}, ${123.45}, ${Buffer.from("binary")})`;
</pre> <hr> <h2 id="transactions"><span>Transactions</span></h2> <span data-as="p">To start a new transaction, use <code>sql.begin</code>. This method works for both PostgreSQL and SQLite. For PostgreSQL, it reserves a dedicated connection from the pool. For SQLite, it begins a transaction on the single connection.</span> <span data-as="p">The <code>BEGIN</code> command is sent automatically, including any optional configurations you specify. If an error occurs during the transaction, a <code>ROLLBACK</code> is triggered to ensure the process continues smoothly.</span> <h3 id="basic-transactions"><span>Basic Transactions</span></h3> <pre numberoflines="8" language="typescript" data-language="typescript">await sql.begin(async tx =&gt; {
  // All queries in this function run in a transaction
  await tx`INSERT INTO users (name) VALUES (${"Alice"})`;
  await tx`UPDATE accounts SET balance = balance - 100 WHERE user_id = 1`;

  // Transaction automatically commits if no errors are thrown
  // Rolls back if any error occurs
});
</pre> <span data-as="p">It’s also possible to pipeline the requests in a transaction if needed by returning an array with queries from the callback function like this:</span> <pre numberoflines="6" language="typescript" data-language="typescript">await sql.begin(async tx =&gt; {
  return [
    tx`INSERT INTO users (name) VALUES (${"Alice"})`,
    tx`UPDATE accounts SET balance = balance - 100 WHERE user_id = 1`,
  ];
});
</pre> <h3 id="savepoints"><span>Savepoints</span></h3> <span data-as="p">Savepoints in SQL create intermediate checkpoints within a transaction, enabling partial rollbacks without affecting the entire operation. They are useful in complex transactions, allowing error recovery and maintaining consistent results.</span> <pre numberoflines="14" language="typescript" data-language="typescript">await sql.begin(async tx =&gt; {
  await tx`INSERT INTO users (name) VALUES (${"Alice"})`;

  await tx.savepoint(async sp =&gt; {
    // This part can be rolled back separately
    await sp`UPDATE users SET status = 'active'`;
    if (someCondition) {
      throw new Error("Rollback to savepoint");
    }
  });

  // Continue with transaction even if savepoint rolled back
  await tx`INSERT INTO audit_log (action) VALUES ('user_created')`;
});
</pre> <h3 id="distributed-transactions"><span>Distributed Transactions</span></h3> <span data-as="p">Two-Phase Commit (2PC) is a distributed transaction protocol where Phase 1 has the coordinator preparing nodes by ensuring data is written and ready to commit, while Phase 2 finalizes with nodes either committing or rolling back based on the coordinator’s decision. This process ensures data durability and proper lock management.</span> <span data-as="p">In PostgreSQL and MySQL, distributed transactions persist beyond their original session, allowing privileged users or coordinators to commit or rollback them later. This supports robust distributed transactions, recovery processes, and administrative operations.</span> <span data-as="p">Each database system implements distributed transactions differently:</span> <span data-as="p">PostgreSQL natively supports them through prepared transactions, while MySQL uses XA Transactions.</span> <span data-as="p">If any exceptions occur during the distributed transaction and aren’t caught, the system will automatically rollback all changes. When everything proceeds normally, you maintain the flexibility to either commit or rollback the transaction later.</span> <pre numberoflines="9" language="typescript" data-language="typescript">// Begin a distributed transaction
await sql.beginDistributed("tx1", async tx =&gt; {
  await tx`INSERT INTO users (name) VALUES (${"Alice"})`;
});

// Later, commit or rollback
await sql.commitDistributed("tx1");
// or
await sql.rollbackDistributed("tx1");
</pre> <hr> <h2 id="authentication"><span>Authentication</span></h2> <span data-as="p">Bun supports SCRAM-SHA-256 (SASL), MD5, and Clear Text authentication. SASL is recommended for better security. Check <a href="https://www.postgresql.org/docs/current/sasl-authentication.html" target="_blank" rel="noreferrer">Postgres SASL Authentication</a> for more information.</span> <h3 id="ssl-modes-overview"><span>SSL Modes Overview</span></h3> <span data-as="p">PostgreSQL supports different SSL/TLS modes to control how secure connections are established. These modes determine the behavior when connecting and the level of certificate verification performed.</span> <pre numberoflines="6" language="typescript" data-language="typescript">const sql = new SQL({
  hostname: "localhost",
  username: "user",
  password: "password",
  ssl: "disable", // | "prefer" | "require" | "verify-ca" | "verify-full"
});
</pre> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>SSL Mode</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code>disable</code></td>
<td>No SSL/TLS used. Connections fail if server requires SSL.</td>
</tr>
<tr>
<td><code>prefer</code></td>
<td>Tries SSL first, falls back to non-SSL if SSL fails. Default mode if none specified.</td>
</tr>
<tr>
<td><code>require</code></td>
<td>Requires SSL without certificate verification. Fails if SSL cannot be established.</td>
</tr>
<tr>
<td><code>verify-ca</code></td>
<td>Verifies server certificate is signed by trusted CA. Fails if verification fails.</td>
</tr>
<tr>
<td><code>verify-full</code></td>
<td>Most secure mode. Verifies certificate and hostname match. Protects against untrusted certificates and MITM attacks.</td>
</tr>
</tbody>
</table></div></div> <h3 id="using-with-connection-strings"><span>Using With Connection Strings</span></h3> <span data-as="p">The SSL mode can also be specified in connection strings:</span> <pre numberoflines="5" language="typescript" data-language="typescript">// Using prefer mode
const sql = new SQL("postgres://user:password@localhost/mydb?sslmode=prefer");

// Using verify-full mode
const sql = new SQL("postgres://user:password@localhost/mydb?sslmode=verify-full");
</pre> <hr> <h2 id="connection-pooling"><span>Connection Pooling</span></h2> <span data-as="p">Bun’s SQL client automatically manages a connection pool, which is a pool of database connections that are reused for multiple queries. This helps to reduce the overhead of establishing and closing connections for each query, and it also helps to manage the number of concurrent connections to the database.</span> <pre numberoflines="7" language="typescript" data-language="typescript">const sql = new SQL({
  // Pool configuration
  max: 20, // Maximum 20 concurrent connections
  idleTimeout: 30, // Close idle connections after 30s
  maxLifetime: 3600, // Max connection lifetime 1 hour
  connectionTimeout: 10, // Connection timeout 10s
});
</pre> <span data-as="p">No connection will be made until a query is made.</span> <pre numberoflines="14" language="typescript" data-language="typescript">const sql = Bun.SQL(); // no connection are created

await sql`...`; // pool is started until max is reached (if possible), first available connection is used
await sql`...`; // previous connection is reused

// two connections are used now at the same time
await Promise.all([
  sql`INSERT INTO users ${sql({ name: "Alice" })}`,
  sql`UPDATE users SET name = ${user.name} WHERE id = ${user.id}`,
]);

await sql.close(); // await all queries to finish and close all connections from the pool
await sql.close({ timeout: 5 }); // wait 5 seconds and close all connections from the pool
await sql.close({ timeout: 0 }); // close all connections from the pool immediately
</pre> <hr> <h2 id="reserved-connections"><span>Reserved Connections</span></h2> <span data-as="p">Bun enables you to reserve a connection from the pool, and returns a client that wraps the single connection. This can be used for running queries on an isolated connection.</span> <pre numberoflines="15" language="typescript" data-language="typescript">// Get exclusive connection from pool
const reserved = await sql.reserve();

try {
  await reserved`INSERT INTO users (name) VALUES (${"Alice"})`;
} finally {
  // Important: Release connection back to pool
  reserved.release();
}

// Or using Symbol.dispose
{
  using reserved = await sql.reserve();
  await reserved`SELECT 1`;
} // Automatically released
</pre> <hr> <h2 id="prepared-statements"><span>Prepared Statements</span></h2> <span data-as="p">By default, Bun’s SQL client automatically creates named prepared statements for queries where it can be inferred that the query is static. This provides better performance. However, you can change this behavior by setting <code>prepare: false</code> in the connection options:</span> <pre numberoflines="4" language="typescript" data-language="typescript">const sql = new SQL({
  // ... other options ...
  prepare: false, // Disable persisting named prepared statements on the server
});
</pre> <span data-as="p">When <code>prepare: false</code> is set:</span> <span data-as="p">Queries are still executed using the “extended” protocol, but they are executed using <a href="https://www.postgresql.org/docs/current/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY" target="_blank" rel="noreferrer">unnamed prepared statements</a>, an unnamed prepared statement lasts only until the next Parse statement specifying the unnamed statement as destination is issued.</span> <ul> <li>Parameter binding is still safe against SQL injection</li> <li>Each query is parsed and planned from scratch by the server</li> <li>Queries will not be <a href="https://www.postgresql.org/docs/current/protocol-flow.html#PROTOCOL-FLOW-PIPELINING" target="_blank" rel="noreferrer">pipelined</a>
</li> </ul> <span data-as="p">You might want to use <code>prepare: false</code> when:</span> <ul> <li>Using PGBouncer in transaction mode (though since PGBouncer 1.21.0, protocol-level named prepared statements are supported when configured properly)</li> <li>Debugging query execution plans</li> <li>Working with dynamic SQL where query plans need to be regenerated frequently</li> <li>More than one command per query will not be supported (unless you use <code>sql``.simple()</code>)</li> </ul> <span data-as="p">Note that disabling prepared statements may impact performance for queries that are executed frequently with different parameters, as the server needs to parse and plan each query from scratch.</span> <hr> <h2 id="error-handling"><span>Error Handling</span></h2> <span data-as="p">The client provides typed errors for different failure scenarios. Errors are database-specific and extend from base error classes:</span> <h3 id="error-classes"><span>Error Classes</span></h3> <pre numberoflines="20" language="typescript" data-language="typescript">import { SQL } from "bun";

try {
  await sql`SELECT * FROM users`;
} catch (error) {
  if (error instanceof SQL.PostgresError) {
    // PostgreSQL-specific error
    console.log(error.code); // PostgreSQL error code
    console.log(error.detail); // Detailed error message
    console.log(error.hint); // Helpful hint from PostgreSQL
  } else if (error instanceof SQL.SQLiteError) {
    // SQLite-specific error
    console.log(error.code); // SQLite error code (e.g., "SQLITE_CONSTRAINT")
    console.log(error.errno); // SQLite error number
    console.log(error.byteOffset); // Byte offset in SQL statement (if available)
  } else if (error instanceof SQL.SQLError) {
    // Generic SQL error (base class)
    console.log(error.message);
  }
}
</pre> <details><summary aria-controls="postgresql-specific-error-codes accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">PostgreSQL-Specific Error Codes</p></div></summary><div id="postgresql-specific-error-codes accordion children" role="region" aria-labelledby="postgresql-specific-error-codes" data-component-part="accordion-content">
<h3 id="postgresql-connection-errors"><span>PostgreSQL Connection Errors</span></h3>
<div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Connection Errors</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code>ERR_POSTGRES_CONNECTION_CLOSED</code></td>
<td>Connection was terminated or never established</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_CONNECTION_TIMEOUT</code></td>
<td>Failed to establish connection within timeout period</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_IDLE_TIMEOUT</code></td>
<td>Connection closed due to inactivity</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_LIFETIME_TIMEOUT</code></td>
<td>Connection exceeded maximum lifetime</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_TLS_NOT_AVAILABLE</code></td>
<td>SSL/TLS connection not available</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_TLS_UPGRADE_FAILED</code></td>
<td>Failed to upgrade connection to SSL/TLS</td>
</tr>
</tbody>
</table></div></div>
<h3 id="authentication-errors"><span>Authentication Errors</span></h3>
<div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Authentication Errors</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code>ERR_POSTGRES_AUTHENTICATION_FAILED_PBKDF2</code></td>
<td>Password authentication failed</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_UNKNOWN_AUTHENTICATION_METHOD</code></td>
<td>Server requested unknown auth method</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_UNSUPPORTED_AUTHENTICATION_METHOD</code></td>
<td>Server requested unsupported auth method</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_INVALID_SERVER_KEY</code></td>
<td>Invalid server key during authentication</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_INVALID_SERVER_SIGNATURE</code></td>
<td>Invalid server signature</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_SASL_SIGNATURE_INVALID_BASE64</code></td>
<td>Invalid SASL signature encoding</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_SASL_SIGNATURE_MISMATCH</code></td>
<td>SASL signature verification failed</td>
</tr>
</tbody>
</table></div></div>
<h3 id="query-errors"><span>Query Errors</span></h3>
<div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Query Errors</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code>ERR_POSTGRES_SYNTAX_ERROR</code></td>
<td>Invalid SQL syntax (extends <code>SyntaxError</code>)</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_SERVER_ERROR</code></td>
<td>General error from PostgreSQL server</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_INVALID_QUERY_BINDING</code></td>
<td>Invalid parameter binding</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_QUERY_CANCELLED</code></td>
<td>Query was cancelled</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_NOT_TAGGED_CALL</code></td>
<td>Query was called without a tagged call</td>
</tr>
</tbody>
</table></div></div>
<h3 id="data-type-errors"><span>Data Type Errors</span></h3>
<div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Data Type Errors</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code>ERR_POSTGRES_INVALID_BINARY_DATA</code></td>
<td>Invalid binary data format</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_INVALID_BYTE_SEQUENCE</code></td>
<td>Invalid byte sequence</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_INVALID_BYTE_SEQUENCE_FOR_ENCODING</code></td>
<td>Encoding error</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_INVALID_CHARACTER</code></td>
<td>Invalid character in data</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_OVERFLOW</code></td>
<td>Numeric overflow</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_UNSUPPORTED_BYTEA_FORMAT</code></td>
<td>Unsupported binary format</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_UNSUPPORTED_INTEGER_SIZE</code></td>
<td>Integer size not supported</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_MULTIDIMENSIONAL_ARRAY_NOT_SUPPORTED_YET</code></td>
<td>Multidimensional arrays not supported</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_NULLS_IN_ARRAY_NOT_SUPPORTED_YET</code></td>
<td>NULL values in arrays not supported</td>
</tr>
</tbody>
</table></div></div>
<h3 id="protocol-errors"><span>Protocol Errors</span></h3>
<div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Protocol Errors</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code>ERR_POSTGRES_EXPECTED_REQUEST</code></td>
<td>Expected client request</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_EXPECTED_STATEMENT</code></td>
<td>Expected prepared statement</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_INVALID_BACKEND_KEY_DATA</code></td>
<td>Invalid backend key data</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_INVALID_MESSAGE</code></td>
<td>Invalid protocol message</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_INVALID_MESSAGE_LENGTH</code></td>
<td>Invalid message length</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_UNEXPECTED_MESSAGE</code></td>
<td>Unexpected message type</td>
</tr>
</tbody>
</table></div></div>
<h3 id="transaction-errors"><span>Transaction Errors</span></h3>
<div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Transaction Errors</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code>ERR_POSTGRES_UNSAFE_TRANSACTION</code></td>
<td>Unsafe transaction operation detected</td>
</tr>
<tr>
<td><code>ERR_POSTGRES_INVALID_TRANSACTION_STATE</code></td>
<td>Invalid transaction state</td>
</tr>
</tbody>
</table></div></div>
</div></details> <h3 id="sqlite-specific-errors"><span>SQLite-Specific Errors</span></h3> <span data-as="p">SQLite errors provide error codes and numbers that correspond to SQLite’s standard error codes:</span> <details><summary aria-controls="common-sqlite-error-codes accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">Common SQLite Error Codes</p></div></summary><div id="common-sqlite-error-codes accordion children" role="region" aria-labelledby="common-sqlite-error-codes" data-component-part="accordion-content">
<div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Error Code</th>
<th>errno</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code>SQLITE_CONSTRAINT</code></td>
<td data-numeric="true">19</td>
<td>Constraint violation (UNIQUE, CHECK, NOT NULL, etc.)</td>
</tr>
<tr>
<td><code>SQLITE_BUSY</code></td>
<td data-numeric="true">5</td>
<td>Database is locked</td>
</tr>
<tr>
<td><code>SQLITE_LOCKED</code></td>
<td data-numeric="true">6</td>
<td>Table in the database is locked</td>
</tr>
<tr>
<td><code>SQLITE_READONLY</code></td>
<td data-numeric="true">8</td>
<td>Attempt to write to a readonly database</td>
</tr>
<tr>
<td><code>SQLITE_IOERR</code></td>
<td data-numeric="true">10</td>
<td>Disk I/O error</td>
</tr>
<tr>
<td><code>SQLITE_CORRUPT</code></td>
<td data-numeric="true">11</td>
<td>Database disk image is malformed</td>
</tr>
<tr>
<td><code>SQLITE_FULL</code></td>
<td data-numeric="true">13</td>
<td>Database or disk is full</td>
</tr>
<tr>
<td><code>SQLITE_CANTOPEN</code></td>
<td data-numeric="true">14</td>
<td>Unable to open database file</td>
</tr>
<tr>
<td><code>SQLITE_PROTOCOL</code></td>
<td data-numeric="true">15</td>
<td>Database lock protocol error</td>
</tr>
<tr>
<td><code>SQLITE_SCHEMA</code></td>
<td data-numeric="true">17</td>
<td>Database schema has changed</td>
</tr>
<tr>
<td><code>SQLITE_TOOBIG</code></td>
<td data-numeric="true">18</td>
<td>String or BLOB exceeds size limit</td>
</tr>
<tr>
<td><code>SQLITE_MISMATCH</code></td>
<td data-numeric="true">20</td>
<td>Data type mismatch</td>
</tr>
<tr>
<td><code>SQLITE_MISUSE</code></td>
<td data-numeric="true">21</td>
<td>Library used incorrectly</td>
</tr>
<tr>
<td><code>SQLITE_AUTH</code></td>
<td data-numeric="true">23</td>
<td>Authorization denied</td>
</tr>
</tbody>
</table></div></div>
<span data-as="p">Example error handling:</span><pre numberoflines="13" language="typescript" data-language="typescript">const sqlite = new SQL("sqlite://app.db");

try {
  await sqlite`INSERT INTO users (id, name) VALUES (1, 'Alice')`;
  await sqlite`INSERT INTO users (id, name) VALUES (1, 'Bob')`; // Duplicate ID
} catch (error) {
  if (error instanceof SQL.SQLiteError) {
    if (error.code === "SQLITE_CONSTRAINT") {
      console.log("Constraint violation:", error.message);
      // Handle unique constraint violation
    }
  }
}
</pre>
</div></details> <hr> <h2 id="numbers-and-bigint"><span>Numbers and BigInt</span></h2> <span data-as="p">Bun’s SQL client includes special handling for large numbers that exceed the range of a 53-bit integer. Here’s how it works:</span> <pre numberoflines="6" language="typescript" data-language="typescript">import { sql } from "bun";

const [{ x, y }] = await sql`SELECT 9223372036854777 as x, 12345 as y`;

console.log(typeof x, x); // "string" "9223372036854777"
console.log(typeof y, y); // "number" 12345
</pre> <hr> <h2 id="bigint-instead-of-strings"><span>BigInt Instead of Strings</span></h2> <span data-as="p">If you need large numbers as BigInt instead of strings, you can enable this by setting the <code>bigint</code> option to <code>true</code> when initializing the SQL client:</span> <pre numberoflines="7" language="typescript" data-language="typescript">const sql = new SQL({
  bigint: true,
});

const [{ x }] = await sql`SELECT 9223372036854777 as x`;

console.log(typeof x, x); // "bigint" 9223372036854777n
</pre> <hr> <h2 id="roadmap"><span>Roadmap</span></h2> <span data-as="p">There’s still some things we haven’t finished yet.</span> <ul> <li>Connection preloading via <code>--db-preconnect</code> Bun CLI flag</li> <li>Column name transforms (e.g. <code>snake_case</code> to <code>camelCase</code>). This is mostly blocked on a unicode-aware implementation of changing the case in C++ using WebKit’s <code>WTF::String</code>.</li> <li>Column type transforms</li> </ul> <hr> <h2 id="database-specific-features"><span>Database-Specific Features</span></h2> <h4 id="authentication-methods"><span>Authentication Methods</span></h4> <span data-as="p">MySQL supports multiple authentication plugins that are automatically negotiated:</span> <ul> <li>
<strong><code>mysql_native_password</code></strong> - Traditional MySQL authentication, widely compatible</li> <li>
<strong><code>caching_sha2_password</code></strong> - Default in MySQL 8.0+, more secure with RSA key exchange</li> <li>
<strong><code>sha256_password</code></strong> - SHA-256 based authentication</li> </ul> <span data-as="p">The client automatically handles authentication plugin switching when requested by the server, including secure password exchange over non-SSL connections.</span> <h4 id="prepared-statements-&amp;-performance"><span>Prepared Statements &amp; Performance</span></h4> <span data-as="p">MySQL uses server-side prepared statements for all parameterized queries:</span> <pre numberoflines="15" language="typescript" data-language="typescript">// This automatically creates a prepared statement on the server
const user = await mysql`SELECT * FROM users WHERE id = ${userId}`;

// Prepared statements are cached and reused for identical queries
for (const id of userIds) {
  // Same prepared statement is reused
  await mysql`SELECT * FROM users WHERE id = ${id}`;
}

// Query pipelining - multiple statements sent without waiting
const [users, orders, products] = await Promise.all([
  mysql`SELECT * FROM users WHERE active = ${true}`,
  mysql`SELECT * FROM orders WHERE status = ${"pending"}`,
  mysql`SELECT * FROM products WHERE in_stock = ${true}`,
]);
</pre> <h4 id="multiple-result-sets"><span>Multiple Result Sets</span></h4> <span data-as="p">MySQL can return multiple result sets from multi-statement queries:</span> <pre numberoflines="7" language="typescript" data-language="typescript">const mysql = new SQL("mysql://user:pass@localhost/mydb");

// Multi-statement queries with simple() method
const multiResults = await mysql`
  SELECT * FROM users WHERE id = 1;
  SELECT * FROM orders WHERE user_id = 1;
`.simple();
</pre> <h4 id="character-sets-&amp;-collations"><span>Character Sets &amp; Collations</span></h4> <span data-as="p">Bun.SQL automatically uses <code>utf8mb4</code> character set for MySQL connections, ensuring full Unicode support including emojis. This is the recommended character set for modern MySQL applications.</span> <h4 id="connection-attributes"><span>Connection Attributes</span></h4> <span data-as="p">Bun automatically sends client information to MySQL for better monitoring:</span> <pre numberoflines="4" language="typescript" data-language="typescript">// These attributes are sent automatically:
// _client_name: "Bun"
// _client_version: &lt;bun version&gt;
// You can see these in MySQL's performance_schema.session_connect_attrs
</pre> <h4 id="type-handling"><span>Type Handling</span></h4> <span data-as="p">MySQL types are automatically converted to JavaScript types:</span> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>MySQL Type</th>
<th>JavaScript Type</th>
<th>Notes</th>
</tr></thead>
<tbody>
<tr>
<td>INT, TINYINT, MEDIUMINT</td>
<td>number</td>
<td>Within safe integer range</td>
</tr>
<tr>
<td>BIGINT</td>
<td>string, number or BigInt</td>
<td>If the value fits in i32/u32 size will be number otherwise string or BigInt Based on <code>bigint</code> option</td>
</tr>
<tr>
<td>DECIMAL, NUMERIC</td>
<td>string</td>
<td>To preserve precision</td>
</tr>
<tr>
<td>FLOAT, DOUBLE</td>
<td>number</td>
<td></td>
</tr>
<tr>
<td>DATE</td>
<td>Date</td>
<td>JavaScript Date object</td>
</tr>
<tr>
<td>DATETIME, TIMESTAMP</td>
<td>Date</td>
<td>With timezone handling</td>
</tr>
<tr>
<td>TIME</td>
<td>number</td>
<td>Total of microseconds</td>
</tr>
<tr>
<td>YEAR</td>
<td>number</td>
<td></td>
</tr>
<tr>
<td>CHAR, VARCHAR, VARSTRING, STRING</td>
<td>string</td>
<td></td>
</tr>
<tr>
<td>TINY TEXT, MEDIUM TEXT, TEXT, LONG TEXT</td>
<td>string</td>
<td></td>
</tr>
<tr>
<td>TINY BLOB, MEDIUM BLOB, BLOG, LONG BLOB</td>
<td>string</td>
<td>BLOB Types are alias for TEXT types</td>
</tr>
<tr>
<td>JSON</td>
<td>object/array</td>
<td>Automatically parsed</td>
</tr>
<tr>
<td>BIT(1)</td>
<td>boolean</td>
<td>BIT(1) in MySQL</td>
</tr>
<tr>
<td>GEOMETRY</td>
<td>string</td>
<td>Geometry data</td>
</tr>
</tbody>
</table></div></div> <h4 id="differences-from-postgresql"><span>Differences from PostgreSQL</span></h4> <span data-as="p">While the API is unified, there are some behavioral differences:</span> <ol> <li>
<strong>Parameter placeholders</strong>: MySQL uses <code>?</code> internally but Bun converts <code>$1, $2</code> style automatically</li> <li>
<strong>RETURNING clause</strong>: MySQL doesn’t support RETURNING; use <code>result.lastInsertRowid</code> or a separate SELECT</li> <li>
<strong>Array types</strong>: MySQL doesn’t have native array types like PostgreSQL</li> </ol> <h3 id="mysql-specific-features"><span>MySQL-Specific Features</span></h3> <span data-as="p">We haven’t implemented <code>LOAD DATA INFILE</code> support yet</span> <h3 id="postgresql-specific-features"><span>PostgreSQL-Specific Features</span></h3> <span data-as="p">We haven’t implemented these yet:</span> <ul> <li>
<code>COPY</code> support</li> <li>
<code>LISTEN</code> support</li> <li>
<code>NOTIFY</code> support</li> </ul> <span data-as="p">We also haven’t implemented some of the more uncommon features like:</span> <ul> <li>GSSAPI authentication</li> <li>
<code>SCRAM-SHA-256-PLUS</code> support</li> <li>Point &amp; PostGIS types</li> <li>All the multi-dimensional integer array types (only a couple of the types are supported)</li> </ul> <hr> <h2 id="common-patterns-&amp;-best-practices"><span>Common Patterns &amp; Best Practices</span></h2> <h3 id="working-with-mysql-result-sets"><span>Working with MySQL Result Sets</span></h3> <pre numberoflines="11" language="typescript" data-language="typescript">// Getting insert ID after INSERT
const result = await mysql`INSERT INTO users (name) VALUES (${"Alice"})`;
console.log(result.lastInsertRowid); // MySQL's LAST_INSERT_ID()

// Handling affected rows
const updated = await mysql`UPDATE users SET active = ${false} WHERE age &lt; ${18}`;
console.log(updated.affectedRows); // Number of rows updated

// Using MySQL-specific functions
const now = await mysql`SELECT NOW() as current_time`;
const uuid = await mysql`SELECT UUID() as id`;
</pre> <h3 id="mysql-error-handling"><span>MySQL Error Handling</span></h3> <pre numberoflines="12" language="typescript" data-language="typescript">try {
  await mysql`INSERT INTO users (email) VALUES (${"duplicate@email.com"})`;
} catch (error) {
  if (error.code === "ER_DUP_ENTRY") {
    console.log("Duplicate entry detected");
  } else if (error.code === "ER_ACCESS_DENIED_ERROR") {
    console.log("Access denied");
  } else if (error.code === "ER_BAD_DB_ERROR") {
    console.log("Database does not exist");
  }
  // MySQL error codes are compatible with mysql/mysql2 packages
}
</pre> <h3 id="performance-tips-for-mysql"><span>Performance Tips for MySQL</span></h3> <ol> <li>
<strong>Use connection pooling</strong>: Set appropriate <code>max</code> pool size based on your workload</li> <li>
<strong>Enable prepared statements</strong>: They’re enabled by default and improve performance</li> <li>
<strong>Use transactions for bulk operations</strong>: Group related queries in transactions</li> <li>
<strong>Index properly</strong>: MySQL relies heavily on indexes for query performance</li> <li>
<strong>Use <code>utf8mb4</code> charset</strong>: It’s set by default and handles all Unicode characters</li> </ol> <hr> <h2 id="frequently-asked-questions"><span>Frequently Asked Questions</span></h2> <div>
<details><summary aria-controls="why-is-this-bun-sql-and-not-bun-postgres accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">Why is this `Bun.sql` and not `Bun.postgres`?</p></div></summary><div id="why-is-this-bun-sql-and-not-bun-postgres accordion children" role="region" aria-labelledby="why-is-this-bun-sql-and-not-bun-postgres" data-component-part="accordion-content"><span data-as="p">The plan was to add more database drivers in the future. Now with MySQL support added, this unified API supports PostgreSQL, MySQL, and SQLite.</span></div></details><details><summary aria-controls="how-do-i-know-which-database-adapter-is-being-used accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">How do I know which database adapter is being used?</p></div></summary><div id="how-do-i-know-which-database-adapter-is-being-used accordion children" role="region" aria-labelledby="how-do-i-know-which-database-adapter-is-being-used" data-component-part="accordion-content">
<span data-as="p">The adapter is automatically detected from the connection string:</span><ul> <li>URLs starting with <code>mysql://</code> or <code>mysql2://</code> use MySQL</li> <li>URLs matching SQLite patterns (<code>:memory:</code>, <code>sqlite://</code>, <code>file://</code>) use SQLite</li> <li>Everything else defaults to PostgreSQL</li> </ul>
</div></details><details><summary aria-controls="are-mysql-stored-procedures-supported accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">Are MySQL stored procedures supported?</p></div></summary><div id="are-mysql-stored-procedures-supported accordion children" role="region" aria-labelledby="are-mysql-stored-procedures-supported" data-component-part="accordion-content">
<span data-as="p">Yes, stored procedures are fully supported including OUT parameters and multiple result sets:</span><pre numberoflines="5" language="typescript" data-language="typescript">// Call stored procedure
const results = await mysql`CALL GetUserStats(${userId}, @total_orders)`;

// Get OUT parameter
const outParam = await mysql`SELECT @total_orders as total`;
</pre>
</div></details><details><summary aria-controls="can-i-use-mysql-specific-sql-syntax accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">Can I use MySQL-specific SQL syntax?</p></div></summary><div id="can-i-use-mysql-specific-sql-syntax accordion children" role="region" aria-labelledby="can-i-use-mysql-specific-sql-syntax" data-component-part="accordion-content">
<span data-as="p">Yes, you can use any MySQL-specific syntax:</span><pre numberoflines="5" language="typescript" data-language="typescript">// MySQL-specific syntax works fine
await mysql`SET @user_id = ${userId}`;
await mysql`SHOW TABLES`;
await mysql`DESCRIBE users`;
await mysql`EXPLAIN SELECT * FROM users WHERE id = ${id}`;
</pre>
</div></details>
</div> <hr> <h2 id="why-not-just-use-an-existing-library"><span>Why not just use an existing library?</span></h2> <span data-as="p">npm packages like postgres.js, pg, and node-postgres can be used in Bun too. They’re great options.</span> <span data-as="p">Two reasons why:</span> <ol> <li>We think it’s simpler for developers to have a database driver built into Bun. The time you spend library shopping is time you could be building your app.</li> <li>We leverage some JavaScriptCore engine internals to make it faster to create objects that would be difficult to implement in a library</li> </ol> <h2 id="credits"><span>Credits</span></h2> <span data-as="p">Huge thanks to <a href="https://github.com/porsager" target="_blank" rel="noreferrer">@porsager</a>’s <a href="https://github.com/porsager/postgres" target="_blank" rel="noreferrer">postgres.js</a> for the inspiration for the API interface.</span>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/sql" class="_attribution-link">https://bun.com/docs/runtime/sql</a>
  </p>
</div>
