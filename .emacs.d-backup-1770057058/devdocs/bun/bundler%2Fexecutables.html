<h1 id="header">Single-file executable</h1>
<div data-page-title="Single-file executable" data-page-href="/bundler/executables" id="content">
<span data-as="p">Bun’s bundler implements a <code>--compile</code> flag for generating a standalone binary from a TypeScript or JavaScript file.</span> <div id="cli">
<ul role="tablist" data-component-part="tabs-list">
<li id="cli" role="tab" aria-selected="true" aria-controls="panel-cli-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-CLI"> CLI</div></li>
<li id="javascript" role="tab" aria-selected="false" aria-controls="panel-javascript-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-JavaScript"> JavaScript</div></li>
</ul>
<div>
<div id="panel-cli-0" role="tabpanel" aria-labelledby="cli" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./cli.ts --compile --outfile mycli
</pre></div>
<div id="panel-javascript-1" role="tabpanel" aria-labelledby="javascript" data-component-part="tab-content"><pre numberoflines="6" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ["./cli.ts"],
  compile: {
    outfile: "./mycli",
  },
});
</pre></div>
</div>
</div> <pre numberoflines="1" language="typescript" data-language="typescript">console.log("Hello world!");
</pre> <span data-as="p">This bundles <code>cli.ts</code> into an executable that can be executed directly:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">./mycli
</pre> <pre numberoflines="2" language="text" data-language="typescript">Hello world!
</pre> <span data-as="p">All imported files and packages are bundled into the executable, along with a copy of the Bun runtime. All built-in Bun and Node.js APIs are supported.</span> <hr> <h2 id="cross-compile-to-other-platforms"><span>Cross-compile to other platforms</span></h2> <span data-as="p">The <code>--target</code> flag lets you compile your standalone executable for a different operating system, architecture, or version of Bun than the machine you’re running <code>bun build</code> on.</span> <span data-as="p">To build for Linux x64 (most servers):</span> <div id="cli-2">
<ul role="tablist" data-component-part="tabs-list">
<li id="cli-2" role="tab" aria-selected="true" aria-controls="panel-cli-2-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-CLI"> CLI</div></li>
<li id="javascript-2" role="tab" aria-selected="false" aria-controls="panel-javascript-2-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-JavaScript"> JavaScript</div></li>
</ul>
<div>
<div id="panel-cli-2-0" role="tabpanel" aria-labelledby="cli-2" data-component-part="tab-content"><pre numberoflines="8" language="shellscript" data-language="typescript">bun build --compile --target=bun-linux-x64 ./index.ts --outfile myapp

# To support CPUs from before 2013, use the baseline version (nehalem)
bun build --compile --target=bun-linux-x64-baseline ./index.ts --outfile myapp

# To explicitly only support CPUs from 2013 and later, use the modern version (haswell)
# modern is faster, but baseline is more compatible.
bun build --compile --target=bun-linux-x64-modern ./index.ts --outfile myapp
</pre></div>
<div id="panel-javascript-2-1" role="tabpanel" aria-labelledby="javascript-2" data-component-part="tab-content"><pre numberoflines="26" language="typescript" data-language="typescript">// Standard Linux x64
await Bun.build({
  entrypoints: ["./index.ts"],
  compile: {
    target: "bun-linux-x64",
    outfile: "./myapp",
  },
});

// Baseline (pre-2013 CPUs)
await Bun.build({
  entrypoints: ["./index.ts"],
  compile: {
    target: "bun-linux-x64-baseline",
    outfile: "./myapp",
  },
});

// Modern (2013+ CPUs, faster)
await Bun.build({
  entrypoints: ["./index.ts"],
  compile: {
    target: "bun-linux-x64-modern",
    outfile: "./myapp",
  },
});
</pre></div>
</div>
</div> <span data-as="p">To build for Linux ARM64 (e.g. Graviton or Raspberry Pi):</span> <div id="cli-3">
<ul role="tablist" data-component-part="tabs-list">
<li id="cli-3" role="tab" aria-selected="true" aria-controls="panel-cli-3-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-CLI"> CLI</div></li>
<li id="javascript-3" role="tab" aria-selected="false" aria-controls="panel-javascript-3-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-JavaScript"> JavaScript</div></li>
</ul>
<div>
<div id="panel-cli-3-0" role="tabpanel" aria-labelledby="cli-3" data-component-part="tab-content"><pre numberoflines="2" language="shellscript" data-language="typescript"># Note: the default architecture is x64 if no architecture is specified.
bun build --compile --target=bun-linux-arm64 ./index.ts --outfile myapp
</pre></div>
<div id="panel-javascript-3-1" role="tabpanel" aria-labelledby="javascript-3" data-component-part="tab-content"><pre numberoflines="7" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ["./index.ts"],
  compile: {
    target: "bun-linux-arm64",
    outfile: "./myapp",
  },
});
</pre></div>
</div>
</div> <span data-as="p">To build for Windows x64:</span> <div id="cli-4">
<ul role="tablist" data-component-part="tabs-list">
<li id="cli-4" role="tab" aria-selected="true" aria-controls="panel-cli-4-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-CLI"> CLI</div></li>
<li id="javascript-4" role="tab" aria-selected="false" aria-controls="panel-javascript-4-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-JavaScript"> JavaScript</div></li>
</ul>
<div>
<div id="panel-cli-4-0" role="tabpanel" aria-labelledby="cli-4" data-component-part="tab-content"><pre numberoflines="9" language="shellscript" data-language="typescript">bun build --compile --target=bun-windows-x64 ./path/to/my/app.ts --outfile myapp

# To support CPUs from before 2013, use the baseline version (nehalem)
bun build --compile --target=bun-windows-x64-baseline ./path/to/my/app.ts --outfile myapp

# To explicitly only support CPUs from 2013 and later, use the modern version (haswell)
bun build --compile --target=bun-windows-x64-modern ./path/to/my/app.ts --outfile myapp

# note: if no .exe extension is provided, Bun will automatically add it for Windows executables
</pre></div>
<div id="panel-javascript-4-1" role="tabpanel" aria-labelledby="javascript-4" data-component-part="tab-content"><pre numberoflines="17" language="typescript" data-language="typescript">// Standard Windows x64
await Bun.build({
  entrypoints: ["./path/to/my/app.ts"],
  compile: {
    target: "bun-windows-x64",
    outfile: "./myapp", // .exe added automatically
  },
});

// Baseline or modern variants
await Bun.build({
  entrypoints: ["./path/to/my/app.ts"],
  compile: {
    target: "bun-windows-x64-baseline",
    outfile: "./myapp",
  },
});
</pre></div>
</div>
</div> <span data-as="p">To build for macOS arm64:</span> <div id="cli-5">
<ul role="tablist" data-component-part="tabs-list">
<li id="cli-5" role="tab" aria-selected="true" aria-controls="panel-cli-5-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-CLI"> CLI</div></li>
<li id="javascript-5" role="tab" aria-selected="false" aria-controls="panel-javascript-5-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-JavaScript"> JavaScript</div></li>
</ul>
<div>
<div id="panel-cli-5-0" role="tabpanel" aria-labelledby="cli-5" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build --compile --target=bun-darwin-arm64 ./path/to/my/app.ts --outfile myapp
</pre></div>
<div id="panel-javascript-5-1" role="tabpanel" aria-labelledby="javascript-5" data-component-part="tab-content"><pre numberoflines="7" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ["./path/to/my/app.ts"],
  compile: {
    target: "bun-darwin-arm64",
    outfile: "./myapp",
  },
});
</pre></div>
</div>
</div> <span data-as="p">To build for macOS x64:</span> <div id="cli-6">
<ul role="tablist" data-component-part="tabs-list">
<li id="cli-6" role="tab" aria-selected="true" aria-controls="panel-cli-6-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-CLI"> CLI</div></li>
<li id="javascript-6" role="tab" aria-selected="false" aria-controls="panel-javascript-6-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-JavaScript"> JavaScript</div></li>
</ul>
<div>
<div id="panel-cli-6-0" role="tabpanel" aria-labelledby="cli-6" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build --compile --target=bun-darwin-x64 ./path/to/my/app.ts --outfile myapp
</pre></div>
<div id="panel-javascript-6-1" role="tabpanel" aria-labelledby="javascript-6" data-component-part="tab-content"><pre numberoflines="7" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ["./path/to/my/app.ts"],
  compile: {
    target: "bun-darwin-x64",
    outfile: "./myapp",
  },
});
</pre></div>
</div>
</div> <h3 id="supported-targets"><span>Supported targets</span></h3> <span data-as="p">The order of the <code>--target</code> flag does not matter, as long as they’re delimited by a <code>-</code>.</span> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>—target</th>
<th>Operating System</th>
<th>Architecture</th>
<th>Modern</th>
<th>Baseline</th>
<th>Libc</th>
</tr></thead>
<tbody>
<tr>
<td>bun-linux-x64</td>
<td>Linux</td>
<td>x64</td>
<td>✅</td>
<td>✅</td>
<td>glibc</td>
</tr>
<tr>
<td>bun-linux-arm64</td>
<td>Linux</td>
<td>arm64</td>
<td>✅</td>
<td>N/A</td>
<td>glibc</td>
</tr>
<tr>
<td>bun-windows-x64</td>
<td>Windows</td>
<td>x64</td>
<td>✅</td>
<td>✅</td>
<td data-numeric="true">-</td>
</tr>
<tr>
<td><del>bun-windows-arm64</del></td>
<td><del>Windows</del></td>
<td><del>arm64</del></td>
<td>❌</td>
<td>❌</td>
<td data-numeric="true">-</td>
</tr>
<tr>
<td>bun-darwin-x64</td>
<td>macOS</td>
<td>x64</td>
<td>✅</td>
<td>✅</td>
<td data-numeric="true">-</td>
</tr>
<tr>
<td>bun-darwin-arm64</td>
<td>macOS</td>
<td>arm64</td>
<td>✅</td>
<td>N/A</td>
<td data-numeric="true">-</td>
</tr>
<tr>
<td>bun-linux-x64-musl</td>
<td>Linux</td>
<td>x64</td>
<td>✅</td>
<td>✅</td>
<td>musl</td>
</tr>
<tr>
<td>bun-linux-arm64-musl</td>
<td>Linux</td>
<td>arm64</td>
<td>✅</td>
<td>N/A</td>
<td>musl</td>
</tr>
</tbody>
</table></div></div> <div data-callout-type="warning">

<div data-component-part="callout-content"><span data-as="p">On x64 platforms, Bun uses SIMD optimizations which require a modern CPU supporting AVX2 instructions. The <code>-baseline</code> build of Bun is for older CPUs that don’t support these optimizations. Normally, when you install Bun we automatically detect which version to use but this can be harder to do when cross-compiling since you might not know the target CPU. You usually don’t need to worry about it on Darwin x64, but it is relevant for Windows x64 and Linux x64. If you or your users see <code>"Illegal instruction"</code> errors, you might need to use the baseline version.</span></div>
</div> <hr> <h2 id="build-time-constants"><span>Build-time constants</span></h2> <span data-as="p">Use the <code>--define</code> flag to inject build-time constants into your executable, such as version numbers, build timestamps, or configuration values:</span> <div id="cli-7">
<ul role="tablist" data-component-part="tabs-list">
<li id="cli-7" role="tab" aria-selected="true" aria-controls="panel-cli-7-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-CLI"> CLI</div></li>
<li id="javascript-7" role="tab" aria-selected="false" aria-controls="panel-javascript-7-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-JavaScript"> JavaScript</div></li>
</ul>
<div>
<div id="panel-cli-7-0" role="tabpanel" aria-labelledby="cli-7" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build --compile --define BUILD_VERSION='"1.2.3"' --define BUILD_TIME='"2024-01-15T10:30:00Z"' src/cli.ts --outfile mycli
</pre></div>
<div id="panel-javascript-7-1" role="tabpanel" aria-labelledby="javascript-7" data-component-part="tab-content"><pre numberoflines="10" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ["./src/cli.ts"],
  compile: {
    outfile: "./mycli",
  },
  define: {
    BUILD_VERSION: JSON.stringify("1.2.3"),
    BUILD_TIME: JSON.stringify("2024-01-15T10:30:00Z"),
  },
});
</pre></div>
</div>
</div> <span data-as="p">These constants are embedded directly into your compiled binary at build time, providing zero runtime overhead and enabling dead code elimination optimizations.</span> <div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p">For comprehensive examples and advanced patterns, see the <a href="../guides/runtime/build-time-constants">Build-time constants guide</a>.</span></div>
</div> <hr> <h2 id="deploying-to-production"><span>Deploying to production</span></h2> <span data-as="p">Compiled executables reduce memory usage and improve Bun’s start time.</span> <span data-as="p">Normally, Bun reads and transpiles JavaScript and TypeScript files on <code>import</code> and <code>require</code>. This is part of what makes so much of Bun “just work”, but it’s not free. It costs time and memory to read files from disk, resolve file paths, parse, transpile, and print source code.</span> <span data-as="p">With compiled executables, you can move that cost from runtime to build-time.</span> <span data-as="p">When deploying to production, we recommend the following:</span> <div id="cli-8">
<ul role="tablist" data-component-part="tabs-list">
<li id="cli-8" role="tab" aria-selected="true" aria-controls="panel-cli-8-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-CLI"> CLI</div></li>
<li id="javascript-8" role="tab" aria-selected="false" aria-controls="panel-javascript-8-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-JavaScript"> JavaScript</div></li>
</ul>
<div>
<div id="panel-cli-8-0" role="tabpanel" aria-labelledby="cli-8" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build --compile --minify --sourcemap ./path/to/my/app.ts --outfile myapp
</pre></div>
<div id="panel-javascript-8-1" role="tabpanel" aria-labelledby="javascript-8" data-component-part="tab-content"><pre numberoflines="8" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ["./path/to/my/app.ts"],
  compile: {
    outfile: "./myapp",
  },
  minify: true,
  sourcemap: "linked",
});
</pre></div>
</div>
</div> <h3 id="bytecode-compilation"><span>Bytecode compilation</span></h3> <span data-as="p">To improve startup time, enable bytecode compilation:</span> <div id="cli-9">
<ul role="tablist" data-component-part="tabs-list">
<li id="cli-9" role="tab" aria-selected="true" aria-controls="panel-cli-9-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-CLI"> CLI</div></li>
<li id="javascript-9" role="tab" aria-selected="false" aria-controls="panel-javascript-9-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-JavaScript"> JavaScript</div></li>
</ul>
<div>
<div id="panel-cli-9-0" role="tabpanel" aria-labelledby="cli-9" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build --compile --minify --sourcemap --bytecode ./path/to/my/app.ts --outfile myapp
</pre></div>
<div id="panel-javascript-9-1" role="tabpanel" aria-labelledby="javascript-9" data-component-part="tab-content"><pre numberoflines="9" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ["./path/to/my/app.ts"],
  compile: {
    outfile: "./myapp",
  },
  minify: true,
  sourcemap: "linked",
  bytecode: true,
});
</pre></div>
</div>
</div> <span data-as="p">Using bytecode compilation, <code>tsc</code> starts 2x faster:</span>  <span data-as="p">Bytecode compilation moves parsing overhead for large input files from runtime to bundle time. Your app starts faster, in exchange for making the <code>bun build</code> command a little slower. It doesn’t obscure source code.</span> <div data-callout-type="warning">

<div data-component-part="callout-content"><span data-as="p"><strong>Experimental:</strong> Bytecode compilation is an experimental feature. Only <code>cjs</code> format is supported (which means no top-level-await). Let us know if you run into any issues!</span></div>
</div> <h3 id="what-do-these-flags-do"><span>What do these flags do?</span></h3> <span data-as="p">The <code>--minify</code> argument optimizes the size of the transpiled output code. If you have a large application, this can save megabytes of space. For smaller applications, it might still improve start time a little.</span> <span data-as="p">The <code>--sourcemap</code> argument embeds a sourcemap compressed with zstd, so that errors &amp; stacktraces point to their original locations instead of the transpiled location. Bun will automatically decompress &amp; resolve the sourcemap when an error occurs.</span> <span data-as="p">The <code>--bytecode</code> argument enables bytecode compilation. Every time you run JavaScript code in Bun, JavaScriptCore (the engine) will compile your source code into bytecode. We can move this parsing work from runtime to bundle time, saving you startup time.</span> <hr> <h2 id="embedding-runtime-arguments"><span>Embedding runtime arguments</span></h2> <span data-as="p"><strong><code>--compile-exec-argv="args"</code></strong> - Embed runtime arguments that are available via <code>process.execArgv</code>:</span> <div id="cli-10">
<ul role="tablist" data-component-part="tabs-list">
<li id="cli-10" role="tab" aria-selected="true" aria-controls="panel-cli-10-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-CLI"> CLI</div></li>
<li id="javascript-10" role="tab" aria-selected="false" aria-controls="panel-javascript-10-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-JavaScript"> JavaScript</div></li>
</ul>
<div>
<div id="panel-cli-10-0" role="tabpanel" aria-labelledby="cli-10" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build --compile --compile-exec-argv="--smol --user-agent=MyBot" ./app.ts --outfile myapp
</pre></div>
<div id="panel-javascript-10-1" role="tabpanel" aria-labelledby="javascript-10" data-component-part="tab-content"><pre numberoflines="7" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ["./app.ts"],
  compile: {
    execArgv: ["--smol", "--user-agent=MyBot"],
    outfile: "./myapp",
  },
});
</pre></div>
</div>
</div> <pre numberoflines="2" language="typescript" data-language="typescript">// In the compiled app
console.log(process.execArgv); // ["--smol", "--user-agent=MyBot"]
</pre> <hr> <h2 id="automatic-config-loading"><span>Automatic config loading</span></h2> <span data-as="p">Standalone executables can automatically load configuration files from the directory where they are run. By default:</span> <ul> <li>
<strong><code>tsconfig.json</code></strong> and <strong><code>package.json</code></strong> loading is <strong>disabled</strong> — these are typically only needed at development time, and the bundler already uses them when compiling</li> <li>
<strong><code>.env</code></strong> and <strong><code>bunfig.toml</code></strong> loading is <strong>enabled</strong> — these often contain runtime configuration that may vary per deployment</li> </ul> <div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p">In a future version of Bun, <code>.env</code> and <code>bunfig.toml</code> may also be disabled by default for more deterministic behavior.</span></div>
</div> <h3 id="enabling-config-loading-at-runtime"><span>Enabling config loading at runtime</span></h3> <span data-as="p">If your executable needs to read <code>tsconfig.json</code> or <code>package.json</code> at runtime, you can opt in with the new CLI flags:</span> <pre numberoflines="8" language="shellscript" data-language="typescript"># Enable runtime loading of tsconfig.json
bun build --compile --compile-autoload-tsconfig ./app.ts --outfile myapp

# Enable runtime loading of package.json
bun build --compile --compile-autoload-package-json ./app.ts --outfile myapp

# Enable both
bun build --compile --compile-autoload-tsconfig --compile-autoload-package-json ./app.ts --outfile myapp
</pre> <h3 id="disabling-config-loading-at-runtime"><span>Disabling config loading at runtime</span></h3> <span data-as="p">To disable <code>.env</code> or <code>bunfig.toml</code> loading for deterministic execution:</span> <div id="cli-11">
<ul role="tablist" data-component-part="tabs-list">
<li id="cli-11" role="tab" aria-selected="true" aria-controls="panel-cli-11-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-CLI"> CLI</div></li>
<li id="javascript-11" role="tab" aria-selected="false" aria-controls="panel-javascript-11-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-JavaScript"> JavaScript</div></li>
</ul>
<div>
<div id="panel-cli-11-0" role="tabpanel" aria-labelledby="cli-11" data-component-part="tab-content"><pre numberoflines="8" language="shellscript" data-language="typescript"># Disable .env loading
bun build --compile --no-compile-autoload-dotenv ./app.ts --outfile myapp

# Disable bunfig.toml loading
bun build --compile --no-compile-autoload-bunfig ./app.ts --outfile myapp

# Disable all config loading
bun build --compile --no-compile-autoload-dotenv --no-compile-autoload-bunfig ./app.ts --outfile myapp
</pre></div>
<div id="panel-javascript-11-1" role="tabpanel" aria-labelledby="javascript-11" data-component-part="tab-content"><pre numberoflines="13" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ["./app.ts"],
  compile: {
    // tsconfig.json and package.json are disabled by default
    autoloadTsconfig: true, // Enable tsconfig.json loading
    autoloadPackageJson: true, // Enable package.json loading

    // .env and bunfig.toml are enabled by default
    autoloadDotenv: false, // Disable .env loading
    autoloadBunfig: false, // Disable bunfig.toml loading
    outfile: "./myapp",
  },
});
</pre></div>
</div>
</div> <hr> <h2 id="act-as-the-bun-cli"><span>Act as the Bun CLI</span></h2> <div data-callout-type="note">

<div data-component-part="callout-content">New in Bun v1.2.16</div>
</div> <span data-as="p">You can run a standalone executable as if it were the <code>bun</code> CLI itself by setting the <code>BUN_BE_BUN=1</code> environment variable. When this variable is set, the executable will ignore its bundled entrypoint and instead expose all the features of Bun’s CLI.</span> <span data-as="p">For example, consider an executable compiled from a simple script:</span> <pre numberoflines="2" language="shellscript" data-language="typescript">echo "console.log(\"you shouldn't see this\");" &gt; such-bun.js
bun build --compile ./such-bun.js
</pre> <pre numberoflines="3" language="text" data-language="typescript">[3ms] bundle 1 modules
[89ms] compile such-bun
</pre> <span data-as="p">Normally, running <code>./such-bun</code> with arguments would execute the script.</span> <pre numberoflines="2" language="shellscript" data-language="typescript"># Executable runs its own entrypoint by default
./such-bun install
</pre> <pre numberoflines="2" language="text" data-language="typescript">you shouldn't see this
</pre> <span data-as="p">However, with the <code>BUN_BE_BUN=1</code> environment variable, it acts just like the <code>bun</code> binary:</span> <pre numberoflines="2" language="shellscript" data-language="typescript"># With the env var, the executable acts like the `bun` CLI
BUN_BE_BUN=1 ./such-bun install
</pre> <pre numberoflines="3" language="text" data-language="typescript">bun install v1.2.16-canary.1 (1d1db811)
Checked 63 installs across 64 packages (no changes) [5.00ms]
</pre> <span data-as="p">This is useful for building CLI tools on top of Bun that may need to install packages, bundle dependencies, run different or local files and more without needing to download a separate binary or install bun.</span> <hr> <h2 id="full-stack-executables"><span>Full-stack executables</span></h2> <div data-callout-type="note">

<div data-component-part="callout-content">New in Bun v1.2.17</div>
</div> <span data-as="p">Bun’s <code>--compile</code> flag can create standalone executables that contain both server and client code, making it ideal for full-stack applications. When you import an HTML file in your server code, Bun automatically bundles all frontend assets (JavaScript, CSS, etc.) and embeds them into the executable. When Bun sees the HTML import on the server, it kicks off a frontend build process to bundle JavaScript, CSS, and other assets.</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">server.tsindex.htmlapp.tsstyles.cssimport { serve } from "bun";
import index from "./index.html";

const server = serve({
  routes: {
    "/": index,
    "/api/hello": { GET: () =&gt; Response.json({ message: "Hello from API" }) },
  },
});

console.log(`Server running at http://localhost:${server.port}`);
</pre> <span data-as="p">To build this into a single executable:</span> <div id="cli-12">
<ul role="tablist" data-component-part="tabs-list">
<li id="cli-12" role="tab" aria-selected="true" aria-controls="panel-cli-12-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-CLI"> CLI</div></li>
<li id="javascript-12" role="tab" aria-selected="false" aria-controls="panel-javascript-12-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-JavaScript"> JavaScript</div></li>
</ul>
<div>
<div id="panel-cli-12-0" role="tabpanel" aria-labelledby="cli-12" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build --compile ./server.ts --outfile myapp
</pre></div>
<div id="panel-javascript-12-1" role="tabpanel" aria-labelledby="javascript-12" data-component-part="tab-content"><pre numberoflines="6" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ["./server.ts"],
  compile: {
    outfile: "./myapp",
  },
});
</pre></div>
</div>
</div> <span data-as="p">This creates a self-contained binary that includes:</span> <ul> <li>Your server code</li> <li>The Bun runtime</li> <li>All frontend assets (HTML, CSS, JavaScript)</li> <li>Any npm packages used by your server</li> </ul> <span data-as="p">The result is a single file that can be deployed anywhere without needing Node.js, Bun, or any dependencies installed. Just run:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">./myapp
</pre> <span data-as="p">Bun automatically handles serving the frontend assets with proper MIME types and cache headers. The HTML import is replaced with a manifest object that <code>Bun.serve</code> uses to efficiently serve pre-bundled assets.</span> <span data-as="p">For more details on building full-stack applications with Bun, see the <a href="fullstack">full-stack guide</a>.</span> <hr> <h2 id="worker"><span>Worker</span></h2> <span data-as="p">To use workers in a standalone executable, add the worker’s entrypoint to the build:</span> <div id="cli-13">
<ul role="tablist" data-component-part="tabs-list">
<li id="cli-13" role="tab" aria-selected="true" aria-controls="panel-cli-13-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-CLI"> CLI</div></li>
<li id="javascript-13" role="tab" aria-selected="false" aria-controls="panel-javascript-13-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-JavaScript"> JavaScript</div></li>
</ul>
<div>
<div id="panel-cli-13-0" role="tabpanel" aria-labelledby="cli-13" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build --compile ./index.ts ./my-worker.ts --outfile myapp
</pre></div>
<div id="panel-javascript-13-1" role="tabpanel" aria-labelledby="javascript-13" data-component-part="tab-content"><pre numberoflines="6" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ["./index.ts", "./my-worker.ts"],
  compile: {
    outfile: "./myapp",
  },
});
</pre></div>
</div>
</div> <span data-as="p">Then, reference the worker in your code:</span> <pre numberoflines="6" language="typescript" data-language="typescript">console.log("Hello from Bun!");

// Any of these will work:
new Worker("./my-worker.ts");
new Worker(new URL("./my-worker.ts", import.meta.url));
new Worker(new URL("./my-worker.ts", import.meta.url).href);
</pre> <span data-as="p">When you add multiple entrypoints to a standalone executable, they will be bundled separately into the executable.</span> <span data-as="p">In the future, we may automatically detect usages of statically-known paths in <code>new Worker(path)</code> and then bundle those into the executable, but for now, you’ll need to add it to the shell command manually like the above example.</span> <span data-as="p">If you use a relative path to a file not included in the standalone executable, it will attempt to load that path from disk relative to the current working directory of the process (and then error if it doesn’t exist).</span> <hr> <h2 id="sqlite"><span>SQLite</span></h2> <span data-as="p">You can use <code>bun:sqlite</code> imports with <code>bun build --compile</code>.</span> <span data-as="p">By default, the database is resolved relative to the current working directory of the process.</span> <pre numberoflines="3" language="typescript" data-language="typescript">import db from "./my.db" with { type: "sqlite" };

console.log(db.query("select * from users LIMIT 1").get());
</pre> <span data-as="p">That means if the executable is located at <code>/usr/bin/hello</code>, the user’s terminal is located at <code>/home/me/Desktop</code>, it will look for <code>/home/me/Desktop/my.db</code>.</span> <pre numberoflines="2" language="shellscript" data-language="typescript">cd /home/me/Desktop
./hello
</pre> <hr> <h2 id="embed-assets-&amp;-files"><span>Embed assets &amp; files</span></h2> <span data-as="p">Standalone executables support embedding files directly into the binary. This lets you ship a single executable that contains images, JSON configs, templates, or any other assets your application needs.</span> <h3 id="how-it-works"><span>How it works</span></h3> <span data-as="p">Use the <code>with { type: "file" }</code> <a href="https://github.com/tc39/proposal-import-attributes" target="_blank" rel="noreferrer">import attribute</a> to embed a file:</span> <pre numberoflines="5" language="typescript" data-language="typescript">import icon from "./icon.png" with { type: "file" };

console.log(icon);
// During development: "./icon.png"
// After compilation: "$bunfs/icon-a1b2c3d4.png" (internal path)
</pre> <span data-as="p">The import returns a <strong>path string</strong> that points to the embedded file. At build time, Bun:</span> <ol> <li>Reads the file contents</li> <li>Embeds the data into the executable</li> <li>Replaces the import with an internal path (prefixed with <code>$bunfs/</code>)</li> </ol> <span data-as="p">You can then read this embedded file using <code>Bun.file()</code> or Node.js <code>fs</code> APIs.</span> <h3 id="reading-embedded-files-with-bun-file"><span>Reading embedded files with Bun.file()</span></h3> <span data-as="p"><code>Bun.file()</code> is the recommended way to read embedded files:</span> <pre numberoflines="16" language="typescript" data-language="typescript">import icon from "./icon.png" with { type: "file" };
import { file } from "bun";

// Get file contents as different types
const bytes = await file(icon).arrayBuffer(); // ArrayBuffer
const text = await file(icon).text(); // string (for text files)
const blob = file(icon); // Blob

// Stream the file in a response
export default {
  fetch(req) {
    return new Response(file(icon), {
      headers: { "Content-Type": "image/png" },
    });
  },
};
</pre> <h3 id="reading-embedded-files-with-node-js-fs"><span>Reading embedded files with Node.js fs</span></h3> <span data-as="p">Embedded files work seamlessly with Node.js file system APIs:</span> <pre numberoflines="14" language="typescript" data-language="typescript">import icon from "./icon.png" with { type: "file" };
import config from "./config.json" with { type: "file" };
import { readFileSync, promises as fs } from "node:fs";

// Synchronous read
const iconBuffer = readFileSync(icon);

// Async read
const configData = await fs.readFile(config, "utf-8");
const parsed = JSON.parse(configData);

// Check file stats
const stats = await fs.stat(icon);
console.log(`Icon size: ${stats.size} bytes`);
</pre> <h3 id="practical-examples"><span>Practical examples</span></h3> <h4 id="embedding-a-json-config-file"><span>Embedding a JSON config file</span></h4> <pre numberoflines="11" language="typescript" data-language="typescript">import configPath from "./default-config.json" with { type: "file" };
import { file } from "bun";

// Load the embedded default configuration
const defaultConfig = await file(configPath).json();

// Merge with user config if it exists
const userConfig = await file("./user-config.json")
  .json()
  .catch(() =&gt; ({}));
const config = { ...defaultConfig, ...userConfig };
</pre> <h4 id="serving-static-assets-in-an-http-server"><span>Serving static assets in an HTTP server</span></h4> <span data-as="p">Use <code>static</code> routes in <code>Bun.serve()</code> for efficient static file serving:</span> <pre numberoflines="15" language="typescript" data-language="typescript">import favicon from "./favicon.ico" with { type: "file" };
import logo from "./logo.png" with { type: "file" };
import styles from "./styles.css" with { type: "file" };
import { file, serve } from "bun";

serve({
  static: {
    "/favicon.ico": file(favicon),
    "/logo.png": file(logo),
    "/styles.css": file(styles),
  },
  fetch(req) {
    return new Response("Not found", { status: 404 });
  },
});
</pre> <span data-as="p">Bun automatically handles Content-Type headers and caching for static routes.</span> <h4 id="embedding-templates"><span>Embedding templates</span></h4> <pre numberoflines="9" language="typescript" data-language="typescript">import templatePath from "./email-template.html" with { type: "file" };
import { file } from "bun";

async function sendWelcomeEmail(user: { name: string; email: string }) {
  const template = await file(templatePath).text();
  const html = template.replace("{{name}}", user.name).replace("{{email}}", user.email);

  // Send email with the rendered template...
}
</pre> <h4 id="embedding-binary-files"><span>Embedding binary files</span></h4> <pre numberoflines="10" language="typescript" data-language="typescript">import wasmPath from "./processor.wasm" with { type: "file" };
import fontPath from "./font.ttf" with { type: "file" };
import { file } from "bun";

// Load a WebAssembly module
const wasmBytes = await file(wasmPath).arrayBuffer();
const wasmModule = await WebAssembly.instantiate(wasmBytes);

// Read binary font data
const fontData = await file(fontPath).bytes();
</pre> <h3 id="embed-sqlite-databases"><span>Embed SQLite databases</span></h3> <span data-as="p">If your application wants to embed a SQLite database into the compiled executable, set <code>type: "sqlite"</code> in the import attribute and the <code>embed</code> attribute to <code>"true"</code>.</span> <span data-as="p">The database file must already exist on disk. Then, import it in your code:</span> <pre numberoflines="3" language="typescript" data-language="typescript">import myEmbeddedDb from "./my.db" with { type: "sqlite", embed: "true" };

console.log(myEmbeddedDb.query("select * from users LIMIT 1").get());
</pre> <span data-as="p">Finally, compile it into a standalone executable:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun build --compile ./index.ts --outfile mycli
</pre> <div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p">The database file must exist on disk when you run <code>bun build --compile</code>. The <code>embed: "true"</code> attribute tells the bundler to include the database contents inside the compiled executable. When running normally with <code>bun run</code>, the database file is loaded from disk just like a regular SQLite import.</span></div>
</div> <span data-as="p">In the compiled executable, the embedded database is read-write, but all changes are lost when the executable exits (since it’s stored in memory).</span> <h3 id="embed-n-api-addons"><span>Embed N-API Addons</span></h3> <span data-as="p">You can embed <code>.node</code> files into executables.</span> <pre numberoflines="3" language="typescript" data-language="typescript">const addon = require("./addon.node");

console.log(addon.hello());
</pre> <span data-as="p">Unfortunately, if you’re using <code>@mapbox/node-pre-gyp</code> or other similar tools, you’ll need to make sure the <code>.node</code> file is directly required or it won’t bundle correctly.</span> <h3 id="embed-directories"><span>Embed directories</span></h3> <span data-as="p">To embed a directory with <code>bun build --compile</code>, include file patterns in your build:</span> <div id="cli-14">
<ul role="tablist" data-component-part="tabs-list">
<li id="cli-14" role="tab" aria-selected="true" aria-controls="panel-cli-14-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-CLI"> CLI</div></li>
<li id="javascript-14" role="tab" aria-selected="false" aria-controls="panel-javascript-14-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-JavaScript"> JavaScript</div></li>
</ul>
<div>
<div id="panel-cli-14-0" role="tabpanel" aria-labelledby="cli-14" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build --compile ./index.ts ./public/**/*.png
</pre></div>
<div id="panel-javascript-14-1" role="tabpanel" aria-labelledby="javascript-14" data-component-part="tab-content"><pre numberoflines="12" language="typescript" data-language="typescript">import { Glob } from "bun";

// Expand glob pattern to file list
const glob = new Glob("./public/**/*.png");
const pngFiles = Array.from(glob.scanSync("."));

await Bun.build({
  entrypoints: ["./index.ts", ...pngFiles],
  compile: {
    outfile: "./myapp",
  },
});
</pre></div>
</div>
</div> <span data-as="p">Then, you can reference the files in your code:</span> <pre numberoflines="9" language="typescript" data-language="typescript">import icon from "./public/assets/icon.png" with { type: "file" };
import { file } from "bun";

export default {
  fetch(req) {
    // Embedded files can be streamed from Response objects
    return new Response(file(icon));
  },
};
</pre> <span data-as="p">This is honestly a workaround, and we expect to improve this in the future with a more direct API.</span> <h3 id="listing-embedded-files"><span>Listing embedded files</span></h3> <span data-as="p"><code>Bun.embeddedFiles</code> gives you access to all embedded files as <code>Blob</code> objects:</span> <pre numberoflines="13" language="typescript" data-language="typescript">import "./icon.png" with { type: "file" };
import "./data.json" with { type: "file" };
import "./template.html" with { type: "file" };
import { embeddedFiles } from "bun";

// List all embedded files
for (const blob of embeddedFiles) {
  console.log(`${blob.name} - ${blob.size} bytes`);
}
// Output:
//   icon-a1b2c3d4.png - 4096 bytes
//   data-e5f6g7h8.json - 256 bytes
//   template-i9j0k1l2.html - 1024 bytes
</pre> <span data-as="p">Each item in <code>Bun.embeddedFiles</code> is a <code>Blob</code> with a <code>name</code> property:</span> <pre numberoflines="1" language="typescript" data-language="typescript">embeddedFiles: ReadonlyArray&lt;Blob&gt;;
</pre> <span data-as="p">This is useful for dynamically serving all embedded assets using <code>static</code> routes:</span> <pre numberoflines="19" language="typescript" data-language="typescript">import "./public/favicon.ico" with { type: "file" };
import "./public/logo.png" with { type: "file" };
import "./public/styles.css" with { type: "file" };
import { embeddedFiles, serve } from "bun";

// Build static routes from all embedded files
const staticRoutes: Record&lt;string, Blob&gt; = {};
for (const blob of embeddedFiles) {
  // Remove hash from filename: "icon-a1b2c3d4.png" -&gt; "icon.png"
  const name = blob.name.replace(/-[a-f0-9]+\./, ".");
  staticRoutes[`/${name}`] = blob;
}

serve({
  static: staticRoutes,
  fetch(req) {
    return new Response("Not found", { status: 404 });
  },
});
</pre> <div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p"><code>Bun.embeddedFiles</code> excludes bundled source code (<code>.ts</code>, <code>.js</code>, etc.) to help protect your application’s source.</span></div>
</div> <h4 id="content-hash"><span>Content hash</span></h4> <span data-as="p">By default, embedded files have a content hash appended to their name. This is useful for situations where you want to serve the file from a URL or CDN and have fewer cache invalidation issues. But sometimes, this is unexpected and you might want the original name instead:</span> <span data-as="p">To disable the content hash, configure asset naming:</span> <div id="cli-15">
<ul role="tablist" data-component-part="tabs-list">
<li id="cli-15" role="tab" aria-selected="true" aria-controls="panel-cli-15-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-CLI"> CLI</div></li>
<li id="javascript-15" role="tab" aria-selected="false" aria-controls="panel-javascript-15-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-JavaScript"> JavaScript</div></li>
</ul>
<div>
<div id="panel-cli-15-0" role="tabpanel" aria-labelledby="cli-15" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build --compile --asset-naming="[name].[ext]" ./index.ts
</pre></div>
<div id="panel-javascript-15-1" role="tabpanel" aria-labelledby="javascript-15" data-component-part="tab-content"><pre numberoflines="9" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ["./index.ts"],
  compile: {
    outfile: "./myapp",
  },
  naming: {
    asset: "[name].[ext]",
  },
});
</pre></div>
</div>
</div> <hr> <h2 id="minification"><span>Minification</span></h2> <span data-as="p">To trim down the size of the executable, enable minification:</span> <div id="cli-16">
<ul role="tablist" data-component-part="tabs-list">
<li id="cli-16" role="tab" aria-selected="true" aria-controls="panel-cli-16-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-CLI"> CLI</div></li>
<li id="javascript-16" role="tab" aria-selected="false" aria-controls="panel-javascript-16-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-JavaScript"> JavaScript</div></li>
</ul>
<div>
<div id="panel-cli-16-0" role="tabpanel" aria-labelledby="cli-16" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build --compile --minify ./index.ts --outfile myapp
</pre></div>
<div id="panel-javascript-16-1" role="tabpanel" aria-labelledby="javascript-16" data-component-part="tab-content"><pre numberoflines="20" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ["./index.ts"],
  compile: {
    outfile: "./myapp",
  },
  minify: true, // Enable all minification
});

// Or granular control:
await Bun.build({
  entrypoints: ["./index.ts"],
  compile: {
    outfile: "./myapp",
  },
  minify: {
    whitespace: true,
    syntax: true,
    identifiers: true,
  },
});
</pre></div>
</div>
</div> <span data-as="p">This uses Bun’s minifier to reduce the code size. Overall though, Bun’s binary is still way too big and we need to make it smaller.</span> <hr> <h2 id="windows-specific-flags"><span>Windows-specific flags</span></h2> <span data-as="p">When compiling a standalone executable on Windows, there are platform-specific options to customize metadata on the generated <code>.exe</code> file:</span> <div id="cli-17">
<ul role="tablist" data-component-part="tabs-list">
<li id="cli-17" role="tab" aria-selected="true" aria-controls="panel-cli-17-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-CLI"> CLI</div></li>
<li id="javascript-17" role="tab" aria-selected="false" aria-controls="panel-javascript-17-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-JavaScript"> JavaScript</div></li>
</ul>
<div>
<div id="panel-cli-17-0" role="tabpanel" aria-labelledby="cli-17" data-component-part="tab-content"><pre numberoflines="5" language="shellscript" data-language="typescript"># Custom icon
bun build --compile --windows-icon=path/to/icon.ico ./app.ts --outfile myapp

# Hide console window (for GUI apps)
bun build --compile --windows-hide-console ./app.ts --outfile myapp
</pre></div>
<div id="panel-javascript-17-1" role="tabpanel" aria-labelledby="javascript-17" data-component-part="tab-content"><pre numberoflines="16" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ["./app.ts"],
  compile: {
    outfile: "./myapp",
    windows: {
      icon: "./path/to/icon.ico",
      hideConsole: true,
      // Additional Windows metadata:
      title: "My Application",
      publisher: "My Company",
      version: "1.0.0",
      description: "A standalone Windows application",
      copyright: "Copyright 2024",
    },
  },
});
</pre></div>
</div>
</div> <span data-as="p">Available Windows options:</span> <ul> <li>
<code>icon</code> - Path to <code>.ico</code> file for the executable icon</li> <li>
<code>hideConsole</code> - Disable the background terminal (for GUI apps)</li> <li>
<code>title</code> - Application title in file properties</li> <li>
<code>publisher</code> - Publisher name in file properties</li> <li>
<code>version</code> - Version string in file properties</li> <li>
<code>description</code> - Description in file properties</li> <li>
<code>copyright</code> - Copyright notice in file properties</li> </ul> <div data-callout-type="warning">

<div data-component-part="callout-content">These flags currently cannot be used when cross-compiling because they depend on Windows APIs.</div>
</div> <hr> <h2 id="code-signing-on-macos"><span>Code signing on macOS</span></h2> <span data-as="p">To codesign a standalone executable on macOS (which fixes Gatekeeper warnings), use the <code>codesign</code> command.</span> <pre numberoflines="1" language="shellscript" data-language="typescript">codesign --deep --force -vvvv --sign "XXXXXXXXXX" ./myapp
</pre> <span data-as="p">We recommend including an <code>entitlements.plist</code> file with JIT permissions.</span> <pre numberoflines="16" language="xml" data-language="typescript">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
    &lt;key&gt;com.apple.security.cs.allow-jit&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;com.apple.security.cs.allow-unsigned-executable-memory&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;com.apple.security.cs.disable-executable-page-protection&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;com.apple.security.cs.allow-dyld-environment-variables&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;com.apple.security.cs.disable-library-validation&lt;/key&gt;
    &lt;true/&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</pre> <span data-as="p">To codesign with JIT support, pass the <code>--entitlements</code> flag to <code>codesign</code>.</span> <pre numberoflines="1" language="shellscript" data-language="typescript">codesign --deep --force -vvvv --sign "XXXXXXXXXX" --entitlements entitlements.plist ./myapp
</pre> <span data-as="p">After codesigning, verify the executable:</span> <pre numberoflines="3" language="shellscript" data-language="typescript">codesign -vvv --verify ./myapp
./myapp: valid on disk
./myapp: satisfies its Designated Requirement
</pre> <div data-callout-type="warning">

<div data-component-part="callout-content">Codesign support requires Bun v1.2.4 or newer.</div>
</div> <hr> <h2 id="code-splitting"><span>Code splitting</span></h2> <span data-as="p">Standalone executables support code splitting. Use <code>--compile</code> with <code>--splitting</code> to create an executable that loads code-split chunks at runtime.</span> <div id="cli-18">
<ul role="tablist" data-component-part="tabs-list">
<li id="cli-18" role="tab" aria-selected="true" aria-controls="panel-cli-18-0" tabindex="0"><div data-component-part="tab-button" data-active="true" data-testid="tab-CLI"> CLI</div></li>
<li id="javascript-18" role="tab" aria-selected="false" aria-controls="panel-javascript-18-1" tabindex="-1"><div data-component-part="tab-button" data-active="false" data-testid="tab-JavaScript"> JavaScript</div></li>
</ul>
<div>
<div id="panel-cli-18-0" role="tabpanel" aria-labelledby="cli-18" data-component-part="tab-content"><pre numberoflines="1" language="shellscript" data-language="typescript">bun build --compile --splitting ./src/entry.ts --outdir ./build
</pre></div>
<div id="panel-javascript-18-1" role="tabpanel" aria-labelledby="javascript-18" data-component-part="tab-content"><pre numberoflines="6" language="typescript" data-language="typescript">await Bun.build({
  entrypoints: ["./src/entry.ts"],
  compile: true,
  splitting: true,
  outdir: "./build",
});
</pre></div>
</div>
</div> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">src/entry.tssrc/lazy.tsconsole.log("Entrypoint loaded");
const lazy = await import("./lazy.ts");
lazy.hello();
</pre> <pre numberoflines="1" language="shellscript" data-language="typescript">./build/entry
</pre> <pre numberoflines="3" language="text" data-language="typescript">Entrypoint loaded
Lazy module loaded
</pre> <hr> <h2 id="using-plugins"><span>Using plugins</span></h2> <span data-as="p">Plugins work with standalone executables, allowing you to transform files during the build process:</span> <pre numberoflines="24" language="typescript" data-language="typescript">import type { BunPlugin } from "bun";

const envPlugin: BunPlugin = {
  name: "env-loader",
  setup(build) {
    build.onLoad({ filter: /\.env\.json$/ }, async args =&gt; {
      // Transform .env.json files into validated config objects
      const env = await Bun.file(args.path).json();

      return {
        contents: `export default ${JSON.stringify(env)};`,
        loader: "js",
      };
    });
  },
};

await Bun.build({
  entrypoints: ["./cli.ts"],
  compile: {
    outfile: "./mycli",
  },
  plugins: [envPlugin],
});
</pre> <span data-as="p">Example use case - embedding environment config at build time:</span> <pre numberoflines="4" language="typescript" data-language="typescript">import config from "./config.env.json";

console.log(`Running in ${config.environment} mode`);
console.log(`API endpoint: ${config.apiUrl}`);
</pre> <span data-as="p">Plugins can perform any transformation: compile YAML/TOML configs, inline SQL queries, generate type-safe API clients, or preprocess templates. Refer to the <a href="plugins">plugin documentation</a> for more details.</span> <hr> <h2 id="unsupported-cli-arguments"><span>Unsupported CLI arguments</span></h2> <span data-as="p">Currently, the <code>--compile</code> flag can only accept a single entrypoint at a time and does not support the following flags:</span> <ul> <li>
<code>--outdir</code> — use <code>outfile</code> instead (except when using with <code>--splitting</code>).</li> <li><code>--public-path</code></li> <li>
<code>--target=node</code> or <code>--target=browser</code>
</li> <li>
<code>--no-bundle</code> - we always bundle everything into the executable.</li> </ul> <hr> <h2 id="api-reference"><span>API reference</span></h2> <span data-as="p">The <code>compile</code> option in <code>Bun.build()</code> accepts three forms:</span> <pre numberoflines="24" language="typescript" data-language="typescript">interface BuildConfig {
  entrypoints: string[];
  compile: boolean | Bun.Build.Target | CompileBuildOptions;
  // ... other BuildConfig options (minify, sourcemap, define, plugins, etc.)
}

interface CompileBuildOptions {
  target?: Bun.Build.Target; // Cross-compilation target
  outfile?: string; // Output executable path
  execArgv?: string[]; // Runtime arguments (process.execArgv)
  autoloadTsconfig?: boolean; // Load tsconfig.json (default: false)
  autoloadPackageJson?: boolean; // Load package.json (default: false)
  autoloadDotenv?: boolean; // Load .env files (default: true)
  autoloadBunfig?: boolean; // Load bunfig.toml (default: true)
  windows?: {
    icon?: string; // Path to .ico file
    hideConsole?: boolean; // Hide console window
    title?: string; // Application title
    publisher?: string; // Publisher name
    version?: string; // Version string
    description?: string; // Description
    copyright?: string; // Copyright notice
  };
}
</pre> <span data-as="p">Usage forms:</span> <pre numberoflines="11" language="typescript" data-language="typescript">// Simple boolean - compile for current platform (uses entrypoint name as output)
compile: true

// Target string - cross-compile (uses entrypoint name as output)
compile: "bun-linux-x64"

// Full options object - specify outfile and other options
compile: {
  target: "bun-linux-x64",
  outfile: "./myapp",
}
</pre> <h3 id="supported-targets-2"><span>Supported targets</span></h3> <pre numberoflines="13" language="typescript" data-language="typescript">type Target =
  | "bun-darwin-x64"
  | "bun-darwin-x64-baseline"
  | "bun-darwin-arm64"
  | "bun-linux-x64"
  | "bun-linux-x64-baseline"
  | "bun-linux-x64-modern"
  | "bun-linux-arm64"
  | "bun-linux-x64-musl"
  | "bun-linux-arm64-musl"
  | "bun-windows-x64"
  | "bun-windows-x64-baseline"
  | "bun-windows-x64-modern";
</pre> <h3 id="complete-example"><span>Complete example</span></h3> <pre numberoflines="31" language="typescript" data-language="typescript">import type { BunPlugin } from "bun";

const myPlugin: BunPlugin = {
  name: "my-plugin",
  setup(build) {
    // Plugin implementation
  },
};

const result = await Bun.build({
  entrypoints: ["./src/cli.ts"],
  compile: {
    target: "bun-linux-x64",
    outfile: "./dist/mycli",
    execArgv: ["--smol"],
    autoloadDotenv: false,
    autoloadBunfig: false,
  },
  minify: true,
  sourcemap: "linked",
  bytecode: true,
  define: {
    "process.env.NODE_ENV": JSON.stringify("production"),
    VERSION: JSON.stringify("1.0.0"),
  },
  plugins: [myPlugin],
});

if (result.success) {
  console.log("Build successful:", result.outputs[0].path);
}
</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/bundler/executables" class="_attribution-link">https://bun.com/docs/bundler/executables</a>
  </p>
</div>
