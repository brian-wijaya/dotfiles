<h1 id="header">Shell</h1>
<div data-page-title="Shell" data-page-href="/runtime/shell" id="content">
<span data-as="p">Bun Shell makes shell scripting with JavaScript &amp; TypeScript fun. It’s a cross-platform bash-like shell with seamless JavaScript interop.</span> <span data-as="p">Quickstart:</span> <pre numberoflines="6" language="typescript" data-language="typescript">import { $ } from "bun";

const response = await fetch("https://example.com");

// Use Response as stdin.
await $`cat &lt; ${response} | wc -c`; // 1256
</pre> <hr> <h2 id="features"><span>Features</span></h2> <ul> <li>
<strong>Cross-platform</strong>: works on Windows, Linux &amp; macOS. Instead of <code>rimraf</code> or <code>cross-env</code>’, you can use Bun Shell without installing extra dependencies. Common shell commands like <code>ls</code>, <code>cd</code>, <code>rm</code> are implemented natively.</li> <li>
<strong>Familiar</strong>: Bun Shell is a bash-like shell, supporting redirection, pipes, environment variables and more.</li> <li>
<strong>Globs</strong>: Glob patterns are supported natively, including <code>**</code>, <code>*</code>, <code>{expansion}</code>, and more.</li> <li>
<strong>Template literals</strong>: Template literals are used to execute shell commands. This allows for easy interpolation of variables and expressions.</li> <li>
<strong>Safety</strong>: Bun Shell escapes all strings by default, preventing shell injection attacks.</li> <li>
<strong>JavaScript interop</strong>: Use <code>Response</code>, <code>ArrayBuffer</code>, <code>Blob</code>, <code>Bun.file(path)</code> and other JavaScript objects as stdin, stdout, and stderr.</li> <li>
<strong>Shell scripting</strong>: Bun Shell can be used to run shell scripts (<code>.bun.sh</code> files).</li> <li>
<strong>Custom interpreter</strong>: Bun Shell is written in Zig, along with its lexer, parser, and interpreter. Bun Shell is a small programming language.</li> </ul> <hr> <h2 id="getting-started"><span>Getting started</span></h2> <span data-as="p">The simplest shell command is <code>echo</code>. To run it, use the <code>$</code> template literal tag:</span> <pre numberoflines="3" language="javascript" data-language="typescript">import { $ } from "bun";

await $`echo "Hello World!"`; // Hello World!
</pre> <span data-as="p">By default, shell commands print to stdout. To quiet the output, call <code>.quiet()</code>:</span> <pre numberoflines="3" language="javascript" data-language="typescript">import { $ } from "bun";

await $`echo "Hello World!"`.quiet(); // No output
</pre> <span data-as="p">What if you want to access the output of the command as text? Use <code>.text()</code>:</span> <pre numberoflines="6" language="javascript" data-language="typescript">import { $ } from "bun";

// .text() automatically calls .quiet() for you
const welcome = await $`echo "Hello World!"`.text();

console.log(welcome); // Hello World!\n
</pre> <span data-as="p">By default, <code>await</code>ing will return stdout and stderr as <code>Buffer</code>s.</span> <pre numberoflines="6" language="javascript" data-language="typescript">import { $ } from "bun";

const { stdout, stderr } = await $`echo "Hello!"`.quiet();

console.log(stdout); // Buffer(7) [ 72, 101, 108, 108, 111, 33, 10 ]
console.log(stderr); // Buffer(0) []
</pre> <hr> <h2 id="error-handling"><span>Error handling</span></h2> <span data-as="p">By default, non-zero exit codes will throw an error. This <code>ShellError</code> contains information about the command run.</span> <pre numberoflines="10" language="javascript" data-language="typescript">import { $ } from "bun";

try {
  const output = await $`something-that-may-fail`.text();
  console.log(output);
} catch (err) {
  console.log(`Failed with code ${err.exitCode}`);
  console.log(err.stdout.toString());
  console.log(err.stderr.toString());
}
</pre> <span data-as="p">Throwing can be disabled with <code>.nothrow()</code>. The result’s <code>exitCode</code> will need to be checked manually.</span> <pre numberoflines="10" language="javascript" data-language="typescript">import { $ } from "bun";

const { stdout, stderr, exitCode } = await $`something-that-may-fail`.nothrow().quiet();

if (exitCode !== 0) {
  console.log(`Non-zero exit code ${exitCode}`);
}

console.log(stdout);
console.log(stderr);
</pre> <span data-as="p">The default handling of non-zero exit codes can be configured by calling <code>.nothrow()</code> or <code>.throws(boolean)</code> on the <code>$</code> function itself.</span> <pre numberoflines="12" language="javascript" data-language="typescript">import { $ } from "bun";
// shell promises will not throw, meaning you will have to
// check for `exitCode` manually on every shell command.
$.nothrow(); // equivalent to $.throws(false)

// default behavior, non-zero exit codes will throw an error
$.throws(true);

// alias for $.nothrow()
$.throws(false);

await $`something-that-may-fail`; // No exception thrown
</pre> <hr> <h2 id="redirection"><span>Redirection</span></h2> <span data-as="p">A command’s <em>input</em> or <em>output</em> may be <em>redirected</em> using the typical Bash operators:</span> <ul> <li>
<code>&lt;</code> redirect stdin</li> <li>
<code>&gt;</code> or <code>1&gt;</code> redirect stdout</li> <li>
<code>2&gt;</code> redirect stderr</li> <li>
<code>&amp;&gt;</code> redirect both stdout and stderr</li> <li>
<code>&gt;&gt;</code> or <code>1&gt;&gt;</code> redirect stdout, <em>appending</em> to the destination, instead of overwriting</li> <li>
<code>2&gt;&gt;</code> redirect stderr, <em>appending</em> to the destination, instead of overwriting</li> <li>
<code>&amp;&gt;&gt;</code> redirect both stdout and stderr, <em>appending</em> to the destination, instead of overwriting</li> <li>
<code>1&gt;&amp;2</code> redirect stdout to stderr (all writes to stdout will instead be in stderr)</li> <li>
<code>2&gt;&amp;1</code> redirect stderr to stdout (all writes to stderr will instead be in stdout)</li> </ul> <span data-as="p">Bun Shell also supports redirecting from and to JavaScript objects.</span> <h3 id="example:-redirect-output-to-javascript-objects-&gt;"><span>Example: Redirect output to JavaScript objects (<code>&gt;</code>)</span></h3> <span data-as="p">To redirect stdout to a JavaScript object, use the <code>&gt;</code> operator:</span> <pre numberoflines="6" language="javascript" data-language="typescript">import { $ } from "bun";

const buffer = Buffer.alloc(100);
await $`echo "Hello World!" &gt; ${buffer}`;

console.log(buffer.toString()); // Hello World!\n
</pre> <span data-as="p">The following JavaScript objects are supported for redirection to:</span> <ul> <li>
<code>Buffer</code>, <code>Uint8Array</code>, <code>Uint16Array</code>, <code>Uint32Array</code>, <code>Int8Array</code>, <code>Int16Array</code>, <code>Int32Array</code>, <code>Float32Array</code>, <code>Float64Array</code>, <code>ArrayBuffer</code>, <code>SharedArrayBuffer</code> (writes to the underlying buffer)</li> <li>
<code>Bun.file(path)</code>, <code>Bun.file(fd)</code> (writes to the file)</li> </ul> <h3 id="example:-redirect-input-from-javascript-objects-&lt;"><span>Example: Redirect input from JavaScript objects (<code>&lt;</code>)</span></h3> <span data-as="p">To redirect the output from JavaScript objects to stdin, use the <code>&lt;</code> operator:</span> <pre numberoflines="7" language="javascript" data-language="typescript">import { $ } from "bun";

const response = new Response("hello i am a response body");

const result = await $`cat &lt; ${response}`.text();

console.log(result); // hello i am a response body
</pre> <span data-as="p">The following JavaScript objects are supported for redirection from:</span> <ul> <li>
<code>Buffer</code>, <code>Uint8Array</code>, <code>Uint16Array</code>, <code>Uint32Array</code>, <code>Int8Array</code>, <code>Int16Array</code>, <code>Int32Array</code>, <code>Float32Array</code>, <code>Float64Array</code>, <code>ArrayBuffer</code>, <code>SharedArrayBuffer</code> (reads from the underlying buffer)</li> <li>
<code>Bun.file(path)</code>, <code>Bun.file(fd)</code> (reads from the file)</li> <li>
<code>Response</code> (reads from the body)</li> </ul> <h3 id="example:-redirect-stdin-&gt;-file"><span>Example: Redirect stdin -&gt; file</span></h3> <pre numberoflines="3" language="javascript" data-language="typescript">import { $ } from "bun";

await $`cat &lt; myfile.txt`;
</pre> <h3 id="example:-redirect-stdout-&gt;-file"><span>Example: Redirect stdout -&gt; file</span></h3> <pre numberoflines="3" language="javascript" data-language="typescript">import { $ } from "bun";

await $`echo bun! &gt; greeting.txt`;
</pre> <h3 id="example:-redirect-stderr-&gt;-file"><span>Example: Redirect stderr -&gt; file</span></h3> <pre numberoflines="3" language="javascript" data-language="typescript">import { $ } from "bun";

await $`bun run index.ts 2&gt; errors.txt`;
</pre> <h3 id="example:-redirect-stderr-&gt;-stdout"><span>Example: Redirect stderr -&gt; stdout</span></h3> <pre numberoflines="5" language="javascript" data-language="typescript">import { $ } from "bun";

// redirects stderr to stdout, so all output
// will be available on stdout
await $`bun run ./index.ts 2&gt;&amp;1`;
</pre> <h3 id="example:-redirect-stdout-&gt;-stderr"><span>Example: Redirect stdout -&gt; stderr</span></h3> <pre numberoflines="5" language="javascript" data-language="typescript">import { $ } from "bun";

// redirects stdout to stderr, so all output
// will be available on stderr
await $`bun run ./index.ts 1&gt;&amp;2`;
</pre> <h2 id="piping-|"><span>Piping (<code>|</code>)</span></h2> <span data-as="p">Like in bash, you can pipe the output of one command to another:</span> <pre numberoflines="5" language="javascript" data-language="typescript">import { $ } from "bun";

const result = await $`echo "Hello World!" | wc -w`.text();

console.log(result); // 2\n
</pre> <span data-as="p">You can also pipe with JavaScript objects:</span> <pre numberoflines="7" language="javascript" data-language="typescript">import { $ } from "bun";

const response = new Response("hello i am a response body");

const result = await $`cat &lt; ${response} | wc -w`.text();

console.log(result); // 6\n
</pre> <h2 id="command-substitution-$"><span>Command substitution (<code>$(...)</code>)</span></h2> <span data-as="p">Command substitution allows you to substitute the output of another script into the current script:</span> <pre numberoflines="4" language="javascript" data-language="typescript">import { $ } from "bun";

// Prints out the hash of the current commit
await $`echo Hash of current commit: $(git rev-parse HEAD)`;
</pre> <span data-as="p">This is a textual insertion of the command’s output and can be used to, for example, declare a shell variable:</span> <pre numberoflines="7" language="javascript" data-language="typescript">import { $ } from "bun";

await $`
  REV=$(git rev-parse HEAD)
  docker built -t myapp:$REV
  echo Done building docker image "myapp:$REV"
`;
</pre> <div data-callout-type="note">

<div data-component-part="callout-content">
<span data-as="p">Because Bun internally uses the special <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#raw_strings" target="_blank" rel="noreferrer"><code>raw</code></a> property on the input template literal, using the backtick syntax for command substitution won’t work:</span><pre numberoflines="3" language="typescript" data-language="typescript">import { $ } from "bun";

await $`echo \`echo hi\``;
</pre>
<span data-as="p">Instead of printing:</span><pre numberoflines="2" language="text" data-language="typescript">hi
</pre>
<span data-as="p">The above will print out:</span><pre numberoflines="2" language="text" data-language="typescript">echo hi
</pre>
<span data-as="p">We instead recommend sticking to the <code>$(...)</code> syntax.</span>
</div>
</div> <hr> <h2 id="environment-variables"><span>Environment variables</span></h2> <span data-as="p">Environment variables can be set like in bash:</span> <pre numberoflines="3" language="javascript" data-language="typescript">import { $ } from "bun";

await $`FOO=foo bun -e 'console.log(process.env.FOO)'`; // foo\n
</pre> <span data-as="p">You can use string interpolation to set environment variables:</span> <pre numberoflines="5" language="javascript" data-language="typescript">import { $ } from "bun";

const foo = "bar123";

await $`FOO=${foo + "456"} bun -e 'console.log(process.env.FOO)'`; // bar123456\n
</pre> <span data-as="p">Input is escaped by default, preventing shell injection attacks:</span> <pre numberoflines="5" language="javascript" data-language="typescript">import { $ } from "bun";

const foo = "bar123; rm -rf /tmp";

await $`FOO=${foo} bun -e 'console.log(process.env.FOO)'`; // bar123; rm -rf /tmp\n
</pre> <h3 id="changing-the-environment-variables"><span>Changing the environment variables</span></h3> <span data-as="p">By default, <code>process.env</code> is used as the environment variables for all commands.</span> <span data-as="p">You can change the environment variables for a single command by calling <code>.env()</code>:</span> <pre numberoflines="3" language="javascript" data-language="typescript">import { $ } from "bun";

await $`echo $FOO`.env({ ...process.env, FOO: "bar" }); // bar
</pre> <span data-as="p">You can change the default environment variables for all commands by calling <code>$.env</code>:</span> <pre numberoflines="9" language="javascript" data-language="typescript">import { $ } from "bun";

$.env({ FOO: "bar" });

// the globally-set $FOO
await $`echo $FOO`; // bar

// the locally-set $FOO
await $`echo $FOO`.env({ FOO: "baz" }); // baz
</pre> <span data-as="p">You can reset the environment variables to the default by calling <code>$.env()</code> with no arguments:</span> <pre numberoflines="9" language="javascript" data-language="typescript">import { $ } from "bun";

$.env({ FOO: "bar" });

// the globally-set $FOO
await $`echo $FOO`; // bar

// the locally-set $FOO
await $`echo $FOO`.env(undefined); // ""
</pre> <h3 id="changing-the-working-directory"><span>Changing the working directory</span></h3> <span data-as="p">You can change the working directory of a command by passing a string to <code>.cwd()</code>:</span> <pre numberoflines="3" language="javascript" data-language="typescript">import { $ } from "bun";

await $`pwd`.cwd("/tmp"); // /tmp
</pre> <span data-as="p">You can change the default working directory for all commands by calling <code>$.cwd</code>:</span> <pre numberoflines="9" language="javascript" data-language="typescript">import { $ } from "bun";

$.cwd("/tmp");

// the globally-set working directory
await $`pwd`; // /tmp

// the locally-set working directory
await $`pwd`.cwd("/"); // /
</pre> <hr> <h2 id="reading-output"><span>Reading output</span></h2> <span data-as="p">To read the output of a command as a string, use <code>.text()</code>:</span> <pre numberoflines="5" language="javascript" data-language="typescript">import { $ } from "bun";

const result = await $`echo "Hello World!"`.text();

console.log(result); // Hello World!\n
</pre> <h3 id="reading-output-as-json"><span>Reading output as JSON</span></h3> <span data-as="p">To read the output of a command as JSON, use <code>.json()</code>:</span> <pre numberoflines="5" language="javascript" data-language="typescript">import { $ } from "bun";

const result = await $`echo '{"foo": "bar"}'`.json();

console.log(result); // { foo: "bar" }
</pre> <h3 id="reading-output-line-by-line"><span>Reading output line-by-line</span></h3> <span data-as="p">To read the output of a command line-by-line, use <code>.lines()</code>:</span> <pre numberoflines="5" language="javascript" data-language="typescript">import { $ } from "bun";

for await (let line of $`echo "Hello World!"`.lines()) {
  console.log(line); // Hello World!
}
</pre> <span data-as="p">You can also use <code>.lines()</code> on a completed command:</span> <pre numberoflines="7" language="javascript" data-language="typescript">import { $ } from "bun";

const search = "bun";

for await (let line of $`cat list.txt | grep ${search}`.lines()) {
  console.log(line);
}
</pre> <h3 id="reading-output-as-a-blob"><span>Reading output as a Blob</span></h3> <span data-as="p">To read the output of a command as a Blob, use <code>.blob()</code>:</span> <pre numberoflines="5" language="javascript" data-language="typescript">import { $ } from "bun";

const result = await $`echo "Hello World!"`.blob();

console.log(result); // Blob(13) { size: 13, type: "text/plain" }
</pre> <hr> <h2 id="builtin-commands"><span>Builtin Commands</span></h2> <span data-as="p">For cross-platform compatibility, Bun Shell implements a set of builtin commands, in addition to reading commands from the PATH environment variable.</span> <ul> <li>
<code>cd</code>: change the working directory</li> <li>
<code>ls</code>: list files in a directory</li> <li>
<code>rm</code>: remove files and directories</li> <li>
<code>echo</code>: print text</li> <li>
<code>pwd</code>: print the working directory</li> <li>
<code>bun</code>: run bun in bun</li> <li><code>cat</code></li> <li><code>touch</code></li> <li><code>mkdir</code></li> <li><code>which</code></li> <li><code>mv</code></li> <li><code>exit</code></li> <li><code>true</code></li> <li><code>false</code></li> <li><code>yes</code></li> <li><code>seq</code></li> <li><code>dirname</code></li> <li><code>basename</code></li> </ul> <span data-as="p"><strong>Partially</strong> implemented:</span> <ul> <li>
<code>mv</code>: move files and directories (missing cross-device support)</li> </ul> <span data-as="p"><strong>Not</strong> implemented yet, but planned:</span> <ul> <li>See <a href="https://github.com/oven-sh/bun/issues/9716" target="_blank" rel="noreferrer">Issue #9716</a> for the full list.</li> </ul> <hr> <h2 id="utilities"><span>Utilities</span></h2> <span data-as="p">Bun Shell also implements a set of utilities for working with shells.</span> <h3 id="$-braces-brace-expansion"><span><code>$.braces</code> (brace expansion)</span></h3> <span data-as="p">This function implements simple <a href="https://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html" target="_blank" rel="noreferrer">brace expansion</a> for shell commands:</span> <pre numberoflines="4" language="javascript" data-language="typescript">import { $ } from "bun";

await $.braces(`echo {1,2,3}`);
// =&gt; ["echo 1", "echo 2", "echo 3"]
</pre> <h3 id="$-escape-escape-strings"><span><code>$.escape</code> (escape strings)</span></h3> <span data-as="p">Exposes Bun Shell’s escaping logic as a function:</span> <pre numberoflines="4" language="javascript" data-language="typescript">import { $ } from "bun";

console.log($.escape('$(foo) `bar` "baz"'));
// =&gt; \$(foo) \`bar\` \"baz\"
</pre> <span data-as="p">If you do not want your string to be escaped, wrap it in a <code>{ raw: 'str' }</code> object:</span> <pre numberoflines="6" language="javascript" data-language="typescript">import { $ } from "bun";

await $`echo ${{ raw: '$(foo) `bar` "baz"' }}`;
// =&gt; bun: command not found: foo
// =&gt; bun: command not found: bar
// =&gt; baz
</pre> <hr> <h2 id="sh-file-loader"><span><code>.sh</code> file loader</span></h2> <span data-as="p">For simple shell scripts, instead of <code>/bin/sh</code>, you can use Bun Shell to run shell scripts.</span> <span data-as="p">To do so, just run the script with <code>bun</code> on a file with the <code>.sh</code> extension.</span> <pre numberoflines="1" language="shellscript" data-language="typescript">echo "Hello World! pwd=$(pwd)"
</pre> <pre numberoflines="1" language="shellscript" data-language="typescript">bun ./script.sh
</pre> <pre numberoflines="2" language="text" data-language="typescript">Hello World! pwd=/home/demo
</pre> <span data-as="p">Scripts with Bun Shell are cross platform, which means they work on Windows:</span> <pre numberoflines="1" language="powershell" data-language="typescript">bun .\script.sh
</pre> <pre numberoflines="2" language="text" data-language="typescript">Hello World! pwd=C:\Users\Demo
</pre> <hr> <h2 id="implementation-notes"><span>Implementation notes</span></h2> <span data-as="p">Bun Shell is a small programming language in Bun that is implemented in Zig. It includes a handwritten lexer, parser, and interpreter. Unlike bash, zsh, and other shells, Bun Shell runs operations concurrently.</span> <hr> <h2 id="security-in-the-bun-shell"><span>Security in the Bun shell</span></h2> <span data-as="p">By design, the Bun shell <em>does not invoke a system shell</em> (like <code>/bin/sh</code>) and is instead a re-implementation of bash that runs in the same Bun process, designed with security in mind.</span> <span data-as="p">When parsing command arguments, it treats all <em>interpolated variables</em> as single, literal strings.</span> <span data-as="p">This protects the Bun shell against <strong>command injection</strong>:</span> <pre numberoflines="6" language="javascript" data-language="typescript">import { $ } from "bun";

const userInput = "my-file.txt; rm -rf /";

// SAFE: `userInput` is treated as a single quoted string
await $`ls ${userInput}`;
</pre> <span data-as="p">In the above example, <code>userInput</code> is treated as a single string. This causes the <code>ls</code> command to try to read the contents of a single directory named “my-file; rm -rf /”.</span> <h3 id="security-considerations"><span>Security considerations</span></h3> <span data-as="p">While command injection is prevented by default, developers are still responsible for security in certain scenarios.</span> <span data-as="p">Similar to the <code>Bun.spawn</code> or <code>node:child_process.exec()</code> APIs, you can intentionally execute a command which spawns a new shell (e.g. <code>bash -c</code>) with arguments.</span> <span data-as="p">When you do this, you hand off control, and Bun’s built-in protections no longer apply to the string interpreted by that new shell.</span> <pre numberoflines="8" language="javascript" data-language="typescript">import { $ } from "bun";

const userInput = "world; touch /tmp/pwned";

// UNSAFE: You have explicitly started a new shell process with `bash -c`.
// This new shell will execute the `touch` command. Any user input
// passed this way must be rigorously sanitized.
await $`bash -c "echo ${userInput}"`;
</pre> <h3 id="argument-injection"><span>Argument injection</span></h3> <span data-as="p">The Bun shell cannot know how an external command interprets its own command-line arguments. An attacker can supply input that the target program recognizes as one of its own options or flags, leading to unintended behavior.</span> <pre numberoflines="8" language="javascript" data-language="typescript">import { $ } from "bun";

// Malicious input formatted as a Git command-line flag
const branch = "--upload-pack=echo pwned";

// UNSAFE: While Bun safely passes the string as a single argument,
// the `git` program itself sees and acts upon the malicious flag.
await $`git ls-remote origin ${branch}`;
</pre> <div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p"><strong>Recommendation</strong> — As is best practice in every language, always sanitize user-provided input before passing it as an argument to an external command. The responsibility for validating arguments rests with your application code.</span></div>
</div> <hr> <h2 id="credits"><span>Credits</span></h2> <span data-as="p">Large parts of this API were inspired by <a href="https://github.com/google/zx" target="_blank" rel="noreferrer">zx</a>, <a href="https://github.com/dsherret/dax" target="_blank" rel="noreferrer">dax</a>, and <a href="https://github.com/wobsoriano/bnx" target="_blank" rel="noreferrer">bnx</a>. Thank you to the authors of those projects.</span>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/shell" class="_attribution-link">https://bun.com/docs/runtime/shell</a>
  </p>
</div>
