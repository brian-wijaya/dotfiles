<h1 id="header">Isolated installs</h1>
<div data-page-title="Isolated installs" data-page-href="/pm/isolated-installs" id="content">
<span data-as="p">Bun provides an alternative package installation strategy called <strong>isolated installs</strong> that creates strict dependency isolation similar to pnpm’s approach. This mode prevents phantom dependencies and ensures reproducible, deterministic builds.</span> <span data-as="p">This is the default installation strategy for <strong>new</strong> workspace/monorepo projects (with <code>configVersion = 1</code> in the lockfile). Existing projects continue using hoisted installs unless explicitly configured.</span> <h2 id="what-are-isolated-installs"><span>What are isolated installs?</span></h2> <span data-as="p">Isolated installs create a non-hoisted dependency structure where packages can only access their explicitly declared dependencies. This differs from the traditional “hoisted” installation strategy used by npm and Yarn, where dependencies are flattened into a shared <code>node_modules</code> directory.</span> <h3 id="key-benefits"><span>Key benefits</span></h3> <ul> <li>
<strong>Prevents phantom dependencies</strong> — Packages cannot accidentally import dependencies they haven’t declared</li> <li>
<strong>Deterministic resolution</strong> — Same dependency tree regardless of what else is installed</li> <li>
<strong>Better for monorepos</strong> — Workspace isolation prevents cross-contamination between packages</li> <li>
<strong>Reproducible builds</strong> — More predictable resolution behavior across environments</li> </ul> <h2 id="using-isolated-installs"><span>Using isolated installs</span></h2> <h3 id="command-line"><span>Command line</span></h3> <span data-as="p">Use the <code>--linker</code> flag to specify the installation strategy:</span> <pre numberoflines="5" language="shellscript" data-language="typescript"># Use isolated installs
bun install --linker isolated

# Use traditional hoisted installs
bun install --linker hoisted
</pre> <h3 id="configuration-file"><span>Configuration file</span></h3> <span data-as="p">Set the default linker strategy in your <code>bunfig.toml</code> or globally in <code>$HOME/.bunfig.toml</code>:</span> <pre numberoflines="2" language="toml" data-language="typescript">[install]
linker = "isolated"
</pre> <h3 id="default-behavior"><span>Default behavior</span></h3> <span data-as="p">The default linker strategy depends on your project’s lockfile <code>configVersion</code>:</span> <div data-table-wrapper="true"><div><table> <thead><tr>
<th><code>configVersion</code></th>
<th>Using workspaces?</th>
<th>Default Linker</th>
</tr></thead> <tbody>
<tr>
<td><code>1</code></td>
<td>✅</td>
<td><code>isolated</code></td>
</tr>
<tr>
<td><code>1</code></td>
<td>❌</td>
<td><code>hoisted</code></td>
</tr>
<tr>
<td><code>0</code></td>
<td>✅</td>
<td><code>hoisted</code></td>
</tr>
<tr>
<td><code>0</code></td>
<td>❌</td>
<td><code>hoisted</code></td>
</tr>
</tbody> </table></div></div> <span data-as="p"><strong>New projects</strong>: Default to <code>configVersion = 1</code>. In workspaces, v1 uses the isolated linker by default; otherwise it uses hoisted linking.</span> <span data-as="p"><strong>Existing Bun projects (made pre-v1.3.2)</strong>: If your existing lockfile doesn’t have a version yet, Bun sets <code>configVersion = 0</code> when you run <code>bun install</code>, preserving the previous hoisted linker default.</span> <span data-as="p"><strong>Migrations from other package managers</strong>:</span> <ul> <li>From pnpm: <code>configVersion = 1</code> (using isolated installs in workspaces)</li> <li>From npm or yarn: <code>configVersion = 0</code> (using hoisted installs)</li> </ul> <span data-as="p">You can override the default behavior by explicitly specifying the <code>--linker</code> flag or setting it in your configuration file.</span> <h2 id="how-isolated-installs-work"><span>How isolated installs work</span></h2> <h3 id="directory-structure"><span>Directory structure</span></h3> <span data-as="p">Instead of hoisting dependencies, isolated installs create a two-tier structure:</span> <pre numberoflines="11" language="shellscript" data-language="typescript">node_modules/
├── .bun/                          # Central package store
│   ├── package@1.0.0/             # Versioned package installations
│   │   └── node_modules/
│   │       └── package/           # Actual package files
│   ├── @scope+package@2.1.0/      # Scoped packages (+ replaces /)
│   │   └── node_modules/
│   │       └── @scope/
│   │           └── package/
│   └── ...
└── package-name -&gt; .bun/package@1.0.0/node_modules/package  # Symlinks
</pre> <h3 id="resolution-algorithm"><span>Resolution algorithm</span></h3> <ol> <li>
<strong>Central store</strong> — All packages are installed in <code>node_modules/.bun/package@version/</code> directories</li> <li>
<strong>Symlinks</strong> — Top-level <code>node_modules</code> contains symlinks pointing to the central store</li> <li>
<strong>Peer resolution</strong> — Complex peer dependencies create specialized directory names</li> <li>
<strong>Deduplication</strong> — Packages with identical package IDs and peer dependency sets are shared</li> </ol> <h3 id="workspace-handling"><span>Workspace handling</span></h3> <span data-as="p">In monorepos, workspace dependencies are handled specially:</span> <ul> <li>
<strong>Workspace packages</strong> — Symlinked directly to their source directories, not the store</li> <li>
<strong>Workspace dependencies</strong> — Can access other workspace packages in the monorepo</li> <li>
<strong>External dependencies</strong> — Installed in the isolated store with proper isolation</li> </ul> <h2 id="comparison-with-hoisted-installs"><span>Comparison with hoisted installs</span></h2> <div data-table-wrapper="true"><div><table> <thead><tr>
<th>Aspect</th>
<th>Hoisted (npm/Yarn)</th>
<th>Isolated (pnpm-like)</th>
</tr></thead> <tbody>
<tr>
<td><strong>Dependency access</strong></td>
<td>Packages can access any hoisted dependency</td>
<td>Packages only see declared dependencies</td>
</tr>
<tr>
<td><strong>Phantom dependencies</strong></td>
<td>❌ Possible</td>
<td>✅ Prevented</td>
</tr>
<tr>
<td><strong>Disk usage</strong></td>
<td>✅ Lower (shared installs)</td>
<td>✅ Similar (uses symlinks)</td>
</tr>
<tr>
<td><strong>Determinism</strong></td>
<td>❌ Less deterministic</td>
<td>✅ More deterministic</td>
</tr>
<tr>
<td><strong>Node.js compatibility</strong></td>
<td>✅ Standard behavior</td>
<td>✅ Compatible via symlinks</td>
</tr>
<tr>
<td><strong>Best for</strong></td>
<td>Single projects, legacy code</td>
<td>Monorepos, strict dependency management</td>
</tr>
</tbody> </table></div></div> <h2 id="advanced-features"><span>Advanced features</span></h2> <h3 id="peer-dependency-handling"><span>Peer dependency handling</span></h3> <span data-as="p">Isolated installs handle peer dependencies through sophisticated resolution:</span> <pre numberoflines="2" language="shellscript" data-language="typescript"># Package with peer dependencies creates specialized paths
node_modules/.bun/package@1.0.0_react@18.2.0/
</pre> <span data-as="p">The directory name encodes both the package version and its peer dependency versions, ensuring each unique combination gets its own installation.</span> <h3 id="backend-strategies"><span>Backend strategies</span></h3> <span data-as="p">Bun uses different file operation strategies for performance:</span> <ul> <li>
<strong>Clonefile</strong> (macOS) — Copy-on-write filesystem clones for maximum efficiency</li> <li>
<strong>Hardlink</strong> (Linux/Windows) — Hardlinks to save disk space</li> <li>
<strong>Copyfile</strong> (fallback) — Full file copies when other methods aren’t available</li> </ul> <h3 id="debugging-isolated-installs"><span>Debugging isolated installs</span></h3> <span data-as="p">Enable verbose logging to understand the installation process:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun install --linker isolated --verbose
</pre> <span data-as="p">This shows:</span> <ul> <li>Store entry creation</li> <li>Symlink operations</li> <li>Peer dependency resolution</li> <li>Deduplication decisions</li> </ul> <h2 id="troubleshooting"><span>Troubleshooting</span></h2> <h3 id="compatibility-issues"><span>Compatibility issues</span></h3> <span data-as="p">Some packages may not work correctly with isolated installs due to:</span> <ul> <li>
<strong>Hardcoded paths</strong> — Packages that assume a flat <code>node_modules</code> structure</li> <li>
<strong>Dynamic imports</strong> — Runtime imports that don’t follow Node.js resolution</li> <li>
<strong>Build tools</strong> — Tools that scan <code>node_modules</code> directly</li> </ul> <span data-as="p">If you encounter issues, you can:</span> <ol> <li> <span data-as="p"><strong>Switch to hoisted mode</strong> for specific projects:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun install --linker hoisted
</pre> </li> <li> <span data-as="p"><strong>Report compatibility issues</strong> to help improve isolated install support</span> </li> </ol> <h3 id="performance-considerations"><span>Performance considerations</span></h3> <ul> <li>
<strong>Install time</strong> — May be slightly slower due to symlink operations</li> <li>
<strong>Disk usage</strong> — Similar to hoisted (uses symlinks, not file copies)</li> <li>
<strong>Memory usage</strong> — Higher during install due to complex peer resolution</li> </ul> <h2 id="migration-guide"><span>Migration guide</span></h2> <h3 id="from-npm/yarn"><span>From npm/Yarn</span></h3> <pre numberoflines="5" language="shellscript" data-language="typescript"># Remove existing node_modules and lockfiles
rm -rf node_modules package-lock.json yarn.lock

# Install with isolated linker
bun install --linker isolated
</pre> <h3 id="from-pnpm"><span>From pnpm</span></h3> <span data-as="p">Isolated installs are conceptually similar to pnpm, so migration should be straightforward:</span> <pre numberoflines="5" language="shellscript" data-language="typescript"># Remove pnpm files
$ rm -rf node_modules pnpm-lock.yaml

# Install with Bun's isolated linker
bun install --linker isolated
</pre> <span data-as="p">The main difference is that Bun uses symlinks in <code>node_modules</code> while pnpm uses a global store with symlinks.</span> <h2 id="when-to-use-isolated-installs"><span>When to use isolated installs</span></h2> <span data-as="p"><strong>Use isolated installs when:</strong></span> <ul> <li>Working in monorepos with multiple packages</li> <li>Strict dependency management is required</li> <li>Preventing phantom dependencies is important</li> <li>Building libraries that need deterministic dependencies</li> </ul> <span data-as="p"><strong>Use hoisted installs when:</strong></span> <ul> <li>Working with legacy code that assumes flat <code>node_modules</code>
</li> <li>Compatibility with existing build tools is required</li> <li>Working in environments where symlinks aren’t well supported</li> <li>You prefer the simpler traditional npm behavior</li> </ul> <h2 id="related-documentation"><span>Related documentation</span></h2> <ul> <li>
<a href="workspaces">Package manager &gt; Workspaces</a> — Monorepo workspace management</li> <li>
<a href="lockfile">Package manager &gt; Lockfile</a> — Understanding Bun’s lockfile format</li> <li>
<a href="cli/install">CLI &gt; install</a> — Complete <code>bun install</code> command reference</li> </ul>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/pm/isolated-installs" class="_attribution-link">https://bun.com/docs/pm/isolated-installs</a>
  </p>
</div>
