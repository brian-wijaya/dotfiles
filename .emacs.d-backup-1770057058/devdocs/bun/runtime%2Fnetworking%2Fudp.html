<h1 id="header">UDP</h1>
<div data-page-title="UDP" data-page-href="/runtime/networking/udp" id="content">
<h2 id="bind-a-udp-socket-bun-udpsocket"><span>Bind a UDP socket (<code>Bun.udpSocket()</code>)</span></h2> <span data-as="p">To create a new (bound) UDP socket:</span> <pre numberoflines="2" language="typescript" data-language="typescript">const socket = await Bun.udpSocket({});
console.log(socket.port); // assigned by the operating system
</pre> <span data-as="p">Specify a port:</span> <pre numberoflines="5" language="typescript" data-language="typescript">const socket = await Bun.udpSocket({
  port: 41234, 
});

console.log(socket.port); // 41234
</pre> <h3 id="send-a-datagram"><span>Send a datagram</span></h3> <span data-as="p">Specify the data to send, as well as the destination port and address.</span> <pre numberoflines="1" language="typescript" data-language="typescript">socket.send("Hello, world!", 41234, "127.0.0.1");
</pre> <span data-as="p">Note that the address must be a valid IP address - <code>send</code> does not perform DNS resolution, as it is intended for low-latency operations.</span> <h3 id="receive-datagrams"><span>Receive datagrams</span></h3> <span data-as="p">When creating your socket, add a callback to specify what should be done when packets are received:</span> <pre numberoflines="11" language="typescript" data-language="typescript">const server = await Bun.udpSocket({
  socket: {
    data(socket, buf, port, addr) {
      console.log(`message from ${addr}:${port}:`);
      console.log(buf.toString());
    },
  },
});

const client = await Bun.udpSocket({});
client.send("Hello!", server.port, "127.0.0.1");
</pre> <h3 id="connections"><span>Connections</span></h3> <span data-as="p">While UDP does not have a concept of a connection, many UDP communications (especially as a client) involve only one peer. In such cases it can be beneficial to connect the socket to that peer, which specifies to which address all packets are sent and restricts incoming packets to that peer only.</span> <pre numberoflines="17" language="typescript" data-language="typescript">const server = await Bun.udpSocket({
  socket: {
    data(socket, buf, port, addr) {
      console.log(`message from ${addr}:${port}:`);
      console.log(buf.toString());
    },
  },
});

const client = await Bun.udpSocket({
  connect: {
    port: server.port,
    hostname: "127.0.0.1",
  },
});

client.send("Hello");
</pre> <span data-as="p">Because connections are implemented on the operating system level, you can potentially observe performance benefits, too.</span> <h3 id="send-many-packets-at-once-using-sendmany"><span>Send many packets at once using <code>sendMany()</code></span></h3> <span data-as="p">If you want to send a large volume of packets at once, it can make sense to batch them all together to avoid the overhead of making a system call for each. This is made possible by the <code>sendMany()</code> API:</span> <span data-as="p">For an unconnected socket, <code>sendMany</code> takes an array as its only argument. Each set of three array elements describes a packet: The first item is the data to be sent, the second is the target port, and the last is the target address.</span> <pre numberoflines="4" language="typescript" data-language="typescript">const socket = await Bun.udpSocket({});

// sends 'Hello' to 127.0.0.1:41234, and 'foo' to 1.1.1.1:53 in a single operation
socket.sendMany(["Hello", 41234, "127.0.0.1", "foo", 53, "1.1.1.1"]);
</pre> <span data-as="p">With a connected socket, <code>sendMany</code> simply takes an array, where each element represents the data to be sent to the peer.</span> <pre numberoflines="8" language="typescript" data-language="typescript">const socket = await Bun.udpSocket({
  connect: {
    port: 41234,
    hostname: "localhost",
  },
});

socket.sendMany(["foo", "bar", "baz"]);
</pre> <span data-as="p"><code>sendMany</code> returns the number of packets that were successfully sent. As with <code>send</code>, <code>sendMany</code> only takes valid IP addresses as destinations, as it does not perform DNS resolution.</span> <h3 id="handle-backpressure"><span>Handle backpressure</span></h3> <span data-as="p">It may happen that a packet that you’re sending does not fit into the operating system’s packet buffer. You can detect that this has happened when:</span> <ul> <li>
<code>send</code> returns <code>false</code>
</li> <li>
<code>sendMany</code> returns a number smaller than the number of packets you specified. In this case, the <code>drain</code> socket handler will be called once the socket becomes writable again:</li> </ul> <pre numberoflines="7" language="typescript" data-language="typescript">const socket = await Bun.udpSocket({
  socket: {
    drain(socket) {
      // continue sending data
    },
  },
});
</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/networking/udp" class="_attribution-link">https://bun.com/docs/runtime/networking/udp</a>
  </p>
</div>
