<h1 id="header">SQLite</h1>
<div data-page-title="SQLite" data-page-href="/runtime/sqlite" id="content">
<span data-as="p">Bun natively implements a high-performance <a href="https://www.sqlite.org/" target="_blank" rel="noreferrer">SQLite3</a> driver. To use it import from the built-in <code>bun:sqlite</code> module.</span> <pre numberoflines="5" language="typescript" data-language="typescript">import { Database } from "bun:sqlite";

const db = new Database(":memory:");
const query = db.query("select 'Hello world' as message;");
query.get();
</pre> <pre numberoflines="2" language="text" data-language="typescript">{ message: "Hello world" }
</pre> <span data-as="p">The API is simple, synchronous, and fast. Credit to <a href="https://github.com/JoshuaWise/better-sqlite3" target="_blank" rel="noreferrer">better-sqlite3</a> and its contributors for inspiring the API of <code>bun:sqlite</code>.</span> <span data-as="p">Features include:</span> <ul> <li>Transactions</li> <li>Parameters (named &amp; positional)</li> <li>Prepared statements</li> <li>Datatype conversions (<code>BLOB</code> becomes <code>Uint8Array</code>)</li> <li>Map query results to classes without an ORM - <code>query.as(MyClass)</code>
</li> <li>The fastest performance of any SQLite driver for JavaScript</li> <li>
<code>bigint</code> support</li> <li>Multi-query statements (e.g. <code>SELECT 1; SELECT 2;</code>) in a single call to database.run(query)</li> </ul> <span data-as="p">The <code>bun:sqlite</code> module is roughly 3-6x faster than <code>better-sqlite3</code> and 8-9x faster than <code>deno.land/x/sqlite</code> for read queries. Each driver was benchmarked against the <a href="https://github.com/jpwhite3/northwind-SQLite3/blob/46d5f8a64f396f87cd374d1600dbf521523980e8/Northwind_large.sqlite.zip" target="_blank" rel="noreferrer">Northwind Traders</a> dataset. View and run the <a href="https://github.com/oven-sh/bun/tree/main/bench/sqlite" target="_blank" rel="noreferrer">benchmark source</a>.</span> <div><div data-name="frame">


<div contenteditable="false" data-component-part="frame-caption"><p>Benchmarked on an M1 MacBook Pro (64GB) running macOS 12.3.1</p></div>

</div></div> <hr> <h2 id="database"><span>Database</span></h2> <span data-as="p">To open or create a SQLite3 database:</span> <pre numberoflines="3" language="typescript" data-language="typescript">import { Database } from "bun:sqlite";

const db = new Database("mydb.sqlite");
</pre> <span data-as="p">To open an in-memory database:</span> <pre numberoflines="6" language="typescript" data-language="typescript">import { Database } from "bun:sqlite";

// all of these do the same thing
const db = new Database(":memory:");
const db = new Database();
const db = new Database("");
</pre> <span data-as="p">To open in <code>readonly</code> mode:</span> <pre highlight="[2]" numberoflines="2" language="typescript" data-language="typescript">import { Database } from "bun:sqlite";
const db = new Database("mydb.sqlite", { readonly: true });
</pre> <span data-as="p">To create the database if the file doesn’t exist:</span> <pre highlight="[2]" numberoflines="2" language="typescript" data-language="typescript">import { Database } from "bun:sqlite";
const db = new Database("mydb.sqlite", { create: true });
</pre> <h3 id="strict-mode"><span>Strict mode</span></h3> <span data-as="p">By default, <code>bun:sqlite</code> requires binding parameters to include the <code>$</code>, <code>:</code>, or <code>@</code> prefix, and does not throw an error if a parameter is missing.</span> <span data-as="p">To instead throw an error when a parameter is missing and allow binding without a prefix, set <code>strict: true</code> on the <code>Database</code> constructor:</span> <pre highlight="[3]" numberoflines="10" language="typescript" data-language="typescript">import { Database } from "bun:sqlite";

const strict = new Database(":memory:", { strict: true });

// throws error because of the typo:
const query = strict.query("SELECT $message;").all({ messag: "Hello world" });

const notStrict = new Database(":memory:");
// does not throw error:
notStrict.query("SELECT $message;").all({ messag: "Hello world" });
</pre> <h3 id="load-via-es-module-import"><span>Load via ES module import</span></h3> <span data-as="p">You can also use an import attribute to load a database.</span> <pre highlight="[1]" numberoflines="3" language="typescript" data-language="typescript">import db from "./mydb.sqlite" with { type: "sqlite" };

console.log(db.query("select * from users LIMIT 1").get());
</pre> <span data-as="p">This is equivalent to the following:</span> <pre numberoflines="2" language="typescript" data-language="typescript">import { Database } from "bun:sqlite";
const db = new Database("./mydb.sqlite");
</pre> <h3 id="close-throwonerror:-boolean-=-false"><span><code>.close(throwOnError: boolean = false)</code></span></h3> <span data-as="p">To close a database connection, but allow existing queries to finish, call <code>.close(false)</code>:</span> <pre highlight="[3]" numberoflines="3" language="typescript" data-language="typescript">const db = new Database();
// ... do stuff
db.close(false);
</pre> <span data-as="p">To close the database and throw an error if there are any pending queries, call <code>.close(true)</code>:</span> <pre highlight="[3]" numberoflines="3" language="typescript" data-language="typescript">const db = new Database();
// ... do stuff
db.close(true);
</pre> <div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p"><code>close(false)</code> is called automatically when the database is garbage collected. It is safe to call multiple times but has no effect after the first.</span></div>
</div> <h3 id="using-statement"><span><code>using</code> statement</span></h3> <span data-as="p">You can use the <code>using</code> statement to ensure that a database connection is closed when the <code>using</code> block is exited.</span> <pre highlight="[4,5]" numberoflines="7" language="typescript" data-language="typescript">import { Database } from "bun:sqlite";

{
  using db = new Database("mydb.sqlite");
  using query = db.query("select 'Hello world' as message;");
  console.log(query.get());
}
</pre> <pre numberoflines="2" language="text" data-language="typescript">{ message: "Hello world" }
</pre> <h3 id="serialize"><span><code>.serialize()</code></span></h3> <span data-as="p"><code>bun:sqlite</code> supports SQLite’s built-in mechanism for <a href="https://www.sqlite.org/c3ref/serialize.html" target="_blank" rel="noreferrer">serializing</a> and <a href="https://www.sqlite.org/c3ref/deserialize.html" target="_blank" rel="noreferrer">deserializing</a> databases to and from memory.</span> <pre highlight="[2]" numberoflines="3" language="typescript" data-language="typescript">const olddb = new Database("mydb.sqlite");
const contents = olddb.serialize(); // =&gt; Uint8Array
const newdb = Database.deserialize(contents);
</pre> <span data-as="p">Internally, <code>.serialize()</code> calls <a href="https://www.sqlite.org/c3ref/serialize.html" target="_blank" rel="noreferrer"><code>sqlite3_serialize</code></a>.</span> <h3 id="query"><span><code>.query()</code></span></h3> <span data-as="p">Use the <code>db.query()</code> method on your <code>Database</code> instance to <a href="https://www.sqlite.org/c3ref/prepare.html" target="_blank" rel="noreferrer">prepare</a> a SQL query. The result is a <code>Statement</code> instance that will be cached on the <code>Database</code> instance. <em>The query will not be executed.</em></span> <pre numberoflines="1" language="typescript" data-language="typescript">const query = db.query(`select "Hello world" as message`);
</pre> <div data-callout-type="note">

<div data-component-part="callout-content">
<span data-as="p"><strong>What does “cached” mean?</strong></span><span data-as="p">The caching refers to the <strong>compiled prepared statement</strong> (the SQL bytecode), not the query results. When you call <code>db.query()</code> with the same SQL string multiple times, Bun returns the same cached <code>Statement</code> object instead of recompiling the SQL.</span><span data-as="p">It is completely safe to reuse a cached statement with different parameter values:</span><pre numberoflines="4" language="typescript" data-language="typescript">const query = db.query("SELECT * FROM users WHERE id = ?");
query.get(1); // ✓ Works
query.get(2); // ✓ Also works - parameters are bound fresh each time
query.get(3); // ✓ Still works
</pre>
<span data-as="p">Use <code>.prepare()</code> instead of <code>.query()</code> when you want a fresh <code>Statement</code> instance that isn’t cached, for example if you’re dynamically generating SQL and don’t want to fill the cache with one-off queries.</span><pre numberoflines="2" language="typescript" data-language="typescript">// compile the prepared statement without caching
const query = db.prepare("SELECT * FROM foo WHERE bar = ?");
</pre>
</div>
</div> <hr> <h2 id="wal-mode"><span>WAL mode</span></h2> <span data-as="p">SQLite supports <a href="https://www.sqlite.org/wal.html" target="_blank" rel="noreferrer">write-ahead log mode</a> (WAL) which dramatically improves performance, especially in situations with many concurrent readers and a single writer. It’s broadly recommended to enable WAL mode for most typical applications.</span> <span data-as="p">To enable WAL mode, run this pragma query at the beginning of your application:</span> <pre numberoflines="1" language="typescript" data-language="typescript">db.run("PRAGMA journal_mode = WAL;");
</pre> <details><summary aria-controls="what-is-wal-mode accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">What is WAL mode?</p></div></summary><div id="what-is-wal-mode accordion children" role="region" aria-labelledby="what-is-wal-mode" data-component-part="accordion-content">
<span data-as="p">In WAL mode, writes to the database are written directly to a separate file called the “WAL file” (write-ahead log). This file will be later integrated into the main database file. Think of it as a buffer for pending writes. Refer to the <a href="https://www.sqlite.org/wal.html" target="_blank" rel="noreferrer">SQLite docs</a> for a more detailed overview.</span><span data-as="p">On macOS, WAL files may be persistent by default. This is not a bug, it is how macOS configured the system version of SQLite.</span>
</div></details> <hr> <h2 id="statements"><span>Statements</span></h2> <span data-as="p">A <code>Statement</code> is a <em>prepared query</em>, which means it’s been parsed and compiled into an efficient binary form. It can be executed multiple times in a performant way.</span> <span data-as="p">Create a statement with the <code>.query</code> method on your <code>Database</code> instance.</span> <pre numberoflines="1" language="typescript" data-language="typescript">const query = db.query(`select "Hello world" as message`);
</pre> <span data-as="p">Queries can contain parameters. These can be numerical (<code>?1</code>) or named (<code>$param</code> or <code>:param</code> or <code>@param</code>).</span> <pre numberoflines="2" language="typescript" data-language="typescript">const query = db.query(`SELECT ?1, ?2;`);
const query = db.query(`SELECT $param1, $param2;`);
</pre> <span data-as="p">Values are bound to these parameters when the query is executed. A <code>Statement</code> can be executed with several different methods, each returning the results in a different form.</span> <h3 id="binding-values"><span>Binding values</span></h3> <span data-as="p">To bind values to a statement, pass an object to the <code>.all()</code>, <code>.get()</code>, <code>.run()</code>, or <code>.values()</code> method.</span> <pre highlight="[2]" numberoflines="2" language="typescript" data-language="typescript">const query = db.query(`select $message;`);
query.all({ $message: "Hello world" });
</pre> <span data-as="p">You can bind using positional parameters too:</span> <pre numberoflines="2" language="typescript" data-language="typescript">const query = db.query(`select ?1;`);
query.all("Hello world");
</pre> <h4 id="strict:-true-lets-you-bind-values-without-prefixes"><span><code>strict: true</code> lets you bind values without prefixes</span></h4> <span data-as="p">By default, the <code>$</code>, <code>:</code>, and <code>@</code> prefixes are <strong>included</strong> when binding values to named parameters. To bind without these prefixes, use the <code>strict</code> option in the <code>Database</code> constructor.</span> <pre numberoflines="14" language="typescript" data-language="typescript">import { Database } from "bun:sqlite";

const db = new Database(":memory:", {
  // bind values without prefixes
  strict: true, 
});

const query = db.query(`select $message;`);

// strict: true
query.all({ message: "Hello world" });

// strict: false
// query.all({ $message: "Hello world" });
</pre> <h3 id="all"><span><code>.all()</code></span></h3> <span data-as="p">Use <code>.all()</code> to run a query and get back the results as an array of objects.</span> <pre highlight="[2]" numberoflines="2" language="typescript" data-language="typescript">const query = db.query(`select $message;`);
query.all({ $message: "Hello world" });
</pre> <pre numberoflines="2" language="text" data-language="typescript">[{ message: "Hello world" }]
</pre> <span data-as="p">Internally, this calls <a href="https://www.sqlite.org/capi3ref.html#sqlite3_reset" target="_blank" rel="noreferrer"><code>sqlite3_reset</code></a> and repeatedly calls <a href="https://www.sqlite.org/capi3ref.html#sqlite3_step" target="_blank" rel="noreferrer"><code>sqlite3_step</code></a> until it returns <code>SQLITE_DONE</code>.</span> <h3 id="get"><span><code>.get()</code></span></h3> <span data-as="p">Use <code>.get()</code> to run a query and get back the first result as an object.</span> <pre highlight="[2]" numberoflines="2" language="typescript" data-language="typescript">const query = db.query(`select $message;`);
query.get({ $message: "Hello world" });
</pre> <pre numberoflines="2" language="text" data-language="typescript">{ $message: "Hello world" }
</pre> <span data-as="p">Internally, this calls <a href="https://www.sqlite.org/capi3ref.html#sqlite3_reset" target="_blank" rel="noreferrer"><code>sqlite3_reset</code></a> followed by <a href="https://www.sqlite.org/capi3ref.html#sqlite3_step" target="_blank" rel="noreferrer"><code>sqlite3_step</code></a> until it no longer returns <code>SQLITE_ROW</code>. If the query returns no rows, <code>undefined</code> is returned.</span> <h3 id="run"><span><code>.run()</code></span></h3> <span data-as="p">Use <code>.run()</code> to run a query and get back an object with execution metadata. This is useful for schema-modifying queries (e.g. <code>CREATE TABLE</code>) or bulk write operations.</span> <pre highlight="[2]" numberoflines="2" language="typescript" data-language="typescript">const query = db.query(`create table foo;`);
query.run();
</pre> <pre numberoflines="5" language="text" data-language="typescript">{
  lastInsertRowid: 0,
  changes: 0,
}
</pre> <span data-as="p">Internally, this calls <a href="https://www.sqlite.org/capi3ref.html#sqlite3_reset" target="_blank" rel="noreferrer"><code>sqlite3_reset</code></a> and calls <a href="https://www.sqlite.org/capi3ref.html#sqlite3_step" target="_blank" rel="noreferrer"><code>sqlite3_step</code></a> once. Stepping through all the rows is not necessary when you don’t care about the results.</span> <span data-as="p">The <code>lastInsertRowid</code> property returns the ID of the last row inserted into the database. The <code>changes</code> property is the number of rows affected by the query.</span> <h3 id="as-class-map-query-results-to-a-class"><span><code>.as(Class)</code> - Map query results to a class</span></h3> <span data-as="p">Use <code>.as(Class)</code> to run a query and get back the results as instances of a class. This lets you attach methods &amp; getters/setters to results.</span> <pre highlight="[10]" numberoflines="15" language="typescript" data-language="typescript">class Movie {
  title: string;
  year: number;

  get isMarvel() {
    return this.title.includes("Marvel");
  }
}

const query = db.query("SELECT title, year FROM movies").as(Movie);
const movies = query.all();
const first = query.get();

console.log(movies[0].isMarvel);
console.log(first.isMarvel);
</pre> <pre numberoflines="3" language="text" data-language="typescript">true
true
</pre> <span data-as="p">As a performance optimization, the class constructor is not called, default initializers are not run, and private fields are not accessible. This is more like using <code>Object.create</code> than <code>new</code>. The class’s prototype is assigned to the object, methods are attached, and getters/setters are set up, but the constructor is not called.</span> <span data-as="p">The database columns are set as properties on the class instance.</span> <h3 id="iterate-@@iterator"><span><code>.iterate()</code> (<code>@@iterator</code>)</span></h3> <span data-as="p">Use <code>.iterate()</code> to run a query and incrementally return results. This is useful for large result sets that you want to process one row at a time without loading all the results into memory.</span> <pre highlight="[2]" numberoflines="4" language="typescript" data-language="typescript">const query = db.query("SELECT * FROM foo");
for (const row of query.iterate()) {
  console.log(row);
}
</pre> <span data-as="p">You can also use the <code>@@iterator</code> protocol:</span> <pre highlight="[2]" numberoflines="4" language="typescript" data-language="typescript">const query = db.query("SELECT * FROM foo");
for (const row of query) {
  console.log(row);
}
</pre> <h3 id="values"><span><code>.values()</code></span></h3> <span data-as="p">Use <code>values()</code> to run a query and get back all results as an array of arrays.</span> <pre highlight="[3,4]" numberoflines="4" language="typescript" data-language="typescript">const query = db.query(`select $message;`);

query.values({ $message: "Hello world" });
query.values(2);
</pre> <pre numberoflines="6" language="text" data-language="typescript">[
  [ "Iron Man", 2008 ],
  [ "The Avengers", 2012 ],
  [ "Ant-Man: Quantumania", 2023 ],
]
</pre> <span data-as="p">Internally, this calls <a href="https://www.sqlite.org/capi3ref.html#sqlite3_reset" target="_blank" rel="noreferrer"><code>sqlite3_reset</code></a> and repeatedly calls <a href="https://www.sqlite.org/capi3ref.html#sqlite3_step" target="_blank" rel="noreferrer"><code>sqlite3_step</code></a> until it returns <code>SQLITE_DONE</code>.</span> <h3 id="finalize"><span><code>.finalize()</code></span></h3> <span data-as="p">Use <code>.finalize()</code> to destroy a <code>Statement</code> and free any resources associated with it. Once finalized, a <code>Statement</code> cannot be executed again. Typically, the garbage collector will do this for you, but explicit finalization may be useful in performance-sensitive applications.</span> <pre highlight="[3]" numberoflines="3" language="typescript" data-language="typescript">const query = db.query("SELECT title, year FROM movies");
const movies = query.all();
query.finalize();
</pre> <h3 id="tostring"><span><code>.toString()</code></span></h3> <span data-as="p">Calling <code>toString()</code> on a <code>Statement</code> instance prints the expanded SQL query. This is useful for debugging.</span> <pre highlight="[6,9,12]" numberoflines="12" language="typescript" data-language="typescript">import { Database } from "bun:sqlite";

// setup
const query = db.query("SELECT $param;");

console.log(query.toString()); // =&gt; "SELECT NULL"

query.run(42);
console.log(query.toString()); // =&gt; "SELECT 42"

query.run(365);
console.log(query.toString()); // =&gt; "SELECT 365"
</pre> <span data-as="p">Internally, this calls <a href="https://www.sqlite.org/capi3ref.html#sqlite3_expanded_sql" target="_blank" rel="noreferrer"><code>sqlite3_expanded_sql</code></a>. The parameters are expanded using the most recently bound values.</span> <h2 id="parameters"><span>Parameters</span></h2> <span data-as="p">Queries can contain parameters. These can be numerical (<code>?1</code>) or named (<code>$param</code> or <code>:param</code> or <code>@param</code>). Bind values to these parameters when executing the query:</span> <pre numberoflines="4" language="typescript" data-language="typescript">const query = db.query("SELECT * FROM foo WHERE bar = $bar");
const results = query.all({
  $bar: "bar",
});
</pre> <pre numberoflines="2" language="text" data-language="typescript">[{ "$bar": "bar" }]
</pre> <span data-as="p">Numbered (positional) parameters work too:</span> <pre numberoflines="2" language="typescript" data-language="typescript">const query = db.query("SELECT ?1, ?2");
const results = query.all("hello", "goodbye");
</pre> <pre numberoflines="7" language="text" data-language="typescript">[
	{
		"?1": "hello",
		"?2": "goodbye",
	},
];
</pre> <hr> <h2 id="integers"><span>Integers</span></h2> <span data-as="p">sqlite supports signed 64 bit integers, but JavaScript only supports signed 52 bit integers or arbitrary precision integers with <code>bigint</code>.</span> <span data-as="p"><code>bigint</code> input is supported everywhere, but by default <code>bun:sqlite</code> returns integers as <code>number</code> types. If you need to handle integers larger than 2^53, set <code>safeIntegers</code> option to <code>true</code> when creating a <code>Database</code> instance. This also validates that <code>bigint</code> passed to <code>bun:sqlite</code> do not exceed 64 bits.</span> <span data-as="p">By default, <code>bun:sqlite</code> returns integers as <code>number</code> types. If you need to handle integers larger than 2^53, you can use the <code>bigint</code> type.</span> <h3 id="safeintegers:-true"><span><code>safeIntegers: true</code></span></h3> <span data-as="p">When <code>safeIntegers</code> is <code>true</code>, <code>bun:sqlite</code> will return integers as <code>bigint</code> types:</span> <pre highlight="[3]" numberoflines="7" language="typescript" data-language="typescript">import { Database } from "bun:sqlite";

const db = new Database(":memory:", { safeIntegers: true });
const query = db.query(`SELECT ${BigInt(Number.MAX_SAFE_INTEGER) + 102n} as max_int`);
const result = query.get();

console.log(result.max_int);
</pre> <pre numberoflines="2" language="text" data-language="typescript">9007199254741093n
</pre> <span data-as="p">When <code>safeIntegers</code> is <code>true</code>, <code>bun:sqlite</code> will throw an error if a <code>bigint</code> value in a bound parameter exceeds 64 bits:</span> <pre highlight="[3]" numberoflines="12" language="typescript" data-language="typescript">import { Database } from "bun:sqlite";

const db = new Database(":memory:", { safeIntegers: true });
db.run("CREATE TABLE test (id INTEGER PRIMARY KEY, value INTEGER)");

const query = db.query("INSERT INTO test (value) VALUES ($value)");

try {
  query.run({ $value: BigInt(Number.MAX_SAFE_INTEGER) ** 2n });
} catch (e) {
  console.log(e.message);
}
</pre> <pre numberoflines="2" language="text" data-language="typescript">BigInt value '81129638414606663681390495662081' is out of range
</pre> <h3 id="safeintegers:-false-default"><span><code>safeIntegers: false</code> (default)</span></h3> <span data-as="p">When <code>safeIntegers</code> is <code>false</code>, <code>bun:sqlite</code> will return integers as <code>number</code> types and truncate any bits beyond 53:</span> <pre highlight="[3]" numberoflines="6" language="typescript" data-language="typescript">import { Database } from "bun:sqlite";

const db = new Database(":memory:", { safeIntegers: false });
const query = db.query(`SELECT ${BigInt(Number.MAX_SAFE_INTEGER) + 102n} as max_int`);
const result = query.get();
console.log(result.max_int);
</pre> <pre numberoflines="2" language="text" data-language="typescript">9007199254741092
</pre> <hr> <h2 id="transactions"><span>Transactions</span></h2> <span data-as="p">Transactions are a mechanism for executing multiple queries in an <em>atomic</em> way; that is, either all of the queries succeed or none of them do. Create a transaction with the <code>db.transaction()</code> method:</span> <pre highlight="[2]" numberoflines="4" language="typescript" data-language="typescript">const insertCat = db.prepare("INSERT INTO cats (name) VALUES ($name)");
const insertCats = db.transaction(cats =&gt; {
  for (const cat of cats) insertCat.run(cat);
});
</pre> <span data-as="p">At this stage, we haven’t inserted any cats! The call to <code>db.transaction()</code> returns a new function (<code>insertCats</code>) that <em>wraps</em> the function that executes the queries.</span> <span data-as="p">To execute the transaction, call this function. All arguments will be passed through to the wrapped function; the return value of the wrapped function will be returned by the transaction function. The wrapped function also has access to the <code>this</code> context as defined where the transaction is executed.</span> <pre highlight="[3]" numberoflines="9" language="typescript" data-language="typescript">const insert = db.prepare("INSERT INTO cats (name) VALUES ($name)");
const insertCats = db.transaction(cats =&gt; {
  for (const cat of cats) insert.run(cat);
  return cats.length;
});

const count = insertCats([{ $name: "Keanu" }, { $name: "Salem" }, { $name: "Crookshanks" }]);

console.log(`Inserted ${count} cats`);
</pre> <span data-as="p">The driver will automatically <a href="https://www.sqlite.org/lang_transaction.html" target="_blank" rel="noreferrer"><code>begin</code></a> a transaction when <code>insertCats</code> is called and <code>commit</code> it when the wrapped function returns. If an exception is thrown, the transaction will be rolled back. The exception will propagate as usual; it is not caught.</span> <div data-callout-type="note">

<div data-component-part="callout-content">
<span data-as="p"><strong>Nested transactions</strong> — Transaction functions can be called from inside other transaction functions. When doing so, the inner transaction becomes a <a href="https://www.sqlite.org/lang_savepoint.html" target="_blank" rel="noreferrer">savepoint</a>.</span><details><summary aria-controls="view-nested-transaction-example accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">View nested transaction example</p></div></summary><div id="view-nested-transaction-example accordion children" role="region" aria-labelledby="view-nested-transaction-example" data-component-part="accordion-content"><pre numberoflines="21" language="typescript" data-language="typescript">// setup
import { Database } from "bun:sqlite";
const db = Database.open(":memory:");
db.run("CREATE TABLE expenses (id INTEGER PRIMARY KEY AUTOINCREMENT, note TEXT, dollars INTEGER);");
db.run("CREATE TABLE cats (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT UNIQUE, age INTEGER)");
const insertExpense = db.prepare("INSERT INTO expenses (note, dollars) VALUES (?, ?)");
const insert = db.prepare("INSERT INTO cats (name, age) VALUES ($name, $age)");
const insertCats = db.transaction(cats =&gt; {
  for (const cat of cats) insert.run(cat);
});

const adopt = db.transaction(cats =&gt; {
  insertExpense.run("adoption fees", 20);
  insertCats(cats); // nested transaction
});

adopt([
  { $name: "Joey", $age: 2 },
  { $name: "Sally", $age: 4 },
  { $name: "Junior", $age: 1 },
]);
</pre></div></details>
</div>
</div> <span data-as="p">Transactions also come with <code>deferred</code>, <code>immediate</code>, and <code>exclusive</code> versions.</span> <pre numberoflines="4" language="typescript" data-language="typescript">insertCats(cats); // uses "BEGIN"
insertCats.deferred(cats); // uses "BEGIN DEFERRED"
insertCats.immediate(cats); // uses "BEGIN IMMEDIATE"
insertCats.exclusive(cats); // uses "BEGIN EXCLUSIVE"
</pre> <h3 id="loadextension"><span><code>.loadExtension()</code></span></h3> <span data-as="p">To load a <a href="https://www.sqlite.org/loadext.html" target="_blank" rel="noreferrer">SQLite extension</a>, call <code>.loadExtension(name)</code> on your <code>Database</code> instance</span> <pre highlight="[4]" numberoflines="4" language="typescript" data-language="typescript">import { Database } from "bun:sqlite";

const db = new Database();
db.loadExtension("myext");
</pre> <div data-callout-type="note">

<div data-component-part="callout-content">
<span data-as="p"><strong>MacOS users</strong> By default, macOS ships with Apple’s proprietary build of SQLite, which doesn’t support extensions. To use extensions, you’ll need to install a vanilla build of SQLite.</span><pre numberoflines="2" language="shellscript" data-language="typescript">brew install sqlite
which sqlite # get path to binary
</pre>
<span data-as="p">To point <code>bun:sqlite</code> to the new build, call <code>Database.setCustomSQLite(path)</code> before creating any <code>Database</code> instances. (On other operating systems, this is a no-op.) Pass a path to the SQLite <code>.dylib</code> file, <em>not</em> the executable. With recent versions of Homebrew this is something like <code>/opt/homebrew/Cellar/sqlite/&lt;version&gt;/libsqlite3.dylib</code>.</span><pre highlight="[3]" numberoflines="6" language="typescript" data-language="typescript">import { Database } from "bun:sqlite";

Database.setCustomSQLite("/path/to/libsqlite.dylib");

const db = new Database();
db.loadExtension("myext");
</pre>
</div>
</div> <h3 id="filecontrol-cmd:-number,-value:-any"><span><code>.fileControl(cmd: number, value: any)</code></span></h3> <span data-as="p">To use the advanced <code>sqlite3_file_control</code> API, call <code>.fileControl(cmd, value)</code> on your <code>Database</code> instance.</span> <pre highlight="[6]" numberoflines="6" language="typescript" data-language="typescript">import { Database, constants } from "bun:sqlite";

const db = new Database();
// Ensure WAL mode is NOT persistent
// this prevents wal files from lingering after the database is closed
db.fileControl(constants.SQLITE_FCNTL_PERSIST_WAL, 0);
</pre> <span data-as="p"><code>value</code> can be:</span> <ul> <li><code>number</code></li> <li><code>TypedArray</code></li> <li>
<code>undefined</code> or <code>null</code>
</li> </ul> <hr> <h2 id="reference"><span>Reference</span></h2> <pre numberoflines="57" language="typescript" data-language="typescript">class Database {
  constructor(
    filename: string,
    options?:
      | number
      | {
          readonly?: boolean;
          create?: boolean;
          readwrite?: boolean;
          safeIntegers?: boolean;
          strict?: boolean;
        },
  );

  query&lt;ReturnType, ParamsType&gt;(sql: string): Statement&lt;ReturnType, ParamsType&gt;;
  prepare&lt;ReturnType, ParamsType&gt;(sql: string): Statement&lt;ReturnType, ParamsType&gt;;
  run(sql: string, params?: SQLQueryBindings): { lastInsertRowid: number; changes: number };
  exec = this.run;

  transaction(insideTransaction: (...args: any) =&gt; void): CallableFunction &amp; {
    deferred: (...args: any) =&gt; void;
    immediate: (...args: any) =&gt; void;
    exclusive: (...args: any) =&gt; void;
  };

  close(throwOnError?: boolean): void;
}

class Statement&lt;ReturnType, ParamsType&gt; {
  all(...params: ParamsType[]): ReturnType[];
  get(...params: ParamsType[]): ReturnType | null;
  run(...params: ParamsType[]): {
    lastInsertRowid: number;
    changes: number;
  };
  values(...params: ParamsType[]): unknown[][];

  finalize(): void; // destroy statement and clean up resources
  toString(): string; // serialize to SQL

  columnNames: string[]; // the column names of the result set
  columnTypes: string[]; // types based on actual values in first row (call .get()/.all() first)
  declaredTypes: (string | null)[]; // types from CREATE TABLE schema (call .get()/.all() first)
  paramsCount: number; // the number of parameters expected by the statement
  native: any; // the native object representing the statement

  as&lt;T&gt;(Class: new (...args: any[]) =&gt; T): Statement&lt;T, ParamsType&gt;;
}

type SQLQueryBindings =
  | string
  | bigint
  | TypedArray
  | number
  | boolean
  | null
  | Record&lt;string, string | bigint | TypedArray | number | boolean | null&gt;;
See all 57 lines</pre> <h3 id="datatypes"><span>Datatypes</span></h3> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>JavaScript type</th>
<th>SQLite type</th>
</tr></thead>
<tbody>
<tr>
<td><code>string</code></td>
<td><code>TEXT</code></td>
</tr>
<tr>
<td><code>number</code></td>
<td>
<code>INTEGER</code> or <code>DECIMAL</code>
</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>
<code>INTEGER</code> (1 or 0)</td>
</tr>
<tr>
<td><code>Uint8Array</code></td>
<td><code>BLOB</code></td>
</tr>
<tr>
<td><code>Buffer</code></td>
<td><code>BLOB</code></td>
</tr>
<tr>
<td><code>bigint</code></td>
<td><code>INTEGER</code></td>
</tr>
<tr>
<td><code>null</code></td>
<td><code>NULL</code></td>
</tr>
</tbody>
</table></div></div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/sqlite" class="_attribution-link">https://bun.com/docs/runtime/sqlite</a>
  </p>
</div>
