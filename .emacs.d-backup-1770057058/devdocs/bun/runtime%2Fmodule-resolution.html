<h1 id="header">Module Resolution</h1>
<div data-page-title="Module Resolution" data-page-href="/runtime/module-resolution" id="content">
<span data-as="p">Module resolution in JavaScript is a complex topic.</span> <span data-as="p">The ecosystem is currently in the midst of a years-long transition from CommonJS modules to native ES modules. TypeScript enforces its own set of rules around import extensions that aren’t compatible with ESM. Different build tools support path re-mapping via disparate non-compatible mechanisms.</span> <span data-as="p">Bun aims to provide a consistent and predictable module resolution system that just works. Unfortunately it’s still quite complex.</span> <h2 id="syntax"><span>Syntax</span></h2> <span data-as="p">Consider the following files.</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">index.tshello.tsimport { hello } from "./hello";

hello();
</pre> <span data-as="p">When we run <code>index.ts</code>, it prints “Hello world!”.</span> <pre numberoflines="2" language="shellscript" data-language="typescript">bun index.ts
Hello world!
</pre> <span data-as="p">In this case, we are importing from <code>./hello</code>, a relative path with no extension. <strong>Extensioned imports are optional but supported.</strong> To resolve this import, Bun will check for the following files in order:</span> <ul> <li><code>./hello.tsx</code></li> <li><code>./hello.jsx</code></li> <li><code>./hello.ts</code></li> <li><code>./hello.mjs</code></li> <li><code>./hello.js</code></li> <li><code>./hello.cjs</code></li> <li><code>./hello.json</code></li> <li><code>./hello/index.tsx</code></li> <li><code>./hello/index.jsx</code></li> <li><code>./hello/index.ts</code></li> <li><code>./hello/index.mjs</code></li> <li><code>./hello/index.js</code></li> <li><code>./hello/index.cjs</code></li> <li><code>./hello/index.json</code></li> </ul> <span data-as="p">Import paths can optionally include extensions. If an extension is present, Bun will only check for a file with that exact extension.</span> <pre numberoflines="2" language="typescript" data-language="typescript">import { hello } from "./hello";
import { hello } from "./hello.ts"; // this works
</pre> <span data-as="p">If you import <code>from "*.js{x}"</code>, Bun will additionally check for a matching <code>*.ts{x}</code> file, to be compatible with TypeScript’s <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#new-file-extensions" target="_blank" rel="noreferrer">ES module support</a>.</span> <pre numberoflines="3" language="typescript" data-language="typescript">import { hello } from "./hello";
import { hello } from "./hello.ts"; // this works
import { hello } from "./hello.js"; // this also works
</pre> <span data-as="p">Bun supports both ES modules (<code>import</code>/<code>export</code> syntax) and CommonJS modules (<code>require()</code>/<code>module.exports</code>). The following CommonJS version would also work in Bun.</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">index.jshello.jsconst { hello } = require("./hello");

hello();
</pre> <span data-as="p">That said, using CommonJS is discouraged in new projects.</span> <hr> <h2 id="module-systems"><span>Module systems</span></h2> <span data-as="p">Bun has native support for CommonJS and ES modules. ES Modules are the recommended module format for new projects, but CommonJS modules are still widely used in the Node.js ecosystem.</span> <span data-as="p">In Bun’s JavaScript runtime, <code>require</code> can be used by both ES Modules and CommonJS modules. If the target module is an ES Module, <code>require</code> returns the module namespace object (equivalent to <code>import * as</code>). If the target module is a CommonJS module, <code>require</code> returns the <code>module.exports</code> object (as in Node.js).</span> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Module Type</th>
<th><code>require()</code></th>
<th><code>import * as</code></th>
</tr></thead>
<tbody>
<tr>
<td>ES Module</td>
<td>Module Namespace</td>
<td>Module Namespace</td>
</tr>
<tr>
<td>CommonJS</td>
<td>module.exports</td>
<td>
<code>default</code> is <code>module.exports</code>, keys of module.exports are named exports</td>
</tr>
</tbody>
</table></div></div> <h3 id="using-require"><span>Using <code>require()</code></span></h3> <span data-as="p">You can <code>require()</code> any file or package, even <code>.ts</code> or <code>.mjs</code> files.</span> <pre numberoflines="3" language="typescript" data-language="typescript">const { foo } = require("./foo"); // extensions are optional
const { bar } = require("./bar.mjs");
const { baz } = require("./baz.tsx");
</pre> <details><summary aria-controls="what-is-a-commonjs-module accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">What is a CommonJS module?</p></div></summary><div id="what-is-a-commonjs-module accordion children" role="region" aria-labelledby="what-is-a-commonjs-module" data-component-part="accordion-content">
<span data-as="p">In 2016, ECMAScript added support for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules" target="_blank" rel="noreferrer">ES Modules</a>. ES Modules are the standard for JavaScript modules. However, millions of npm packages still use CommonJS modules.</span><span data-as="p">CommonJS modules are modules that use <code>module.exports</code> to export values. Typically, <code>require</code> is used to import CommonJS modules.</span><pre numberoflines="2" language="typescript" data-language="typescript">const stuff = require("./stuff");
module.exports = { stuff };
</pre>
<span data-as="p">The biggest difference between CommonJS and ES Modules is that CommonJS modules are synchronous, while ES Modules are asynchronous. There are other differences too.</span><ul> <li>ES Modules support top-level <code>await</code> and CommonJS modules don’t.</li> <li>ES Modules are always in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noreferrer">strict mode</a>, while CommonJS modules are not.</li> <li>Browsers do not have native support for CommonJS modules, but they do have native support for ES Modules via <code>&lt;script type="module"&gt;</code>.</li> <li>CommonJS modules are not statically analyzable, while ES Modules only allow static imports and exports.</li> </ul>
<span data-as="p"><strong>CommonJS Modules:</strong> These are a type of module system used in JavaScript. One key feature of CommonJS modules is that they load and execute synchronously. This means that when you import a CommonJS module, the code in that module runs immediately, and your program waits for it to finish before moving on to the next task. It’s similar to reading a book from start to finish without skipping pages.</span><span data-as="p"><strong>ES Modules (ESM):</strong> These are another type of module system introduced in JavaScript. They have a slightly different behavior compared to CommonJS. In ESM, static imports (imports made using <code>import</code> statements) are synchronous, just like CommonJS. This means that when you import an ESM using a regular <code>import</code> statement, the code in that module runs immediately, and your program proceeds in a step-by-step manner. Think of it like reading a book page by page.</span><span data-as="p"><strong>Dynamic imports:</strong> Now, here comes the part that might be confusing. ES Modules also support importing modules on the fly via the <code>import()</code> function. This is called a “dynamic import” and it’s asynchronous, so it doesn’t block the main program execution. Instead, it fetches and loads the module in the background while your program continues to run. Once the module is ready, you can use it. This is like getting additional information from a book while you’re still reading it, without having to pause your reading.</span><span data-as="p"><strong>In summary:</strong></span><ul> <li>CommonJS modules and static ES Modules (<code>import</code> statements) work in a similar synchronous way, like reading a book from start to finish.</li> <li>ES Modules also offer the option to import modules asynchronously using the <code>import()</code> function. This is like looking up additional information in the middle of reading the book without stopping.</li> </ul>
</div></details> <h3 id="using-import"><span>Using <code>import</code></span></h3> <span data-as="p">You can <code>import</code> any file or package, even <code>.cjs</code> files.</span> <pre numberoflines="3" language="typescript" data-language="typescript">import { foo } from "./foo"; // extensions are optional
import bar from "./bar.ts";
import { stuff } from "./my-commonjs.cjs";
</pre> <h3 id="using-import-and-require-together"><span>Using <code>import</code> and <code>require()</code> together</span></h3> <span data-as="p">In Bun, you can use <code>import</code> or <code>require</code> in the same file—they both work, all the time.</span> <pre numberoflines="4" language="typescript" data-language="typescript">import { stuff } from "./my-commonjs.cjs";
import Stuff from "./my-commonjs.cjs";

const myStuff = require("./my-commonjs.cjs");
</pre> <h3 id="top-level-await"><span>Top level await</span></h3> <span data-as="p">The only exception to this rule is top-level await. You can’t <code>require()</code> a file that uses top-level await, since the <code>require()</code> function is inherently synchronous.</span> <span data-as="p">Fortunately, very few libraries use top-level await, so this is rarely a problem. But if you’re using top-level await in your application code, make sure that file isn’t being <code>require()</code> from elsewhere in your application. Instead, you should use <code>import</code> or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import" target="_blank" rel="noreferrer">dynamic <code>import()</code></a>.</span> <hr> <h2 id="importing-packages"><span>Importing packages</span></h2> <span data-as="p">Bun implements the Node.js module resolution algorithm, so you can import packages from <code>node_modules</code> with a bare specifier.</span> <pre numberoflines="1" language="typescript" data-language="typescript">import { stuff } from "foo";
</pre> <span data-as="p">The full specification of this algorithm are officially documented in the <a href="https://nodejs.org/api/modules.html" target="_blank" rel="noreferrer">Node.js documentation</a>; we won’t rehash it here. Briefly: if you import <code>from "foo"</code>, Bun scans up the file system for a <code>node_modules</code> directory containing the package <code>foo</code>.</span> <h3 id="node-path"><span>NODE_PATH</span></h3> <span data-as="p">Bun supports <code>NODE_PATH</code> for additional module resolution directories:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">NODE_PATH=./packages bun run src/index.js
</pre> <pre numberoflines="5" language="typescript" data-language="typescript">// packages/foo/index.js
export const hello = "world";

// src/index.js
import { hello } from "foo";
</pre> <span data-as="p">Multiple paths use the platform’s delimiter (<code>:</code> on Unix, <code>;</code> on Windows):</span> <pre numberoflines="2" language="shellscript" data-language="typescript">NODE_PATH=./packages:./lib bun run src/index.js  # Unix/macOS
NODE_PATH=./packages;./lib bun run src/index.js  # Windows
</pre> <span data-as="p">Once it finds the <code>foo</code> package, Bun reads the <code>package.json</code> to determine how the package should be imported. To determine the package’s entrypoint, Bun first reads the <code>exports</code> field and checks for the following conditions.</span> <pre numberoflines="10" language="json" data-language="typescript">{
  "name": "foo",
  "exports": {
    "bun": "./index.js",
    "node": "./index.js",
    "require": "./index.js", // if importer is CommonJS
    "import": "./index.mjs", // if importer is ES module
    "default": "./index.js"
  }
}
</pre> <span data-as="p">Whichever one of these conditions occurs <em>first</em> in the <code>package.json</code> is used to determine the package’s entrypoint.</span> <span data-as="p">Bun respects subpath <a href="https://nodejs.org/api/packages.html#subpath-exports" target="_blank" rel="noreferrer"><code>"exports"</code></a> and <a href="https://nodejs.org/api/packages.html#imports" target="_blank" rel="noreferrer"><code>"imports"</code></a>.</span> <pre numberoflines="6" language="json" data-language="typescript">{
  "name": "foo",
  "exports": {
    ".": "./index.js"
  }
}
</pre> <span data-as="p">Subpath imports and conditional imports work in conjunction with each other.</span> <pre numberoflines="9" language="json" data-language="typescript">{
  "name": "foo",
  "exports": {
    ".": {
      "import": "./index.mjs",
      "require": "./index.js"
    }
  }
}
</pre> <span data-as="p">As in Node.js, Specifying any subpath in the <code>"exports"</code> map will prevent other subpaths from being importable; you can only import files that are explicitly exported. Given the <code>package.json</code> above:</span> <pre numberoflines="2" language="typescript" data-language="typescript">import stuff from "foo"; // this works
import stuff from "foo/index.mjs"; // this doesn't
</pre> <div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p"><strong>Shipping TypeScript</strong> — Note that Bun supports the special <code>"bun"</code> export condition. If your library is written in TypeScript, you can publish your (un-transpiled!) TypeScript files to <code>npm</code> directly. If you specify your package’s <code>*.ts</code> entrypoint in the <code>"bun"</code> condition, Bun will directly import and execute your TypeScript source files.</span></div>
</div> <span data-as="p">If <code>exports</code> is not defined, Bun falls back to <code>"module"</code> (ESM imports only) then <a href="https://nodejs.org/api/packages.html#main" target="_blank" rel="noreferrer"><code>"main"</code></a>.</span> <pre numberoflines="5" language="json" data-language="typescript">{
  "name": "foo",
  "module": "./index.js",
  "main": "./index.js"
}
</pre> <h3 id="custom-conditions"><span>Custom conditions</span></h3> <span data-as="p">The <code>--conditions</code> flag allows you to specify a list of conditions to use when resolving packages from package.json <code>"exports"</code>.</span> <span data-as="p">This flag is supported in both <code>bun build</code> and Bun’s runtime.</span> <pre numberoflines="5" language="shellscript" data-language="typescript"># Use it with bun build:
bun build --conditions="react-server" --target=bun ./app/foo/route.js

# Use it with bun's runtime:
bun --conditions="react-server" ./app/foo/route.js
</pre> <span data-as="p">You can also use <code>conditions</code> programmatically with <code>Bun.build</code>:</span> <pre numberoflines="5" language="typescript" data-language="typescript">await Bun.build({
  conditions: ["react-server"],
  target: "bun",
  entryPoints: ["./app/foo/route.js"],
});
</pre> <hr> <h2 id="path-re-mapping"><span>Path re-mapping</span></h2> <span data-as="p">Bun supports import path re-mapping through TypeScript’s <a href="https://www.typescriptlang.org/tsconfig#paths" target="_blank" rel="noreferrer"><code>compilerOptions.paths</code></a> in <code>tsconfig.json</code>, which works well with editors. If you aren’t a TypeScript user, you can achieve the same behavior by using a <a href="https://code.visualstudio.com/docs/languages/jsconfig" target="_blank" rel="noreferrer"><code>jsconfig.json</code></a> in your project root.</span> <pre numberoflines="8" language="json" data-language="typescript">{
  "compilerOptions": {
    "paths": {
      "config": ["./config.ts"], // map specifier to file
      "components/*": ["components/*"] // wildcard matching
    }
  }
}
</pre> <span data-as="p">Bun also supports <a href="https://nodejs.org/api/packages.html#subpath-imports" target="_blank" rel="noreferrer">Node.js-style subpath imports</a> in <code>package.json</code>, where mapped paths must start with <code>#</code>. This approach doesn’t work as well with editors, but both options can be used together.</span> <pre numberoflines="6" language="json" data-language="typescript">{
  "imports": {
    "#config": "./config.ts", // map specifier to file
    "#components/*": "./components/*" // wildcard matching
  }
}
</pre> <details><summary aria-controls="low-level-details-of-commonjs-interop-in-bun accordion children" aria-expanded="false" data-component-part="accordion-button">

<div contenteditable="false" data-component-part="accordion-title-container"><p data-component-part="accordion-title">Low-level details of CommonJS interop in Bun</p></div></summary><div id="low-level-details-of-commonjs-interop-in-bun accordion children" role="region" aria-labelledby="low-level-details-of-commonjs-interop-in-bun" data-component-part="accordion-content">
<span data-as="p">Bun’s JavaScript runtime has native support for CommonJS. When Bun’s JavaScript transpiler detects usages of <code>module.exports</code>, it treats the file as CommonJS. The module loader will then wrap the transpiled module in a function shaped like this:</span><pre numberoflines="3" language="javascript" data-language="typescript">(function (module, exports, require) {
  // transpiled module
})(module, exports, require);
</pre>
<span data-as="p"><code>module</code>, <code>exports</code>, and <code>require</code> are very much like the <code>module</code>, <code>exports</code>, and <code>require</code> in Node.js. These are assigned via a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with" target="_blank" rel="noreferrer"><code>with scope</code></a> in C++. An internal <code>Map</code> stores the <code>exports</code> object to handle cyclical <code>require</code> calls before the module is fully loaded.</span><span data-as="p">Once the CommonJS module is successfully evaluated, a Synthetic Module Record is created with the <code>default</code> ES Module <a href="https://github.com/oven-sh/bun/blob/9b6913e1a674ceb7f670f917fc355bb8758c6c72/src/bun.js/bindings/CommonJSModuleRecord.cpp#L212-L213" target="_blank" rel="noreferrer">export set to <code>module.exports</code></a> and keys of the <code>module.exports</code> object are re-exported as named exports (if the <code>module.exports</code> object is an object).</span><span data-as="p">When using Bun’s bundler, this works differently. The bundler will wrap the CommonJS module in a <code>require_${moduleName}</code> function which returns the <code>module.exports</code> object.</span>
</div></details> <hr> <h2 id="import-meta"><span><code>import.meta</code></span></h2> <span data-as="p">The <code>import.meta</code> object is a way for a module to access information about itself. It’s part of the JavaScript language, but its contents are not standardized. Each “host” (browser, runtime, etc) is free to implement any properties it wishes on the <code>import.meta</code> object.</span> <span data-as="p">Bun implements the following properties.</span> <pre numberoflines="9" language="typescript" data-language="typescript">import.meta.dir; // =&gt; "/path/to/project"
import.meta.file; // =&gt; "file.ts"
import.meta.path; // =&gt; "/path/to/project/file.ts"
import.meta.url; // =&gt; "file:///path/to/project/file.ts"

import.meta.main; // `true` if this file is directly executed by `bun run`
// `false` otherwise

import.meta.resolve("zod"); // =&gt; "file:///path/to/project/node_modules/zod/index.js"
</pre> <div data-table-wrapper="true"><div><table>
<thead><tr>
<th>Property</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><code>import.meta.dir</code></td>
<td>Absolute path to the directory containing the current file, e.g. <code>/path/to/project</code>. Equivalent to <code>__dirname</code> in CommonJS modules (and Node.js)</td>
</tr>
<tr>
<td><code>import.meta.dirname</code></td>
<td>An alias to <code>import.meta.dir</code>, for Node.js compatibility</td>
</tr>
<tr>
<td><code>import.meta.env</code></td>
<td>An alias to <code>process.env</code>.</td>
</tr>
<tr>
<td><code>import.meta.file</code></td>
<td>The name of the current file, e.g. <code>index.tsx</code>
</td>
</tr>
<tr>
<td><code>import.meta.path</code></td>
<td>Absolute path to the current file, e.g. <code>/path/to/project/index.ts</code>. Equivalent to <code>__filename</code> in CommonJS modules (and Node.js)</td>
</tr>
<tr>
<td><code>import.meta.filename</code></td>
<td>An alias to <code>import.meta.path</code>, for Node.js compatibility</td>
</tr>
<tr>
<td><code>import.meta.main</code></td>
<td>Indicates whether the current file is the entrypoint to the current <code>bun</code> process. Is the file being directly executed by <code>bun run</code> or is it being imported?</td>
</tr>
<tr>
<td><code>import.meta.resolve</code></td>
<td>Resolve a module specifier (e.g. <code>"zod"</code> or <code>"./file.tsx"</code>) to a url. Equivalent to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta#resolve" target="_blank" rel="noreferrer"><code>import.meta.resolve</code> in browsers</a>. Example: <code>import.meta.resolve("zod")</code> returns <code>"file:///path/to/project/node_modules/zod/index.ts"</code>
</td>
</tr>
<tr>
<td><code>import.meta.url</code></td>
<td>A <code>string</code> url to the current file, e.g. <code>file:///path/to/project/index.ts</code>. Equivalent to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta#url" target="_blank" rel="noreferrer"><code>import.meta.url</code> in browsers</a>
</td>
</tr>
</tbody>
</table></div></div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/module-resolution" class="_attribution-link">https://bun.com/docs/runtime/module-resolution</a>
  </p>
</div>
