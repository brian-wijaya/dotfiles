<h1 id="header">Redis</h1>
<div data-page-title="Redis" data-page-href="/runtime/redis" id="content">
<div data-callout-type="note">

<div data-component-part="callout-content">Bun’s Redis client supports Redis server versions 7.2 and up.</div>
</div> <span data-as="p">Bun provides native bindings for working with Redis databases with a modern, Promise-based API. The interface is designed to be simple and performant, with built-in connection management, fully typed responses, and TLS support.</span> <pre numberoflines="18" language="typescript" data-language="typescript">import { redis } from "bun";

// Set a key
await redis.set("greeting", "Hello from Bun!");

// Get a key
const greeting = await redis.get("greeting");
console.log(greeting); // "Hello from Bun!"

// Increment a counter
await redis.set("counter", 0);
await redis.incr("counter");

// Check if a key exists
const exists = await redis.exists("greeting");

// Delete a key
await redis.del("greeting");
</pre> <hr> <h2 id="getting-started"><span>Getting Started</span></h2> <span data-as="p">To use the Redis client, you first need to create a connection:</span> <pre numberoflines="11" language="typescript" data-language="typescript">import { redis, RedisClient } from "bun";

// Using the default client (reads connection info from environment)
// process.env.REDIS_URL is used by default
await redis.set("hello", "world");
const result = await redis.get("hello");

// Creating a custom client
const client = new RedisClient("redis://username:password@localhost:6379");
await client.set("counter", "0");
await client.incr("counter");
</pre> <span data-as="p">By default, the client reads connection information from the following environment variables (in order of precedence):</span> <ul> <li><code>REDIS_URL</code></li> <li><code>VALKEY_URL</code></li> <li>If not set, defaults to <code>"redis://localhost:6379"</code>
</li> </ul> <h3 id="connection-lifecycle"><span>Connection Lifecycle</span></h3> <span data-as="p">The Redis client automatically handles connections in the background:</span> <pre numberoflines="11" language="typescript" data-language="typescript">// No connection is made until a command is executed
const client = new RedisClient();

// First command initiates the connection
await client.set("key", "value");

// Connection remains open for subsequent commands
await client.get("key");

// Explicitly close the connection when done
client.close();
</pre> <span data-as="p">You can also manually control the connection lifecycle:</span> <pre numberoflines="10" language="typescript" data-language="typescript">const client = new RedisClient();

// Explicitly connect
await client.connect();

// Run commands
await client.set("key", "value");

// Disconnect when done
client.close();
</pre> <hr> <h2 id="basic-operations"><span>Basic Operations</span></h2> <h3 id="string-operations"><span>String Operations</span></h3> <pre numberoflines="21" language="typescript" data-language="typescript">// Set a key
await redis.set("user:1:name", "Alice");

// Get a key
const name = await redis.get("user:1:name");

// Get a key as Uint8Array
const buffer = await redis.getBuffer("user:1:name");

// Delete a key
await redis.del("user:1:name");

// Check if a key exists
const exists = await redis.exists("user:1:name");

// Set expiration (in seconds)
await redis.set("session:123", "active");
await redis.expire("session:123", 3600); // expires in 1 hour

// Get time to live (in seconds)
const ttl = await redis.ttl("session:123");
</pre> <h3 id="numeric-operations"><span>Numeric Operations</span></h3> <pre numberoflines="8" language="typescript" data-language="typescript">// Set initial value
await redis.set("counter", "0");

// Increment by 1
await redis.incr("counter");

// Decrement by 1
await redis.decr("counter");
</pre> <h3 id="hash-operations"><span>Hash Operations</span></h3> <pre numberoflines="16" language="typescript" data-language="typescript">// Set multiple fields in a hash
await redis.hmset("user:123", ["name", "Alice", "email", "alice@example.com", "active", "true"]);

// Get multiple fields from a hash
const userFields = await redis.hmget("user:123", ["name", "email"]);
console.log(userFields); // ["Alice", "alice@example.com"]

// Get single field from hash (returns value directly, null if missing)
const userName = await redis.hget("user:123", "name");
console.log(userName); // "Alice"

// Increment a numeric field in a hash
await redis.hincrby("user:123", "visits", 1);

// Increment a float field in a hash
await redis.hincrbyfloat("user:123", "score", 1.5);
</pre> <h3 id="set-operations"><span>Set Operations</span></h3> <pre numberoflines="17" language="typescript" data-language="typescript">// Add member to set
await redis.sadd("tags", "javascript");

// Remove member from set
await redis.srem("tags", "javascript");

// Check if member exists in set
const isMember = await redis.sismember("tags", "javascript");

// Get all members of a set
const allTags = await redis.smembers("tags");

// Get a random member
const randomTag = await redis.srandmember("tags");

// Pop (remove and return) a random member
const poppedTag = await redis.spop("tags");
</pre> <hr> <h2 id="pub/sub"><span>Pub/Sub</span></h2> <span data-as="p">Bun provides native bindings for the <a href="https://redis.io/docs/latest/develop/pubsub/" target="_blank" rel="noreferrer">Redis Pub/Sub</a> protocol. <strong>New in Bun 1.2.23</strong></span> <div data-callout-type="warning">

<div data-component-part="callout-content"><span data-as="p">The Redis Pub/Sub feature is experimental. Although we expect it to be stable, we’re currently actively looking for feedback and areas for improvement.</span></div>
</div> <h3 id="basic-usage"><span>Basic Usage</span></h3> <span data-as="p">To get started publishing messages, you can set up a publisher in <code>publisher.ts</code>:</span> <pre numberoflines="8" language="typescript" data-language="typescript">import { RedisClient } from "bun";

const writer = new RedisClient("redis://localhost:6739");
await writer.connect();

writer.publish("general", "Hello everyone!");

writer.close();
</pre> <span data-as="p">In another file, create the subscriber in <code>subscriber.ts</code>:</span> <pre numberoflines="8" language="typescript" data-language="typescript">import { RedisClient } from "bun";

const listener = new RedisClient("redis://localhost:6739");
await listener.connect();

await listener.subscribe("general", (message, channel) =&gt; {
  console.log(`Received: ${message}`);
});
</pre> <span data-as="p">In one shell, run your subscriber:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun run subscriber.ts
</pre> <span data-as="p">and, in another, run your publisher:</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun run publisher.ts
</pre> <div data-callout-type="note">

<div data-component-part="callout-content">
<span data-as="p">The subscription mode takes over the <code>RedisClient</code> connection. A client with subscriptions can only call <code>RedisClient.prototype.subscribe()</code>. In other words, applications which need to message Redis need a separate connection, acquirable through <code>.duplicate()</code>:</span><pre numberoflines="8" language="typescript" data-language="typescript">import { RedisClient } from "bun";

const redis = new RedisClient("redis://localhost:6379");
await redis.connect();
const subscriber = await redis.duplicate(); 

await subscriber.subscribe("foo", () =&gt; {});
await redis.set("bar", "baz");
</pre>
</div>
</div> <h3 id="publishing"><span>Publishing</span></h3> <span data-as="p">Publishing messages is done through the <code>publish()</code> method:</span> <pre numberoflines="1" language="typescript" data-language="typescript">await client.publish(channelName, message);
</pre> <h3 id="subscriptions"><span>Subscriptions</span></h3> <span data-as="p">The Bun <code>RedisClient</code> allows you to subscribe to channels through the <code>.subscribe()</code> method:</span> <pre numberoflines="1" language="typescript" data-language="typescript">await client.subscribe(channel, (message, channel) =&gt; {});
</pre> <span data-as="p">You can unsubscribe through the <code>.unsubscribe()</code> method:</span> <pre numberoflines="3" language="typescript" data-language="typescript">await client.unsubscribe(); // Unsubscribe from all channels.
await client.unsubscribe(channel); // Unsubscribe a particular channel.
await client.unsubscribe(channel, listener); // Unsubscribe a particular listener.
</pre> <h2 id="advanced-usage"><span>Advanced Usage</span></h2> <h3 id="command-execution-and-pipelining"><span>Command Execution and Pipelining</span></h3> <span data-as="p">The client automatically pipelines commands, improving performance by sending multiple commands in a batch and processing responses as they arrive.</span> <pre numberoflines="2" language="typescript" data-language="typescript">// Commands are automatically pipelined by default
const [infoResult, listResult] = await Promise.all([redis.get("user:1:name"), redis.get("user:2:email")]);
</pre> <span data-as="p">To disable automatic pipelining, you can set the <code>enableAutoPipelining</code> option to <code>false</code>:</span> <pre numberoflines="3" language="typescript" data-language="typescript">const client = new RedisClient("redis://localhost:6379", {
  enableAutoPipelining: false, 
});
</pre> <h3 id="raw-commands"><span>Raw Commands</span></h3> <span data-as="p">When you need to use commands that don’t have convenience methods, you can use the <code>send</code> method:</span> <pre numberoflines="8" language="typescript" data-language="typescript">// Run any Redis command
const info = await redis.send("INFO", []);

// LPUSH to a list
await redis.send("LPUSH", ["mylist", "value1", "value2"]);

// Get list range
const list = await redis.send("LRANGE", ["mylist", "0", "-1"]);
</pre> <span data-as="p">The <code>send</code> method allows you to use any Redis command, even ones that don’t have dedicated methods in the client. The first argument is the command name, and the second argument is an array of string arguments.</span> <h3 id="connection-events"><span>Connection Events</span></h3> <span data-as="p">You can register handlers for connection events:</span> <pre numberoflines="15" language="typescript" data-language="typescript">const client = new RedisClient();

// Called when successfully connected to Redis server
client.onconnect = () =&gt; {
  console.log("Connected to Redis server");
};

// Called when disconnected from Redis server
client.onclose = error =&gt; {
  console.error("Disconnected from Redis server:", error);
};

// Manually connect/disconnect
await client.connect();
client.close();
</pre> <h3 id="connection-status-and-monitoring"><span>Connection Status and Monitoring</span></h3> <pre numberoflines="5" language="typescript" data-language="typescript">// Check if connected
console.log(client.connected); // boolean indicating connection status

// Check amount of data buffered (in bytes)
console.log(client.bufferedAmount);
</pre> <h3 id="type-conversion"><span>Type Conversion</span></h3> <span data-as="p">The Redis client handles automatic type conversion for Redis responses:</span> <ul> <li>Integer responses are returned as JavaScript numbers</li> <li>Bulk strings are returned as JavaScript strings</li> <li>Simple strings are returned as JavaScript strings</li> <li>Null bulk strings are returned as <code>null</code>
</li> <li>Array responses are returned as JavaScript arrays</li> <li>Error responses throw JavaScript errors with appropriate error codes</li> <li>Boolean responses (RESP3) are returned as JavaScript booleans</li> <li>Map responses (RESP3) are returned as JavaScript objects</li> <li>Set responses (RESP3) are returned as JavaScript arrays</li> </ul> <span data-as="p">Special handling for specific commands:</span> <ul> <li>
<code>EXISTS</code> returns a boolean instead of a number (1 becomes true, 0 becomes false)</li> <li>
<code>SISMEMBER</code> returns a boolean (1 becomes true, 0 becomes false)</li> </ul> <span data-as="p">The following commands disable automatic pipelining:</span> <ul> <li><code>AUTH</code></li> <li><code>INFO</code></li> <li><code>QUIT</code></li> <li><code>EXEC</code></li> <li><code>MULTI</code></li> <li><code>WATCH</code></li> <li><code>SCRIPT</code></li> <li><code>SELECT</code></li> <li><code>CLUSTER</code></li> <li><code>DISCARD</code></li> <li><code>UNWATCH</code></li> <li><code>PIPELINE</code></li> <li><code>SUBSCRIBE</code></li> <li><code>UNSUBSCRIBE</code></li> <li><code>UNPSUBSCRIBE</code></li> </ul> <hr> <h2 id="connection-options"><span>Connection Options</span></h2> <span data-as="p">When creating a client, you can pass various options to configure the connection:</span> <pre numberoflines="29" language="typescript" data-language="typescript">const client = new RedisClient("redis://localhost:6379", {
  // Connection timeout in milliseconds (default: 10000)
  connectionTimeout: 5000,

  // Idle timeout in milliseconds (default: 0 = no timeout)
  idleTimeout: 30000,

  // Whether to automatically reconnect on disconnection (default: true)
  autoReconnect: true,

  // Maximum number of reconnection attempts (default: 10)
  maxRetries: 10,

  // Whether to queue commands when disconnected (default: true)
  enableOfflineQueue: true,

  // Whether to automatically pipeline commands (default: true)
  enableAutoPipelining: true,

  // TLS options (default: false)
  tls: true,
  // Alternatively, provide custom TLS config:
  // tls: {
  //   rejectUnauthorized: true,
  //   ca: "path/to/ca.pem",
  //   cert: "path/to/cert.pem",
  //   key: "path/to/key.pem",
  // }
});
</pre> <h3 id="reconnection-behavior"><span>Reconnection Behavior</span></h3> <span data-as="p">When a connection is lost, the client automatically attempts to reconnect with exponential backoff:</span> <ol> <li>The client starts with a small delay (50ms) and doubles it with each attempt</li> <li>Reconnection delay is capped at 2000ms (2 seconds)</li> <li>The client attempts to reconnect up to <code>maxRetries</code> times (default: 10)</li> <li>Commands executed during disconnection are: <ul> <li>Queued if <code>enableOfflineQueue</code> is true (default)</li> <li>Rejected immediately if <code>enableOfflineQueue</code> is false</li> </ul> </li> </ol> <hr> <h2 id="supported-url-formats"><span>Supported URL Formats</span></h2> <span data-as="p">The Redis client supports various URL formats:</span> <pre numberoflines="23" language="typescript" data-language="typescript">// Standard Redis URL
new RedisClient("redis://localhost:6379");
new RedisClient("redis://localhost:6379");

// With authentication
new RedisClient("redis://username:password@localhost:6379");

// With database number
new RedisClient("redis://localhost:6379/0");

// TLS connections
new RedisClient("rediss://localhost:6379");
new RedisClient("rediss://localhost:6379");
new RedisClient("redis+tls://localhost:6379");
new RedisClient("redis+tls://localhost:6379");

// Unix socket connections
new RedisClient("redis+unix:///path/to/socket");
new RedisClient("redis+unix:///path/to/socket");

// TLS over Unix socket
new RedisClient("redis+tls+unix:///path/to/socket");
new RedisClient("redis+tls+unix:///path/to/socket");
</pre> <hr> <h2 id="error-handling"><span>Error Handling</span></h2> <span data-as="p">The Redis client throws typed errors for different scenarios:</span> <pre numberoflines="11" language="typescript" data-language="typescript">try {
  await redis.get("non-existent-key");
} catch (error) {
  if (error.code === "ERR_REDIS_CONNECTION_CLOSED") {
    console.error("Connection to Redis server was closed");
  } else if (error.code === "ERR_REDIS_AUTHENTICATION_FAILED") {
    console.error("Authentication failed");
  } else {
    console.error("Unexpected error:", error);
  }
}
</pre> <span data-as="p">Common error codes:</span> <ul> <li>
<code>ERR_REDIS_CONNECTION_CLOSED</code> - Connection to the server was closed</li> <li>
<code>ERR_REDIS_AUTHENTICATION_FAILED</code> - Failed to authenticate with the server</li> <li>
<code>ERR_REDIS_INVALID_RESPONSE</code> - Received an invalid response from the server</li> </ul> <hr> <h2 id="example-use-cases"><span>Example Use Cases</span></h2> <h3 id="caching"><span>Caching</span></h3> <pre numberoflines="18" language="typescript" data-language="typescript">async function getUserWithCache(userId) {
  const cacheKey = `user:${userId}`;

  // Try to get from cache first
  const cachedUser = await redis.get(cacheKey);
  if (cachedUser) {
    return JSON.parse(cachedUser);
  }

  // Not in cache, fetch from database
  const user = await database.getUser(userId);

  // Store in cache for 1 hour
  await redis.set(cacheKey, JSON.stringify(user));
  await redis.expire(cacheKey, 3600);

  return user;
}
</pre> <h3 id="rate-limiting"><span>Rate Limiting</span></h3> <pre numberoflines="17" language="typescript" data-language="typescript">async function rateLimit(ip, limit = 100, windowSecs = 3600) {
  const key = `ratelimit:${ip}`;

  // Increment counter
  const count = await redis.incr(key);

  // Set expiry if this is the first request in window
  if (count === 1) {
    await redis.expire(key, windowSecs);
  }

  // Check if limit exceeded
  return {
    limited: count &gt; limit,
    remaining: Math.max(0, limit - count),
  };
}
</pre> <h3 id="session-storage"><span>Session Storage</span></h3> <pre numberoflines="26" language="typescript" data-language="typescript">async function createSession(userId, data) {
  const sessionId = crypto.randomUUID();
  const key = `session:${sessionId}`;

  // Store session with expiration
  await redis.hmset(key, ["userId", userId.toString(), "created", Date.now().toString(), "data", JSON.stringify(data)]);
  await redis.expire(key, 86400); // 24 hours

  return sessionId;
}

async function getSession(sessionId) {
  const key = `session:${sessionId}`;

  // Get session data
  const exists = await redis.exists(key);
  if (!exists) return null;

  const [userId, created, data] = await redis.hmget(key, ["userId", "created", "data"]);

  return {
    userId: Number(userId),
    created: Number(created),
    data: JSON.parse(data),
  };
}
</pre> <hr> <h2 id="implementation-notes"><span>Implementation Notes</span></h2> <span data-as="p">Bun’s Redis client is implemented in Zig and uses the Redis Serialization Protocol (RESP3). It manages connections efficiently and provides automatic reconnection with exponential backoff.</span> <span data-as="p">The client supports pipelining commands, meaning multiple commands can be sent without waiting for the replies to previous commands. This significantly improves performance when sending multiple commands in succession.</span> <h2 id="limitations-and-future-plans"><span>Limitations and Future Plans</span></h2> <span data-as="p">Current limitations of the Redis client we are planning to address in future versions:</span> <ul> <li>Transactions (MULTI/EXEC) must be done through raw commands for now</li> </ul> <span data-as="p">Unsupported features:</span> <ul> <li>Redis Sentinel</li> <li>Redis Cluster</li> </ul>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/redis" class="_attribution-link">https://bun.com/docs/runtime/redis</a>
  </p>
</div>
