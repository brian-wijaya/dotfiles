<h1 id="header">Macros</h1>
<div data-page-title="Macros" data-page-href="/bundler/macros" id="content">
<span data-as="p">Macros are a mechanism for running JavaScript functions at bundle-time. The value returned from these functions are directly inlined into your bundle.</span> <span data-as="p">As a toy example, consider this simple function that returns a random number.</span> <pre numberoflines="3" language="typescript" data-language="typescript">export function random() {
  return Math.random();
}
</pre> <span data-as="p">This is just a regular function in a regular file, but we can use it as a macro like so:</span> <pre numberoflines="3" language="tsx" data-language="typescript">import { random } from "./random.ts" with { type: "macro" };

console.log(`Your random number is ${random()}`);
</pre> <div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p">Macros are indicated using import attribute syntax. If you haven’t seen this syntax before, it’s a Stage 3 TC39 proposal that lets you attach additional metadata to import statements.</span></div>
</div> <span data-as="p">Now we’ll bundle this file with <code>bun build</code>. The bundled file will be printed to stdout.</span> <pre numberoflines="1" language="shellscript" data-language="typescript">bun build ./cli.tsx
</pre> <pre numberoflines="1" language="javascript" data-language="typescript">console.log(`Your random number is ${0.6805550949689833}`);
</pre> <span data-as="p">As you can see, the source code of the <code>random</code> function occurs nowhere in the bundle. Instead, it is executed during bundling and function call (<code>random()</code>) is replaced with the result of the function. Since the source code will never be included in the bundle, macros can safely perform privileged operations like reading from a database.</span> <h2 id="when-to-use-macros"><span>When to use macros</span></h2> <span data-as="p">If you have several build scripts for small things where you would otherwise have a one-off build script, bundle-time code execution can be easier to maintain. It lives with the rest of your code, it runs with the rest of the build, it is automatically parallelized, and if it fails, the build fails too.</span> <span data-as="p">If you find yourself running a lot of code at bundle-time though, consider running a server instead.</span> <h2 id="import-attributes"><span>Import attributes</span></h2> <span data-as="p">Bun Macros are import statements annotated using either:</span> <ul> <li>
<code>with { type: 'macro' }</code> — an import attribute, a Stage 3 ECMA Script proposal</li> <li>
<code>assert { type: 'macro' }</code> — an import assertion, an earlier incarnation of import attributes that has now been abandoned (but is already supported by a number of browsers and runtimes)</li> </ul> <h2 id="security-considerations"><span>Security considerations</span></h2> <span data-as="p">Macros must explicitly be imported with <code>{ type: "macro" }</code> in order to be executed at bundle-time. These imports have no effect if they are not called, unlike regular JavaScript imports which may have side effects.</span> <span data-as="p">You can disable macros entirely by passing the <code>--no-macros</code> flag to Bun. It produces a build error like this:</span> <pre numberoflines="6" language="text" data-language="typescript">error: Macros are disabled

foo();
^
./hello.js:3:1 53
</pre> <span data-as="p">To reduce the potential attack surface for malicious packages, macros cannot be invoked from inside <code>node_modules/**/*</code>. If a package attempts to invoke a macro, you’ll see an error like this:</span> <pre numberoflines="6" language="text" data-language="typescript">error: For security reasons, macros cannot be run from node_modules.

beEvil();
^
node_modules/evil/index.js:3:1 50
</pre> <span data-as="p">Your application code can still import macros from <code>node_modules</code> and invoke them.</span> <pre numberoflines="3" language="typescript" data-language="typescript">import { macro } from "some-package" with { type: "macro" };

macro();
</pre> <h2 id="export-condition-“macro”"><span>Export condition “macro”</span></h2> <span data-as="p">When shipping a library containing a macro to npm or another package registry, use the <code>"macro"</code> export condition to provide a special version of your package exclusively for the macro environment.</span> <pre numberoflines="9" language="json" data-language="typescript">{
  "name": "my-package",
  "exports": {
    "import": "./index.js",
    "require": "./index.js",
    "default": "./index.js",
    "macro": "./index.macro.js"
  }
}
</pre> <span data-as="p">With this configuration, users can consume your package at runtime or at bundle-time using the same import specifier:</span> <pre numberoflines="2" language="typescript" data-language="typescript">import pkg from "my-package"; // runtime import
import { macro } from "my-package" with { type: "macro" }; // macro import
</pre> <span data-as="p">The first import will resolve to <code>./node_modules/my-package/index.js</code>, while the second will be resolved by Bun’s bundler to <code>./node_modules/my-package/index.macro.js</code>.</span> <h2 id="execution"><span>Execution</span></h2> <span data-as="p">When Bun’s transpiler sees a macro import, it calls the function inside the transpiler using Bun’s JavaScript runtime and converts the return value from JavaScript into an AST node. These JavaScript functions are called at bundle-time, not runtime.</span> <span data-as="p">Macros are executed synchronously in the transpiler during the visiting phase—before plugins and before the transpiler generates the AST. They are executed in the order they are imported. The transpiler will wait for the macro to finish executing before continuing. The transpiler will also await any Promise returned by a macro.</span> <span data-as="p">Bun’s bundler is multi-threaded. As such, macros execute in parallel inside of multiple spawned JavaScript “workers”.</span> <h2 id="dead-code-elimination"><span>Dead code elimination</span></h2> <span data-as="p">The bundler performs dead code elimination after running and inlining macros. So given the following macro:</span> <pre numberoflines="3" language="typescript" data-language="typescript">export function returnFalse() {
  return false;
}
</pre> <span data-as="p">…then bundling the following file will produce an empty bundle, provided that the minify syntax option is enabled.</span> <pre numberoflines="5" language="typescript" data-language="typescript">import { returnFalse } from "./returnFalse.ts" with { type: "macro" };

if (returnFalse()) {
  console.log("This code is eliminated");
}
</pre> <h2 id="serializability"><span>Serializability</span></h2> <span data-as="p">Bun’s transpiler needs to be able to serialize the result of the macro so it can be inlined into the AST. All JSON-compatible data structures are supported:</span> <pre numberoflines="7" language="typescript" data-language="typescript">export function getObject() {
  return {
    foo: "bar",
    baz: 123,
    array: [1, 2, { nested: "value" }],
  };
}
</pre> <span data-as="p">Macros can be async, or return Promise instances. Bun’s transpiler will automatically await the Promise and inline the result.</span> <pre numberoflines="3" language="typescript" data-language="typescript">export async function getText() {
  return "async value";
}
</pre> <span data-as="p">The transpiler implements special logic for serializing common data formats like <code>Response</code>, <code>Blob</code>, <code>TypedArray</code>.</span> <ul> <li>
<strong>TypedArray</strong>: Resolves to a base64-encoded string.</li> <li>
<strong>Response</strong>: Bun will read the <code>Content-Type</code> and serialize accordingly; for instance, a Response with type <code>application/json</code> will be automatically parsed into an object and <code>text/plain</code> will be inlined as a string. Responses with an unrecognized or undefined type will be base-64 encoded.</li> <li>
<strong>Blob</strong>: As with Response, the serialization depends on the <code>type</code> property.</li> </ul> <span data-as="p">The result of <code>fetch</code> is <code>Promise&lt;Response&gt;</code>, so it can be directly returned.</span> <pre numberoflines="3" language="typescript" data-language="typescript">export function getObject() {
  return fetch("https://bun.com");
}
</pre> <span data-as="p">Functions and instances of most classes (except those mentioned above) are not serializable.</span> <pre numberoflines="4" language="typescript" data-language="typescript">export function getText(url: string) {
  // this doesn't work!
  return () =&gt; {};
}
</pre> <h2 id="arguments"><span>Arguments</span></h2> <span data-as="p">Macros can accept inputs, but only in limited cases. The value must be statically known. For example, the following is not allowed:</span> <pre numberoflines="9" language="typescript" data-language="typescript">import { getText } from "./getText.ts" with { type: "macro" };

export function howLong() {
  // the value of `foo` cannot be statically known
  const foo = Math.random() ? "foo" : "bar";

  const text = getText(`https://example.com/${foo}`);
  console.log("The page is ", text.length, " characters long");
}
</pre> <span data-as="p">However, if the value of <code>foo</code> is known at bundle-time (say, if it’s a constant or the result of another macro) then it’s allowed:</span> <pre numberoflines="9" language="typescript" data-language="typescript">import { getText } from "./getText.ts" with { type: "macro" };
import { getFoo } from "./getFoo.ts" with { type: "macro" };

export function howLong() {
  // this works because getFoo() is statically known
  const foo = getFoo();
  const text = getText(`https://example.com/${foo}`);
  console.log("The page is", text.length, "characters long");
}
</pre> <span data-as="p">This outputs:</span> <pre numberoflines="4" language="javascript" data-language="typescript">function howLong() {
  console.log("The page is", 1322, "characters long");
}
export { howLong };
</pre> <h2 id="examples"><span>Examples</span></h2> <h3 id="embed-latest-git-commit-hash"><span>Embed latest git commit hash</span></h3> <pre numberoflines="8" language="typescript" data-language="typescript">export function getGitCommitHash() {
  const { stdout } = Bun.spawnSync({
    cmd: ["git", "rev-parse", "HEAD"],
    stdout: "pipe",
  });

  return stdout.toString();
}
</pre> <span data-as="p">When we build it, the <code>getGitCommitHash</code> is replaced with the result of calling the function:</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">inputoutputimport { getGitCommitHash } from "./getGitCommitHash.ts" with { type: "macro" };

console.log(`The current Git commit hash is ${getGitCommitHash()}`);
</pre> <div data-callout-type="info">

<div data-component-part="callout-content"><span data-as="p">You’re probably thinking “Why not just use <code>process.env.GIT_COMMIT_HASH</code>?” Well, you can do that too. But can you do this with an environment variable?</span></div>
</div> <h3 id="make-fetch-requests-at-bundle-time"><span>Make fetch() requests at bundle-time</span></h3> <span data-as="p">In this example, we make an outgoing HTTP request using <code>fetch()</code>, parse the HTML response using <code>HTMLRewriter</code>, and return an object containing the title and meta tags–all at bundle-time.</span> <pre numberoflines="23" language="typescript" data-language="typescript">export async function extractMetaTags(url: string) {
  const response = await fetch(url);
  const meta = {
    title: "",
  };
  new HTMLRewriter()
    .on("title", {
      text(element) {
        meta.title += element.text;
      },
    })
    .on("meta", {
      element(element) {
        const name =
          element.getAttribute("name") || element.getAttribute("property") || element.getAttribute("itemprop");

        if (name) meta[name] = element.getAttribute("content");
      },
    })
    .transform(response);

  return meta;
}
</pre> <span data-as="p">The <code>extractMetaTags</code> function is erased at bundle-time and replaced with the result of the function call. This means that the fetch request happens at bundle-time, and the result is embedded in the bundle. Also, the branch throwing the error is eliminated since it’s unreachable.</span> <pre dir="ltr" data-orientation="horizontal" data-language="typescript">inputoutputimport { extractMetaTags } from "./meta.ts" with { type: "macro" };

export const Head = () =&gt; {
  const headTags = extractMetaTags("https://example.com");

  if (headTags.title !== "Example Domain") {
    throw new Error("Expected title to be 'Example Domain'");
  }

  return (
    &lt;head&gt;
      &lt;title&gt;{headTags.title}&lt;/title&gt;
      &lt;meta name="viewport" content={headTags.viewport} /&gt;
    &lt;/head&gt;
  );
};
</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/bundler/macros" class="_attribution-link">https://bun.com/docs/bundler/macros</a>
  </p>
</div>
