<h1 id="header">Streams</h1>
<div data-page-title="Streams" data-page-href="/runtime/streams" id="content">
<span data-as="p">Streams are an important abstraction for working with binary data without loading it all into memory at once. They are commonly used for reading and writing files, sending and receiving network requests, and processing large amounts of data.</span> <span data-as="p">Bun implements the Web APIs <a href="https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream" target="_blank" rel="noreferrer"><code>ReadableStream</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/WritableStream" target="_blank" rel="noreferrer"><code>WritableStream</code></a>.</span> <div data-callout-type="note">

<div data-component-part="callout-content"><span data-as="p">Bun also implements the <code>node:stream</code> module, including <a href="https://nodejs.org/api/stream.html#stream_readable_streams" target="_blank" rel="noreferrer"><code>Readable</code></a>, <a href="https://nodejs.org/api/stream.html#stream_writable_streams" target="_blank" rel="noreferrer"><code>Writable</code></a>, and <a href="https://nodejs.org/api/stream.html#stream_duplex_and_transform_streams" target="_blank" rel="noreferrer"><code>Duplex</code></a>. For complete documentation, refer to the <a href="https://nodejs.org/api/stream.html" target="_blank" rel="noreferrer">Node.js docs</a>.</span></div>
</div> <span data-as="p">To create a simple <code>ReadableStream</code>:</span> <pre numberoflines="7" language="typescript" data-language="typescript">const stream = new ReadableStream({
  start(controller) {
    controller.enqueue("hello");
    controller.enqueue("world");
    controller.close();
  },
});
</pre> <span data-as="p">The contents of a <code>ReadableStream</code> can be read chunk-by-chunk with <code>for await</code> syntax.</span> <pre numberoflines="6" language="typescript" data-language="typescript">for await (const chunk of stream) {
  console.log(chunk);
}

// hello
// world
</pre> <hr> <h2 id="direct-readablestream"><span>Direct <code>ReadableStream</code></span></h2> <span data-as="p">Bun implements an optimized version of <code>ReadableStream</code> that avoid unnecessary data copying &amp; queue management logic.</span> <span data-as="p">With a traditional <code>ReadableStream</code>, chunks of data are <em>enqueued</em>. Each chunk is copied into a queue, where it sits until the stream is ready to send more data.</span> <pre numberoflines="7" language="typescript" data-language="typescript">const stream = new ReadableStream({
  start(controller) {
    controller.enqueue("hello");
    controller.enqueue("world");
    controller.close();
  },
});
</pre> <span data-as="p">With a direct <code>ReadableStream</code>, chunks of data are written directly to the stream. No queueing happens, and there’s no need to clone the chunk data into memory. The <code>controller</code> API is updated to reflect this; instead of <code>.enqueue()</code> you call <code>.write</code>.</span> <pre numberoflines="7" language="typescript" data-language="typescript">const stream = new ReadableStream({
  type: "direct", 
  pull(controller) {
    controller.write("hello");
    controller.write("world");
  },
});
</pre> <span data-as="p">When using a direct <code>ReadableStream</code>, all chunk queueing is handled by the destination. The consumer of the stream receives exactly what is passed to <code>controller.write()</code>, without any encoding or modification.</span> <hr> <h2 id="async-generator-streams"><span>Async generator streams</span></h2> <span data-as="p">Bun also supports async generator functions as a source for <code>Response</code> and <code>Request</code>. This is an easy way to create a <code>ReadableStream</code> that fetches data from an asynchronous source.</span> <pre numberoflines="8" language="typescript" data-language="typescript">const response = new Response(
  (async function* () {
    yield "hello";
    yield "world";
  })(),
);

await response.text(); // "helloworld"
</pre> <span data-as="p">You can also use <code>[Symbol.asyncIterator]</code> directly.</span> <pre numberoflines="8" language="typescript" data-language="typescript">const response = new Response({
  [Symbol.asyncIterator]: async function* () {
    yield "hello";
    yield "world";
  },
});

await response.text(); // "helloworld"
</pre> <span data-as="p">If you need more granular control over the stream, <code>yield</code> will return the direct ReadableStream controller.</span> <pre numberoflines="8" language="typescript" data-language="typescript">const response = new Response({
  [Symbol.asyncIterator]: async function* () {
    const controller = yield "hello";
    await controller.end();
  },
});

await response.text(); // "hello"
</pre> <hr> <h2 id="bun-arraybuffersink"><span><code>Bun.ArrayBufferSink</code></span></h2> <span data-as="p">The <code>Bun.ArrayBufferSink</code> class is a fast incremental writer for constructing an <code>ArrayBuffer</code> of unknown size.</span> <pre numberoflines="10" language="typescript" data-language="typescript">const sink = new Bun.ArrayBufferSink();

sink.write("h");
sink.write("e");
sink.write("l");
sink.write("l");
sink.write("o");

sink.end();
// ArrayBuffer(5) [ 104, 101, 108, 108, 111 ]
</pre> <span data-as="p">To instead retrieve the data as a <code>Uint8Array</code>, pass the <code>asUint8Array</code> option to the <code>start</code> method.</span> <pre numberoflines="13" language="typescript" data-language="typescript">const sink = new Bun.ArrayBufferSink();
sink.start({
  asUint8Array: true, 
});

sink.write("h");
sink.write("e");
sink.write("l");
sink.write("l");
sink.write("o");

sink.end();
// Uint8Array(5) [ 104, 101, 108, 108, 111 ]
</pre> <span data-as="p">The <code>.write()</code> method supports strings, typed arrays, <code>ArrayBuffer</code>, and <code>SharedArrayBuffer</code>.</span> <pre numberoflines="5" language="typescript" data-language="typescript">sink.write("h");
sink.write(new Uint8Array([101, 108]));
sink.write(Buffer.from("lo").buffer);

sink.end();
</pre> <span data-as="p">Once <code>.end()</code> is called, no more data can be written to the <code>ArrayBufferSink</code>. However, in the context of buffering a stream, it’s useful to continuously write data and periodically <code>.flush()</code> the contents (say, into a <code>WriteableStream</code>). To support this, pass <code>stream: true</code> to the constructor.</span> <pre numberoflines="15" language="typescript" data-language="typescript">const sink = new Bun.ArrayBufferSink();
sink.start({
  stream: true, 
});

sink.write("h");
sink.write("e");
sink.write("l");
sink.flush();
// ArrayBuffer(5) [ 104, 101, 108 ]

sink.write("l");
sink.write("o");
sink.flush();
// ArrayBuffer(5) [ 108, 111 ]
</pre> <span data-as="p">The <code>.flush()</code> method returns the buffered data as an <code>ArrayBuffer</code> (or <code>Uint8Array</code> if <code>asUint8Array: true</code>) and clears internal buffer.</span> <span data-as="p">To manually set the size of the internal buffer in bytes, pass a value for <code>highWaterMark</code>:</span> <pre numberoflines="4" language="typescript" data-language="typescript">const sink = new Bun.ArrayBufferSink();
sink.start({
  highWaterMark: 1024 * 1024, // 1 MB
});
</pre> <hr> <h2 id="reference"><span>Reference</span></h2> <pre numberoflines="33" language="typescript" data-language="typescript">/**
 * Fast incremental writer that becomes an `ArrayBuffer` on end().
 */
export class ArrayBufferSink {
  constructor();

  start(options?: {
    asUint8Array?: boolean;
    /**
     * Preallocate an internal buffer of this size
     * This can significantly improve performance when the chunk size is small
     */
    highWaterMark?: number;
    /**
     * On {@link ArrayBufferSink.flush}, return the written data as a `Uint8Array`.
     * Writes will restart from the beginning of the buffer.
     */
    stream?: boolean;
  }): void;

  write(chunk: string | ArrayBufferView | ArrayBuffer | SharedArrayBuffer): number;
  /**
   * Flush the internal buffer
   *
   * If {@link ArrayBufferSink.start} was passed a `stream` option, this will return a `ArrayBuffer`
   * If {@link ArrayBufferSink.start} was passed a `stream` option and `asUint8Array`, this will return a `Uint8Array`
   * Otherwise, this will return the number of bytes written since the last flush
   *
   * This API might change later to separate Uint8ArraySink and ArrayBufferSink
   */
  flush(): number | Uint8Array&lt;ArrayBuffer&gt; | ArrayBuffer;
  end(): ArrayBuffer | Uint8Array&lt;ArrayBuffer&gt;;
}
See all 33 lines</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; bun.com, oven-sh, Jarred Sumner<br>Licensed under the MIT License.<br>
    <a href="https://bun.com/docs/runtime/streams" class="_attribution-link">https://bun.com/docs/runtime/streams</a>
  </p>
</div>
