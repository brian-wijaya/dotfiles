<header><h1>Plugins</h1></header><p>Plugins are ways of adding new languages or formatting rules to Prettier. Prettier’s own implementations of all languages are expressed using the plugin API. The core <code>prettier</code> package contains JavaScript and other web-focused languages built in. For additional languages you’ll need to install a plugin.</p> <h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="using-plugins">Using Plugins</h2> <p>You can load plugins with:</p> <ul> <li class=""> <p>The <a class="" href="cli">CLI</a>, via <code>--plugin</code>:</p> <div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" data-language="bash">prettier --write main.foo --plugin=prettier-plugin-foo</pre></div></div> <div class="theme-admonition theme-admonition-tip admonition_xJq3 alert alert--success">
<div class="admonitionHeading_Gvgb">
<svg viewbox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg>tip</div>
<div class="admonitionContent_BuS1"><p>You can set <code>--plugin</code> options multiple times.</p></div>
</div> </li> <li class=""> <p>The <a class="" href="api">API</a>, via the <code>plugins</code> options:</p> <div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" data-language="js">await prettier.format("code", {
  parser: "foo",
  plugins: ["prettier-plugin-foo"],
});</pre></div></div> </li> <li class=""> <p>The <a class="" href="configuration">Configuration File</a>:</p> <div class="language-json codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" data-language="json">{
  "plugins": ["prettier-plugin-foo"]
}</pre></div></div> </li> </ul> <p>Strings provided to <code>plugins</code> are ultimately passed to <a href="https://nodejs.org/api/esm.html#import-expressions" rel="noopener noreferrer" class=""><code>import()</code> expression</a>, so you can provide a module/package name, a path, or anything else <code>import()</code> takes.</p> <h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="official-plugins">Official Plugins</h2> <ul> <li class=""><a href="https://github.com/prettier/plugin-php" rel="noopener noreferrer" class=""><code>@prettier/plugin-php</code></a></li> <li class="">
<a href="https://github.com/prettier/plugin-pug" rel="noopener noreferrer" class=""><code>@prettier/plugin-pug</code></a> by <a href="https://github.com/Shinigami92" rel="noopener noreferrer" class=""><strong>@Shinigami92</strong></a>
</li> <li class=""><a href="https://github.com/prettier/plugin-ruby" rel="noopener noreferrer" class=""><code>@prettier/plugin-ruby</code></a></li> <li class=""><a href="https://github.com/prettier/plugin-xml" rel="noopener noreferrer" class=""><code>@prettier/plugin-xml</code></a></li> </ul> <h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="community-plugins">Community Plugins</h2> <ul> <li class="">
<a href="https://github.com/dangmai/prettier-plugin-apex" rel="noopener noreferrer" class=""><code>prettier-plugin-apex</code></a> by <a href="https://github.com/dangmai" rel="noopener noreferrer" class=""><strong>@dangmai</strong></a>
</li> <li class="">
<a href="https://github.com/withastro/prettier-plugin-astro" rel="noopener noreferrer" class=""><code>prettier-plugin-astro</code></a> by <a href="https://github.com/withastro/prettier-plugin-astro/graphs/contributors" rel="noopener noreferrer" class=""><strong>@withastro contributors</strong></a>
</li> <li class="">
<a href="https://github.com/phoenix128/prettier-plugin-bigcommerce-stencil" rel="noopener noreferrer" class=""><code>prettier-plugin-bigcommerce-stencil</code></a> by <a href="https://github.com/phoenix128" rel="noopener noreferrer" class=""><strong>@phoenix128</strong></a>
</li> <li class="">
<a href="https://github.com/gicentre/prettier-plugin-elm" rel="noopener noreferrer" class=""><code>prettier-plugin-elm</code></a> by <a href="https://github.com/gicentre" rel="noopener noreferrer" class=""><strong>@giCentre</strong></a>
</li> <li class="">
<a href="https://github.com/adamzapasnik/prettier-plugin-erb" rel="noopener noreferrer" class=""><code>prettier-plugin-erb</code></a> by <a href="https://github.com/adamzapasnik" rel="noopener noreferrer" class=""><strong>@adamzapasnik</strong></a>
</li> <li class="">
<a href="https://github.com/mapado/prettier-plugin-gherkin" rel="noopener noreferrer" class=""><code>prettier-plugin-gherkin</code></a> by <a href="https://github.com/mapado" rel="noopener noreferrer" class=""><strong>@mapado</strong></a>
</li> <li class="">
<a href="https://github.com/NaridaL/glsl-language-toolkit/tree/main/packages/prettier-plugin-glsl" rel="noopener noreferrer" class=""><code>prettier-plugin-glsl</code></a> by <a href="https://github.com/NaridaL" rel="noopener noreferrer" class=""><strong>@NaridaL</strong></a>
</li> <li class="">
<a href="https://github.com/NiklasPor/prettier-plugin-go-template" rel="noopener noreferrer" class=""><code>prettier-plugin-go-template</code></a> by <a href="https://github.com/NiklasPor" rel="noopener noreferrer" class=""><strong>@NiklasPor</strong></a>
</li> <li class="">
<a href="https://github.com/metcalfc/prettier-plugin-hugo-post" rel="noopener noreferrer" class=""><code>prettier-plugin-hugo-post</code></a> by <a href="https://github.com/metcalfc" rel="noopener noreferrer" class=""><strong>@metcalfc</strong></a>
</li> <li class="">
<a href="https://github.com/jhipster/prettier-java" rel="noopener noreferrer" class=""><code>prettier-plugin-java</code></a> by <a href="https://github.com/jhipster" rel="noopener noreferrer" class=""><strong>@JHipster</strong></a>
</li> <li class="">
<a href="https://github.com/davidodenwald/prettier-plugin-jinja-template" rel="noopener noreferrer" class=""><code>prettier-plugin-jinja-template</code></a> by <a href="https://github.com/davidodenwald" rel="noopener noreferrer" class=""><strong>@davidodenwald</strong></a>
</li> <li class="">
<a href="https://github.com/Stedi/prettier-plugin-jsonata" rel="noopener noreferrer" class=""><code>prettier-plugin-jsonata</code></a> by <a href="https://github.com/Stedi" rel="noopener noreferrer" class=""><strong>@Stedi</strong></a>
</li> <li class="">
<a href="https://github.com/Angry-Potato/prettier-plugin-kotlin" rel="noopener noreferrer" class=""><code>prettier-plugin-kotlin</code></a> by <a href="https://github.com/Angry-Potato" rel="noopener noreferrer" class=""><strong>@Angry-Potato</strong></a>
</li> <li class="">
<a href="https://github.com/marko-js/prettier" rel="noopener noreferrer" class=""><code>prettier-plugin-marko</code></a> by <a href="https://github.com/marko-js" rel="noopener noreferrer" class=""><strong>@marko-js</strong></a>
</li> <li class="">
<a href="https://github.com/dfinity/prettier-plugin-motoko" rel="noopener noreferrer" class=""><code>prettier-plugin-motoko</code></a> by <a href="https://github.com/dfinity" rel="noopener noreferrer" class=""><strong>@dfinity</strong></a>
</li> <li class="">
<a href="https://github.com/joedeandev/prettier-plugin-nginx" rel="noopener noreferrer" class=""><code>prettier-plugin-nginx</code></a> by <a href="https://github.com/joedeandev" rel="noopener noreferrer" class=""><strong>@joedeandev</strong></a>
</li> <li class="">
<a href="https://github.com/umidbekk/prettier-plugin-prisma" rel="noopener noreferrer" class=""><code>prettier-plugin-prisma</code></a> by <a href="https://github.com/umidbekk" rel="noopener noreferrer" class=""><strong>@umidbekk</strong></a>
</li> <li class="">
<a href="https://github.com/eemeli/prettier-plugin-properties" rel="noopener noreferrer" class=""><code>prettier-plugin-properties</code></a> by <a href="https://github.com/eemeli" rel="noopener noreferrer" class=""><strong>@eemeli</strong></a>
</li> <li class="">
<a href="https://github.com/jinxdash/prettier-plugin-rust" rel="noopener noreferrer" class=""><code>prettier-plugin-rust</code></a> by <a href="https://github.com/jinxdash" rel="noopener noreferrer" class=""><strong>@jinxdash</strong></a>
</li> <li class="">
<a href="https://github.com/un-ts/prettier/tree/master/packages/sh" rel="noopener noreferrer" class=""><code>prettier-plugin-sh</code></a> by <a href="https://github.com/JounQin" rel="noopener noreferrer" class=""><strong>@JounQin</strong></a>
</li> <li class="">
<a href="https://github.com/un-ts/prettier/tree/master/packages/sql" rel="noopener noreferrer" class=""><code>prettier-plugin-sql</code></a> by <a href="https://github.com/JounQin" rel="noopener noreferrer" class=""><strong>@JounQin</strong></a>
</li> <li class="">
<a href="https://github.com/nene/prettier-plugin-sql-cst" rel="noopener noreferrer" class=""><code>prettier-plugin-sql-cst</code></a> by <a href="https://github.com/nene" rel="noopener noreferrer" class=""><strong>@nene</strong></a>
</li> <li class="">
<a href="https://github.com/prettier-solidity/prettier-plugin-solidity" rel="noopener noreferrer" class=""><code>prettier-plugin-solidity</code></a> by <a href="https://github.com/mattiaerre" rel="noopener noreferrer" class=""><strong>@mattiaerre</strong></a>
</li> <li class="">
<a href="https://github.com/sveltejs/prettier-plugin-svelte" rel="noopener noreferrer" class=""><code>prettier-plugin-svelte</code></a> by <a href="https://github.com/sveltejs" rel="noopener noreferrer" class=""><strong>@sveltejs</strong></a>
</li> <li class="">
<a href="https://github.com/un-ts/prettier/tree/master/packages/toml" rel="noopener noreferrer" class=""><code>prettier-plugin-toml</code></a> by <a href="https://github.com/JounQin" rel="noopener noreferrer" class=""><strong>@JounQin</strong></a> and <a href="https://github.com/so1ve" rel="noopener noreferrer" class=""><strong>@so1ve</strong></a>
</li> <li class="">
<a href="https://github.com/drrataplan/prettier-plugin-xquery" rel="noopener noreferrer" class=""><code>prettier-plugin-xquery</code></a> by <a href="https://github.com/drrataplan" rel="noopener noreferrer" class=""><strong>@DrRataplan</strong></a>
</li> </ul> <h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="developing-plugins">Developing Plugins</h2> <p>Prettier plugins are regular JavaScript modules with the following five exports or default export with the following properties:</p> <ul> <li class=""><code>languages</code></li> <li class=""><code>parsers</code></li> <li class=""><code>printers</code></li> <li class=""><code>options</code></li> <li class=""><code>defaultOptions</code></li> </ul> <h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="languages"><code>languages</code></h3> <p>Languages is an array of language definitions that your plugin will contribute to Prettier. It can include all of the fields specified in <a class="" href="api#prettiergetsupportinfo"><code>prettier.getSupportInfo()</code></a>.</p> <p>It <strong>must</strong> include <code>name</code> and <code>parsers</code>.</p> <pre tabindex="0" data-language="js">export const languages = [
  {
    // The language name
    name: "InterpretedDanceScript",
    // Parsers that can parse this language.
    // This can be built-in parsers, or parsers you have contributed via this plugin.
    parsers: ["dance-parse"],
  },
];</pre> <h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="parsers"><code>parsers</code></h3> <p>Parsers convert code as a string into an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener noreferrer" class="">AST</a>.</p> <p>The key must match the name in the <code>parsers</code> array from <code>languages</code>. The value contains a parse function, an AST format name, and two location extraction functions (<code>locStart</code> and <code>locEnd</code>).</p> <pre tabindex="0" data-language="js">export const parsers = {
  "dance-parse": {
    parse,
    // The name of the AST that the parser produces.
    astFormat: "dance-ast",
    hasPragma,
    hasIgnorePragma,
    locStart,
    locEnd,
    preprocess,
  },
};</pre> <p>The signature of the <code>parse</code> function is:</p> <pre tabindex="0" data-language="ts">function parse(text: string, options: object): Promise&lt;AST&gt; | AST;</pre> <p>The location extraction functions (<code>locStart</code> and <code>locEnd</code>) return the starting and ending locations of a given AST node:</p> <pre tabindex="0" data-language="ts">function locStart(node: object): number;</pre> <p><em>(Optional)</em> The pragma detection function (<code>hasPragma</code>) should return if the text contains the pragma comment.</p> <pre tabindex="0" data-language="ts">function hasPragma(text: string): boolean;</pre> <p><em>(Optional)</em> The "ignore pragma" detection function (<code>hasIgnorePragma</code>) should return if the text contains a pragma indicating the text should not be formatted.</p> <pre tabindex="0" data-language="ts">function hasIgnorePragma(text: string): boolean;</pre> <p><em>(Optional)</em> The preprocess function can process the input text before passing into <code>parse</code> function.</p> <pre tabindex="0" data-language="ts">function preprocess(text: string, options: object): string | Promise&lt;string&gt;;</pre> <p><em>Support for async preprocess first added in v3.7.0</em></p> <h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="printers"><code>printers</code></h3> <p>Printers convert ASTs into a Prettier intermediate representation, also known as a Doc.</p> <p>The key must match the <code>astFormat</code> that the parser produces. The value contains an object with a <code>print</code> function. All other properties (<code>embed</code>, <code>preprocess</code>, etc.) are optional.</p> <pre tabindex="0" data-language="js">export const printers = {
  "dance-ast": {
    print,
    embed,
    preprocess,
    getVisitorKeys,
    insertPragma,
    canAttachComment,
    isBlockComment,
    printComment,
    getCommentChildNodes,
    hasPrettierIgnore,
    printPrettierIgnored,
    handleComments: {
      ownLine,
      endOfLine,
      remaining,
    },
  },
};</pre> <h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="the-printing-process">The printing process</h4> <p>Prettier uses an intermediate representation, called a Doc, which Prettier then turns into a string (based on options like <code>printWidth</code>). A <em>printer</em>'s job is to take the AST generated by <code>parsers[&lt;parser name&gt;].parse</code> and return a Doc. A Doc is constructed using <a href="https://github.com/prettier/prettier/blob/main/commands.md" rel="noopener noreferrer" class="">builder commands</a>:</p> <pre tabindex="0" data-language="js">import * as prettier from "prettier";

const { join, line, ifBreak, group } = prettier.doc.builders;</pre> <p>The printing process consists of the following steps:</p> <ol> <li class="">
<strong>AST preprocessing</strong> (optional). See <a href="#optional-preprocess" class=""><code>preprocess</code></a>.</li> <li class="">
<strong>Comment attachment</strong> (optional). See <a href="#handling-comments-in-a-printer" class="">Handling comments in a printer</a>.</li> <li class="">
<strong>Processing embedded languages</strong> (optional). The <a href="#optional-embed" class=""><code>embed</code></a> method, if defined, is called for each node, depth-first. While, for performance reasons, the recursion itself is synchronous, <code>embed</code> may return asynchronous functions that can call other parsers and printers to compose docs for embedded syntaxes like CSS-in-JS. These returned functions are queued up and sequentially executed before the next step.</li> <li class="">
<strong>Recursive printing</strong>. A doc is recursively constructed from the AST. Starting from the root node: <ul> <li class="">If, from the step 3, there is an embedded language doc associated with the current node, this doc is used.</li> <li class="">Otherwise, the <code>print(path, options, print): Doc</code> method is called. It composes a doc for the current node, often by printing child nodes using the <code>print</code> callback.</li> </ul> </li> </ol> <h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="print"><code>print</code></h4> <p>Most of the work of a plugin's printer will take place in its <code>print</code> function, whose signature is:</p> <pre tabindex="0" data-language="ts">function print(
  // Path to the AST node to print
  path: AstPath,
  options: object,
  // Recursively print a child node
  print: (selector?: string | number | Array&lt;string | number&gt; | AstPath) =&gt; Doc,
): Doc;</pre> <p>The <code>print</code> function is passed the following parameters:</p> <ul> <li class="">
<strong><code>path</code></strong>: An object, which can be used to access nodes in the AST. It’s a stack-like data structure that maintains the current state of the recursion. It is called “path” because it represents the path to the current node from the root of the AST. The current node is returned by <code>path.node</code>.</li> <li class="">
<strong><code>options</code></strong>: A persistent object, which contains global options and which a plugin may mutate to store contextual data.</li> <li class="">
<strong><code>print</code></strong>: A callback for printing sub-nodes. This function contains the core printing logic that consists of steps whose implementation is provided by plugins. In particular, it calls the printer’s <code>print</code> function and passes itself to it. Thus, the two <code>print</code> functions – the one from the core and the one from the plugin – call each other while descending down the AST recursively.</li> </ul> <p>Here’s a simplified example to give an idea of what a typical implementation of <code>print</code> looks like:</p> <pre tabindex="0" data-language="js">import * as prettier from "prettier";

const { group, indent, join, line, softline } = prettier.doc.builders;

function print(path, options, print) {
  const node = path.node;

  switch (node.type) {
    case "list":
      return group([
        "(",
        indent([softline, join(line, path.map(print, "elements"))]),
        softline,
        ")",
      ]);

    case "pair":
      return group([
        "(",
        indent([softline, print("left"), line, ". ", print("right")]),
        softline,
        ")",
      ]);

    case "symbol":
      return node.name;
  }

  throw new Error(`Unknown node type: ${node.type}`);
}</pre> <p>Check out <a href="https://github.com/prettier/prettier-python/blob/034ba8a9551f3fa22cead41b323be0b28d06d13b/src/printer.js#L174" rel="noopener noreferrer" class="">prettier-python's printer</a> for some examples of what is possible.</p> <h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="optional-embed">(optional) <code>embed</code>
</h4> <p>A printer can have the <code>embed</code> method to print one language inside another. Examples of this are printing CSS-in-JS or fenced code blocks in Markdown. The signature is:</p> <pre tabindex="0" data-language="ts">function embed(
  // Path to the current AST node
  path: AstPath,
  // Current options
  options: Options,
):
  | ((
      // Parses and prints the passed text using a different parser.
      // You should set `options.parser` to specify which parser to use.
      textToDoc: (text: string, options: Options) =&gt; Promise&lt;Doc&gt;,
      // Prints the current node or its descendant node with the current printer
      print: (
        selector?: string | number | Array&lt;string | number&gt; | AstPath,
      ) =&gt; Doc,
      // The following two arguments are passed for convenience.
      // They're the same `path` and `options` that are passed to `embed`.
      path: AstPath,
      options: Options,
    ) =&gt; Promise&lt;Doc | undefined&gt; | Doc | undefined)
  | Doc
  | undefined;</pre> <p>The <code>embed</code> method is similar to the <code>print</code> method in that it maps AST nodes to docs, but unlike <code>print</code>, it has power to do async work by returning an async function. That function's first parameter, the <code>textToDoc</code> async function, can be used to render a doc using a different plugin.</p> <p>If a function returned from <code>embed</code> returns a doc or a promise that resolves to a doc, that doc will be used in printing, and the <code>print</code> method won’t be called for this node. It's also possible and, in rare situations, might be convenient to return a doc synchronously directly from <code>embed</code>, however <code>textToDoc</code> and the <code>print</code> callback aren’t available at that case. Return a function to get them.</p> <p>If <code>embed</code> returns <code>undefined</code>, or if a function it returned returns <code>undefined</code> or a promise that resolves to <code>undefined</code>, the node will be printed normally with the <code>print</code> method. Same will happen if a returned function throws an error or returns a promise that rejects (e.g., if a parsing error has happened). Set the <code>PRETTIER_DEBUG</code> environment variable to a non-empty value if you want Prettier to rethrow these errors.</p> <p>For example, a plugin that has nodes with embedded JavaScript might have the following <code>embed</code> method:</p> <pre tabindex="0" data-language="js">function embed(path, options) {
  const node = path.node;
  if (node.type === "javascript") {
    return async (textToDoc) =&gt; {
      return [
        "&lt;script&gt;",
        hardline,
        await textToDoc(node.javaScriptCode, { parser: "babel" }),
        hardline,
        "&lt;/script&gt;",
      ];
    };
  }
}</pre> <p>If the <a class="" href="options#embedded-language-formatting"><code>--embedded-language-formatting</code></a> option is set to <code>off</code>, the embedding step is entirely skipped, <code>embed</code> isn’t called, and all nodes are printed with the <code>print</code> method.</p> <h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="optional-preprocess">(optional) <code>preprocess</code>
</h4> <p>The <code>preprocess</code> method can process the AST from the parser before passing it into the <code>print</code> method.</p> <pre tabindex="0" data-language="ts">function preprocess(ast: AST, options: Options): AST | Promise&lt;AST&gt;;</pre> <h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="optional-getvisitorkeys">(optional) <code>getVisitorKeys</code>
</h4> <p>This property might come in handy if the plugin uses comment attachment or embedded languages. These features traverse the AST iterating through all the own enumerable properties of each node starting from the root. If the AST has <a href="https://en.wikipedia.org/wiki/Cycle_(graph_theory)" rel="noopener noreferrer" class="">cycles</a>, such a traverse ends up in an infinite loop. Also, nodes might contain non-node objects (e.g., location data), iterating through which is a waste of resources. To solve these issues, the printer can define a function to return property names that should be traversed.</p> <p>Its signature is:</p> <pre tabindex="0" data-language="ts">function getVisitorKeys(node, nonTraversableKeys: Set&lt;string&gt;): string[];</pre> <p>The default <code>getVisitorKeys</code>:</p> <pre tabindex="0" data-language="js">function getVisitorKeys(node, nonTraversableKeys) {
  return Object.keys(node).filter((key) =&gt; !nonTraversableKeys.has(key));
}</pre> <p>The second argument <code>nonTraversableKeys</code> is a set of common keys and keys that prettier used internal.</p> <p>If you have full list of visitor keys</p> <pre tabindex="0" data-language="js">const visitorKeys = {
  Program: ["body"],
  Identifier: [],
  // ...
};

function getVisitorKeys(node /* , nonTraversableKeys*/) {
  // Return `[]` for unknown node to prevent Prettier fallback to use `Object.keys()`
  return visitorKeys[node.type] ?? [];
}</pre> <p>If you only need exclude a small set of keys</p> <pre tabindex="0" data-language="js">const ignoredKeys = new Set(["prev", "next", "range"]);

function getVisitorKeys(node, nonTraversableKeys) {
  return Object.keys(node).filter(
    (key) =&gt; !nonTraversableKeys.has(key) &amp;&amp; !ignoredKeys.has(key),
  );
}</pre> <h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="optional-insertpragma">(optional) <code>insertPragma</code>
</h4> <p>A plugin can implement how a pragma comment is inserted in the resulting code when the <code>--insert-pragma</code> option is used, in the <code>insertPragma</code> function. Its signature is:</p> <pre tabindex="0" data-language="ts">function insertPragma(text: string): string;</pre> <h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="handling-comments-in-a-printer">Handling comments in a printer</h4> <p>Comments are often not part of a language's AST and present a challenge for pretty printers. A Prettier plugin can either print comments itself in its <code>print</code> function or rely on Prettier's comment algorithm.</p> <p>By default, if the AST has a top-level <code>comments</code> property, Prettier assumes that <code>comments</code> stores an array of comment nodes. Prettier will then use the provided <code>parsers[&lt;plugin&gt;].locStart</code>/<code>locEnd</code> functions to search for the AST node that each comment "belongs" to. Comments are then attached to these nodes <strong>mutating the AST in the process</strong>, and the <code>comments</code> property is deleted from the AST root. The <code>*Comment</code> functions are used to adjust Prettier's algorithm. Once the comments are attached to the AST, Prettier will automatically call the <code>printComment(path, options): Doc</code> function and insert the returned doc into the (hopefully) correct place.</p> <h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="optional-getcommentchildnodes">(optional) <code>getCommentChildNodes</code>
</h4> <p>By default, Prettier searches all object properties (except for a few predefined ones) of each node recursively. This function can be provided to override that behavior. It has the signature:</p> <pre tabindex="0" data-language="ts">function getCommentChildNodes(
  // The node whose children should be returned.
  node: AST,
  // Current options
  options: object,
): AST[] | undefined;</pre> <p>Return <code>[]</code> if the node has no children or <code>undefined</code> to fall back on the default behavior.</p> <h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="optional-hasprettierignore">(optional) <code>hasPrettierIgnore</code>
</h3> <pre tabindex="0" data-language="ts">function hasPrettierIgnore(path: AstPath): boolean;</pre> <p>Returns whether or not the AST node is <code>prettier-ignore</code>d.</p> <h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="optional-printprettierignored">(optional) <code>printPrettierIgnored</code>
</h3> <p>If the AST node is <code>prettier-ignore</code>d, Prettier will slice for the text for parsing without calling <code>print</code> function by default, however plugin can also handle the <code>prettier-ignore</code>d node print by adding this property.</p> <p>This property have the same signature as the <code>print</code> property.</p> <p><em>First available in v3.7.0</em></p> <h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="optional-printcomment">(optional) <code>printComment</code>
</h4> <p>Called whenever a comment node needs to be printed. It has the signature:</p> <pre tabindex="0" data-language="ts">function printComment(
  // Path to the current comment node
  commentPath: AstPath,
  // Current options
  options: object,
): Doc;</pre> <h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="optional-canattachcomment">(optional) <code>canAttachComment</code>
</h4> <pre tabindex="0" data-language="ts">function canAttachComment(node: AST, ancestors: T[]): boolean;</pre> <p>This function is used for deciding whether a comment can be attached to a particular AST node. By default, <em>all</em> AST properties are traversed searching for nodes that comments can be attached to. This function is used to prevent comments from being attached to a particular node. A typical implementation looks like</p> <pre tabindex="0" data-language="js">function canAttachComment(node, [parent]) {
  return !(
    node.type === "comment" ||
    (parent?.type === "shorthand-property" &amp;&amp;
      parent.key === node &amp;&amp;
      parent.key !== parent.value)
  );
}</pre> <p><em>The second parameter <code>ancestors</code> first added in v3.7.0.</em></p> <h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="optional-isblockcomment">(optional) <code>isBlockComment</code>
</h4> <pre tabindex="0" data-language="ts">function isBlockComment(node: AST): boolean;</pre> <p>Returns whether or not the AST node is a block comment.</p> <h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="optional-handlecomments">(optional) <code>handleComments</code>
</h4> <p>The <code>handleComments</code> object contains three optional functions, each with signature</p> <pre tabindex="0" data-language="ts">(
  // The AST node corresponding to the comment
  comment: AST,
  // The full source code text
  text: string,
  // The global options object
  options: object,
  // The AST
  ast: AST,
  // Whether this comment is the last comment
  isLastComment: boolean,
) =&gt; boolean;</pre> <p>These functions are used to override Prettier's default comment attachment algorithm. <code>ownLine</code>/<code>endOfLine</code>/<code>remaining</code> is expected to either manually attach a comment to a node and return <code>true</code>, or return <code>false</code> and let Prettier attach the comment.</p> <p>Based on the text surrounding a comment node, Prettier dispatches:</p> <ul> <li class="">
<code>ownLine</code> if a comment has only whitespace preceding it and a newline afterwards,</li> <li class="">
<code>endOfLine</code> if a comment has a newline afterwards but some non-whitespace preceding it,</li> <li class="">
<code>remaining</code> in all other cases.</li> </ul> <p>At the time of dispatching, Prettier will have annotated each AST comment node (i.e., created new properties) with at least one of <code>enclosingNode</code>, <code>precedingNode</code>, or <code>followingNode</code>. These can be used to aid a plugin's decision process (of course the entire AST and original text is also passed in for making more complicated decisions).</p> <h4 class="anchor anchorTargetStickyNavbar_Vzrq" id="manually-attaching-a-comment">Manually attaching a comment</h4> <p>The <code>prettier.util.addTrailingComment</code>/<code>addLeadingComment</code>/<code>addDanglingComment</code> functions can be used to manually attach a comment to an AST node. An example <code>ownLine</code> function that ensures a comment does not follow a "punctuation" node (made up for demonstration purposes) might look like:</p> <pre tabindex="0" data-language="js">import * as prettier from "prettier";

function ownLine(comment, text, options, ast, isLastComment) {
  const { precedingNode } = comment;
  if (precedingNode &amp;&amp; precedingNode.type === "punctuation") {
    prettier.util.addTrailingComment(precedingNode, comment);
    return true;
  }
  return false;
}</pre> <p>Nodes with comments are expected to have a <code>comments</code> property containing an array of comments. Each comment is expected to have the following properties: <code>leading</code>, <code>trailing</code>, <code>printed</code>.</p> <p>The example above uses <code>prettier.util.addTrailingComment</code>, which automatically sets <code>comment.leading</code>/<code>trailing</code>/<code>printed</code> to appropriate values and adds the comment to the AST node's <code>comments</code> array.</p> <p>The <code>--debug-print-comments</code> CLI flag can help with debugging comment attachment issues. It prints a detailed list of comments, which includes information on how every comment was classified (<code>ownLine</code>/<code>endOfLine</code>/<code>remaining</code>, <code>leading</code>/<code>trailing</code>/<code>dangling</code>) and to which node it was attached. For Prettier’s built-in languages, this information is also available on the Playground (the 'show comments' checkbox in the Debug section).</p> <h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="options"><code>options</code></h3> <p><code>options</code> is an object containing the custom options your plugin supports.</p> <p>Example:</p> <pre tabindex="0" data-language="js">export default {
  // ... plugin implementation
  options: {
    openingBraceNewLine: {
      type: "boolean",
      category: "Global",
      default: true,
      description: "Move open brace for code blocks onto new line.",
    },
  },
};</pre> <h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="defaultoptions"><code>defaultOptions</code></h3> <p>If your plugin requires different default values for some of Prettier’s core options, you can specify them in <code>defaultOptions</code>:</p> <pre tabindex="0" data-language="js">export default {
  // ... plugin implementation
  defaultOptions: {
    tabWidth: 4,
  },
};</pre> <h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="utility-functions">Utility functions</h3> <p><code>prettier.util</code> provides the following limited set of utility functions for plugins:</p> <pre tabindex="0" data-language="ts">type Quote = '"' | "'";
type SkipOptions = { backwards?: boolean };

function getMaxContinuousCount(text: string, searchString: string): number;

function getStringWidth(text: string): number;

function getAlignmentSize(
  text: string,
  tabWidth: number,
  startIndex?: number,
): number;

function getIndentSize(value: string, tabWidth: number): number;

function skip(
  characters: string | RegExp,
): (
  text: string,
  startIndex: number | false,
  options?: SkipOptions,
) =&gt; number | false;

function skipWhitespace(
  text: string,
  startIndex: number | false,
  options?: SkipOptions,
): number | false;

function skipSpaces(
  text: string,
  startIndex: number | false,
  options?: SkipOptions,
): number | false;

function skipToLineEnd(
  text: string,
  startIndex: number | false,
  options?: SkipOptions,
): number | false;

function skipEverythingButNewLine(
  text: string,
  startIndex: number | false,
  options?: SkipOptions,
): number | false;

function skipInlineComment(
  text: string,
  startIndex: number | false,
): number | false;

function skipTrailingComment(
  text: string,
  startIndex: number | false,
): number | false;

function skipNewline(
  text: string,
  startIndex: number | false,
  options?: SkipOptions,
): number | false;

function hasNewline(
  text: string,
  startIndex: number,
  options?: SkipOptions,
): boolean;

function hasNewlineInRange(
  text: string,
  startIndex: number,
  startIndex: number,
): boolean;

function hasSpaces(
  text: string,
  startIndex: number,
  options?: SkipOptions,
): boolean;

function getPreferredQuote(
  text: string,
  preferredQuoteOrPreferSingleQuote: Quote | boolean,
): Quote;

function makeString(
  rawText: string,
  enclosingQuote: Quote,
  unescapeUnnecessaryEscapes?: boolean,
): string;

function getNextNonSpaceNonCommentCharacter(
  text: string,
  startIndex: number,
): string;

function getNextNonSpaceNonCommentCharacterIndex(
  text: string,
  startIndex: number,
): number | false;

function isNextLineEmpty(text: string, startIndex: number): boolean;

function isPreviousLineEmpty(text: string, startIndex: number): boolean;</pre> <h3 class="anchor anchorTargetStickyNavbar_Vzrq" id="tutorials">Tutorials</h3> <ul> <li class="">
<a href="https://medium.com/@fvictorio/how-to-write-a-plugin-for-prettier-a0d98c845e70" rel="noopener noreferrer" class="">How to write a plugin for Prettier</a>: Teaches you how to write a very basic Prettier plugin for TOML.</li> </ul> <h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="testing-plugins">Testing Plugins</h2> <p>Since plugins can be resolved using relative paths, when working on one you can do:</p> <pre tabindex="0" data-language="js">import * as prettier from "prettier";

const code = "(add 1 2)";
await prettier.format(code, {
  parser: "lisp",
  plugins: ["./index.js"],
});</pre> <p>This will resolve a plugin relative to the current working directory.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; James Long and contributors<br>
    <a href="https://prettier.io/docs/plugins" class="_attribution-link">https://prettier.io/docs/plugins</a>
  </p>
</div>
