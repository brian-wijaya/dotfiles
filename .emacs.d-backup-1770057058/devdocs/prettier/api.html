<header><h1>API</h1></header><p>If you want to run Prettier programmatically, check this page out.</p> <pre tabindex="0" data-language="js">import * as prettier from "prettier";</pre> <p>Our public APIs are all asynchronous, if you must use synchronous version for some reason, you can try <a href="https://github.com/prettier/prettier-synchronized" rel="noopener noreferrer" class=""><code>@prettier/sync</code></a>.</p> <h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="prettierformatsource-options"><code>prettier.format(source, options)</code></h2> <p><code>format</code> is used to format text using Prettier. <code>options.parser</code> must be set according to the language you are formatting (see the <a class="" href="options#parser">list of available parsers</a>). Alternatively, <code>options.filepath</code> can be specified for Prettier to infer the parser from the file extension. Other <a class="" href="options">options</a> may be provided to override the defaults.</p> <pre tabindex="0" data-language="js">await prettier.format("foo ( );", { semi: false, parser: "babel" });
// -&gt; 'foo()\n'</pre> <h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="prettierchecksource--options"><code>prettier.check(source [, options])</code></h2> <p><code>check</code> checks to see if the file has been formatted with Prettier given those options and returns a <code>Promise&lt;boolean&gt;</code>. This is similar to the <code>--check</code> or <code>--list-different</code> parameter in the CLI and is useful for running Prettier in CI scenarios.</p> <h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="prettierformatwithcursorsource--options"><code>prettier.formatWithCursor(source [, options])</code></h2> <p><code>formatWithCursor</code> both formats the code, and translates a cursor position from unformatted code to formatted code. This is useful for editor integrations, to prevent the cursor from moving when code is formatted.</p> <p>The <code>cursorOffset</code> option should be provided, to specify where the cursor is.</p> <pre tabindex="0" data-language="js">await prettier.formatWithCursor(" 1", { cursorOffset: 2, parser: "babel" });
// -&gt; { formatted: '1;\n', cursorOffset: 1 }</pre> <h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="prettierresolveconfigfileurlorpath--options"><code>prettier.resolveConfig(fileUrlOrPath [, options])</code></h2> <p><code>resolveConfig</code> can be used to resolve configuration for a given source file, passing its path or url as the first argument. The config search will start at the directory of the file location and continue to search up the directory. Or you can pass directly the path of the config file as <code>options.config</code> if you don’t wish to search for it. A promise is returned which will resolve to:</p> <ul> <li class="">An options object, providing a <a class="" href="configuration">config file</a> was found.</li> <li class="">
<code>null</code>, if no file was found.</li> </ul> <p>The promise will be rejected if there was an error parsing the configuration file.</p> <p>If <code>options.useCache</code> is <code>false</code>, all caching will be bypassed.</p> <pre tabindex="0" data-language="js">const text = await fs.readFile(filePath, "utf8");
const options = await prettier.resolveConfig(filePath);
const formatted = await prettier.format(text, {
  ...options,
  filepath: filePath,
});</pre> <p>If <code>options.editorconfig</code> is <code>true</code> and an <a href="https://editorconfig.org/" rel="noopener noreferrer" class=""><code>.editorconfig</code> file</a> is in your project, Prettier will parse it and convert its properties to the corresponding Prettier configuration. This configuration will be overridden by <code>.prettierrc</code>, etc. Currently, the following EditorConfig properties are supported:</p> <ul> <li class=""><code>end_of_line</code></li> <li class=""><code>indent_style</code></li> <li class="">
<code>indent_size</code>/<code>tab_width</code>
</li> <li class=""><code>max_line_length</code></li> </ul> <h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="prettierresolveconfigfilefileurlorpath"><code>prettier.resolveConfigFile([fileUrlOrPath])</code></h2> <p><code>resolveConfigFile</code> can be used to find the path of the Prettier configuration file that will be used when resolving the config (i.e. when calling <code>resolveConfig</code>). A promise is returned which will resolve to:</p> <ul> <li class="">The path of the configuration file.</li> <li class="">
<code>null</code>, if no file was found.</li> </ul> <p>The promise will be rejected if there was an error parsing the configuration file.</p> <p>The search starts at <code>process.cwd()</code>, or at the directory of <code>fileUrlOrPath</code> if provided.</p> <pre tabindex="0" data-language="js">const configFile = await prettier.resolveConfigFile(filePath);
// you got the path of the configuration file</pre> <h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="prettierclearconfigcache"><code>prettier.clearConfigCache()</code></h2> <p>When Prettier loads configuration files and plugins, the file system structure is cached for performance. This function will clear the cache. Generally this is only needed for editor integrations that know that the file system has changed since the last format took place.</p> <h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="prettiergetfileinfofileurlorpath--options"><code>prettier.getFileInfo(fileUrlOrPath [, options])</code></h2> <p><code>getFileInfo</code> can be used by editor extensions to decide if a particular file needs to be formatted. This method returns a promise, which resolves to an object with the following properties:</p> <pre tabindex="0" data-language="ts">{
  ignored: boolean;
  inferredParser: string | null;
}</pre> <p>The promise will be rejected if the type of <code>fileUrlOrPath</code> is not <code>string</code> or <code>URL</code>.</p> <p>Setting <code>options.ignorePath</code> (<code>string | URL | (string | URL)[]</code>) and <code>options.withNodeModules</code> (<code>boolean</code>) influence the value of <code>ignored</code> (<code>false</code> by default).</p> <p>If the given <code>fileUrlOrPath</code> is ignored, the <code>inferredParser</code> is always <code>null</code>.</p> <p>Providing <a class="" href="plugins">plugin</a> paths in <code>options.plugins</code> (<code>(string | URL | Plugin)[]</code>) helps extract <code>inferredParser</code> for files that are not supported by Prettier core.</p> <p>When setting <code>options.resolveConfig</code> (<code>boolean</code>, default <code>true</code>) to <code>false</code>, Prettier will not search for configuration file. This can be useful if this function is only used to check if file is ignored.</p> <h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="prettiergetsupportinfo"><code>prettier.getSupportInfo()</code></h2> <p>Returns a promise which resolves to an object representing the options, parsers, languages and file types Prettier supports.</p> <p>The support information looks like this:</p> <pre tabindex="0" data-language="ts">{
  languages: Array&lt;{
    name: string;
    parsers: string[];
    group?: string;
    tmScope?: string;
    aceMode?: string;
    codemirrorMode?: string;
    codemirrorMimeType?: string;
    aliases?: string[];
    extensions?: string[];
    filenames?: string[];
    linguistLanguageId?: number;
    vscodeLanguageIds?: string[];
    isSupported?(options: { filepath: string }): boolean;
  }&gt;;
}</pre> <svg viewbox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg>note<p>Prettier can not ensure that <code>filepath</code> exists on disk.<br> When using from APIs(eg: <code>prettier.format()</code>), Prettier can not ensure it's a valid path either.</p>  <h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="custom-parser-api-removed">Custom Parser API (removed)</h2> <p><em>Removed in v3.0.0 (superseded by the Plugin API)</em></p> <p>Before <a class="" href="plugins">plugins</a> were a thing, Prettier had a similar but more limited feature called custom parsers. It’s been removed in v3.0.0 as its functionality was a subset of what the Plugin API did. If you used it, please check the example below on how to migrate.</p> <p>❌ Custom parser API (removed):</p> <pre tabindex="0" data-language="js">import { format } from "prettier";

format("lodash ( )", {
  parser(text, { babel }) {
    const ast = babel(text);
    ast.program.body[0].expression.callee.name = "_";
    return ast;
  },
});
// -&gt; "_();\n"</pre> <p>✔️ Plugin API:</p> <pre tabindex="0" data-language="js">import { format } from "prettier";
import * as prettierPluginBabel from "prettier/plugins/babel";

const myCustomPlugin = {
  parsers: {
    "my-custom-parser": {
      async parse(text) {
        const ast = await prettierPluginBabel.parsers.babel.parse(text);
        ast.program.body[0].expression.callee.name = "_";
        return ast;
      },
      astFormat: "estree",
    },
  },
};

await format("lodash ( )", {
  parser: "my-custom-parser",
  plugins: [myCustomPlugin],
});
// -&gt; "_();\n"</pre> <svg viewbox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg>note<p>Overall, doing codemods this way isn’t recommended. Prettier uses the location data of AST nodes for many things like preserving blank lines and attaching comments. When the AST is modified after the parsing, the location data often gets out of sync, which may lead to unpredictable results. Consider using <a href="https://github.com/facebook/jscodeshift" rel="noopener noreferrer" class="">jscodeshift</a> if you need codemods.</p> <p>As part of the removed Custom parser API, it was previously possible to pass a path to a module exporting a <code>parse</code> function via the <code>--parser</code> option. Use the <code>--plugin</code> CLI option or the <code>plugins</code> API option instead to <a class="" href="plugins#using-plugins">load plugins</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; James Long and contributors<br>
    <a href="https://prettier.io/docs/api" class="_attribution-link">https://prettier.io/docs/api</a>
  </p>
</div>
