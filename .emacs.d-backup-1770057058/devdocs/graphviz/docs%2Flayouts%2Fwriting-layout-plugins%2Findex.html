<h1>Writing Layout Plugins</h1> <div class="lead">How to write a custom layout engine.</div>  <p>To create a new layout plugin called <code>xxx</code>, you first need to provide two functions: <code>xxx_layout</code> and <code>xxx_cleanup</code>. The semantics of these are described below.</p> <h2 id="layout">Layout</h2> <pre data-language="c">void xxx_layout(Agraph_t * g)
</pre>
<p>Initialize the graph.</p> <ul> <li> <p>If the algorithm will use the common edge routing code, it should call <code>setEdgeType (g, ...);</code>.</p> </li> <li> <p>For each node, call <code>common_init_node</code> and <code>gv_nodesize</code>.</p> </li> <li> <p>If the algorithm will use <code>spline_edges()</code> to route the edges, the node coordinates need to be stored in <code>ND_pos</code>, so this should be allocated here. This, and the two calls mentioned above, are all handled by a call to <code>neato_init_node()</code>.</p> </li> <li> <p>For each edge, call <code>common_init_edge</code>.</p> </li> <li> <p>The algorithm should allocate whatever other data structures it needs. This can involve fields in the <code>A*info_t</code> fields. In addition, each of these fields contains a <code>void* alg;</code> subfield that the algorithm can use the store additional data. Once we move to cgraph, this will all be replaced with algorithm specific records.</p> </li> <li> <p>Layout the graph. When finished, each node should have its coordinates stored in points in <code>ND_coord_i(n)</code>, each edge should have its layout described in <code>ED_spl(e)</code>. (N.B. As of version 2.21, <code>ND_coord_i</code> has been replaced by <code>ND_coord</code>, which are now floating point coordinates.)</p> </li> </ul> <p>To add edges, there are 3 functions available:</p> <ol> <li>
<code>spline_edges1 (Agraph_t*, int edgeType)</code> Assumes the node coordinates are stored in <code>ND_coord_i</code>, and that <code>GD_bb</code> is set. For each edge, this function constructs the appropriate data and stores it in <code>ED_spl</code>.</li> <li>
<code>spline_edges0 (Agraph_t*)</code> Assumes the node coordinates are stored in <code>ND_pos</code>, and that <code>GD_bb</code> is set. This function uses the ratio attribute if set, copies the values in <code>ND_pos</code> to <code>ND_coord_i</code> (converting from inches to points); and calls spline_edges1 using the edge type specified by <code>setEdgeType()</code>.</li> <li>
<code>spline_edges (Agraph_t*)</code> Assumes the node coordinates are stored in <code>ND_pos</code>. This function calculates the bounding box of g and stores it in <code>GD_bb</code>, then calls <code>spline_edges0()</code>.</li> </ol> <p>If the algorithm only works with connected components, the code can use the pack library to get components, lay them out individually, and pack them together based on user specifications. A typical schema is given below. One can look at the code for <a href="../twopi/index"><code>twopi</code></a>, <a href="../circo/index"><code>circo</code></a>, <a href="../neato/index"><code>neato</code></a> or <a href="../fdp/index"><code>fdp</code></a> for more detailed examples.</p> <div class="highlight"><pre data-language="c">int ncc;

Agraph_t **ccs = ccomps(g, &amp;ncc, 0);
if (ncc == 1) {
    /* layout nodes of g */
    adjustNodes(g);  /* if you need to remove overlaps */
    spline_edges(g); /* generic edge routing code */

} else {
    pack_info pinfo;
    pack_mode pmode = getPackMode(g, l_node);

    for (int i = 0; i &lt; ncc; i++) {
        Agraph_t *const sg = ccs[i];
        /* layout sg */
        adjustNodes(sg);  /* if you need to remove overlaps */
    }
    spline_edges(g);  /* generic edge routing */

    /* initialize packing info, e.g. */
    pinfo.margin = getPack(g, CL_OFFSET, CL_OFFSET);
    pinfo.doSplines = 1;
    pinfo.mode = pmode;
    pinfo.fixed = 0;
    packSubgraphs(ncc, ccs, g, &amp;pinfo);
}
for (int i = 0; i &lt; ncc; i++) {
    agdelete(g, ccs[i]);
}

free(ccs);
</pre></div>
<p>Be careful in laying out subgraphs if you rely on attributes that have only been set in the root graph. With connected components, edges can be added with each component, before packing (as above) or after the components have been packed (see circo).</p> <p>It is good to check for trivial cases where the graph has 0 or 1 nodes, or no edges.</p> <p>At the end of <code>xxx_layout</code>, call</p> <div class="highlight"><pre data-language="c">dotneato_postprocess(g);
</pre></div>
<p>The following template will work in most cases, ignoring the problems of handling disconnected graphs and removing node overlaps:</p> <div class="highlight"><pre data-language="c">static void
xxx_init_node(node_t * n)
{
  neato_init_node(n);
  /* add algorithm-specific data, if desired */
}

static void
xxx_init_edge(edge_t * e)
{
  common_init_edge(e);
  /* add algorithm-specific data, if desired */
}

static void
xxx_init_node_edge(graph_t * g)
{
  for (node_t *n = agfstnode(g); n; n = agnxtnode(g, n)) {
      xxx_init_node(n);
  }
  for (node_t *n = agfstnode(g); n; n = agnxtnode(g, n)) {
      for (edge_t *e = agfstout(g, n); e; e = agnxtout(g, e)){
          xxx_init_edge(e);
      }
  }
}

void
xxx_layout (Agraph_t* g)
{
  xxx_init_node_edge(g);
  /* Set ND_pos(n) for each node n */
  spline_edges(g);
  dotneato_postprocess(g);
}  
</pre></div>
<h2 id="cleanup">Cleanup</h2> <div class="highlight"><pre data-language="c">void xxx_cleanup(Agraph_t * g)
</pre></div>
<p>Free up any resources allocated in the layout.</p> <p>Finish with calls to <code>gv_cleanup_node</code> and <code>gv_cleanup_edge</code> for each node and edge. This cleans up splines labels, <code>ND_pos</code>, shapes and 0's out the <code>A*info_t</code>, so these have to occur last, but could be part of explicit <code>xxx_cleanup_node</code> and <code>xxx_cleanup_edge</code>, if desired.</p> <p>At the end, you should do:</p> <div class="highlight"><pre data-language="c">if (g != g-&gt;root) memset(&amp;g-&gt;u, 0, sizeof(Agraphinfo_t));
</pre></div>
<p>This is necessary for the graph to be laid out again, as the layout code assumes this structure is clean.</p> <p><code>libgvc</code> does a final cleanup to the root graph, freeing any drawing, freeing its label, and zeroing out <code>Agraphinfo_t</code> of the root graph.</p> <p>The following template will work in most cases:</p> <div class="highlight"><pre data-language="c">static void xxx_cleanup_graph(Agraph_t * g)
{
  /* Free any algorithm-specific data attached to the graph */
  if (g != g-&gt;root) memset(&amp;g-&gt;u, 0, sizeof(Agraphinfo_t));
}

static void xxx_cleanup_edge (Agedge_t* e)
{
  /* Free any algorithm-specific data attached to the edge */
  gv_cleanup_edge(e);
}

static void xxx_cleanup_node (Agnode_t* n)
{
  /* Free any algorithm-specific data attached to the node */
  gv_cleanup_node(e);
}

void xxx_cleanup(Agraph_t * g)
{
  for (Agnode_t *n = agfstnode(g); n; n = agnxtnode(g, n)) {
      for (Agedge_t *e = agfstout(g, n); e; e = agnxtout(g, e)) {
          xxx_cleanup_edge(e);
      }
      xxx_cleanup_node(n);
  }
  xxx_cleanup_graph(g);
}   
</pre></div>
<p>Most layouts use auxiliary routines similar to <code>neato</code>, so the entry points can be added in <code>plugin/neato_layout</code>.</p> <p>Add to <code>gvlayout_neato_layout.c</code>:</p> <div class="highlight"><pre data-language="c">gvlayout_engine_t xxxgen_engine = {
    xxx_layout,
    xxx_cleanup,
};
</pre></div>
<p>and the line</p> <div class="highlight"><pre data-language="c">{LAYOUT_XXX, "xxx", 0, &amp;xxxgen_engine, &amp;neatogen_features},
</pre></div>
<p>to <code>gvlayout_neato_types</code> and a new emum <code>LAYOUT_XXX</code> to <code>layout_type</code> in that file.</p> <p>The above allows the new layout to piggyback on top of the <code>neato</code> plugin, but requires rebuilding the plugin. In general, a user can (and probably should) build a layout plugin totally separately.</p> <p>To do this, after writing <code>xxx_layout</code> and <code>xxx_cleanup</code>, it is necessary to:</p> <ol> <li> <p>Add the types and data structures:</p> <div class="highlight"><pre data-language="c">typedef enum { LAYOUT_XXX } layout_type;

static gvlayout_features_t xxxgen_features = {
    0
};
gvlayout_engine_t xxxgen_engine = {
    xxx_layout,
    xxx_cleanup,
};
static gvplugin_installed_t gvlayout_xxx_types[] = {
    {LAYOUT_XXX, "xxx", 0, &amp;xxxgen_engine, &amp;xxxgen_features},
    {0}
};
static gvplugin_api_t apis[] = {
    {API_layout, &amp;gvlayout_xxx_types},
    {0},
};
gvplugin_library_t gvplugin_xxx_layout_LTX_library = { "xxx_layout", apis };
</pre></div>
</li> <li> <p>Combine all of this into a dynamic library whose name contains the string <code>gvplugin_</code> and install the library in the same directory as the other Graphviz plugins. For example, on Linux systems, the dot layout plugin is in the library <code>libgvplugin_dot_layout.so</code>.</p> </li> <li> <p>Run <code>dot -c</code> to regenerate the config file.</p> </li> </ol> <p>NOTES:</p> <ul> <li>Additional layouts can be added as extra lines in <code>gvlayout_xxx_types</code>.</li> <li>Obviously, most of the names and strings can be arbitrary. One constraint is that external identifier for the <code>gvplugin_library_t</code> type must end in <code>_LTX_library</code>. In addition, the string <code>xxx</code> in each entry of <code>gvlayout_xxx_types</code> is the name used to identify the layout algorithm, so needs to be distinct from any other layout name.</li> <li>The features of a layout algorithm are currently limited to a flag of bits, and the only flag supported is <code>LAYOUT_USES_RANKDIR</code>, which enables the layout to the <a href="../../attrs/rankdir/index"><code>rankdir</code></a> attribute.</li> </ul> <p>Changes need to be made to any applications that statically know about layout algorithms.</p> <h2 id="automake-configuration">Automake Configuration</h2> <p>If you want to integrate your code into the Graphviz software and use its build system, follow the instructions below. You can certainly build and install your plugin using your own build software.</p> <ol start="0"> <li>Put your software in <code>lib/xxxgen</code>, and added the hooks describe above into <code>gvlayout_neato_layout.c</code>
</li> <li>In <code>lib/xxxgen</code>, provide a <code>Makefile.am</code> (based on a simple example like <code>lib/fdpgen/Makefile.am</code>)</li> <li>In <code>lib/Makefile.am</code>, add <code>xxxgen</code> to <code>SUBDIRS</code>
</li> <li>In <code>configure.ac</code>, add <code>lib/xxxgen/Makefile</code> to <code>AC_CONFIG_FILES</code>.</li> <li>In <code>lib/plugin/neato_layout/Makefile.am</code>, insert <code>$(top_builddir)/lib/xxxgen/libxxxgen_C.la</code> in <code>libgvplugin_neato_layout_C_la_LIBADD</code>.</li> <li>Remember to run <code>autogen.sh</code> because on its own <code>configure</code> can guess wrong.</li> </ol> <p>This also assumes you have a good version of the various automake tools on your system.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2025 The Graphviz Authors<br>Licensed under the Eclipse Public License 1.0.<br>
    <a href="https://www.graphviz.org/docs/layouts/writing-layout-plugins/" class="_attribution-link">https://www.graphviz.org/docs/layouts/writing-layout-plugins/</a>
  </p>
</div>
