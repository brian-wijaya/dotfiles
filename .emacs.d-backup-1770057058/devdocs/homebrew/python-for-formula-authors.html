<h1 id="python-for-formula-authors">Python for Formula Authors</h1> <p>This document explains how to successfully use Python in a Homebrew formula.</p> <p>Homebrew draws a distinction between Python <strong>applications</strong> and Python <strong>libraries</strong>. The difference is that users generally do not care that applications are written in Python; it is unusual that a user would expect to be able to <code class="language-plaintext highlighter-rouge">import foo</code> after installing an application. Examples of applications are <a href="https://github.com/Homebrew/homebrew-core/blob/HEAD/Formula/a/ansible.rb"><code class="language-plaintext highlighter-rouge">ansible</code></a> and <a href="https://github.com/Homebrew/homebrew-core/blob/HEAD/Formula/j/jrnl.rb"><code class="language-plaintext highlighter-rouge">jrnl</code></a>.</p> <p>Python libraries exist to be imported by other Python modules; they are often dependencies of Python applications. They are usually no more than incidentally useful in a terminal. Examples of libraries are <a href="https://github.com/Homebrew/homebrew-core/blob/HEAD/Formula/c/certifi.rb"><code class="language-plaintext highlighter-rouge">certifi</code></a> and <a href="https://github.com/Homebrew/homebrew-core/blob/HEAD/Formula/n/numpy.rb"><code class="language-plaintext highlighter-rouge">numpy</code></a>.</p> <p>Bindings are a special case of libraries that allow Python code to interact with a library or application implemented in another language. An example is the Python bindings installed by <a href="https://github.com/Homebrew/homebrew-core/blob/HEAD/Formula/lib/libxml2.rb"><code class="language-plaintext highlighter-rouge">libxml2</code></a>.</p> <p>Homebrew is happy to accept applications that are built in Python, whether the apps are available from PyPI or not. Homebrew generally won’t accept libraries that can be installed correctly with <code class="language-plaintext highlighter-rouge">pip install foo</code>. Bindings may be installed for packages that provide them, especially if equivalent functionality isn’t available through pip. Similarly, libraries that have non-trivial amounts of native code and have a long compilation as a result can be good candidates. If in doubt, though: do not package libraries.</p> <p>Applications should unconditionally bundle all their Python-language dependencies and libraries and should install any unsatisfied dependencies; these strategies are discussed in depth in the following sections.</p> <h2 id="applications">Applications</h2> <h3 id="python-declarations-for-applications">Python declarations for applications</h3> <p>Formulae for apps that require Python 3 <strong>must</strong> declare an unconditional dependency on <code class="language-plaintext highlighter-rouge">"python@3.y"</code>. These apps <strong>must</strong> work with the current Homebrew Python 3.y formula.</p> <h3 id="installing-applications">Installing applications</h3> <p>Starting with Python@3.12, Homebrew follows <a href="https://peps.python.org/pep-0668/#marking-an-interpreter-as-using-an-external-package-manager">PEP 668</a>. Applications must be installed into a Python <a href="https://docs.python.org/3/library/venv.html">virtual environment</a> rooted in <code class="language-plaintext highlighter-rouge">libexec</code>. This prevents the app’s Python modules from contaminating the system <code class="language-plaintext highlighter-rouge">site-packages</code> and vice versa.</p> <p>All the Python module dependencies of the application (and their dependencies, recursively) should be <a href="formula-cookbook#python-dependencies">declared as <code class="language-plaintext highlighter-rouge">resource</code>s</a> in the formula and installed into the virtual environment as well. Each dependency should be explicitly specified; please do not rely on <code class="language-plaintext highlighter-rouge">setup.py</code> or <code class="language-plaintext highlighter-rouge">pip</code> to perform automatic dependency resolution, for the <a href="acceptable-formulae#we-dont-like-install-scripts-that-download-unversioned-things">reasons described here</a>.</p> <p>You can use <code class="language-plaintext highlighter-rouge">brew update-python-resources</code> to help you write resource stanzas. To use it, simply run <code class="language-plaintext highlighter-rouge">brew update-python-resources &lt;formula&gt;</code>. Sometimes, <code class="language-plaintext highlighter-rouge">brew update-python-resources</code> won’t be able to automatically update the resources. If this happens, try running <code class="language-plaintext highlighter-rouge">brew update-python-resources --print-only &lt;formula&gt;</code> to print the resource stanzas instead of applying the changes directly to the file. You can then copy and paste resources as needed.</p> <p>If using <code class="language-plaintext highlighter-rouge">brew update-python-resources</code> doesn’t work, you can use <a href="https://github.com/tdsmith/homebrew-pypi-poet">homebrew-pypi-poet</a> to help you write resource stanzas. To use it, set up a virtual environment and install your package and all its dependencies. Then, <code class="language-plaintext highlighter-rouge">pip install homebrew-pypi-poet</code> into the same virtual environment. Running <code class="language-plaintext highlighter-rouge">poet some_package</code> will generate the necessary resource stanzas. You can do this like:</p> <pre data-language="bash"># Use a temporary directory for the virtual environment
cd "$(mktemp -d)"

# Create and source a new virtual environment in the venv/ directory
python3 -m venv venv
source venv/bin/activate

# Install the package of interest as well as homebrew-pypi-poet
pip install some_package homebrew-pypi-poet
poet some_package

# Destroy the virtual environment
deactivate
rm -rf venv</pre> <p>Homebrew provides helper methods for instantiating and populating virtual environments. You can use them by putting <code class="language-plaintext highlighter-rouge">include Language::Python::Virtualenv</code> at the top of the <code class="language-plaintext highlighter-rouge">Formula</code> class definition.</p> <p>For most applications, all you will need to write is:</p> <pre data-language="ruby">class Foo &lt; Formula
  include Language::Python::Virtualenv

  # ...
  url "https://example.com/foo-1.0.tar.gz"
  sha256 "abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc1"

  depends_on "python@3.y"

  def install
    virtualenv_install_with_resources
  end
end</pre> <p>This is exactly the same as writing:</p> <pre data-language="ruby">class Foo &lt; Formula
  include Language::Python::Virtualenv

  # ...
  url "https://example.com/foo-1.0.tar.gz"
  sha256 "abc123abc123abc123abc123abc123abc123abc123abc123abc123abc123abc1"

  depends_on "python@3.y"

  def install
    # Create a virtualenv in `libexec`.
    venv = virtualenv_create(libexec, "python3.y")
    # Install all of the resources declared on the formula into the virtualenv.
    venv.pip_install resources
    # `pip_install_and_link` takes a look at the virtualenv's bin directory
    # before and after installing its argument. New scripts will be symlinked
    # into `bin`. `pip_install_and_link buildpath` will install the package
    # that the formula points to, because buildpath is the location where the
    # formula's tarball was unpacked.
    venv.pip_install_and_link buildpath
  end
end</pre> <h3 id="example-formula">Example formula</h3> <p>Installing a formula with dependencies will look like this:</p> <pre data-language="ruby">class Foo &lt; Formula
  include Language::Python::Virtualenv

  desc "Description"
  homepage "https://example.com"
  url "..."

  resource "six" do
    url "https://files.pythonhosted.org/packages/71/39/171f1c67cd00715f190ba0b100d606d440a28c93c7714febeca8b79af85e/six-1.16.0.tar.gz"
    sha256 "1e61c37477a1626458e36f7b1d82aa5c9b094fa4802892072e49de9c60c4c926"
  end

  resource "parsedatetime" do
    url "https://files.pythonhosted.org/packages/a8/20/cb587f6672dbe585d101f590c3871d16e7aec5a576a1694997a3777312ac/parsedatetime-2.6.tar.gz"
    sha256 "4cb368fbb18a0b7231f4d76119165451c8d2e35951455dfee97c62a87b04d455"
  end

  def install
    virtualenv_install_with_resources
  end
end</pre> <p>You can also use the more verbose form and request that specific resources be installed:</p> <pre data-language="ruby">class Foo &lt; Formula
  include Language::Python::Virtualenv

  desc "Description"
  homepage "https://example.com"
  url "..."

  def install
    venv = virtualenv_create(libexec)
    %w[six parsedatetime].each do |r|
      venv.pip_install resource(r)
    end
    venv.pip_install_and_link buildpath
  end
end</pre> <p>in case you need to do different things for different resources.</p> <h2 id="bindings">Bindings</h2> <p>To add bindings for Python 3, please add <code class="language-plaintext highlighter-rouge">depends_on "python@3.y"</code> to work with the current Homebrew Python 3.y formula.</p> <h3 id="dependencies-for-bindings">Dependencies for bindings</h3> <p>Bindings should follow the same advice for Python module dependencies as libraries; see below for more.</p> <h3 id="installing-bindings">Installing bindings</h3> <p>If the bindings are installed by invoking a <code class="language-plaintext highlighter-rouge">setup.py</code>, do something like:</p> <pre data-language="ruby">system "python3.y", "-m", "pip", "install", *std_pip_args(build_isolation: true), "./source/python"</pre> <h4 id="autotools">Autotools</h4> <p>If the configure script takes a <code class="language-plaintext highlighter-rouge">--with-python</code> flag, it usually will not need extra help finding Python. However, if there are multiple Python formulae in the dependency tree, it may need help finding the correct one.</p> <p>If the <code class="language-plaintext highlighter-rouge">configure</code> and <code class="language-plaintext highlighter-rouge">make</code> scripts do not want to install into the Cellar, sometimes you can:</p> <ol> <li>call <code class="language-plaintext highlighter-rouge">./configure --without-python</code> (or a similar named option)</li> <li>call <code class="language-plaintext highlighter-rouge">pip</code> on the directory containing the Python bindings (as described above)</li> </ol> <p>Sometimes we have to edit a <code class="language-plaintext highlighter-rouge">Makefile</code> on-the-fly to use our prefix for the Python bindings using Homebrew’s <a href="formula-cookbook#inreplace"><code class="language-plaintext highlighter-rouge">inreplace</code></a> helper method.</p> <h4 id="cmake">CMake</h4> <p>If <code class="language-plaintext highlighter-rouge">cmake</code> finds a different Python than the direct dependency, sometimes you can help it find the correct Python by setting one of the following variables with the <code class="language-plaintext highlighter-rouge">-D</code> option:</p> <ul> <li>
<code class="language-plaintext highlighter-rouge">Python3_EXECUTABLE</code> for the <a href="https://cmake.org/cmake/help/latest/module/FindPython3.html"><code class="language-plaintext highlighter-rouge">FindPython3</code></a> module</li> <li>
<code class="language-plaintext highlighter-rouge">Python_EXECUTABLE</code> for the <a href="https://cmake.org/cmake/help/latest/module/FindPython.html"><code class="language-plaintext highlighter-rouge">FindPython</code></a> module</li> <li>
<code class="language-plaintext highlighter-rouge">PYTHON_EXECUTABLE</code> for the <a href="https://cmake.org/cmake/help/latest/module/FindPythonInterp.html"><code class="language-plaintext highlighter-rouge">FindPythonInterp</code></a> module</li> </ul> <h4 id="meson">Meson</h4> <p>As a side effect of Homebrew’s symlink installation and the Python sysconfig patch, <code class="language-plaintext highlighter-rouge">meson</code> may be unable to automatically detect the Cellar directories to install Python bindings into. If the formula’s <code class="language-plaintext highlighter-rouge">meson</code> build definition uses <a href="https://mesonbuild.com/Python-module.html#install_sources"><code class="language-plaintext highlighter-rouge">install_sources()</code></a> or similar methods, you can set <code class="language-plaintext highlighter-rouge">python.purelibdir</code> and/or <code class="language-plaintext highlighter-rouge">python.platlibdir</code> to override the default paths.</p> <p>If <code class="language-plaintext highlighter-rouge">meson</code> finds a different Python than the direct dependency and the formula’s <code class="language-plaintext highlighter-rouge">meson</code> option definition file does not provide a user-settable option, then you will need to check how the Python executable is being detected. A common approach is the <a href="https://mesonbuild.com/Python-module.html#find_installation"><code class="language-plaintext highlighter-rouge">find_installation()</code></a> method which will behave differently based on what the <code class="language-plaintext highlighter-rouge">name_or_path</code> argument is set to.</p> <h2 id="libraries">Libraries</h2> <p>Remember: there are very limited cases for libraries (e.g. significant amounts of native code is compiled) so, if in doubt, do not package them.</p> <p><strong>We do not use the <code class="language-plaintext highlighter-rouge">python-</code> prefix for these kinds of formulae!</strong></p> <h3 id="examples-of-allowed-libraries-in-homebrew-core">Examples of allowed libraries in homebrew-core</h3> <ul> <li> <p><code class="language-plaintext highlighter-rouge">numpy</code>, <code class="language-plaintext highlighter-rouge">scipy</code>: long build time, complex build process</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">cryptography</code>: builds with <code class="language-plaintext highlighter-rouge">rust</code></p> </li> <li> <p><code class="language-plaintext highlighter-rouge">certifi</code>: patched formula to allow any Python-based formulae to leverage the brewed CA certs (see <a href="https://github.com/orgs/Homebrew/discussions/4691">https://github.com/orgs/Homebrew/discussions/4691</a>).</p> </li> </ul> <h3 id="python-declarations-for-libraries">Python declarations for libraries</h3> <p>Libraries built for Python 3 must include <code class="language-plaintext highlighter-rouge">depends_on "python@3.y"</code>, which will bottle against Homebrew’s Python 3.y.</p> <h3 id="installing-libraries">Installing libraries</h3> <p>Libraries may be installed to <code class="language-plaintext highlighter-rouge">libexec</code> and added to <code class="language-plaintext highlighter-rouge">sys.path</code> by writing a <code class="language-plaintext highlighter-rouge">.pth</code> file (named like “homebrew-foo.pth”) to the <code class="language-plaintext highlighter-rouge">prefix</code> site-packages. This simplifies the ensuing drama if pip is accidentally used to upgrade a Homebrew-installed package and prevents the accumulation of stale <code class="language-plaintext highlighter-rouge">.pyc</code> files in Homebrew’s site-packages.</p> <p>Most formulae presently just install to <code class="language-plaintext highlighter-rouge">prefix</code>. Any stale <code class="language-plaintext highlighter-rouge">.pyc</code> files are handled by <code class="language-plaintext highlighter-rouge">brew cleanup</code>.</p> <h3 id="dependencies-for-libraries">Dependencies for libraries</h3> <p>Library dependencies must be installed so that they are importable. To minimise the potential for linking conflicts, dependencies should be installed to <code class="language-plaintext highlighter-rouge">libexec/&lt;vendor&gt;</code> and added to <code class="language-plaintext highlighter-rouge">sys.path</code> by writing a second <code class="language-plaintext highlighter-rouge">.pth</code> file (named like “homebrew-foo-dependencies.pth”) to the <code class="language-plaintext highlighter-rouge">prefix</code> site-packages.</p> <p>Formulae with general Python library dependencies (e.g. <code class="language-plaintext highlighter-rouge">setuptools</code>, <code class="language-plaintext highlighter-rouge">six</code>) should not use this approach as it will contaminate the system <code class="language-plaintext highlighter-rouge">site-packages</code> with all libraries installed inside <code class="language-plaintext highlighter-rouge">libexec/&lt;vendor&gt;</code>.</p> <h2 id="further-down-the-rabbit-hole">Further down the rabbit hole</h2> <p>Additional commentary that explains why Homebrew does some of the things it does.</p> <h3 id="setuptools-vs-distutils-vs-pip">Setuptools vs. Distutils vs. pip</h3> <p>Distutils was a module in the Python standard library that provided developers a basic package management API until its removal in Python 3.12. Setuptools is a module distributed outside the standard library that extends and replaces Distutils. It is a convention that Python packages provide a <code class="language-plaintext highlighter-rouge">setup.py</code> that calls the <code class="language-plaintext highlighter-rouge">setup()</code> function from either Distutils or Setuptools.</p> <p>Setuptools used to provide the <code class="language-plaintext highlighter-rouge">easy_install</code> command, which was an end-user package management tool that fetched and installed packages from PyPI, the Python Package Index. The <code class="language-plaintext highlighter-rouge">easy_install</code> console script was removed in Setuptools v52.0.0 and direct usage has been deprecated since v58.3.0. <code class="language-plaintext highlighter-rouge">pip</code> is another, newer end-user package management tool, which is also provided outside the standard library. While <code class="language-plaintext highlighter-rouge">pip</code> supplants <code class="language-plaintext highlighter-rouge">easy_install</code>, it does not replace the other functionality of the Setuptools module.</p> <p>Distutils and pip use a “flat” installation hierarchy that installs modules as individual files under <code class="language-plaintext highlighter-rouge">site-packages</code> while <code class="language-plaintext highlighter-rouge">easy_install</code> installs zipped eggs to <code class="language-plaintext highlighter-rouge">site-packages</code> instead.</p> <p>Distribute (not to be confused with Distutils) is an obsolete fork of Setuptools. Distlib is a package maintained outside the standard library which is used by pip for some low-level packaging operations and is not relevant to most <code class="language-plaintext highlighter-rouge">setup.py</code> users.</p> <h3 id="running-setuppy">Running <code class="language-plaintext highlighter-rouge">setup.py</code>
</h3> <p>For when a formula needs to interact with <code class="language-plaintext highlighter-rouge">setup.py</code> instead of calling <code class="language-plaintext highlighter-rouge">pip</code>, Homebrew provides the helper method <code class="language-plaintext highlighter-rouge">Language::Python.setup_install_args</code> which returns useful arguments for invoking <code class="language-plaintext highlighter-rouge">setup.py</code>. Your formula should use this instead of invoking <code class="language-plaintext highlighter-rouge">setup.py</code> explicitly. The syntax is:</p> <pre data-language="ruby">system Formula["python@3.y"].opt_bin/"python3.y", *Language::Python.setup_install_args(prefix)</pre> <p>where <code class="language-plaintext highlighter-rouge">prefix</code> is the destination prefix (usually <code class="language-plaintext highlighter-rouge">libexec</code> or <code class="language-plaintext highlighter-rouge">prefix</code>).</p> <h3 id="what-is---single-version-externally-managed">What is <code class="language-plaintext highlighter-rouge">--single-version-externally-managed</code>?</h3> <p><code class="language-plaintext highlighter-rouge">--single-version-externally-managed</code> (“SVEM”) is a <a href="https://setuptools.readthedocs.io/en/latest/setuptools.html">Setuptools</a>-only argument to <code class="language-plaintext highlighter-rouge">setup.py install</code>. The primary effect of SVEM is using Distutils to perform the install instead of Setuptools’ <code class="language-plaintext highlighter-rouge">easy_install</code>.</p> <p><code class="language-plaintext highlighter-rouge">easy_install</code> does a few things that we need to avoid:</p> <ul> <li>fetches and installs dependencies</li> <li>upgrades dependencies in <code class="language-plaintext highlighter-rouge">sys.path</code> in-place</li> <li>writes <code class="language-plaintext highlighter-rouge">.pth</code> and <code class="language-plaintext highlighter-rouge">site.py</code> files which aren’t useful for us and cause link conflicts</li> </ul> <p>Setuptools requires that SVEM be used in conjunction with <code class="language-plaintext highlighter-rouge">--record</code>, which provides a list of files that can later be used to uninstall the package. We don’t need or want this because Homebrew can manage uninstallation, but since Setuptools demands it we comply. The Homebrew convention is to name the record file “installed.txt”.</p> <p>Detecting whether a <code class="language-plaintext highlighter-rouge">setup.py</code> uses <code class="language-plaintext highlighter-rouge">setup()</code> from Setuptools or Distutils is difficult, but we always need to pass this flag to Setuptools-based scripts. <code class="language-plaintext highlighter-rouge">pip</code> faces the same problem that we do and forces <code class="language-plaintext highlighter-rouge">setup()</code> to use the Setuptools version by loading a shim around <code class="language-plaintext highlighter-rouge">setup.py</code> that imports Setuptools before doing anything else. Since Setuptools monkey-patches Distutils and replaces its <code class="language-plaintext highlighter-rouge">setup</code> function, this provides a single, consistent interface. We have borrowed this code and use it in <code class="language-plaintext highlighter-rouge">Language::Python.setup_install_args</code>.</p> <h3 id="--prefix-vs---root">
<code class="language-plaintext highlighter-rouge">--prefix</code> vs <code class="language-plaintext highlighter-rouge">--root</code>
</h3> <p><code class="language-plaintext highlighter-rouge">setup.py</code> accepts a slightly bewildering array of installation options. The correct switch for Homebrew is <code class="language-plaintext highlighter-rouge">--prefix</code>, which automatically sets the <code class="language-plaintext highlighter-rouge">--install-foo</code> family of options with sane POSIX-y values.</p> <p><code class="language-plaintext highlighter-rouge">--root</code> <a href="https://mail.python.org/pipermail/distutils-sig/2010-November/017099.html">is used</a> when installing into a prefix that will not become part of the final installation location of the files, like when building a RPM or binary distribution. When using a <code class="language-plaintext highlighter-rouge">setup.py</code>-based Setuptools, <code class="language-plaintext highlighter-rouge">--root</code> has the side effect of activating <code class="language-plaintext highlighter-rouge">--single-version-externally-managed</code>. It is not safe to use <code class="language-plaintext highlighter-rouge">--root</code> with an empty <code class="language-plaintext highlighter-rouge">--prefix</code> because the <code class="language-plaintext highlighter-rouge">root</code> is removed from paths when byte-compiling modules.</p> <p>It is probably safe to use <code class="language-plaintext highlighter-rouge">--prefix</code> with <code class="language-plaintext highlighter-rouge">--root=/</code>, which should work with either Setuptools- or Distutils-based <code class="language-plaintext highlighter-rouge">setup.py</code>’s, but it’s kinda ugly.</p> <h3 id="pip-vs-setuppy">
<code class="language-plaintext highlighter-rouge">pip</code> vs. <code class="language-plaintext highlighter-rouge">setup.py</code>
</h3> <p><a href="https://legacy.python.org/dev/peps/pep-0453/#recommendations-for-downstream-distributors">PEP 453</a> makes a recommendation to downstream distributors (us) that sdist tarballs should be installed with <code class="language-plaintext highlighter-rouge">pip</code> instead of by invoking <code class="language-plaintext highlighter-rouge">setup.py</code> directly. For historical reasons we did not follow PEP 453, so some formulae still use <code class="language-plaintext highlighter-rouge">setup.py</code> installs. Nowadays, most core formulae use <code class="language-plaintext highlighter-rouge">pip</code> as we have migrated them to this preferred method of installation.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2009&ndash;present Homebrew contributors<br>Licensed under the BSD 2-Clause License.<br>
    <a href="https://docs.brew.sh/Python-for-Formula-Authors" class="_attribution-link">https://docs.brew.sh/Python-for-Formula-Authors</a>
  </p>
</div>
