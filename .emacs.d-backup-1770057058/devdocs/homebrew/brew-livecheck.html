<h1 id="brew-livecheck"><code class="language-plaintext highlighter-rouge">brew livecheck</code></h1> <p>The <code class="language-plaintext highlighter-rouge">brew livecheck</code> command finds the newest version of a formula or cask’s software by checking upstream. Livecheck has <a href="https://rubydoc.brew.sh/Homebrew/Livecheck/Strategy">strategies</a> to identify versions from various sources, such as Git repositories, websites, etc.</p> <h2 id="behaviour">Behaviour</h2> <p>When livecheck isn’t given instructions for how to check for upstream versions, it does the following by default:</p> <ol> <li>Collect a list of URLs to check. <ul> <li>For formulae: use their <code class="language-plaintext highlighter-rouge">stable</code>, <code class="language-plaintext highlighter-rouge">head</code>, and <code class="language-plaintext highlighter-rouge">homepage</code> URLs, in that order.</li> <li>For formula resources: use their <code class="language-plaintext highlighter-rouge">url</code>.</li> <li>For casks: use their <code class="language-plaintext highlighter-rouge">url</code> and <code class="language-plaintext highlighter-rouge">homepage</code> URLs, in that order.</li> </ul> </li> <li>Determine if any strategies apply to the first URL. If not, try the next URL.</li> <li>If a strategy can be applied, use it to check for new versions.</li> <li>Return the newest version (or an error if versions could not be found at any available URLs).</li> </ol> <p>It’s sometimes necessary to override this default behaviour to create a working check. If a source doesn’t provide the newest version, we need to check a different one. If livecheck doesn’t correctly match version text, we need to provide an appropriate regex or <code class="language-plaintext highlighter-rouge">strategy</code> block.</p> <p>This can be accomplished by adding a <code class="language-plaintext highlighter-rouge">livecheck</code> block to the formula/cask/resource. For more information on the available methods, please refer to the <a href="https://rubydoc.brew.sh/Livecheck"><code class="language-plaintext highlighter-rouge">Livecheck</code> class</a> documentation.</p> <h2 id="creating-a-check">Creating a check</h2> <ol> <li> <p><strong>Use the debug output to understand the situation</strong>. <code class="language-plaintext highlighter-rouge">brew livecheck --debug &lt;formula&gt;|&lt;cask&gt;</code> provides information about which URLs livecheck tries, any strategies that apply, matched versions, etc.</p> </li> <li> <p><strong>Research available sources to select a URL</strong>. Try removing the file name from <code class="language-plaintext highlighter-rouge">stable</code>/<code class="language-plaintext highlighter-rouge">url</code> to see if it provides a directory listing page. If that doesn’t work, try to find a page that links to the file (e.g. a download page). If it’s not possible to find the newest version on the website, try checking other sources from the formula/cask. When necessary, search for other sources outside of the formula/cask.</p> </li> <li> <p><strong>Create a regex, if necessary</strong>. If the check works without a regex and wouldn’t benefit from having one, it’s usually fine to omit it. More information on creating regexes can be found in the <a href="#regex-guidelines">regex guidelines</a> section.</p> </li> </ol> <h3 id="general-guidelines">General guidelines</h3> <ul> <li> <p><strong>Only use <code class="language-plaintext highlighter-rouge">strategy</code> when it’s necessary</strong>. For example, if livecheck is already using the <code class="language-plaintext highlighter-rouge">Git</code> strategy for a URL, it’s not necessary to use <code class="language-plaintext highlighter-rouge">strategy :git</code>. However, if <code class="language-plaintext highlighter-rouge">Git</code> applies to a URL but we need to use <code class="language-plaintext highlighter-rouge">PageMatch</code>, it’s necessary to specify <code class="language-plaintext highlighter-rouge">strategy :page_match</code>.</p> </li> <li> <p><strong>Only use the <code class="language-plaintext highlighter-rouge">GithubLatest</code> and <code class="language-plaintext highlighter-rouge">GithubReleases</code> strategies when they are necessary and correct</strong>. GitHub rate-limits API requests, so we only use these strategies when <code class="language-plaintext highlighter-rouge">Git</code> isn’t sufficient or appropriate. <code class="language-plaintext highlighter-rouge">GithubLatest</code> should only be used if the upstream repository has a “latest” release for a suitable version and either the formula/cask uses a release asset or the <code class="language-plaintext highlighter-rouge">Git</code> strategy can’t correctly identify the latest release version. <code class="language-plaintext highlighter-rouge">GithubReleases</code> should only be used if the upstream repository uses releases and both the <code class="language-plaintext highlighter-rouge">Git</code> and <code class="language-plaintext highlighter-rouge">GithubLatest</code> strategies aren’t suitable.</p> </li> </ul> <h3 id="url-guidelines">URL guidelines</h3> <ul> <li> <p><strong>A <code class="language-plaintext highlighter-rouge">url</code> is required in a <code class="language-plaintext highlighter-rouge">livecheck</code> block</strong>. This can be a URL string (e.g. <code class="language-plaintext highlighter-rouge">"https://www.example.com/downloads/"</code>) or a formula/cask URL symbol (i.e. <code class="language-plaintext highlighter-rouge">:stable</code>, <code class="language-plaintext highlighter-rouge">:url</code>, <code class="language-plaintext highlighter-rouge">:head</code>, <code class="language-plaintext highlighter-rouge">:homepage</code>). The exception to this rule is a <code class="language-plaintext highlighter-rouge">livecheck</code> block that only uses <code class="language-plaintext highlighter-rouge">skip</code>.</p> </li> <li> <p><strong>Check for versions in the same location as the stable archive, whenever possible</strong>.</p> </li> <li> <p><strong>Avoid checking paginated release pages, when possible</strong>. For example, we generally avoid checking the <code class="language-plaintext highlighter-rouge">release</code> page for a GitHub project because the latest stable version can be pushed off the first page by pre-release versions. In this scenario, it’s more reliable to use the <code class="language-plaintext highlighter-rouge">Git</code> strategy, which fetches all the tags in the repository.</p> </li> </ul> <h3 id="regex-guidelines">Regex guidelines</h3> <p>The <code class="language-plaintext highlighter-rouge">livecheck</code> block regex restricts matches to a subset of the fetched content and uses a capture group around the version text.</p> <ul> <li> <p><strong>Regexes should be made case insensitive, whenever possible</strong>, by adding <code class="language-plaintext highlighter-rouge">i</code> at the end (e.g. <code class="language-plaintext highlighter-rouge">/.../i</code> or <code class="language-plaintext highlighter-rouge">%r{...}i</code>). This improves reliability, as the regex will handle changes in letter case without needing modifications.</p> </li> <li> <p><strong>Regexes should only use a capturing group around the version text</strong>. For example, in <code class="language-plaintext highlighter-rouge">/href=.*?example-v?(\d+(?:\.\d+)+)(?:-src)?\.t/i</code>, we’re only using a capturing group around the version text (matching a version like <code class="language-plaintext highlighter-rouge">1.2</code>, <code class="language-plaintext highlighter-rouge">1.2.3</code>, etc.) and we’re using non-capturing groups elsewhere (e.g. <code class="language-plaintext highlighter-rouge">(?:-src)?</code>).</p> </li> <li> <p><strong>Anchor the start/end of the regex to restrict its scope</strong>. For example, on HTML pages we often match file names or version directories in <code class="language-plaintext highlighter-rouge">href</code> attribute URLs (e.g. <code class="language-plaintext highlighter-rouge">/href=.*?example[._-]v?(\d+(?:\.\d+)+)\.zip/i</code>). The general idea is that limiting scope will help exclude unwanted matches.</p> </li> <li> <p><strong>Avoid generic catchalls like <code class="language-plaintext highlighter-rouge">.*</code> or <code class="language-plaintext highlighter-rouge">.+</code></strong> in favor of something non-greedy and/or contextually appropriate. For example, to match characters within the bounds of an HTML attribute, use <code class="language-plaintext highlighter-rouge">[^"' &gt;]+?</code>.</p> </li> <li> <p><strong>Use <code class="language-plaintext highlighter-rouge">[._-]</code> in place of a period/underscore/hyphen between the software name and version in a file name</strong>. For a file named <code class="language-plaintext highlighter-rouge">example-1.2.3.tar.gz</code>, <code class="language-plaintext highlighter-rouge">example[._-]v?(\d+(?:\.\d+)+)\.t</code> will continue matching if the upstream file name format changes to <code class="language-plaintext highlighter-rouge">example_1.2.3.tar.gz</code> or <code class="language-plaintext highlighter-rouge">example.1.2.3.tar.gz</code>.</p> </li> <li> <p><strong>Use <code class="language-plaintext highlighter-rouge">\.t</code> in place of <code class="language-plaintext highlighter-rouge">\.tgz</code>, <code class="language-plaintext highlighter-rouge">\.tar\.gz</code>, etc.</strong> There are a variety of different file extensions for tarballs (e.g. <code class="language-plaintext highlighter-rouge">.tar.bz2</code>, <code class="language-plaintext highlighter-rouge">tbz2</code>, <code class="language-plaintext highlighter-rouge">.tar.gz</code>, <code class="language-plaintext highlighter-rouge">.tgz</code>, <code class="language-plaintext highlighter-rouge">.tar.xz</code>, <code class="language-plaintext highlighter-rouge">.txz</code>, etc.) and the upstream source may switch from one compression format to another over time. <code class="language-plaintext highlighter-rouge">\.t</code> avoids this issue by matching current and future formats starting with <code class="language-plaintext highlighter-rouge">t</code>. Outside of tarballs, we use the full file extension in the regex like <code class="language-plaintext highlighter-rouge">\.zip</code>, <code class="language-plaintext highlighter-rouge">\.jar</code>, etc.</p> </li> </ul> <h2 id="example-livecheck-blocks">Example <code class="language-plaintext highlighter-rouge">livecheck</code> blocks</h2> <p>The following examples cover a number of patterns that you may encounter. These are intended to be representative samples and can be easily adapted.</p> <p>When in doubt, start with one of these examples instead of copy-pasting a <code class="language-plaintext highlighter-rouge">livecheck</code> block from a random formula/cask.</p> <h3 id="file-names">File names</h3> <p>When matching the version from a file name on an HTML page, we often restrict matching to <code class="language-plaintext highlighter-rouge">href</code> attributes. <code class="language-plaintext highlighter-rouge">href=.*?</code> will match the opening delimiter (<code class="language-plaintext highlighter-rouge">"</code>, <code class="language-plaintext highlighter-rouge">'</code>) as well as any part of the URL before the file name.</p> <pre data-language="ruby">livecheck do
  url "https://www.example.com/downloads/"
  regex(/href=.*?example[._-]v?(\d+(?:\.\d+)+)\.t/i)
end</pre> <p>We sometimes make this more explicit to exclude unwanted matches. URLs with a preceding path can use <code class="language-plaintext highlighter-rouge">href=.*?/</code> and others can use <code class="language-plaintext highlighter-rouge">href=["']?</code>. For example, this is necessary when the page also contains unwanted files with a longer prefix (<code class="language-plaintext highlighter-rouge">another-example-1.2.tar.gz</code>).</p> <h3 id="version-directories">Version directories</h3> <p>When checking a directory listing page, sometimes files are separated into version directories (e.g. <code class="language-plaintext highlighter-rouge">1.2.3/</code>). In this case, we must identify versions from the directory names.</p> <pre data-language="ruby">livecheck do
  url "https://www.example.com/releases/example/"
  regex(%r{href=["']?v?(\d+(?:\.\d+)+)/?["' &gt;]}i)
end</pre> <h3 id="git-tags">Git tags</h3> <p>When the <code class="language-plaintext highlighter-rouge">stable</code> URL uses the <code class="language-plaintext highlighter-rouge">Git</code> strategy, the following example will only match tags like <code class="language-plaintext highlighter-rouge">1.2</code>/<code class="language-plaintext highlighter-rouge">v1.2</code>, etc.</p> <pre data-language="ruby">livecheck do
  url :stable
  regex(/^v?(\d+(?:\.\d+)+)$/i)
end</pre> <p>If tags include the software name as a prefix (e.g. <code class="language-plaintext highlighter-rouge">example-1.2.3</code>), it’s easy to modify the regex accordingly: <code class="language-plaintext highlighter-rouge">/^example[._-]v?(\d+(?:\.\d+)+)$/i</code></p> <h3 id="referenced-formulacask">Referenced formula/cask</h3> <p>A formula/cask can use the same check as another by using <code class="language-plaintext highlighter-rouge">formula</code> or <code class="language-plaintext highlighter-rouge">cask</code>.</p> <pre data-language="ruby">livecheck do
  formula "another-formula"
end</pre> <p>The referenced formula/cask should be in the same tap, as a reference to a formula/cask from another tap will generate an error if the user doesn’t already have it tapped.</p> <p>A formula resource whose version stays in sync with its parent formula versioning can use the same check with <code class="language-plaintext highlighter-rouge">formula :parent</code>.</p> <pre data-language="ruby">livecheck do
  formula :parent
end</pre> <h3 id="post-requests">
<code class="language-plaintext highlighter-rouge">POST</code> requests</h3> <p>Some checks require making a <code class="language-plaintext highlighter-rouge">POST</code> request, which can be accomplished by adding a <code class="language-plaintext highlighter-rouge">post_form</code> or <code class="language-plaintext highlighter-rouge">post_json</code> option to a <code class="language-plaintext highlighter-rouge">livecheck</code> block <code class="language-plaintext highlighter-rouge">url</code>.</p> <pre data-language="ruby">livecheck do
  url "https://example.com/download.php", post_form: {
    Name:     "",
    "E-mail": "",
  }
  regex(/href=.*?example[._-]v?(\d+(?:\.\d+)+)\.t/i)
end</pre> <p><code class="language-plaintext highlighter-rouge">post_form</code> is used for form data and <code class="language-plaintext highlighter-rouge">post_json</code> is used for JSON data. Livecheck will encode the provided hash value to the appropriate format before making the request.</p> <p><code class="language-plaintext highlighter-rouge">POST</code> support only applies to strategies that use <code class="language-plaintext highlighter-rouge">Strategy::page_headers</code> or <code class="language-plaintext highlighter-rouge">::page_content</code> (directly or indirectly), so it does not apply to <code class="language-plaintext highlighter-rouge">ExtractPlist</code>, <code class="language-plaintext highlighter-rouge">Git</code>, <code class="language-plaintext highlighter-rouge">GithubLatest</code>, <code class="language-plaintext highlighter-rouge">GithubReleases</code>, etc.</p> <h3 id="strategy-blocks">
<code class="language-plaintext highlighter-rouge">strategy</code> blocks</h3> <p>If the upstream version format needs to be manipulated to match the formula/cask format, a <code class="language-plaintext highlighter-rouge">strategy</code> block can be used instead of a <code class="language-plaintext highlighter-rouge">regex</code>.</p> <h4 id="pagematch-strategy-block">
<code class="language-plaintext highlighter-rouge">PageMatch</code> <code class="language-plaintext highlighter-rouge">strategy</code> block</h4> <p>Here is a basic example, extracting a simple version from a page:</p> <pre data-language="ruby">livecheck do
  url "https://example.org/my-app/download"
  regex(%r{href=.*?/MyApp-(\d+(?:\.\d+)*)\.zip}i)
  strategy :page_match
end</pre> <p>More complex versions can be handled by specifying a block.</p> <pre data-language="ruby">livecheck do
  url "https://example.org/my-app/download"
  regex(%r{href=.*?/(\d+)/MyApp-(\d+(?:\.\d+)*)\.zip}i)
  strategy :page_match do |page, regex|
    match = page.match(regex)
    next if match.blank?

    "#{match[2]},#{match[1]}"
  end
end</pre> <p>In the example below, we’re scanning the contents of the homepage for a date format like <code class="language-plaintext highlighter-rouge">2020-01-01</code> and converting it into <code class="language-plaintext highlighter-rouge">20200101</code>.</p> <pre data-language="ruby">livecheck do
  url :homepage
  strategy :page_match do |page|
    page.scan(/href=.*?example[._-]v?(\d{4}-\d{2}-\d{2})\.t/i)
        .map { |match| match&amp;.first&amp;.gsub(/\D/, "") }
  end
end</pre> <p>The <code class="language-plaintext highlighter-rouge">PageMatch</code> <code class="language-plaintext highlighter-rouge">strategy</code> block style seen here also applies to any site-specific strategy that uses <code class="language-plaintext highlighter-rouge">PageMatch</code> internally.</p> <h4 id="headermatch-strategy-block">
<code class="language-plaintext highlighter-rouge">HeaderMatch</code> <code class="language-plaintext highlighter-rouge">strategy</code> block</h4> <p>A <code class="language-plaintext highlighter-rouge">strategy</code> block for <code class="language-plaintext highlighter-rouge">HeaderMatch</code> will try to parse a version from the filename (in the <code class="language-plaintext highlighter-rouge">Content-Disposition</code> header) and the final URL (in the <code class="language-plaintext highlighter-rouge">Location</code> header). If that doesn’t work, a <code class="language-plaintext highlighter-rouge">regex</code> can be specified.</p> <pre data-language="ruby">livecheck do
  url "https://example.org/my-app/download/latest"
  regex(/MyApp-(\d+(?:\.\d+)*)\.zip/i)
  strategy :header_match
end</pre> <p>If the version depends on multiple header fields, a block can be specified.</p> <pre data-language="ruby">livecheck do
  url "https://example.org/my-app/download/latest"
  strategy :header_match do |headers|
    v = headers["content-disposition"][/MyApp-(\d+(?:\.\d+)*)\.zip/i, 1]
    id = headers["location"][%r{/(\d+)/download$}i, 1]
    next if v.blank? || id.blank?

    "#{v},#{id}"
  end
end</pre> <h4 id="git-strategy-block">
<code class="language-plaintext highlighter-rouge">Git</code> <code class="language-plaintext highlighter-rouge">strategy</code> block</h4> <p>A <code class="language-plaintext highlighter-rouge">strategy</code> block for <code class="language-plaintext highlighter-rouge">Git</code> is a bit different, as the block receives an array of tag strings instead of a page content string. Similar to the <code class="language-plaintext highlighter-rouge">PageMatch</code> example, this is converting tags with a date format like <code class="language-plaintext highlighter-rouge">2020-01-01</code> into <code class="language-plaintext highlighter-rouge">20200101</code>.</p> <pre data-language="ruby">livecheck do
  url :stable
  strategy :git do |tags|
    tags.filter_map { |tag| tag[/^(\d{4}-\d{2}-\d{2})$/i, 1]&amp;.gsub(/\D/, "") }
  end
end</pre> <h4 id="githublatest-strategy-block">
<code class="language-plaintext highlighter-rouge">GithubLatest</code> <code class="language-plaintext highlighter-rouge">strategy</code> block</h4> <p>A <code class="language-plaintext highlighter-rouge">strategy</code> block for <code class="language-plaintext highlighter-rouge">GithubLatest</code> receives the parsed JSON data from the GitHub API for a repository’s “latest” release, along with a regex. When a regex is not provided in a <code class="language-plaintext highlighter-rouge">livecheck</code> block, the strategy’s default regex is passed into the <code class="language-plaintext highlighter-rouge">strategy</code> block instead.</p> <p>By default, the strategy matches version text in the release’s tag or title but a <code class="language-plaintext highlighter-rouge">strategy</code> block can be used to check any of the fields in the release JSON. The logic in the following <code class="language-plaintext highlighter-rouge">strategy</code> block is similar to the default behaviour but only checks the release tag instead, for the sake of demonstration:</p> <pre data-language="ruby">livecheck do
  url :stable
  regex(/^example[._-]v?(\d+(?:\.\d+)+)$/i)
  strategy :github_latest do |json, regex|
    match = json["tag_name"]&amp;.match(regex)
    next if match.blank?

    match[1]
  end
end</pre> <p>You can find more information on the response JSON from this API endpoint in the related <a href="https://docs.github.com/en/rest/releases/releases?apiVersion=latest#get-the-latest-release">GitHub REST API documentation</a>.</p> <h4 id="githubreleases-strategy-block">
<code class="language-plaintext highlighter-rouge">GithubReleases</code> <code class="language-plaintext highlighter-rouge">strategy</code> block</h4> <p>A <code class="language-plaintext highlighter-rouge">strategy</code> block for <code class="language-plaintext highlighter-rouge">GithubReleases</code> receives the parsed JSON data from the GitHub API for a repository’s most recent releases, along with a regex. When a regex is not provided in a <code class="language-plaintext highlighter-rouge">livecheck</code> block, the strategy’s default regex is passed into the <code class="language-plaintext highlighter-rouge">strategy</code> block instead.</p> <p>By default, the strategy matches version text in each release’s tag or title but a <code class="language-plaintext highlighter-rouge">strategy</code> block can be used to check any of the fields in the release JSON. The logic in the following <code class="language-plaintext highlighter-rouge">strategy</code> block is similar to the default behaviour but only checks the release tag instead, for the sake of demonstration:</p> <pre data-language="ruby">livecheck do
  url :stable
  regex(/^example[._-]v?(\d+(?:\.\d+)+)$/i)
  strategy :github_releases do |json, regex|
    json.map do |release|
      next if release["draft"] || release["prerelease"]

      match = release["tag_name"]&amp;.match(regex)
      next if match.blank?

      match[1]
    end
  end
end</pre> <p>The strategy’s default logic skips releases marked as draft or pre-release but this can be modified by using a <code class="language-plaintext highlighter-rouge">strategy</code> block. Removing the <code class="language-plaintext highlighter-rouge">release["prerelease"]</code> condition from the previous example would allow us to work with pre-release releases, though the regex may also need to be adapted to handle unstable version formats.</p> <p>You can find more information on the response JSON from this API endpoint in the related <a href="https://docs.github.com/en/rest/releases/releases?apiVersion=latest#list-releases">GitHub REST API documentation</a>.</p> <h4 id="crate-strategy-block">
<code class="language-plaintext highlighter-rouge">Crate</code> <code class="language-plaintext highlighter-rouge">strategy</code> block</h4> <p>A <code class="language-plaintext highlighter-rouge">strategy</code> block for <code class="language-plaintext highlighter-rouge">Crate</code> receives parsed JSON data from the registry API’s <code class="language-plaintext highlighter-rouge">versions</code> endpoint and either the provided or default strategy regex. The strategy uses the following logic by default, so this <code class="language-plaintext highlighter-rouge">strategy</code> block may be a good starting point for a modified approach:</p> <pre data-language="ruby">livecheck do
  url :stable
  strategy :crate do |json, regex|
    json["versions"]&amp;.map do |version|
      next if version["yanked"]
      next unless (match = version["num"]&amp;.match(regex))

      match[1]
    end
  end
end</pre> <h4 id="electronbuilder-strategy-block">
<code class="language-plaintext highlighter-rouge">ElectronBuilder</code> <code class="language-plaintext highlighter-rouge">strategy</code> block</h4> <p>A <code class="language-plaintext highlighter-rouge">strategy</code> block for <code class="language-plaintext highlighter-rouge">ElectronBuilder</code> fetches content at a URL and parses it as an electron-builder appcast in YAML format. It’s used for casks of macOS applications built using the Electron framework.</p> <pre data-language="ruby">livecheck do
  url "https://example.org/my-app/latest-mac.yml"
  strategy :electron_builder
end</pre> <p>If you need to modify the version, you can access the YAML hash in the <code class="language-plaintext highlighter-rouge">strategy</code> block like so:</p> <pre data-language="ruby">livecheck do
  url "https://example.org/my-app/latest-mac.yml"
  strategy :electron_builder do |yaml|
    yaml["version"]&amp;.gsub(/\D/, "")
  end
end</pre> <p>Similarly, you can work with the <code class="language-plaintext highlighter-rouge">files</code> array like this:</p> <pre data-language="ruby">livecheck do
  url "https://example.org/my-app/latest-mac.yml"
  regex(/MyApp[._-]v?(\d+(?:\.\d+)+)-(\h+)\.dmg/i)
  strategy :electron_builder do |yaml, regex|
    yaml["files"]&amp;.map do |file|
      match = file["url"]&amp;.match(regex)
      next if match.blank?

      "#{match[1]},#{match[2]}"
    end
  end
end</pre> <h4 id="json-strategy-block">
<code class="language-plaintext highlighter-rouge">Json</code> <code class="language-plaintext highlighter-rouge">strategy</code> block</h4> <p>A <code class="language-plaintext highlighter-rouge">strategy</code> block for <code class="language-plaintext highlighter-rouge">Json</code> receives parsed JSON data and, if provided, a regex. For example, if we have an object containing an array of objects with a <code class="language-plaintext highlighter-rouge">version</code> string, we can select only the members that match the regex and isolate the relevant version text as follows:</p> <pre data-language="ruby">livecheck do
  url "https://www.example.com/example.json"
  regex(/^v?(\d+(?:\.\d+)+)$/i)
  strategy :json do |json, regex|
    json["versions"].select { |item| item["version"]&amp;.match?(regex) }
                    .map { |item| item["version"][regex, 1] }
  end
end</pre> <h4 id="sparkle-strategy-block">
<code class="language-plaintext highlighter-rouge">Sparkle</code> <code class="language-plaintext highlighter-rouge">strategy</code> block</h4> <p>A <code class="language-plaintext highlighter-rouge">strategy</code> block for <code class="language-plaintext highlighter-rouge">Sparkle</code> receives an <code class="language-plaintext highlighter-rouge">item</code> which has methods for the <code class="language-plaintext highlighter-rouge">version</code>, <code class="language-plaintext highlighter-rouge">short_version</code>, <code class="language-plaintext highlighter-rouge">nice_version</code>, <code class="language-plaintext highlighter-rouge">url</code>, <code class="language-plaintext highlighter-rouge">channel</code> and <code class="language-plaintext highlighter-rouge">title</code>. It expects a URL for an XML feed providing release information to a macOS application that self-updates using the Sparkle framework. This URL can be found within the app bundle as the <code class="language-plaintext highlighter-rouge">SUFeedURL</code> property in <code class="language-plaintext highlighter-rouge">Contents/Info.plist</code> or by using the <a href="https://github.com/Homebrew/homebrew-cask/blob/HEAD/cmd/find-appcast.rb"><code class="language-plaintext highlighter-rouge">find-appcast</code></a> command. Run it with:</p> <pre data-language="bash">brew find-appcast '/path/to/application.app'</pre> <p>The default pattern for the <code class="language-plaintext highlighter-rouge">Sparkle</code> strategy is to generate <code class="language-plaintext highlighter-rouge">"#{item.short_version},#{item.version}"</code> from <code class="language-plaintext highlighter-rouge">sparkle:shortVersionString</code> and <code class="language-plaintext highlighter-rouge">sparkle:version</code> if both are set. In the example below, the returned value also includes a needed download ID from the <code class="language-plaintext highlighter-rouge">url</code>:</p> <pre data-language="ruby">livecheck do
  url "https://www.example.com/example.xml"
  strategy :sparkle do |item|
    "#{item.short_version},#{item.version}:#{item.url[%r{/(\d+)/[^/]+\.zip}i, 1]}"
  end
end</pre> <p>To use only one, specify <code class="language-plaintext highlighter-rouge">&amp;:version</code>, <code class="language-plaintext highlighter-rouge">&amp;:short_version</code> or <code class="language-plaintext highlighter-rouge">&amp;:nice_version</code>:</p> <pre data-language="ruby">livecheck do
  url "https://www.example.com/example.xml"
  strategy :sparkle, &amp;:short_version
end</pre> <p>If the value returned by <code class="language-plaintext highlighter-rouge">item</code> is not the most recent or not what’s desired, passing <code class="language-plaintext highlighter-rouge">items</code> instead will allow iterating over all the items in the feed:</p> <pre data-language="ruby">livecheck do
  url "https://www.example.com/example.xml"
  strategy :sparkle do |items|
    items.find { |item| item.channel.nil? }&amp;.short_version
  end
end</pre> <h4 id="xml-strategy-block">
<code class="language-plaintext highlighter-rouge">Xml</code> <code class="language-plaintext highlighter-rouge">strategy</code> block</h4> <p>A <code class="language-plaintext highlighter-rouge">strategy</code> block for <code class="language-plaintext highlighter-rouge">Xml</code> receives an <code class="language-plaintext highlighter-rouge">REXML::Document</code> object and, if provided, a regex. For example, if the XML contains a <code class="language-plaintext highlighter-rouge">versions</code> element with nested <code class="language-plaintext highlighter-rouge">version</code> elements and their inner text contains the version string, we could extract it using a regex as follows:</p> <pre data-language="ruby">livecheck do
  url "https://www.example.com/example.xml"
  regex(/v?(\d+(?:\.\d+)+)/i)
  strategy :xml do |xml, regex|
    xml.get_elements("versions//version").map { |item| item.text[regex, 1] }
  end
end</pre> <p>For more information on how to work with an <code class="language-plaintext highlighter-rouge">REXML::Document</code> object, please refer to the <a href="https://ruby.github.io/rexml/REXML/Document.html"><code class="language-plaintext highlighter-rouge">REXML::Document</code></a> and <a href="https://ruby.github.io/rexml/REXML/Element.html"><code class="language-plaintext highlighter-rouge">REXML::Element</code></a> documentation.</p> <h4 id="yaml-strategy-block">
<code class="language-plaintext highlighter-rouge">Yaml</code> <code class="language-plaintext highlighter-rouge">strategy</code> block</h4> <p>A <code class="language-plaintext highlighter-rouge">strategy</code> block for <code class="language-plaintext highlighter-rouge">Yaml</code> receives parsed YAML data and, if provided, a regex. Borrowing the <code class="language-plaintext highlighter-rouge">Json</code> example, if we have an object containing an array of objects with a <code class="language-plaintext highlighter-rouge">version</code> string, we can select only the members that match the regex and isolate the relevant version text as follows:</p> <pre data-language="ruby">livecheck do
  url "https://www.example.com/example.yaml"
  regex(/^v?(\d+(?:\.\d+)+)$/i)
  strategy :yaml do |yaml, regex|
    yaml["versions"].select { |item| item["version"]&amp;.match?(regex) }
                    .map { |item| item["version"][regex, 1] }
  end
end</pre> <h4 id="extractplist-strategy-block">
<code class="language-plaintext highlighter-rouge">ExtractPlist</code> <code class="language-plaintext highlighter-rouge">strategy</code> block</h4> <p>If no means are available online for checking which version of a macOS package is current, as a last resort the <code class="language-plaintext highlighter-rouge">:extract_plist</code> strategy will have <code class="language-plaintext highlighter-rouge">brew livecheck</code> download the artifact and retrieve its version string from contained <code class="language-plaintext highlighter-rouge">.plist</code> files.</p> <pre data-language="ruby">livecheck do
  url :url
  strategy :extract_plist
end</pre> <p>A <code class="language-plaintext highlighter-rouge">strategy</code> block for <code class="language-plaintext highlighter-rouge">ExtractPlist</code> receives a hash containing keys for each found bundle identifier and <code class="language-plaintext highlighter-rouge">item</code>s with methods for each <code class="language-plaintext highlighter-rouge">version</code> and <code class="language-plaintext highlighter-rouge">short_version</code>.</p> <pre data-language="ruby">livecheck do
  url :url
  strategy :extract_plist do |items|
    items["com.example.MyApp"].short_version
  end
end</pre> <p>Note that if a package uses this livecheck strategy it will be excluded from <a href="autobump">autobumping</a> as this strategy has negative impact on CI time.</p> <h3 id="throttle"><code class="language-plaintext highlighter-rouge">throttle</code></h3> <p>For software with extremely frequent releases that don’t all need to be published as formula/cask updates, livecheck can be set to reduce how many versions it surfaces by using <code class="language-plaintext highlighter-rouge">throttle</code>. In this example, only versions whose last component is divisible by 10 will be returned.</p> <pre data-language="ruby">livecheck do
  url :stable
  regex(/^v?(\d+(?:\.\d+)+)$/i)
  throttle 10
end</pre> <h3 id="skip"><code class="language-plaintext highlighter-rouge">skip</code></h3> <p>Livecheck automatically skips some formulae/casks for a number of reasons (deprecated, disabled, etc.). However, on rare occasions we need to use a <code class="language-plaintext highlighter-rouge">livecheck</code> block to do a manual skip. The <code class="language-plaintext highlighter-rouge">skip</code> method takes a string containing a very brief reason for skipping.</p> <pre data-language="ruby">livecheck do
  skip "No version information available"
end</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2009&ndash;present Homebrew contributors<br>Licensed under the BSD 2-Clause License.<br>
    <a href="https://docs.brew.sh/Brew-Livecheck" class="_attribution-link">https://docs.brew.sh/Brew-Livecheck</a>
  </p>
</div>
