<header><h1>Service Workers</h1></header><h2 id="introduction">Introduction<a href="#introduction" aria-label="Direct link to Introduction" title="Direct link to Introduction">​</a>
</h2> <blockquote>
<div>
<span><svg viewbox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>warning</div>
<div><p>Service workers are only supported on Chromium-based browsers.</p></div>
</blockquote> <blockquote>
<div>
<span><svg viewbox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</div>
<div><p>If you're looking to do general network mocking, routing, and interception, please see the <a href="network">Network Guide</a> first. Playwright provides built-in APIs for this use case that don't require the information below. However, if you're interested in requests made by Service Workers themselves, please read below.</p></div>
</blockquote> <p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener noreferrer">Service Workers</a> provide a browser-native method of handling requests made by a page with the native <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="noopener noreferrer">Fetch API (<code>fetch</code>)</a> along with other network-requested assets (like scripts, css, and images).</p> <p>They can act as a <strong>network proxy</strong> between the page and the external network to perform caching logic or can provide users with an offline experience if the Service Worker adds a <a href="https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent#examples" target="_blank" rel="noopener noreferrer">FetchEvent</a> listener.</p> <p>Many sites that use Service Workers simply use them as a transparent optimization technique. While users might notice a faster experience, the app's implementation is unaware of their existence. Running the app with or without Service Workers enabled appears functionally equivalent.</p> <h2 id="how-to-disable-service-workers">How to Disable Service Workers<a href="#how-to-disable-service-workers" aria-label="Direct link to How to Disable Service Workers" title="Direct link to How to Disable Service Workers">​</a>
</h2> <p>Playwright allows to disable Service Workers during testing. This makes tests more predictable and performant. However, if your actual page uses a Service Worker, the behavior might be different.</p> <p>To disable service workers, set <a href="api/class-testoptions#test-options-service-workers">testOptions.serviceWorkers</a> to <code>'block'</code>.</p> <pre tabindex="0" data-language="javascript">import { defineConfig } from '@playwright/test';

export default defineConfig({
  use: {
    serviceWorkers: 'allow'
  },
});</pre> <h2 id="accessing-service-workers-and-waiting-for-activation">Accessing Service Workers and Waiting for Activation<a href="#accessing-service-workers-and-waiting-for-activation" aria-label="Direct link to Accessing Service Workers and Waiting for Activation" title="Direct link to Accessing Service Workers and Waiting for Activation">​</a>
</h2> <p>You can use <a href="api/class-browsercontext#browser-context-service-workers">browserContext.serviceWorkers()</a> to list the Service <a title="Worker" href="api/class-worker">Worker</a>s, or specifically watch for the Service <a title="Worker" href="api/class-worker">Worker</a> if you anticipate a page will trigger its <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register" target="_blank" rel="noopener noreferrer">registration</a>:</p> <pre tabindex="0" data-language="javascript">const serviceWorkerPromise = context.waitForEvent('serviceworker');
await page.goto('/example-with-a-service-worker.html');
const serviceworker = await serviceWorkerPromise;</pre> <p><a href="api/class-browsercontext#browser-context-event-service-worker">browserContext.on('serviceworker')</a> event is fired <em><strong>before</strong></em> the Service Worker has taken control over the page, so <em><strong>before</strong></em> evaluating in the worker with <a href="api/class-worker#worker-evaluate">worker.evaluate()</a> you should wait on its activation.</p> <p>There are more idiomatic methods of waiting for a Service Worker to be activated, but the following is an implementation agnostic method:</p> <pre tabindex="0" data-language="javascript">await page.evaluate(async () =&gt; {
  const registration = await window.navigator.serviceWorker.getRegistration();
  if (registration.active?.state === 'activated')
    return;
  await new Promise(resolve =&gt; {
    window.navigator.serviceWorker.addEventListener('controllerchange', resolve);
  });
});</pre> <h2 id="network-events-and-routing">Network Events and Routing<a href="#network-events-and-routing" aria-label="Direct link to Network Events and Routing" title="Direct link to Network Events and Routing">​</a>
</h2> <p>Any network request made by the <strong>Service Worker</strong> is reported through the <a title="BrowserContext" href="api/class-browsercontext">BrowserContext</a> object:</p> <ul> <li>
<a href="api/class-browsercontext#browser-context-event-request">browserContext.on('request')</a>, <a href="api/class-browsercontext#browser-context-event-request-finished">browserContext.on('requestfinished')</a>, <a href="api/class-browsercontext#browser-context-event-response">browserContext.on('response')</a> and <a href="api/class-browsercontext#browser-context-event-request-failed">browserContext.on('requestfailed')</a> are fired</li> <li>
<a href="api/class-browsercontext#browser-context-route">browserContext.route()</a> sees the request</li> <li>
<a href="api/class-request#request-service-worker">request.serviceWorker()</a> will be set to the Service <a title="Worker" href="api/class-worker">Worker</a> instance, and <a href="api/class-request#request-frame">request.frame()</a> will <strong>throw</strong>
</li> </ul> <p>Additionally, for any network request made by the <strong>Page</strong>, method <a href="api/class-response#response-from-service-worker">response.fromServiceWorker()</a> return <code>true</code> when the request was handled a Service Worker's fetch handler.</p> <p>Consider a simple service worker that fetches every request made by the page:</p> <pre tabindex="0" data-language="javascript">self.addEventListener('fetch', event =&gt; {
  // actually make the request
  const responsePromise = fetch(event.request);
  // send it back to the page
  event.respondWith(responsePromise);
});

self.addEventListener('activate', event =&gt; {
  event.waitUntil(clients.claim());
});</pre> <p>If <code>index.html</code> registers this service worker, and then fetches <code>data.json</code>, the following Request/Response events would be emitted (along with the corresponding network lifecycle events):</p> <table>
<thead><tr>
<th>Event</th>
<th>Owner</th>
<th>URL</th>
<th>Routed</th>
<th><a href="api/class-response#response-from-service-worker">response.fromServiceWorker()</a></th>
</tr></thead>
<tbody>
<tr>
<td><a href="api/class-browsercontext#browser-context-event-request">browserContext.on('request')</a></td>
<td><a title="Frame" href="api/class-frame">Frame</a></td>
<td>index.html</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td><a href="api/class-page#page-event-request">page.on('request')</a></td>
<td><a title="Frame" href="api/class-frame">Frame</a></td>
<td>index.html</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td><a href="api/class-browsercontext#browser-context-event-request">browserContext.on('request')</a></td>
<td>Service <a title="Worker" href="api/class-worker">Worker</a>
</td>
<td>transparent-service-worker.js</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td><a href="api/class-browsercontext#browser-context-event-request">browserContext.on('request')</a></td>
<td>Service <a title="Worker" href="api/class-worker">Worker</a>
</td>
<td>data.json</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td><a href="api/class-browsercontext#browser-context-event-request">browserContext.on('request')</a></td>
<td><a title="Frame" href="api/class-frame">Frame</a></td>
<td>data.json</td>
<td></td>
<td>Yes</td>
</tr>
<tr>
<td><a href="api/class-page#page-event-request">page.on('request')</a></td>
<td><a title="Frame" href="api/class-frame">Frame</a></td>
<td>data.json</td>
<td></td>
<td>Yes</td>
</tr>
</tbody>
</table> <p>Since the example Service Worker just acts a basic transparent "proxy":</p> <ul> <li>There's 2 <a href="api/class-browsercontext#browser-context-event-request">browserContext.on('request')</a> events for <code>data.json</code>; one <a title="Frame" href="api/class-frame">Frame</a>-owned, the other Service <a title="Worker" href="api/class-worker">Worker</a>-owned.</li> <li>Only the Service <a title="Worker" href="api/class-worker">Worker</a>-owned request for the resource was routable via <a href="api/class-browsercontext#browser-context-route">browserContext.route()</a>; the <a title="Frame" href="api/class-frame">Frame</a>-owned events for <code>data.json</code> are not routeable, as they would not have even had the possibility to hit the external network since the Service Worker has a fetch handler registered.</li> </ul> <blockquote>
<div>
<span><svg viewbox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>caution</div>
<div><p>It's important to note: calling <a href="api/class-request#request-frame">request.frame()</a> or <a href="api/class-response#response-frame">response.frame()</a> will <strong>throw</strong> an exception, if called on a <a title="Request" href="api/class-request">Request</a>/<a title="Response" href="api/class-response">Response</a> that has a non-null <a href="api/class-request#request-service-worker">request.serviceWorker()</a>.</p></div>
</blockquote> <h2 id="routing-service-worker-requests-only">Routing Service Worker Requests Only<a href="#routing-service-worker-requests-only" aria-label="Direct link to Routing Service Worker Requests Only" title="Direct link to Routing Service Worker Requests Only">​</a>
</h2> <pre tabindex="0" data-language="javascript">await context.route('**', async route =&gt; {
  if (route.request().serviceWorker()) {
    // NB: calling route.request().frame() here would THROW
    await route.fulfill({
      contentType: 'text/plain',
      status: 200,
      body: 'from sw',
    });
  } else {
    await route.continue();
  }
});</pre> <h2 id="known-limitations">Known Limitations<a href="#known-limitations" aria-label="Direct link to Known Limitations" title="Direct link to Known Limitations">​</a>
</h2> <p>Requests for updated Service Worker main script code currently cannot be routed (<a href="https://github.com/microsoft/playwright/issues/14711" target="_blank" rel="noopener noreferrer">https://github.com/microsoft/playwright/issues/14711</a>).</p><div class="_attribution">
  <p class="_attribution-p">
          &copy; 2025 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://playwright.dev/docs/service-workers" class="_attribution-link">https://playwright.dev/docs/service-workers</a>
  </p>
</div>
