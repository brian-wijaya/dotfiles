<header><h1>Snapshot testing</h1></header><h2 id="overview">Overview<a href="#overview" aria-label="Direct link to Overview" title="Direct link to Overview">​</a>
</h2> <p>With Playwright's Snapshot testing you can assert the accessibility tree of a page against a predefined snapshot template.</p> <pre tabindex="0" data-language="javascript">await page.goto('https://playwright.dev/');
await expect(page.getByRole('banner')).toMatchAriaSnapshot(`
  - banner:
    - heading /Playwright enables reliable end-to-end/ [level=1]
    - link "Get started"
    - link "Star microsoft/playwright on GitHub"
    - link /[\\d]+k\\+ stargazers on GitHub/
`);</pre>  <h2 id="assertion-testing-vs-snapshot-testing">Assertion testing vs Snapshot testing<a href="#assertion-testing-vs-snapshot-testing" aria-label="Direct link to Assertion testing vs Snapshot testing" title="Direct link to Assertion testing vs Snapshot testing">​</a>
</h2> <p>Snapshot testing and assertion testing serve different purposes in test automation:</p> <h3 id="assertion-testing">Assertion testing<a href="#assertion-testing" aria-label="Direct link to Assertion testing" title="Direct link to Assertion testing">​</a>
</h3> <p>Assertion testing is a targeted approach where you assert specific values or conditions about elements or components. For instance, with Playwright, <a href="api/class-locatorassertions#locator-assertions-to-have-text">expect(locator).toHaveText()</a> verifies that an element contains the expected text, and <a href="api/class-locatorassertions#locator-assertions-to-have-value">expect(locator).toHaveValue()</a> confirms that an input field has the expected value. Assertion tests are specific and generally check the current state of an element or property against an expected, predefined state. They work well for predictable, single-value checks but are limited in scope when testing the broader structure or variations.</p> <p><strong>Advantages</strong></p> <ul> <li>
<strong>Clarity</strong>: The intent of the test is explicit and easy to understand.</li> <li>
<strong>Specificity</strong>: Tests focus on particular aspects of functionality, making them more robust against unrelated changes.</li> <li>
<strong>Debugging</strong>: Failures provide targeted feedback, pointing directly to the problematic aspect.</li> </ul> <p><strong>Disadvantages</strong></p> <ul> <li>
<strong>Verbose for complex outputs</strong>: Writing assertions for complex data structures or large outputs can be cumbersome and error-prone.</li> <li>
<strong>Maintenance overhead</strong>: As code evolves, manually updating assertions can be time-consuming.</li> </ul> <h3 id="snapshot-testing">Snapshot testing<a href="#snapshot-testing" aria-label="Direct link to Snapshot testing" title="Direct link to Snapshot testing">​</a>
</h3> <p>Snapshot testing captures a “snapshot” or representation of the entire state of an element, component, or data at a given moment, which is then saved for future comparisons. When re-running tests, the current state is compared to the snapshot, and if there are differences, the test fails. This approach is especially useful for complex or dynamic structures, where manually asserting each detail would be too time-consuming. Snapshot testing is broader and more holistic than assertion testing, allowing you to track more complex changes over time.</p> <p><strong>Advantages</strong></p> <ul> <li>
<strong>Simplifies complex outputs</strong>: For example, testing a UI component's rendered output can be tedious with traditional assertions. Snapshots capture the entire output for easy comparison.</li> <li>
<strong>Quick Feedback loop</strong>: Developers can easily spot unintended changes in the output.</li> <li>
<strong>Encourages consistency</strong>: Helps maintain consistent output as code evolves.</li> </ul> <p><strong>Disadvantages</strong></p> <ul> <li>
<strong>Over-Reliance</strong>: It can be tempting to accept changes to snapshots without fully understanding them, potentially hiding bugs.</li> <li>
<strong>Granularity</strong>: Large snapshots may be hard to interpret when differences arise, especially if minor changes affect large portions of the output.</li> <li>
<strong>Suitability</strong>: Not ideal for highly dynamic content where outputs change frequently or unpredictably.</li> </ul> <h3 id="when-to-use">When to use<a href="#when-to-use" aria-label="Direct link to When to use" title="Direct link to When to use">​</a>
</h3> <ul> <li>
<strong>Snapshot testing</strong> is ideal for: <ul> <li>UI testing of whole pages and components.</li> <li>Broad structural checks for complex UI components.</li> <li>Regression testing for outputs that rarely change structure.</li> </ul> </li> <li>
<strong>Assertion testing</strong> is ideal for: <ul> <li>Core logic validation.</li> <li>Computed value testing.</li> <li>Fine-grained tests requiring precise conditions.</li> </ul> </li> </ul> <p>By combining snapshot testing for broad, structural checks and assertion testing for specific functionality, you can achieve a well-rounded testing strategy.</p> <h2 id="aria-snapshots">Aria snapshots<a href="#aria-snapshots" aria-label="Direct link to Aria snapshots" title="Direct link to Aria snapshots">​</a>
</h2> <p>In Playwright, aria snapshots provide a YAML representation of the accessibility tree of a page. These snapshots can be stored and compared later to verify if the page structure remains consistent or meets defined expectations.</p> <p>The YAML format describes the hierarchical structure of accessible elements on the page, detailing <strong>roles</strong>, <strong>attributes</strong>, <strong>values</strong>, and <strong>text content</strong>. The structure follows a tree-like syntax, where each node represents an accessible element, and indentation indicates nested elements.</p> <p>Each accessible element in the tree is represented as a YAML node:</p> <pre tabindex="0" data-language="javascript">- role "name" [attribute=value]</pre> <ul> <li>
<strong>role</strong>: Specifies the ARIA or HTML role of the element (e.g., <code>heading</code>, <code>list</code>, <code>listitem</code>, <code>button</code>).</li> <li>
<strong>"name"</strong>: Accessible name of the element. Quoted strings indicate exact values, <code>/patterns/</code> are used for regular expression.</li> <li>
<strong>[attribute=value]</strong>: Attributes and values, in square brackets, represent specific ARIA attributes, such as <code>checked</code>, <code>disabled</code>, <code>expanded</code>, <code>level</code>, <code>pressed</code>, or <code>selected</code>.</li> </ul> <p>These values are derived from ARIA attributes or calculated based on HTML semantics. To inspect the accessibility tree structure of a page, use the <a href="https://developer.chrome.com/docs/devtools/accessibility/reference#tab" target="_blank" rel="noopener noreferrer">Chrome DevTools Accessibility Tab</a>.</p> <h2 id="snapshot-matching">Snapshot matching<a href="#snapshot-matching" aria-label="Direct link to Snapshot matching" title="Direct link to Snapshot matching">​</a>
</h2> <p>The <a href="api/class-locatorassertions#locator-assertions-to-match-aria-snapshot">expect(locator).toMatchAriaSnapshot()</a> assertion method in Playwright compares the accessible structure of the locator scope with a predefined aria snapshot template, helping validate the page's state against testing requirements.</p> <p>For the following DOM:</p> <pre tabindex="0" data-language="html">&lt;h1&gt;title&lt;/h1&gt;</pre> <p>You can match it using the following snapshot template:</p> <pre tabindex="0" data-language="javascript">await expect(page.locator('body')).toMatchAriaSnapshot(`
  - heading "title"
`);</pre> <p>When matching, the snapshot template is compared to the current accessibility tree of the page:</p> <ul> <li>If the tree structure matches the template, the test passes; otherwise, it fails, indicating a mismatch between expected and actual accessibility states.</li> <li>The comparison is case-sensitive and collapses whitespace, so indentation and line breaks are ignored.</li> <li>The comparison is order-sensitive, meaning the order of elements in the snapshot template must match the order in the page's accessibility tree.</li> </ul> <h3 id="partial-matching">Partial matching<a href="#partial-matching" aria-label="Direct link to Partial matching" title="Direct link to Partial matching">​</a>
</h3> <p>You can perform partial matches on nodes by omitting attributes or accessible names, enabling verification of specific parts of the accessibility tree without requiring exact matches. This flexibility is helpful for dynamic or irrelevant attributes.</p> <pre tabindex="0" data-language="html">&lt;button&gt;Submit&lt;/button&gt;</pre> <p><em>aria snapshot</em></p> <pre tabindex="0" data-language="javascript">- button</pre> <p>In this example, the button role is matched, but the accessible name ("Submit") is not specified, allowing the test to pass regardless of the button's label.</p>  <p>For elements with ARIA attributes like <code>checked</code> or <code>disabled</code>, omitting these attributes allows partial matching, focusing solely on role and hierarchy.</p> <pre tabindex="0" data-language="html">&lt;input type="checkbox" checked&gt;</pre> <p><em>aria snapshot for partial match</em></p> <pre tabindex="0" data-language="javascript">- checkbox</pre> <p>In this partial match, the <code>checked</code> attribute is ignored, so the test will pass regardless of the checkbox state.</p>  <p>Similarly, you can partially match children in lists or groups by omitting specific list items or nested elements.</p> <pre tabindex="0" data-language="html">&lt;ul&gt;
  &lt;li&gt;Feature A&lt;/li&gt;
  &lt;li&gt;Feature B&lt;/li&gt;
  &lt;li&gt;Feature C&lt;/li&gt;
&lt;/ul&gt;</pre> <p><em>aria snapshot for partial match</em></p> <pre tabindex="0" data-language="javascript">- list
  - listitem: Feature B</pre> <p>Partial matches let you create flexible snapshot tests that verify essential page structure without enforcing specific content or attributes.</p> <h3 id="strict-matching">Strict matching<a href="#strict-matching" aria-label="Direct link to Strict matching" title="Direct link to Strict matching">​</a>
</h3> <p>By default, a template containing the subset of children will be matched:</p> <pre tabindex="0" data-language="html">&lt;ul&gt;
  &lt;li&gt;Feature A&lt;/li&gt;
  &lt;li&gt;Feature B&lt;/li&gt;
  &lt;li&gt;Feature C&lt;/li&gt;
&lt;/ul&gt;</pre> <p><em>aria snapshot for partial match</em></p> <pre tabindex="0" data-language="javascript">- list
  - listitem: Feature B</pre> <p>The <code>/children</code> property can be used to control how child elements are matched:</p> <ul> <li>
<code>contain</code> (default): Matches if all specified children are present in order</li> <li>
<code>equal</code>: Matches if the children exactly match the specified list in order</li> <li>
<code>deep-equal</code>: Matches if the children exactly match the specified list in order, including nested children</li> </ul> <pre tabindex="0" data-language="html">&lt;ul&gt;
  &lt;li&gt;Feature A&lt;/li&gt;
  &lt;li&gt;Feature B&lt;/li&gt;
  &lt;li&gt;Feature C&lt;/li&gt;
&lt;/ul&gt;</pre> <p><em>aria snapshot will fail due to Feature C not being in the template</em></p> <pre tabindex="0" data-language="javascript">- list
  - /children: equal
  - listitem: Feature A
  - listitem: Feature B</pre> <h3 id="matching-with-regular-expressions">Matching with regular expressions<a href="#matching-with-regular-expressions" aria-label="Direct link to Matching with regular expressions" title="Direct link to Matching with regular expressions">​</a>
</h3> <p>Regular expressions allow flexible matching for elements with dynamic or variable text. Accessible names and text can support regex patterns.</p> <pre tabindex="0" data-language="html">&lt;h1&gt;Issues 12&lt;/h1&gt;</pre> <p><em>aria snapshot with regular expression</em></p> <pre tabindex="0" data-language="javascript">- heading /Issues \d+/</pre> <h2 id="generating-snapshots">Generating snapshots<a href="#generating-snapshots" aria-label="Direct link to Generating snapshots" title="Direct link to Generating snapshots">​</a>
</h2> <p>Creating aria snapshots in Playwright helps ensure and maintain your application's structure. You can generate snapshots in various ways depending on your testing setup and workflow.</p> <h3 id="generating-snapshots-with-the-playwright-code-generator">Generating snapshots with the Playwright code generator<a href="#generating-snapshots-with-the-playwright-code-generator" aria-label="Direct link to Generating snapshots with the Playwright code generator" title="Direct link to Generating snapshots with the Playwright code generator">​</a>
</h3> <p>If you're using Playwright's <a href="codegen">Code Generator</a>, generating aria snapshots is streamlined with its interactive interface:</p> <ul> <li>
<strong>"Assert snapshot" Action</strong>: In the code generator, you can use the "Assert snapshot" action to automatically create a snapshot assertion for the selected elements. This is a quick way to capture the aria snapshot as part of your recorded test flow.</li> <li>
<strong>"Aria snapshot" Tab</strong>: The "Aria snapshot" tab within the code generator interface visually represents the aria snapshot for a selected locator, letting you explore, inspect, and verify element roles, attributes, and accessible names to aid snapshot creation and review.</li> </ul> <h3 id="updating-snapshots-with-playwrighttest-and-the---update-snapshots-flag">Updating snapshots with <code>@playwright/test</code> and the <code>--update-snapshots</code> flag<a href="#updating-snapshots-with-playwrighttest-and-the---update-snapshots-flag" aria-label="Direct link to updating-snapshots-with-playwrighttest-and-the---update-snapshots-flag" title="Direct link to updating-snapshots-with-playwrighttest-and-the---update-snapshots-flag">​</a>
</h3> <p>When using the Playwright test runner (<code>@playwright/test</code>), you can automatically update snapshots with the <code>--update-snapshots</code> flag, <code>-u</code> for short.</p> <p>Running tests with the <code>--update-snapshots</code> flag will update snapshots that did not match. Matching snapshots will not be updated.</p> <pre tabindex="0" data-language="javascript">npx playwright test --update-snapshots</pre> <p>Updating snapshots is useful when application structure changes require new snapshots as a baseline. Note that Playwright will wait for the maximum expect timeout specified in the test runner configuration to ensure the page is settled before taking the snapshot. It might be necessary to adjust the <code>--timeout</code> if the test hits the timeout while generating snapshots.</p> <h4 id="empty-template-for-snapshot-generation">Empty template for snapshot generation<a href="#empty-template-for-snapshot-generation" aria-label="Direct link to Empty template for snapshot generation" title="Direct link to Empty template for snapshot generation">​</a>
</h4> <p>Passing an empty string as the template in an assertion generates a snapshot on-the-fly:</p> <pre tabindex="0" data-language="javascript">await expect(locator).toMatchAriaSnapshot('');</pre> <p>Note that Playwright will wait for the maximum expect timeout specified in the test runner configuration to ensure the page is settled before taking the snapshot. It might be necessary to adjust the <code>--timeout</code> if the test hits the timeout while generating snapshots.</p> <h4 id="snapshot-patch-files">Snapshot patch files<a href="#snapshot-patch-files" aria-label="Direct link to Snapshot patch files" title="Direct link to Snapshot patch files">​</a>
</h4> <p>When updating snapshots, Playwright creates patch files that capture differences. These patch files can be reviewed, applied, and committed to source control, allowing teams to track structural changes over time and ensure updates are consistent with application requirements.</p> <p>The way source code is updated can be changed using the <code>--update-source-method</code> flag. There are several options available:</p> <ul> <li>
<strong>"patch"</strong> (default): Generates a unified diff file that can be applied to the source code using <code>git apply</code>.</li> <li>
<strong>"3way"</strong>: Generates merge conflict markers in your source code, allowing you to choose whether to accept changes.</li> <li>
<strong>"overwrite"</strong>: Overwrites the source code with the new snapshot values.</li> </ul> <pre tabindex="0" data-language="javascript">npx playwright test --update-snapshots --update-source-method=3way</pre> <h4 id="snapshots-as-separate-files">Snapshots as separate files<a href="#snapshots-as-separate-files" aria-label="Direct link to Snapshots as separate files" title="Direct link to Snapshots as separate files">​</a>
</h4> <p>To store your snapshots in a separate file, use the <code>toMatchAriaSnapshot</code> method with the <code>name</code> option, specifying a <code>.aria.yml</code> file extension.</p> <pre tabindex="0" data-language="javascript">await expect(page.getByRole('main')).toMatchAriaSnapshot({ name: 'main.aria.yml' });</pre> <p>By default, snapshots from a test file <code>example.spec.ts</code> are placed in the <code>example.spec.ts-snapshots</code> directory. As snapshots should be the same across browsers, only one snapshot is saved even if testing with multiple browsers. Should you wish, you can customize the <a href="api/class-testconfig#test-config-snapshot-path-template">snapshot path template</a> using the following configuration:</p> <pre tabindex="0" data-language="javascript">export default defineConfig({
  expect: {
    toMatchAriaSnapshot: {
      pathTemplate: '__snapshots__/{testFilePath}/{arg}{ext}',
    },
  },
});</pre> <h3 id="using-the-locatorariasnapshot-method">Using the <code>Locator.ariaSnapshot</code> method<a href="#using-the-locatorariasnapshot-method" aria-label="Direct link to using-the-locatorariasnapshot-method" title="Direct link to using-the-locatorariasnapshot-method">​</a>
</h3> <p>The <a href="api/class-locator#locator-aria-snapshot">locator.ariaSnapshot()</a> method allows you to programmatically create a YAML representation of accessible elements within a locator's scope, especially helpful for generating snapshots dynamically during test execution.</p> <p><strong>Example</strong>:</p> <pre tabindex="0" data-language="javascript">const snapshot = await page.locator('body').ariaSnapshot();
console.log(snapshot);</pre> <p>This command outputs the aria snapshot within the specified locator's scope in YAML format, which you can validate or store as needed.</p> <h2 id="accessibility-tree-examples">Accessibility tree examples<a href="#accessibility-tree-examples" aria-label="Direct link to Accessibility tree examples" title="Direct link to Accessibility tree examples">​</a>
</h2> <h3 id="headings-with-level-attributes">Headings with level attributes<a href="#headings-with-level-attributes" aria-label="Direct link to Headings with level attributes" title="Direct link to Headings with level attributes">​</a>
</h3> <p>Headings can include a <code>level</code> attribute indicating their heading level.</p> <pre tabindex="0" data-language="html">&lt;h1&gt;Title&lt;/h1&gt;
&lt;h2&gt;Subtitle&lt;/h2&gt;</pre> <p><em>aria snapshot</em></p> <pre tabindex="0" data-language="javascript">- heading "Title" [level=1]
- heading "Subtitle" [level=2]</pre> <h3 id="text-nodes">Text nodes<a href="#text-nodes" aria-label="Direct link to Text nodes" title="Direct link to Text nodes">​</a>
</h3> <p>Standalone or descriptive text elements appear as text nodes.</p> <pre tabindex="0" data-language="html">&lt;div&gt;Sample accessible name&lt;/div&gt;</pre> <p><em>aria snapshot</em></p> <pre tabindex="0" data-language="javascript">- text: Sample accessible name</pre> <h3 id="inline-multiline-text">Inline multiline text<a href="#inline-multiline-text" aria-label="Direct link to Inline multiline text" title="Direct link to Inline multiline text">​</a>
</h3> <p>Multiline text, such as paragraphs, is normalized in the aria snapshot.</p> <pre tabindex="0" data-language="html">&lt;p&gt;Line 1&lt;br&gt;Line 2&lt;/p&gt;</pre> <p><em>aria snapshot</em></p> <pre tabindex="0" data-language="javascript">- paragraph: Line 1 Line 2</pre> <h3 id="links">Links<a href="#links" aria-label="Direct link to Links" title="Direct link to Links">​</a>
</h3> <p>Links display their text or composed content from pseudo-elements.</p> <pre tabindex="0" data-language="html">&lt;a href="#more-info"&gt;Read more about Accessibility&lt;/a&gt;</pre> <p><em>aria snapshot</em></p> <pre tabindex="0" data-language="javascript">- link "Read more about Accessibility"</pre> <h3 id="text-boxes">Text boxes<a href="#text-boxes" aria-label="Direct link to Text boxes" title="Direct link to Text boxes">​</a>
</h3> <p>Input elements of type <code>text</code> show their <code>value</code> attribute content.</p> <pre tabindex="0" data-language="html">&lt;input type="text" value="Enter your name"&gt;</pre> <p><em>aria snapshot</em></p> <pre tabindex="0" data-language="javascript">- textbox: Enter your name</pre> <h3 id="lists-with-items">Lists with items<a href="#lists-with-items" aria-label="Direct link to Lists with items" title="Direct link to Lists with items">​</a>
</h3> <p>Ordered and unordered lists include their list items.</p> <pre tabindex="0" data-language="html">&lt;ul aria-label="Main Features"&gt;
  &lt;li&gt;Feature 1&lt;/li&gt;
  &lt;li&gt;Feature 2&lt;/li&gt;
&lt;/ul&gt;</pre> <p><em>aria snapshot</em></p> <pre tabindex="0" data-language="javascript">- list "Main Features":
  - listitem: Feature 1
  - listitem: Feature 2</pre> <h3 id="grouped-elements">Grouped elements<a href="#grouped-elements" aria-label="Direct link to Grouped elements" title="Direct link to Grouped elements">​</a>
</h3> <p>Groups capture nested elements, such as <code>&lt;details&gt;</code> elements with summary content.</p> <pre tabindex="0" data-language="html">&lt;details&gt;
  &lt;summary&gt;Summary&lt;/summary&gt;
  &lt;p&gt;Detail content here&lt;/p&gt;
&lt;/details&gt;</pre> <p><em>aria snapshot</em></p> <pre tabindex="0" data-language="javascript">- group: Summary</pre> <h3 id="attributes-and-states">Attributes and states<a href="#attributes-and-states" aria-label="Direct link to Attributes and states" title="Direct link to Attributes and states">​</a>
</h3> <p>Commonly used ARIA attributes, like <code>checked</code>, <code>disabled</code>, <code>expanded</code>, <code>level</code>, <code>pressed</code>, and <code>selected</code>, represent control states.</p> <h4 id="checkbox-with-checked-attribute">Checkbox with <code>checked</code> attribute<a href="#checkbox-with-checked-attribute" aria-label="Direct link to checkbox-with-checked-attribute" title="Direct link to checkbox-with-checked-attribute">​</a>
</h4> <pre tabindex="0" data-language="html">&lt;input type="checkbox" checked&gt;</pre> <p><em>aria snapshot</em></p> <pre tabindex="0" data-language="javascript">- checkbox [checked]</pre> <h4 id="button-with-pressed-attribute">Button with <code>pressed</code> attribute<a href="#button-with-pressed-attribute" aria-label="Direct link to button-with-pressed-attribute" title="Direct link to button-with-pressed-attribute">​</a>
</h4> <pre tabindex="0" data-language="html">&lt;button aria-pressed="true"&gt;Toggle&lt;/button&gt;</pre> <p><em>aria snapshot</em></p> <pre tabindex="0" data-language="javascript">- button "Toggle" [pressed=true]</pre><div class="_attribution">
  <p class="_attribution-p">
          &copy; 2025 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://playwright.dev/docs/aria-snapshots" class="_attribution-link">https://playwright.dev/docs/aria-snapshots</a>
  </p>
</div>
