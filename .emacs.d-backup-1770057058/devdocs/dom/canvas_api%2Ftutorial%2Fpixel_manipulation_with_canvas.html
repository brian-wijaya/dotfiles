<h1>Pixel manipulation with canvas</h1>     <ul class="prev-next">
<li class="prev"><a class="button secondary" href="advanced_animations"><span class="button-wrap"> Previous </span></a></li>
<li class="next"><a class="button secondary" href="optimizing_canvas"><span class="button-wrap"> Next </span></a></li>
</ul> <p>Until now we haven't looked at the actual pixels of our canvas. With the <code>ImageData</code> object you can directly read and write a data array to manipulate pixel data. We will also look into how image smoothing (anti-aliasing) can be controlled and how to save images from your canvas.</p>     <mdn-survey></mdn-survey>  <h2 id="the_imagedata_object" class="heading">The ImageData object</h2> <p>The <a href="../../imagedata"><code>ImageData</code></a> object represents the underlying pixel data of an area of a canvas object. Its <code>data</code> property returns a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray"><code>Uint8ClampedArray</code></a> (or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float16Array"><code>Float16Array</code></a> if requested) which can be accessed to look at the raw pixel data; each pixel is represented by four one-byte values (red, green, blue, and alpha, in that order; that is, "RGBA" format). Each color component is represented by an integer between 0 and 255. Each component is assigned a consecutive index within the array, with the top left pixel's red component being at index 0 within the array. Pixels then proceed from left to right, then downward, throughout the array.</p> <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray"><code>Uint8ClampedArray</code></a> contains <code>height</code> × <code>width</code> × 4 bytes of data, with index values ranging from 0 to (<code>height</code> × <code>width</code> × 4) - 1.</p> <p>For example, to read the blue component's value from the pixel at column 200, row 50 in the image, you would do the following:</p> <div class="code-example"><pre data-language="js">const blueComponent = imageData.data[50 * (imageData.width * 4) + 200 * 4 + 2];
</pre></div> <p>If given a set of coordinates (X and Y), you may end up doing something like this:</p> <div class="code-example"><pre data-language="js">const xCoord = 50;
const yCoord = 100;
const canvasWidth = 1024;

const getColorIndicesForCoord = (x, y, width) =&gt; {
  const red = y * (width * 4) + x * 4;
  return [red, red + 1, red + 2, red + 3];
};

const colorIndices = getColorIndicesForCoord(xCoord, yCoord, canvasWidth);

const [redIndex, greenIndex, blueIndex, alphaIndex] = colorIndices;
</pre></div> <p>You may also access the size of the pixel array in bytes by reading the <code>Uint8ClampedArray.length</code> attribute:</p> <div class="code-example"><pre data-language="js">const numBytes = imageData.data.length;
</pre></div>  <h2 id="creating_an_imagedata_object" class="heading">Creating an ImageData object</h2> <p>To create a new, blank <code>ImageData</code> object, you should use the <a href="../../canvasrenderingcontext2d/createimagedata"><code>createImageData()</code></a> method. There are two versions of the <code>createImageData()</code> method:</p> <div class="code-example"><pre data-language="js">const myImageData = ctx.createImageData(width, height);
</pre></div> <p>This creates a new <code>ImageData</code> object with the specified dimensions. All pixels are preset to transparent.</p> <p>You can also create a new <code>ImageData</code> object with the same dimensions as the object specified by <code>anotherImageData</code>. The new object's pixels are all preset to transparent black. <strong>This does not copy the image data!</strong></p> <div class="code-example"><pre data-language="js">const myImageData = ctx.createImageData(anotherImageData);
</pre></div>  <h2 id="getting_the_pixel_data_for_a_context" class="heading">Getting the pixel data for a context</h2> <p>To obtain an <code>ImageData</code> object containing a copy of the pixel data for a canvas context, you can use the <code>getImageData()</code> method:</p> <div class="code-example"><pre data-language="js">const myImageData = ctx.getImageData(left, top, width, height);
</pre></div> <p>This method returns an <code>ImageData</code> object representing the pixel data for the area of the canvas whose corners are represented by the points (<code>left</code>, <code>top</code>), (<code>left+width</code>, <code>top</code>), (<code>left</code>, <code>top+height</code>), and (<code>left+width</code>, <code>top+height</code>). The coordinates are specified in canvas coordinate space units.</p> <div class="notecard note"> <p><strong>Note:</strong> Any pixels outside the canvas are returned as transparent black in the resulting <code>ImageData</code> object.</p> </div> <p>This method is also demonstrated in the article <a href="../manipulating_video_using_canvas">Manipulating video using canvas</a>.</p>  <h2 id="creating_a_color_picker" class="heading">Creating a color picker</h2> <p>In this example, we are using the <a href="../../canvasrenderingcontext2d/getimagedata"><code>getImageData()</code></a> method to display the color under the mouse cursor. For this, we need the current position of the mouse, then we look up the pixel data at that position in the pixel array that <a href="../../canvasrenderingcontext2d/getimagedata"><code>getImageData()</code></a> provides. Finally, we use the array data to set a background color and a text in the <code>&lt;div&gt;</code> to display the color. Clicking on the image will do the same operation but uses the selected color.</p> <div class="code-example"><pre data-language="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Source&lt;/th&gt;
      &lt;th&gt;Hovered color&lt;/th&gt;
      &lt;th&gt;Selected color&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;
        &lt;canvas id="canvas" width="300" height="227"&gt;&lt;/canvas&gt;
      &lt;/td&gt;
      &lt;td class="color-cell" id="hovered-color"&gt;&lt;/td&gt;
      &lt;td class="color-cell" id="selected-color"&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</pre></div> <div class="code-example"><pre data-language="js">const img = new Image();
img.crossOrigin = "anonymous";
img.src = "/shared-assets/images/examples/rhino.jpg";
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
img.addEventListener("load", () =&gt; {
  ctx.drawImage(img, 0, 0);
  img.style.display = "none";
});
const hoveredColor = document.getElementById("hovered-color");
const selectedColor = document.getElementById("selected-color");

const pick = (event, destination) =&gt; {
  const bounding = canvas.getBoundingClientRect();
  const x = event.clientX - bounding.left;
  const y = event.clientY - bounding.top;
  const pixel = ctx.getImageData(x, y, 1, 1);
  const data = pixel.data;

  const rgbColor = `rgb(${data[0]} ${data[1]} ${data[2]} / ${data[3] / 255})`;
  destination.style.background = rgbColor;
  destination.textContent = rgbColor;

  return rgbColor;
};

canvas.addEventListener("mousemove", (event) =&gt; pick(event, hoveredColor));
canvas.addEventListener("click", (event) =&gt; pick(event, selectedColor));
</pre></div>  <p>Hover your cursor anywhere over the image to see the result in the "Hovered color" column. Click anywhere in the image to see the result in the "Selected color" column.</p> <div class="code-example"><iframe class="sample-code-frame" title="creating a color picker sample" id="frame_creating_a_color_picker" height="300" src="about:blank" data-live-path="/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas/" data-live-id="creating_a_color_picker" sandbox="allow-same-origin allow-scripts" loading="lazy"></iframe></div>  <h2 id="painting_pixel_data_into_a_context" class="heading">Painting pixel data into a context</h2> <p>You can use the <a href="../../canvasrenderingcontext2d/putimagedata">putImageData()</a> method to paint pixel data into a context:</p> <div class="code-example"><pre data-language="js">ctx.putImageData(myImageData, dx, dy);
</pre></div> <p>The <code>dx</code> and <code>dy</code> parameters indicate the device coordinates within the context at which to paint the top left corner of the pixel data you wish to draw.</p> <p>For example, to paint the entire image represented by <code>myImageData</code> to the top left corner of the context, you can do the following:</p> <div class="code-example"><pre data-language="js">ctx.putImageData(myImageData, 0, 0);
</pre></div>  <h2 id="grayscaling_and_inverting_colors" class="heading">Grayscaling and inverting colors</h2> <p>In this example, we iterate over all pixels to change their values, then we put the modified pixel array back onto the canvas using <a href="../../canvasrenderingcontext2d/putimagedata">putImageData()</a>. The <code>invert</code> function subtracts each color from the max value, <code>255</code>. The <code>grayscale</code> function uses the average of red, green and blue. You can also use a weighted average, given by the formula <code>x = 0.299r + 0.587g + 0.114b</code>, for example. See <a href="https://en.wikipedia.org/wiki/Grayscale" target="_blank">Grayscale</a> on Wikipedia for more information.</p> <div class="code-example"><pre data-language="html">&lt;canvas id="canvas" width="300" height="227"&gt;&lt;/canvas&gt;
&lt;form&gt;
  &lt;input type="radio" id="original" name="color" value="original" checked /&gt;
  &lt;label for="original"&gt;Original&lt;/label&gt;

  &lt;input type="radio" id="grayscale" name="color" value="grayscale" /&gt;
  &lt;label for="grayscale"&gt;Grayscale&lt;/label&gt;

  &lt;input type="radio" id="inverted" name="color" value="inverted" /&gt;
  &lt;label for="inverted"&gt;Inverted&lt;/label&gt;

  &lt;input type="radio" id="sepia" name="color" value="sepia" /&gt;
  &lt;label for="sepia"&gt;Sepia&lt;/label&gt;
&lt;/form&gt;
</pre></div> <div class="code-example"><pre data-language="js">const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const img = new Image();
img.crossOrigin = "anonymous";
img.src = "/shared-assets/images/examples/rhino.jpg";
img.onload = () =&gt; {
  ctx.drawImage(img, 0, 0);
};

const original = () =&gt; {
  ctx.drawImage(img, 0, 0);
};

const invert = () =&gt; {
  ctx.drawImage(img, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;
  for (let i = 0; i &lt; data.length; i += 4) {
    data[i] = 255 - data[i]; // red
    data[i + 1] = 255 - data[i + 1]; // green
    data[i + 2] = 255 - data[i + 2]; // blue
  }
  ctx.putImageData(imageData, 0, 0);
};

const grayscale = () =&gt; {
  ctx.drawImage(img, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;
  for (let i = 0; i &lt; data.length; i += 4) {
    const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
    data[i] = avg; // red
    data[i + 1] = avg; // green
    data[i + 2] = avg; // blue
  }
  ctx.putImageData(imageData, 0, 0);
};

const sepia = () =&gt; {
  ctx.drawImage(img, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;
  for (let i = 0; i &lt; data.length; i += 4) {
    let r = data[i], // red
      g = data[i + 1], // green
      b = data[i + 2]; // blue

    data[i] = Math.min(Math.round(0.393 * r + 0.769 * g + 0.189 * b), 255);
    data[i + 1] = Math.min(Math.round(0.349 * r + 0.686 * g + 0.168 * b), 255);
    data[i + 2] = Math.min(Math.round(0.272 * r + 0.534 * g + 0.131 * b), 255);
  }
  ctx.putImageData(imageData, 0, 0);
};

const inputs = document.querySelectorAll("[name=color]");
for (const input of inputs) {
  input.addEventListener("change", (evt) =&gt; {
    switch (evt.target.value) {
      case "inverted":
        return invert();
      case "grayscale":
        return grayscale();
      case "sepia":
        return sepia();
      default:
        return original();
    }
  });
}
</pre></div> <p>Click different options to view the result in action.</p> <div class="code-example"><iframe class="sample-code-frame" title="grayscaling and inverting colors sample" id="frame_grayscaling_and_inverting_colors" height="300" src="about:blank" data-live-path="/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas/" data-live-id="grayscaling_and_inverting_colors" sandbox="allow-same-origin allow-scripts" loading="lazy"></iframe></div>  <h2 id="zooming_and_anti-aliasing" class="heading">Zooming and anti-aliasing</h2> <p>With the help of the <a href="../../canvasrenderingcontext2d/drawimage"><code>drawImage()</code></a> method, a second canvas, and the <a href="../../canvasrenderingcontext2d/imagesmoothingenabled"><code>imageSmoothingEnabled</code></a> property, we are able to zoom in on our picture and see the details. A third canvas without <a href="../../canvasrenderingcontext2d/imagesmoothingenabled"><code>imageSmoothingEnabled</code></a> is also drawn to allow a side by side comparison.</p> <div class="code-example"><pre data-language="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Source&lt;/th&gt;
      &lt;th&gt;Smoothing enabled = true&lt;/th&gt;
      &lt;th&gt;Smoothing enabled = false&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;
        &lt;canvas id="canvas" width="300" height="227"&gt;&lt;/canvas&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;canvas id="smoothed" width="200" height="200"&gt;&lt;/canvas&gt;
      &lt;/td&gt;
      &lt;td&gt;
        &lt;canvas id="pixelated" width="200" height="200"&gt;&lt;/canvas&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</pre></div>  <p>We get the position of the mouse and crop an image of 5 pixels left and above to 5 pixels right and below. Then we copy that one over to another canvas and resize the image to the size we want it to. In the zoom canvas we resize a 10×10 pixel crop of the original canvas to 200×200:</p> <div class="code-example"><pre data-language="js">const img = new Image();
img.crossOrigin = "anonymous";
img.src = "/shared-assets/images/examples/rhino.jpg";
img.onload = () =&gt; {
  draw(img);
};

const draw = (image) =&gt; {
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  ctx.drawImage(image, 0, 0);

  const smoothCtx = document.getElementById("smoothed").getContext("2d");
  smoothCtx.imageSmoothingEnabled = true;

  const pixelatedCtx = document.getElementById("pixelated").getContext("2d");
  pixelatedCtx.imageSmoothingEnabled = false;

  const zoom = (ctx, x, y) =&gt; {
    ctx.drawImage(
      canvas,
      Math.min(Math.max(0, x - 5), image.width - 10),
      Math.min(Math.max(0, y - 5), image.height - 10),
      10,
      10,
      0,
      0,
      200,
      200,
    );
  };

  canvas.addEventListener("mousemove", (event) =&gt; {
    const x = event.layerX;
    const y = event.layerY;
    zoom(smoothCtx, x, y);
    zoom(pixelatedCtx, x, y);
  });
};
</pre></div> <div class="code-example"><iframe class="sample-code-frame" title="zooming and anti-aliasing sample" id="frame_zooming_and_anti-aliasing" height="300" src="about:blank" data-live-path="/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas/" data-live-id="zooming_and_anti-aliasing" sandbox="allow-same-origin allow-scripts" loading="lazy"></iframe></div>  <h2 id="saving_images" class="heading">Saving images</h2> <p>The <a href="../../htmlcanvaselement"><code>HTMLCanvasElement</code></a> provides a <code>toDataURL()</code> method, which is useful when saving images. It returns a <a href="https://developer.mozilla.org/en-US/docs/Web/URI/Reference/Schemes/data">data URL</a> containing a representation of the image in the format specified by the <code>type</code> parameter (defaults to <a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics" target="_blank">PNG</a>). The returned image is in a resolution of 96 dpi.</p> <div class="notecard note"> <p><strong>Note:</strong> Be aware that if the canvas contains any pixels that were obtained from another <a href="https://developer.mozilla.org/en-US/docs/Glossary/Origin">origin</a> without using CORS, the canvas is <strong>tainted</strong> and its contents can no longer be read and saved. See <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/How_to/CORS_enabled_image#security_and_tainted_canvases">Security and tainted canvases</a>.</p> </div> <dl> <dt id="canvas.todataurlimagepng"><a href="../../htmlcanvaselement/todataurl"><code>canvas.toDataURL('image/png')</code></a></dt> <dd> <p>Default setting. Creates a PNG image.</p> </dd> <dt id="canvas.todataurlimagejpeg_quality"><a href="../../htmlcanvaselement/todataurl"><code>canvas.toDataURL('image/jpeg', quality)</code></a></dt> <dd> <p>Creates a JPG image. Optionally, you can provide a quality in the range from 0 to 1, with one being the best quality and with 0 almost not recognizable but small in file size.</p> </dd> </dl> <p>Once you have generated a data URL from your canvas, you are able to use it as the source of any <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/img"><code>&lt;img&gt;</code></a> or put it into a hyperlink with a <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/a#download">download attribute</a> to save it to disc, for example.</p> <p>You can also create a <a href="../../blob"><code>Blob</code></a> from the canvas.</p> <dl> <dt id="canvas.toblobcallback_type_encoderoptions"><a href="../../htmlcanvaselement/toblob"><code>canvas.toBlob(callback, type, encoderOptions)</code></a></dt> <dd> <p>Creates a <code>Blob</code> object representing the image contained in the canvas.</p> </dd> </dl>  <h2 id="see_also" class="heading">See also</h2> <ul> <li><a href="../../imagedata"><code>ImageData</code></a></li> <li><a href="../manipulating_video_using_canvas">Manipulating video using canvas</a></li> <li><a href="https://www.digitalocean.com/community/tutorials/js-canvas-toblob" target="_blank">Download Canvas API-Generated Images Using toBlob</a></li> </ul> <ul class="prev-next">
<li class="prev"><a class="button secondary" href="advanced_animations"><span class="button-wrap"> Previous </span></a></li>
<li class="next"><a class="button secondary" href="optimizing_canvas"><span class="button-wrap"> Next </span></a></li>
</ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2025 MDN contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas</a>
  </p>
</div>
