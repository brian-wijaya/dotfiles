<h1>URL Pattern API</h1> <details class="baseline-indicator not" data-glean-toggle-open="baseline_toggle_open"> <summary>  <div class="status-title"> <span class="not-bold">Limited availability</span> </div>    </summary> <div class="extra"> <p>This feature is not Baseline because it does not work in some of the most widely-used browsers.</p>  <ul> <li> <a href="https://developer.mozilla.org/en-US/docs/Glossary/Baseline/Compatibility" data-glean-id="baseline_link_learn_more" target="_blank" class="learn-more"> Learn more </a> </li> <li> <a href="#browser_compatibility" data-glean-id="baseline_link_bcd_table"> See full compatibility </a> </li> <li> <a href="https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FAPI%2FURL_Pattern_API&amp;level=not" data-glean-id="baseline_link_feedback" class="feedback-link" target="_blank" rel="noreferrer"> Report feedback </a> </li> </ul> </div> </details>    <div class="notecard note"><p><strong>Note:</strong> This feature is available in <a href="web_workers_api">Web Workers</a>.</p></div> <p>The <strong>URL Pattern API</strong> defines a syntax that is used to create URL pattern matchers. These patterns can be matched against URLs or individual URL components.</p>     <mdn-survey></mdn-survey>  <h2 id="concepts_and_usage" class="heading">Concepts and usage</h2> <p>Patterns are specified using the <a href="urlpattern"><code>URLPattern</code></a> interface. The pattern syntax is based on the syntax from the <a href="https://github.com/pillarjs/path-to-regexp" target="_blank">path-to-regexp</a> library. Patterns can contain:</p> <ul> <li>Literal strings which will be matched exactly.</li> <li>Wildcards (<code>/posts/*</code>) that match any character.</li> <li>Named groups (<code>/books/:id</code>) which extract a part of the matched URL.</li> <li>Non-capturing groups (<code>/books{/old}?</code>) which make parts of a pattern optional or be matched multiple times.</li> <li>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp"><code>RegExp</code></a> groups (<code>/books/(\\d+)</code>) which make arbitrarily complex regex matches. <em>Note that the parentheses are not part of the regex but instead define their contents as a regex.</em> Some APIs prohibit the use of regular expression groups in <code>URLPattern</code> objects. The <a href="urlpattern/hasregexpgroups"><code>hasRegExpGroups</code></a> property indicates whether or not regular expression groups are used.</li> </ul> <p>You can find details about the syntax in the <a href="#pattern_syntax">pattern syntax</a> section below.</p>  <h2 id="interfaces" class="heading">Interfaces</h2> <dl> <dt id="urlpattern"><a href="urlpattern"><code>URLPattern</code></a></dt> <dd> <p>Represents a pattern that can match URLs or parts of URLs. The pattern can contain capturing groups that extract parts of the matched URL.</p> </dd> </dl>  <h2 id="pattern_syntax" class="heading">Pattern syntax</h2> <p>The syntax for patterns is based on the <a href="https://github.com/pillarjs/path-to-regexp" target="_blank">path-to-regexp</a> JavaScript library. This syntax is similar to the one used in <a href="https://rubyonrails.org/" target="_blank">Ruby on Rails</a>, or JavaScript frameworks like <a href="https://expressjs.com/" target="_blank">Express</a> or <a href="https://nextjs.org/" target="_blank">Next.js</a>.</p>  <h3 id="fixed_text_and_capture_groups" class="heading">Fixed text and capture groups</h3> <p>Each pattern can contain a combination of fixed text and groups. The fixed text is a sequence of characters that is matched exactly. Groups match an arbitrary string based on matching rules. Each URL part has its own default rules that are explained below, but they can be overwritten.</p> <div class="code-example"><pre data-language="js">// A pattern matching some fixed text
const pattern = new URLPattern({ pathname: "/books" });
console.log(pattern.test("https://example.com/books")); // true
console.log(pattern.exec("https://example.com/books").pathname.groups); // {}
</pre></div> <div class="code-example"><pre data-language="js">// A pattern matching with a named group
const pattern = new URLPattern({ pathname: "/books/:id" });
console.log(pattern.test("https://example.com/books/123")); // true
console.log(pattern.exec("https://example.com/books/123").pathname.groups); // { id: '123' }
</pre></div>  <h3 id="segment_wildcard" class="heading">Segment wildcard</h3> <p>By default, a group matching the <code>pathname</code> part of the URL will match all characters but the forward slash (<code>/</code>). In the <code>hostname</code> part, the group will match all characters except the dot (<code>.</code>). In all other parts, the group will match all characters. The segment wildcard is non-greedy, meaning that it will match the shortest possible string.</p>  <h3 id="regex_matchers" class="heading">Regex matchers</h3> <p>Instead of using the default match rules for a group, you can specify a regex for each group by specifying it in parentheses. This regex defines the matching rules for the group. Below is an example of a regex matcher on a named group that constrains the group to only match if it contains one or more digits:</p> <div class="code-example"><pre data-language="js">const pattern1 = new URLPattern("/books/:id(\\d+)", "https://example.com");
console.log(pattern1.test("https://example.com/books/123")); // true
console.log(pattern1.test("https://example.com/books/abc")); // false
console.log(pattern1.test("https://example.com/books/")); // false
</pre></div> <p>You can also use regex when constructing a <code>URLPattern</code> with the object syntax.</p> <div class="code-example"><pre data-language="js">const pattern2 = new URLPattern({ pathname: "/books/:id(\\d+)" });
console.log(pattern2.test("https://example.com/books/123")); // true
console.log(pattern2.test("https://example.com/books/abc")); // false
console.log(pattern2.test("https://example.com/books/")); // false
</pre></div> <h4 id="pathname_matching">Pathname matching</h4> <p>The <code>pathname</code> URL-part always starts with <code>/</code>. If you omit the <code>/</code> in your regular expression the match will fail. The example below</p> <div class="code-example"><pre data-language="js">// Doesn't match, because omits the `/`
const pattern1 = new URLPattern({ pathname: "(b.*)" });
console.log(pattern1.test("https://example.com/b")); // false
console.log(pattern1.test("https://example.com/ba")); // false
</pre></div> <p>The following examples include the <code>/</code>:</p> <div class="code-example"><pre data-language="js">// Matches URL where path is exactly "/b"
const pattern2 = new URLPattern({ pathname: "(/b)" });
console.log(pattern2.test("https://example.com/b")); // true
console.log(pattern2.test("https://example.com/ba")); // false

// Matches URL where path is /b followed by any number of characters
const pattern3 = new URLPattern({ pathname: "(/b.*)" });
console.log(pattern3.test("https://example.com/b")); // true
console.log(pattern3.test("https://example.com/ba")); // true
</pre></div> <h4 id="start_and_end_of_line_anchors">Start and end of line anchors</h4> <p>The start of line anchor (<code>^</code>) and end-of line anchor (<code>$</code>) are used to anchor patterns to the start and end of the test string, respectively. While these can be specified for the start and end of an URL-part they are redundant. This is because all URL-parts are implicitly preceded by the <code>^</code> anchor, and followed by the <code>$</code> anchor.</p> <p>The following code demonstrates that it doesn't matter whether or not <code>^</code> is specified. The example uses a pattern in the <code>protocol</code> URL-part, but the other parts of the URL behave the same.</p> <div class="code-example"><pre data-language="js">// with `^` in protocol
const pattern1 = new URLPattern({ protocol: "(^https?)" });
console.log(pattern1.test("https://example.com/index.html")); // true

// without `^` in protocol
const pattern2 = new URLPattern({ protocol: "(https?)" });
console.log(pattern2.test("https://example.com/index.html")); // true
</pre></div> <p>The code below demonstrates that it doesn't matter whether or not <code>$</code> is specified.</p> <div class="code-example"><pre data-language="js">// with `$` in pathname
const pattern1 = new URLPattern({ pathname: "(/path$)" });
console.log(pattern1.test("https://example.com/path")); // true

// without `$` in pathname
const pattern2 = new URLPattern({ pathname: "(/path)" });
console.log(pattern2.test("https://example.com/path")); // true

// with `$` in hash
const pattern3 = new URLPattern({ hash: "(/hash$)" });
console.log(pattern3.test("https://example.com/#hash")); // true

// without `$` in hash
const pattern4 = new URLPattern({ hash: "(/hash)" });
console.log(pattern4.test("https://example.com/#hash")); // true
</pre></div> <h4 id="lookahead_and_lookbehind_assertions">Lookahead and lookbehind assertions</h4> <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Lookahead_assertion">Lookahead</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Lookbehind_assertion">lookbehind</a> asserts allow you to specify that text ahead or behind the current parsing position matches a particular pattern, without that match being captured, or the characters being consumed.</p> <p>There are four types of assertions:</p> <ul> <li>
<code>(?=...)</code>: A positive lookahead assertion specifies a pattern that the following characters must match.</li> <li>
<code>(?!...)</code>: A negative lookahead assertion specifies a pattern that the following characters must not match.</li> <li>
<code>(?&lt;=...)</code>: A positive lookbehind assertion specifies a pattern that the preceding characters must match.</li> <li>
<code>(?&lt;!...)</code>: A negative lookbehind assertion specifies a pattern that the preceding characters must not match.</li> </ul> <p>Be careful when using lookahead and lookbehind assertions with <code>URLPattern</code>, as there is some behavior you may find unintuitive. For example, you would expect the following lookahead assertion to match a <code>pathname</code> of <code>/ab</code>, but this is not what happens.</p> <div class="code-example"><pre data-language="js">const pattern = new URLPattern({ pathname: "(/a(?=b))" });
console.log(pattern.test("https://example.com/ab")); // false
</pre></div> <p>The <code>URLPattern</code> engine matches the test string against the <code>pathname</code> pattern, first finding the match for <code>/a</code> and then asserts that the next character in the test URL is <code>b</code> â€” but not consuming it. The engine continues matching the test URL at the unconsumed character <code>b</code>, but there is nothing left in the pattern to match it against, which causes the match to fail.</p> <p>For the match to work the pattern has to consume all the characters in the test string. To consume the <code>b</code> character you could add <code>b</code> to the end of the expression, a <code>.</code> to match any character, or <code>.*</code> to match all characters after the lookahead assertion:</p> <div class="code-example"><pre data-language="js">// positive-lookahead
const pattern1 = new URLPattern({ pathname: "(/a(?=b).*)" });
console.log(pattern1.test("https://example.com/ab")); // true
console.log(pattern1.test("https://example.com/ax")); // false
</pre></div> <p>The next example shows a negative lookahead match for <code>/a</code> which is not followed by <code>b</code>. Note that the assertion is followed by <code>.*</code> to consume the character matched by the assertion.</p> <div class="code-example"><pre data-language="js">// negative-lookahead - matches /a&lt;not b&gt;&lt;anything&gt;
const pattern2 = new URLPattern({ pathname: "(/a(?!b).*)" });
console.log(pattern2.test("https://example.com/ab")); // false
console.log(pattern2.test("https://example.com/ax")); // true
</pre></div> <p>The following example shows a positive lookbehind match that matches on a pathname like <code>/ba</code>. The pattern matches <code>/</code>, then <code>.</code> to consume the next character, followed by the assertion that the previous character was a <code>b</code>, and then an <code>a</code>.</p> <div class="code-example"><pre data-language="js">// positive-lookbehind
const pattern = new URLPattern({ pathname: "(/.(?&lt;=b)a)" });
console.log(pattern.test("https://example.com/ba")); // true
console.log(pattern.test("https://example.com/xa")); // false
</pre></div> <p>This example shows a negative lookbehind match that matches on a pathname like <code>/&lt;not b&gt;a</code>. The pattern matches <code>/</code>, then <code>.</code> to consume the next character (<code>x</code>), followed by the assertion that the previous character was not <code>b</code>, and then an <code>a</code>.</p> <div class="code-example"><pre data-language="js">// negative-lookbehind
const pattern4 = new URLPattern({ pathname: "(/.*(?&lt;!b)a)" });
console.log(pattern4.test("https://example.com/ba")); // false
console.log(pattern4.test("https://example.com/xa")); // true
</pre></div> <h4 id="other_regex_matcher_limitations">Other regex matcher limitations</h4> <p>Some other regex patterns may not work as you may expect:</p> <ul> <li> <p>Parentheses need to be escaped in range expressions within URLPattern even though they don't in RegExp.</p> <div class="code-example"><pre data-language="js">new URLPattern({ pathname: "([()])" }); // throws
new URLPattern({ pathname: "([\\(\\)])" }); // ok

new RegExp("[()]"); // ok
new RegExp("[\\(\\)]"); // ok
</pre></div> </li> </ul>  <h3 id="unnamed_and_named_groups" class="heading">Unnamed and named groups</h3> <p>Groups can either be named or unnamed. Named groups are specified by prefixing the group name with a colon (<code>:</code>). Regex groups that are not prefixed by a colon and a name are unnamed. Unnamed groups are numerically indexed in the match result based on their order in the pattern.</p> <div class="code-example"><pre data-language="js">// A named group
const pattern = new URLPattern("/books/:id(\\d+)", "https://example.com");
console.log(pattern.exec("https://example.com/books/123").pathname.groups); // { id: '123' }
</pre></div> <div class="code-example"><pre data-language="js">// An unnamed group
const pattern = new URLPattern("/books/(\\d+)", "https://example.com");
console.log(pattern.exec("https://example.com/books/123").pathname.groups); // { '0': '123' }
</pre></div>  <h3 id="group_modifiers" class="heading">Group modifiers</h3> <p>Groups can also have modifiers. These are specified after the group name (or after the regex if there is one). There are three modifiers: <code>?</code> to make the group optional, <code>+</code> to make the group repeat one or more times, and <code>*</code> to make the group repeat zero or more times.</p> <div class="code-example"><pre data-language="js">// An optional group
const pattern = new URLPattern("/books/:id?", "https://example.com");
console.log(pattern.test("https://example.com/books/123")); // true
console.log(pattern.test("https://example.com/books")); // true
console.log(pattern.test("https://example.com/books/")); // false
console.log(pattern.test("https://example.com/books/123/456")); // false
console.log(pattern.test("https://example.com/books/123/456/789")); // false
</pre></div> <div class="code-example"><pre data-language="js">// A repeating group with a minimum of one
const pattern = new URLPattern("/books/:id+", "https://example.com");
console.log(pattern.test("https://example.com/books/123")); // true
console.log(pattern.test("https://example.com/books")); // false
console.log(pattern.test("https://example.com/books/")); // false
console.log(pattern.test("https://example.com/books/123/456")); // true
console.log(pattern.test("https://example.com/books/123/456/789")); // true
</pre></div> <div class="code-example"><pre data-language="js">// A repeating group with a minimum of zero
const pattern = new URLPattern("/books/:id*", "https://example.com");
console.log(pattern.test("https://example.com/books/123")); // true
console.log(pattern.test("https://example.com/books")); // true
console.log(pattern.test("https://example.com/books/")); // false
console.log(pattern.test("https://example.com/books/123/456")); // true
console.log(pattern.test("https://example.com/books/123/456/789")); // true
</pre></div>  <h3 id="group_delimiters" class="heading">Group delimiters</h3> <p>Patterns can also contain group delimiters. These are pieces of a pattern that are surrounded by curly braces (<code>{}</code>). These group delimiters are not captured in the match result like capturing groups, but can still have modifiers applied to them, just like groups. If group delimiters are not modified by a modifier, they are treated as if the items in them were just part of the parent pattern. Group delimiters may not contain other group delimiters, but may contain any other pattern items (capturing groups, regex, wildcard, or fixed text).</p> <div class="code-example"><pre data-language="js">// A group delimiter with a ? (optional) modifier
const pattern = new URLPattern("/book{s}?", "https://example.com");
console.log(pattern.test("https://example.com/books")); // true
console.log(pattern.test("https://example.com/book")); // true
console.log(pattern.exec("https://example.com/books").pathname.groups); // {}
</pre></div> <div class="code-example"><pre data-language="js">// A group delimiter without a modifier
const pattern = new URLPattern("/book{s}", "https://example.com");
console.log(pattern.pathname); // /books
console.log(pattern.test("https://example.com/books")); // true
console.log(pattern.test("https://example.com/book")); // false
</pre></div> <div class="code-example"><pre data-language="js">// A group delimiter containing a capturing group
const pattern = new URLPattern({ pathname: "/blog/:id(\\d+){-:title}?" });
console.log(pattern.test("https://example.com/blog/123-my-blog")); // true
console.log(pattern.test("https://example.com/blog/123")); // true
console.log(pattern.test("https://example.com/blog/my-blog")); // false
</pre></div>  <h3 id="automatic_group_prefixing_in_pathnames" class="heading">Automatic group prefixing in pathnames</h3> <p>In patterns that match against the <code>pathname</code> part of a URL, groups get an automatic slash (<code>/</code>) prefix added if the group definition is preceded by a slash (<code>/</code>). This is useful for groups with modifiers, as it allows for repeating groups to work as expected.</p> <p>If you do not want automatic prefixing, you can disable it by surrounding the group with group delimiters (<code>{}</code>). Group delimiters do not have automatic prefixing behavior.</p> <div class="code-example"><pre data-language="js">// A pattern with an optional group, preceded by a slash
const pattern = new URLPattern("/books/:id?", "https://example.com");
console.log(pattern.test("https://example.com/books/123")); // true
console.log(pattern.test("https://example.com/books")); // true
console.log(pattern.test("https://example.com/books/")); // false
</pre></div> <div class="code-example"><pre data-language="js">// A pattern with a repeating group, preceded by a slash
const pattern = new URLPattern("/books/:id+", "https://example.com");
console.log(pattern.test("https://example.com/books/123")); // true
console.log(pattern.test("https://example.com/books/123/456")); // true
console.log(pattern.test("https://example.com/books/123/")); // false
console.log(pattern.test("https://example.com/books/123/456/")); // false
</pre></div> <div class="code-example"><pre data-language="js">// Segment prefixing does not occur outside of pathname patterns
const pattern = new URLPattern({ hash: "/books/:id?" });
console.log(pattern.test("https://example.com#/books/123")); // true
console.log(pattern.test("https://example.com#/books")); // false
console.log(pattern.test("https://example.com#/books/")); // true
</pre></div> <div class="code-example"><pre data-language="js">// Disabling segment prefixing for a group using a group delimiter
const pattern = new URLPattern({ pathname: "/books/{:id}?" });
console.log(pattern.test("https://example.com/books/123")); // true
console.log(pattern.test("https://example.com/books")); // false
console.log(pattern.test("https://example.com/books/")); // true
</pre></div>  <h3 id="wildcard_tokens" class="heading">Wildcard tokens</h3> <p>The wildcard token (<code>*</code>) is a shorthand for an unnamed capturing group that matches all characters zero or more times. You can place this anywhere in the pattern. The wildcard is greedy, meaning that it will match the longest possible string.</p> <div class="code-example"><pre data-language="js">// A wildcard at the end of a pattern
const pattern = new URLPattern("/books/*", "https://example.com");
console.log(pattern.test("https://example.com/books/123")); // true
console.log(pattern.test("https://example.com/books")); // false
console.log(pattern.test("https://example.com/books/")); // true
console.log(pattern.test("https://example.com/books/123/456")); // true
</pre></div> <div class="code-example"><pre data-language="js">// A wildcard in the middle of a pattern
const pattern = new URLPattern("/*.png", "https://example.com");
console.log(pattern.test("https://example.com/image.png")); // true
console.log(pattern.test("https://example.com/image.png/123")); // false
console.log(pattern.test("https://example.com/folder/image.png")); // true
console.log(pattern.test("https://example.com/.png")); // true
</pre></div>  <h3 id="trailing_slashes_in_pathname_are_not_matched_by_default" class="heading">Trailing slashes in pathname are not matched by default</h3> <p>Trailing slashes in a pathname are not automatically matched. The example below demonstrates that a <code>URLPattern</code> match for a pathname of <code>/books</code> will match <code>https://example.com/books</code> but not <code>https://example.com/books/</code> (and vice versa):</p> <div class="code-example"><pre data-language="js">const patternSlash = new URLPattern({ pathname: "/books/" });
console.log(patternSlash.test("https://example.com/books")); // false
console.log(patternSlash.test("https://example.com/books/")); // true

const patternNoSlash = new URLPattern({ pathname: "/books" });
console.log(patternNoSlash.test("https://example.com/books")); // false
console.log(patternNoSlash.test("https://example.com/books/")); // true
</pre></div> <p>If you want to match both then you need to use a match pattern that allows either. The easiest approach is to use a <a href="#group_delimiters">group delimiter</a> that contains a forward slash, followed by the optional modifier. This will match the pattern with or without a terminating forward slash.</p> <div class="code-example"><pre data-language="js">const patternOptionalSlash = new URLPattern({ pathname: "/books{/}?" });
console.log(patternOptionalSlash.test("https://example.com/books")); // true
console.log(patternOptionalSlash.test("https://example.com/books/")); // true
</pre></div>  <h3 id="pattern_normalization" class="heading">Pattern normalization</h3> <p>When a pattern is parsed it is automatically normalized to a canonical form. For example, Unicode characters are <a href="https://developer.mozilla.org/en-US/docs/Glossary/Percent-encoding">percent-encoded</a> in the pathname property, punycode encoding is used in the hostname, default port numbers are elided, paths like <code>/foo/./bar/</code> are collapsed to <code>/foo/bar</code>, etc. In addition, there are some pattern representations that parse to the same underlying meaning, like <code>foo</code> and <code>{foo}</code>. Such cases are normalized to the simplest form. In this case <code>{foo}</code> is normalized to <code>foo</code>, for example.</p>  <h2 id="inheritance_from_a_base_url" class="heading">Inheritance from a base URL</h2> <p>Both the match patterns defined in <a href="urlpattern"><code>URLPattern</code></a> and the test URLs used in <a href="urlpattern/test"><code>URLPattern.test()</code></a> and <a href="urlpattern/exec"><code>URLPattern.exec()</code></a> allow the inputs to be specified with an optional base URL (this base URL is a separate parameter when specifying the URL as a string, and a separate property when specifying the URL as an object).</p> <p>If a base URL is defined then URL-parts <em>may</em> be inherited from the base URL and used to set parts of the pattern or test URL. URL resolution is much the same as you would expect when resolving a <a href="url"><code>URL</code></a> that is specified with a base URL.</p> <p>The <code>username</code> and <code>password</code> are never inherited from the base URL.</p> <p>Only URL parts that are "more specific" than the most-specific part defined in the input will be inherited from the base URL. The following lists show the order of specificity:</p> <ul> <li>
<code>protocol</code> (most specific), <code>hostname</code>, <code>port</code>, <code>pathname</code>, <code>search</code>, <code>hash</code>
</li> <li>
<code>protocol</code>, <code>hostname</code>, <code>port</code>, <code>username</code>, <code>password</code>
</li> </ul> <p>What this means, for example, is that if the <code>protocol</code> is specified in the input URL, then nothing is more specific, so nothing will be inherited from the base URL. However if the <code>pathname</code> part is specified in the input, the <code>protocol</code>, <code>hostname</code> and <code>port</code> may be inherited from the base URL, but the <code>search</code> and <code>hash</code> will not.</p> <p>Note that URL components that are not specified in the string/input object or inherited from the base URL will default to the wildcard value (<code>"*"</code>) for a <code>URLPattern</code> and to the empty string (<code>""</code>) for a test URL.</p>  <h2 id="case_sensitivity" class="heading">Case sensitivity</h2> <p>The URL Pattern API treats many parts of the URL as case-sensitive by default when matching. In contrast, many client-side JavaScript frameworks use case-insensitive URL matching. An <code>ignoreCase</code> option is available on the <a href="urlpattern/urlpattern"><code>URLPattern()</code></a> constructor to enable case-insensitive matching if desired.</p> <div class="code-example"><pre data-language="js">// Case-sensitive matching by default
const pattern = new URLPattern("https://example.com/2022/feb/*");
console.log(pattern.test("https://example.com/2022/feb/xc44rsz")); // true
console.log(pattern.test("https://example.com/2022/Feb/xc44rsz")); // false
</pre></div> <p>Setting the <code>ignoreCase</code> option to <code>true</code> in the constructor switches all matching operations to case-insensitive for the given pattern:</p> <div class="code-example"><pre data-language="js">// Case-insensitive matching
const pattern = new URLPattern("https://example.com/2022/feb/*", {
  ignoreCase: true,
});
console.log(pattern.test("https://example.com/2022/feb/xc44rsz")); // true
console.log(pattern.test("https://example.com/2022/Feb/xc44rsz")); // true
</pre></div>  <h2 id="examples" class="heading">Examples</h2> &gt;  <h3 id="filter_on_a_specific_url_component" class="heading">Filter on a specific URL component</h3> <p>The following example shows how a <code>URLPattern</code> filters a specific URL component. When the <code>URLPattern()</code> constructor is called with a structured object of component patterns any missing components default to the <code>*</code> wildcard value.</p> <div class="code-example"><pre data-language="js">// Construct a URLPattern that matches a specific domain and its subdomains.
// All other URL components default to the wildcard `*` pattern.
const pattern = new URLPattern({
  hostname: "{*.}?example.com",
});

console.log(pattern.hostname); // '{*.}?example.com'

console.log(pattern.protocol); // '*'
console.log(pattern.port); // '*'
console.log(pattern.username); // '*'
console.log(pattern.password); // '*'
console.log(pattern.pathname); // '*'
console.log(pattern.search); // '*'
console.log(pattern.hash); // '*'

console.log(pattern.test("https://example.com/foo/bar")); // true
console.log(pattern.test({ hostname: "cdn.example.com" })); // true
console.log(pattern.test("custom-protocol://example.com/other/path?q=1")); // true

// Prints `false` because the hostname component does not match
console.log(pattern.test("https://cdn-example.com/foo/bar"));
</pre></div>  <h3 id="construct_a_urlpattern_from_a_full_url_string" class="heading">Construct a URLPattern from a full URL string</h3> <p>The following example shows how to construct a <code>URLPattern</code> from a full URL string with embedded patterns. For example, a <code>:</code> can be both the URL protocol suffix, like <code>https:</code>, and the beginning of a named pattern group, like <code>:foo</code>. It "just works" if there is no ambiguity between whether a character is part of the URL syntax or part of the pattern syntax.</p> <div class="code-example"><pre data-language="js">// Construct a URLPattern that matches URLs to CDN servers loading jpg images.
// URL components not explicitly specified result in the wild string ("*")
const pattern = new URLPattern("https://cdn-*.example.com/*.jpg");

console.log(pattern.protocol); // 'https'
console.log(pattern.hostname); // 'cdn-*.example.com'
console.log(pattern.pathname); // '/*.jpg'

console.log(pattern.username); // '*'
console.log(pattern.password); // '*'
console.log(pattern.search); // '*'
console.log(pattern.hash); // '*'

// `true`
console.log(
  pattern.test("https://cdn-1234.example.com/product/assets/hero.jpg"),
);

// `true` because the search pattern defaults to wildcard
console.log(
  pattern.test("https://cdn-1234.example.com/product/assets/hero.jpg?q=1"),
);
</pre></div>  <h3 id="constructing_a_urlpattern_with_an_ambiguous_url_string" class="heading">Constructing a URLPattern with an ambiguous URL string</h3> <p>The following example shows how a <code>URLPattern</code> constructed from an ambiguous string will favor treating characters as part of the pattern syntax. In this case the <code>:</code> character could be the protocol component suffix or it could be the prefix for a named group in the pattern. The constructor chooses to treat this as part of the pattern and therefore determines this is a relative pathname pattern. Since there is no base URL the relative pathname cannot be resolved and it throws an error.</p> <div class="code-example"><pre data-language="js">// Throws because this is interpreted as a single relative pathname pattern
// with a ":foo" named group and there is no base URL.
const pattern = new URLPattern("data:foo*");
</pre></div>  <h3 id="escaping_characters_to_disambiguate_urlpattern_constructor_strings" class="heading">Escaping characters to disambiguate URLPattern constructor strings</h3> <p>The following example shows how an ambiguous constructor string character can be escaped to be treated as a URL separator instead of a pattern character. Here <code>:</code> is escaped as <code>\\:</code>.</p> <div class="code-example"><pre data-language="js">// Constructs a URLPattern treating the `:` as the protocol suffix.
const pattern = new URLPattern("data\\:foo*");

console.log(pattern.protocol); // 'data'
console.log(pattern.pathname); // 'foo*'
console.log(pattern.username); // '*'
console.log(pattern.password); // '*'
console.log(pattern.hostname); // ''
console.log(pattern.port); // ''
console.log(pattern.search); // '*'
console.log(pattern.hash); // '*'

console.log(pattern.test("data:foobar")); // true
</pre></div>  <h3 id="using_base_urls_for_test_and_exec" class="heading">Using base URLs for test() and exec()</h3> <p>The following example shows how <code>test()</code> and <code>exec()</code> can use base URLs.</p> <div class="code-example"><pre data-language="js">const pattern = new URLPattern({ hostname: "example.com", pathname: "/foo/*" });

console.log(pattern.protocol); // '*'
console.log(pattern.pathname); // '/foo/*'
console.log(pattern.username); // '*'
console.log(pattern.password); // '*'
console.log(pattern.hostname); // 'example.com'
console.log(pattern.port); // '*'
console.log(pattern.search); // '*'
console.log(pattern.hash); // '*'

// `true` as the hostname is inherited from `baseURL` property
// (so is the protocol, but that is matched by the pattern wildcard)
console.log(
  pattern.test({
    pathname: "/foo/bar",
    baseURL: "https://example.com/baz",
  }),
);

// Prints `true` as the hostname in the second argument base URL matches.
console.log(pattern.test("/foo/bar", "https://example.com/baz"));

// Throws because the second argument cannot be passed with the object input.
try {
  pattern.test({ pathname: "/foo/bar" }, "https://example.com/baz");
} catch (e) {}

// The `exec()` method takes the same arguments as `test()`.
const result = pattern.exec("/foo/bar", "https://example.com/baz");
console.log(result.pathname.input); // '/foo/bar'
console.log(result.pathname.groups[0]); // 'bar'
console.log(result.hostname.input); // 'example.com'
</pre></div>  <h3 id="using_base_urls_in_the_urlpattern_constructor" class="heading">Using base URLs in the URLPattern constructor</h3> <p>The following example shows how base URLs can also be used to construct the <code>URLPattern</code>. The base URL is treated strictly as a URL and cannot contain any pattern syntax itself.</p> <p>The pattern only <a href="#inheritance_from_a_base_url">inherits URL parts from the base URL</a> that are less specific than those in the other properties.</p> <p>In this case the <code>pathname</code> is specified so the protocol and host can be inherited, but not the search, hash, username, or password. The properties that are not inherited default to the wildcard string (<code>"*"</code>). The exception is the port, which is set to the empty string because the <em>hostname</em> is inherited from the base URL (<a href="urlpattern/urlpattern#hostname_in_url_or_baseurl_affects_default_port">which has an implied "default port" value</a>).</p> <div class="code-example"><pre data-language="js">const pattern1 = new URLPattern({
  pathname: "/foo/*",
  baseURL: "https://example.com",
});

console.log(pattern1.protocol); // 'https'
console.log(pattern1.hostname); // 'example.com'
console.log(pattern1.pathname); // '/foo/*'
console.log(pattern1.username); // '*'
console.log(pattern1.password); // '*'
console.log(pattern1.port); // ''
console.log(pattern1.search); // '*'
console.log(pattern1.hash); // '*'

// Equivalent to pattern1
const pattern2 = new URLPattern("/foo/*", "https://example.com");

// Throws because a relative constructor string must have a base URL to resolve
// against.
try {
  const pattern3 = new URLPattern("/foo/*");
} catch (e) {}
</pre></div>  <h3 id="accessing_matched_group_values" class="heading">Accessing matched group values</h3> <p>The following example shows how input values that match pattern groups can later be accessed from the <a href="urlpattern/exec"><code>exec()</code></a> result object.</p> <p>The <code>input</code> property is the string that is matched by the pattern: in this case it's <code>cdn.example.com</code>. The <code>groups</code> property contains captured groups, indexed by number for unnamed groups, and name for named groups. In this case, there is only one unnamed group for the wildcard property, with the value <code>cdn</code>.</p> <div class="code-example"><pre data-language="js">const pattern = new URLPattern({ hostname: "*.example.com" });
const result = pattern.exec({ hostname: "cdn.example.com" });

console.log(result.hostname); // {"groups": {"0": "cdn"}, "input": "cdn.example.com"}
</pre></div>  <h3 id="accessing_matched_named_group_values" class="heading">Accessing matched named group values</h3> <p>The following example shows how groups can be given custom names which can be used to accessed the matched value in the result object.</p> <p>The match patterns in the pattern are indicated by the <code>:</code> symbol followed by a name. The same names then appear as keys in the <code>groups</code> property, with the matching values being the matched part of the test URL. The <code>input</code> property contains the whole part of the URL that matched the <code>pathname</code> pattern.</p> <div class="code-example"><pre data-language="js">// Construct a URLPattern using matching groups with custom names.

const pattern = new URLPattern({ pathname: "/:product/:user/:action" });
const result = pattern.exec({ pathname: "/store/wanderview/view" });

console.log(result.pathname);
/*
{
    "groups": {
        "product": "store",
        "user": "wanderview",
        "action": "view"
    },
    "input": "/store/wanderview/view"
}
*/

// These names can then be later used to access the matched values
// in the result object, such as "user" below.
console.log(result.pathname.groups.user); // 'wanderview'
</pre></div>  <h3 id="regular_expression_with_unnamed_group" class="heading">Regular expression with unnamed group</h3> <p>The following example shows how a matching group can use a regular expression to match either <code>/foo</code> or <code>/bar</code> in a test URL. The group is unnamed, so will be referenced by an index number in the result.</p> <div class="code-example"><pre data-language="js">const pattern = new URLPattern({ pathname: "/(foo|bar)" });

console.log(pattern.test({ pathname: "/foo" })); // true
console.log(pattern.test({ pathname: "/bar" })); // true
console.log(pattern.test({ pathname: "/baz" })); // false

const result = pattern.exec({ pathname: "/foo" });
console.log(result.pathname.groups[0]); // 'foo'
</pre></div>  <h3 id="regular_expression_with_a_named_group" class="heading">Regular expression with a named group</h3> <p>The following example shows how to use a custom regular expression with a named group.</p> <p>The group is named <code>type</code>, and matches a path which is either <code>/foo</code> or <code>/bar</code>.</p> <div class="code-example"><pre data-language="js">const pattern = new URLPattern({ pathname: "/:type(foo|bar)" });
const result = pattern.exec({ pathname: "/foo" });

console.log(result.pathname.groups.type); // 'foo'
</pre></div>  <h3 id="making_matching_groups_optional" class="heading">Making matching groups optional</h3> <p>The following example shows how to make a matching group optional by placing a <code>?</code> modifier after it.</p> <p>For the pathname component this also causes any preceding <code>/</code> character to be treated as an optional prefix to the group.</p> <div class="code-example"><pre data-language="js">const pattern = new URLPattern({ pathname: "/product/(index.html)?" });

console.log(pattern.test({ pathname: "/product/index.html" })); // true
console.log(pattern.test({ pathname: "/product" })); // true

const pattern2 = new URLPattern({ pathname: "/product/:action?" });

console.log(pattern2.test({ pathname: "/product/view" })); // true
console.log(pattern2.test({ pathname: "/product" })); // true
</pre></div> <p>Wildcards can be made optional as well. This may not seem to make sense since they already match the empty string, but it also makes the prefix <code>/</code> optional in a pathname pattern.</p> <div class="code-example"><pre data-language="js">const pattern3 = new URLPattern({ pathname: "/product/*?" });

console.log(pattern3.test({ pathname: "/product/wanderview/view" })); // true
console.log(pattern3.test({ pathname: "/product" })); // true
console.log(pattern3.test({ pathname: "/product/" })); // true
</pre></div>  <h3 id="making_matching_groups_repeated" class="heading">Making matching groups repeated</h3> <p>The following example shows how a matching group can be made repeated by placing <code>+</code> modifier after it. In the <code>pathname</code> component this also treats the <code>/</code> prefix as special, so that it effectively the start of the repeating group.</p> <div class="code-example"><pre data-language="js">const pattern = new URLPattern({ pathname: "/product/:action+" });
const result = pattern.exec({ pathname: "/product/do/some/thing/cool" });

console.log(result.pathname);
// { "groups": { "action": "do/some/thing/cool" }, "input": "/product/do/some/thing/cool" }
</pre></div> <p>Note that <code>/product</code> does not match because it is not followed by <code>/</code> and at least one character.</p> <div class="code-example"><pre data-language="js">console.log(pattern.test({ pathname: "/product" })); // false
console.log(pattern.test({ pathname: "/product/" })); // false
console.log(pattern.test({ pathname: "/product/do" })); // true
console.log(pattern.test({ pathname: "/product/do/" })); // false
</pre></div>  <h3 id="making_matching_groups_optional_and_repeated" class="heading">Making matching groups optional and repeated</h3> <p>The following example shows how to make a matching group that is both optional and repeated. Do this by placing a <code>*</code> modifier after the group. Again, the pathname component treats the <code>/</code> prefix as special.</p> <p>It both becomes optional and is also repeated with the group.</p> <div class="code-example"><pre data-language="js">const pattern = new URLPattern({ pathname: "/product/:action*" });
const result = pattern.exec({ pathname: "/product/do/some/thing/cool" });

console.log(result.pathname);
// { "groups": { "action": "do/some/thing/cool" }, "input": "/product/do/some/thing/cool" }
</pre></div> <p>Note that unlike the previous example, <code>/product</code> matches because the repeating segments, including <code>/</code> are optional. However there must be at least one character to capture after a forward slash to match the repeating group.</p> <div class="code-example"><pre data-language="js">console.log(pattern.test({ pathname: "/product" })); // true
console.log(pattern.test({ pathname: "/product/" })); // false
console.log(pattern.test({ pathname: "/product/do" })); // true
console.log(pattern.test({ pathname: "/product/do/" })); // false
</pre></div>  <h3 id="using_a_custom_prefix_or_suffix_for_an_optional_or_repeated_modifier" class="heading">Using a custom prefix or suffix for an optional or repeated modifier</h3> <p>The following example shows how curly braces (a <a href="#group_delimiters">group delimiter</a>) can be with a named group to denote a custom prefix and/or suffix to be operated on by a subsequent <code>?</code>, <code>*</code>, or <code>+</code> modifier.</p> <p>For example, <code>{:subdomain.}*</code> matches against any subdomain of <code>example.com</code> and the domain itself. The match is assigned to the named group "subdomain".</p> <div class="code-example"><pre data-language="js">const pattern = new URLPattern({ hostname: "{:subdomain.}*example.com" });
const result = pattern.exec({ hostname: "foo.bar.example.com" });

console.log(pattern.test({ hostname: "example.com" })); // true
console.log(pattern.test({ hostname: "foo.bar.example.com" })); // true
console.log(pattern.test({ hostname: ".example.com" })); // false

console.log(result.hostname);
// { "groups": { "subdomain": "foo.bar" }, "input": "foo.bar.example.com" }
</pre></div>  <h3 id="making_text_optional_or_repeated_without_a_matching_group" class="heading">Making text optional or repeated without a matching group</h3> <p>The following example shows how curly braces can be used to denote fixed text values as optional or repeated without using a matching group.</p> <p>The pattern below matches either <code>/product</code> or <code>/products/</code> but because <a href="#group_delimiters">group delimiter</a> are non-capturing by default, the result is not found in a corresponding match group.</p> <div class="code-example"><pre data-language="js">const pattern = new URLPattern({ pathname: "/product{/}?" });

console.log(pattern.test({ pathname: "/product" })); // true
console.log(pattern.test({ pathname: "/product/" })); // true

const result = pattern.exec({ pathname: "/product/" });
console.log(result.pathname.groups); // {}
</pre></div>  <h3 id="using_multiple_components_and_features_at_once" class="heading">Using multiple components and features at once</h3> <p>The following example shows how many features can be combined across multiple URL components.</p> <div class="code-example"><pre data-language="js">const pattern = new URLPattern({
  protocol: "http{s}?",
  username: ":user?",
  password: ":pass?",
  hostname: "{:subdomain.}*example.com",
  pathname: "/product/:action*",
});

const result = pattern.exec(
  "http://foo:bar@sub.example.com/product/view?q=12345",
);

console.log(result.username.groups.user); // 'foo'
console.log(result.password.groups.pass); // 'bar'
console.log(result.hostname.groups.subdomain); // 'sub'
console.log(result.pathname.groups.action); // 'view'
</pre></div>  <h2 id="specifications" class="heading">Specifications</h2> <div class="_table"><table> <thead> <tr> <th scope="col">Specification</th> </tr> </thead> <tbody> <tr> <td><a href="https://urlpattern.spec.whatwg.org/" rel="noopener" target="_blank">URL Pattern&gt;</a></td> </tr> </tbody> </table></div>  <h2 id="browser_compatibility" class="heading">Browser compatibility</h2> <div class="_table"><table>
<thead>
<tr id="bct-browser-type">
<th></th>
<th colspan="5">Desktop</th>
<th colspan="7">Mobile</th>
</tr>
<tr id="bct-browsers">
<th></th>
<th>Chrome</th>
<th>Edge</th>
<th>Firefox</th>
<th>Opera</th>
<th>Safari</th>
<th>Chrome Android</th>
<th>Firefox for Android</th>
<th>Opera Android</th>
<th>Safari on IOS</th>
<th>Samsung Internet</th>
<th>WebView Android</th>
<th>WebView on iOS</th>
</tr>
</thead>
<tbody>
<tr>
<th><code>URLPattern</code></th>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">81</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">67</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">17.0</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">26</td>
</tr>
<tr>
<th><code>URL_Pattern_API</code></th>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">81</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">67</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">17.0</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">26</td>
</tr>
<tr>
<th><code>exec</code></th>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">81</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">67</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">17.0</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">26</td>
</tr>
<tr>
<th><code>hasRegExpGroups</code></th>
<td class="bc-supports-yes">122</td>
<td class="bc-supports-yes">122</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">108</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">122</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">81</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">26.0</td>
<td class="bc-supports-yes">122</td>
<td class="bc-supports-yes">26</td>
</tr>
<tr>
<th><code>hash</code></th>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">81</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">67</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">17.0</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">26</td>
</tr>
<tr>
<th><code>hostname</code></th>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">81</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">67</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">17.0</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">26</td>
</tr>
<tr>
<th><code>password</code></th>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">81</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">67</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">17.0</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">26</td>
</tr>
<tr>
<th><code>pathname</code></th>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">81</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">67</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">17.0</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">26</td>
</tr>
<tr>
<th><code>port</code></th>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">81</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">67</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">17.0</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">26</td>
</tr>
<tr>
<th><code>protocol</code></th>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">81</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">67</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">17.0</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">26</td>
</tr>
<tr>
<th><code>search</code></th>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">81</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">67</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">17.0</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">26</td>
</tr>
<tr>
<th><code>test</code></th>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">81</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">67</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">17.0</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">26</td>
</tr>
<tr>
<th><code>username</code></th>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">81</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">142</td>
<td class="bc-supports-yes">67</td>
<td class="bc-supports-yes">26</td>
<td class="bc-supports-yes">17.0</td>
<td class="bc-supports-yes">95</td>
<td class="bc-supports-yes">26</td>
</tr>
</tbody>
</table></div>  <h2 id="see_also" class="heading">See also</h2> <ul> <li>A polyfill of <code>URLPattern</code> is available <a href="https://github.com/kenchris/urlpattern-polyfill" target="_blank">on GitHub</a>
</li> <li>The pattern syntax used by URLPattern is similar to the syntax used by <a href="https://github.com/pillarjs/path-to-regexp" target="_blank">path-to-regexp</a>
</li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2025 MDN contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL_Pattern_API" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/API/URL_Pattern_API</a>
  </p>
</div>
