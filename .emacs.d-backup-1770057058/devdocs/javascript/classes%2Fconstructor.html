<mdn-survey></mdn-survey> <h1>constructor</h1> <details class="baseline-indicator high" data-glean-toggle-open="baseline_toggle_open"> <summary>  <div class="status-title"> Baseline <span class="not-bold"> Widely available </span> </div>   </summary> <div class="extra"> <p> This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨March 2016⁩. </p> <ul> <li> <a href="https://developer.mozilla.org/en-US/docs/Glossary/Baseline/Compatibility" data-glean-id="baseline_link_learn_more" target="_blank" class="learn-more"> Learn more </a> </li> <li> <a href="#browser_compatibility" data-glean-id="baseline_link_bcd_table"> See full compatibility </a> </li> <li> <a href="https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FClasses%2Fconstructor&amp;level=high" data-glean-id="baseline_link_feedback" class="feedback-link" target="_blank" rel="noreferrer"> Report feedback </a> </li> </ul> </div> </details><section class="content-section"> <p>The <code>constructor</code> method is a special method of a <a href="../classes">class</a> for creating and initializing an object instance of that class.</p> <div class="notecard note"> <p><strong>Note:</strong> This page introduces the <code>constructor</code> syntax. For the <code>constructor</code> property present on all objects, see <a href="../global_objects/object/constructor"><code>Object.prototype.constructor</code></a>.</p> </div> </section>    <section class="content-section" aria-labelledby="try_it"> <h2 id="try_it" class="heading">Try it</h2> <interactive-example name="JavaScript Demo: Class constructor"></interactive-example> <div class="code-example"><pre data-language="js">class Polygon {
  constructor() {
    this.name = "Polygon";
  }
}

const poly = new Polygon();

console.log(poly.name);
// Expected output: "Polygon"
</pre></div> </section><section class="content-section" aria-labelledby="syntax"> <h2 id="syntax" class="heading">Syntax</h2> <div class="code-example"><pre data-language="js">constructor() { /* … */ }
constructor(argument0) { /* … */ }
constructor(argument0, argument1) { /* … */ }
constructor(argument0, argument1, /* …, */ argumentN) { /* … */ }
</pre></div> <p>There are some additional syntax restrictions:</p> <ul> <li>A class method called <code>constructor</code> cannot be a <a href="../functions/get">getter</a>, <a href="../functions/set">setter</a>, <a href="../statements/async_function">async</a>, or <a href="../statements/function*">generator</a>.</li> <li>A class cannot have more than one <code>constructor</code> method.</li> </ul> </section><section class="content-section" aria-labelledby="description"> <h2 id="description" class="heading">Description</h2> <p>A constructor enables you to provide any custom initialization that must be done before any other methods can be called on an instantiated object.</p> <div class="code-example"><pre data-language="js">class Person {
  constructor(name) {
    this.name = name;
  }

  introduce() {
    console.log(`Hello, my name is ${this.name}`);
  }
}

const otto = new Person("Otto");

otto.introduce(); // Hello, my name is Otto
</pre></div> <p>If you don't provide your own constructor, then a default constructor will be supplied for you. If your class is a base class, the default constructor is empty:</p> <div class="code-example"><pre data-language="js">constructor() {}
</pre></div> <p>If your class is a derived class, the default constructor calls the parent constructor, passing along any arguments that were provided:</p> <div class="code-example"><pre data-language="js">constructor(...args) {
  super(...args);
}
</pre></div> <div class="notecard note"> <p><strong>Note:</strong> The difference between an explicit constructor like the one above and the default constructor is that the latter doesn't actually invoke <a href="../global_objects/array/symbol.iterator">the array iterator</a> through <a href="../operators/spread_syntax">argument spreading</a>.</p> </div> <p>That enables code like this to work:</p> <div class="code-example"><pre data-language="js">class ValidationError extends Error {
  printCustomerMessage() {
    return `Validation failed :-( (details: ${this.message})`;
  }
}

try {
  throw new ValidationError("Not a valid phone number");
} catch (error) {
  if (error instanceof ValidationError) {
    console.log(error.name); // This is Error instead of ValidationError!
    console.log(error.printCustomerMessage());
  } else {
    console.log("Unknown error", error);
    throw error;
  }
}
</pre></div> <p>The <code>ValidationError</code> class doesn't need an explicit constructor, because it doesn't need to do any custom initialization. The default constructor then takes care of initializing the parent <code>Error</code> from the argument it is given.</p> <p>However, if you provide your own constructor, and your class derives from some parent class, then you must explicitly call the parent class constructor using <a href="../operators/super"><code>super()</code></a>. For example:</p> <div class="code-example"><pre data-language="js">class ValidationError extends Error {
  constructor(message) {
    super(message); // call parent class constructor
    this.name = "ValidationError";
    this.code = "42";
  }

  printCustomerMessage() {
    return `Validation failed :-( (details: ${this.message}, code: ${this.code})`;
  }
}

try {
  throw new ValidationError("Not a valid phone number");
} catch (error) {
  if (error instanceof ValidationError) {
    console.log(error.name); // Now this is ValidationError!
    console.log(error.printCustomerMessage());
  } else {
    console.log("Unknown error", error);
    throw error;
  }
}
</pre></div> <p>Using <a href="../operators/new"><code>new</code></a> on a class goes through the following steps:</p> <ol> <li>(If it's a derived class) The <code>constructor</code> body before the <code>super()</code> call is evaluated. This part should not access <code>this</code> because it's not yet initialized.</li> <li>(If it's a derived class) The <code>super()</code> call is evaluated, which initializes the parent class through the same process.</li> <li>The current class's <a href="public_class_fields">fields</a> are initialized.</li> <li>The <code>constructor</code> body after the <code>super()</code> call (or the entire body, if it's a base class) is evaluated.</li> </ol> <p>Within the <code>constructor</code> body, you can access the object being created through <a href="../operators/this"><code>this</code></a> and access the class that is called with <a href="../operators/new"><code>new</code></a> through <a href="../operators/new.target"><code>new.target</code></a>. Note that methods (including <a href="../functions/get">getters</a> and <a href="../functions/set">setters</a>) and the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain">prototype chain</a> are already initialized on <code>this</code> before the <code>constructor</code> is executed, so you can even access methods of the subclass from the constructor of the superclass. However, if those methods use <code>this</code>, the <code>this</code> will not have been fully initialized yet. This means reading public fields of the derived class will result in <code>undefined</code>, while reading private fields will result in a <code>TypeError</code>.</p> <div class="code-example"><pre data-language="js">new (class C extends class B {
  constructor() {
    console.log(this.foo());
  }
} {
  #a = 1;
  foo() {
    return this.#a; // TypeError: Cannot read private member #a from an object whose class did not declare it
    // It's not really because the class didn't declare it,
    // but because the private field isn't initialized yet
    // when the superclass constructor is running
  }
})();
</pre></div> <p>The <code>constructor</code> method may have a return value. While the base class may return anything from its constructor, the derived class must return an object or <code>undefined</code>, or a <a href="../global_objects/typeerror"><code>TypeError</code></a> will be thrown.</p> <div class="code-example"><pre data-language="js">class ParentClass {
  constructor() {
    return 1;
  }
}

console.log(new ParentClass()); // ParentClass {}
// The return value is ignored because it's not an object
// This is consistent with function constructors

class ChildClass extends ParentClass {
  constructor() {
    return 1;
  }
}

console.log(new ChildClass()); // TypeError: Derived constructors may only return object or undefined
</pre></div> <p>If the parent class constructor returns an object, that object will be used as the <code>this</code> value on which <a href="public_class_fields">class fields</a> of the derived class will be defined. This trick is called <a href="private_elements#returning_overriding_object">"return overriding"</a>, which allows a derived class's fields (including <a href="private_elements">private</a> ones) to be defined on unrelated objects.</p> <p>The <code>constructor</code> follows normal <a href="../functions/method_definitions">method</a> syntax, so <a href="../functions/default_parameters">parameter default values</a>, <a href="../functions/rest_parameters">rest parameters</a>, etc. can all be used.</p> <div class="code-example"><pre data-language="js">class Person {
  constructor(name = "Anonymous") {
    this.name = name;
  }
  introduce() {
    console.log(`Hello, my name is ${this.name}`);
  }
}

const person = new Person();
person.introduce(); // Hello, my name is Anonymous
</pre></div> <p>The constructor must be a literal name. <a href="../operators/object_initializer#computed_property_names">Computed properties</a> cannot become constructors.</p> <div class="code-example"><pre data-language="js">class Foo {
  // This is a computed property. It will not be picked up as a constructor.
  ["constructor"]() {
    console.log("called");
    this.a = 1;
  }
}

const foo = new Foo(); // No log
console.log(foo); // Foo {}
foo.constructor(); // Logs "called"
console.log(foo); // Foo { a: 1 }
</pre></div> <p>Async methods, generator methods, accessors, and class fields are forbidden from being called <code>constructor</code>. Private names cannot be called <code>#constructor</code>. Any member named <code>constructor</code> must be a plain method.</p> </section><section class="content-section" aria-labelledby="examples"> <h2 id="examples" class="heading">Examples</h2> &gt; </section><section class="content-section" aria-labelledby="using_the_constructor"> <h3 id="using_the_constructor" class="heading">Using the constructor</h3> <p>This code snippet is taken from the <a href="https://github.com/GoogleChrome/samples/blob/gh-pages/classes-es6/index.html" target="_blank">classes sample</a> (<a href="https://googlechrome.github.io/samples/classes-es6/index.html" target="_blank">live demo</a>).</p> <div class="code-example"><pre data-language="js">class Square extends Polygon {
  constructor(length) {
    // Here, it calls the parent class' constructor with lengths
    // provided for the Polygon's width and height
    super(length, length);
    // NOTE: In derived classes, `super()` must be called before you
    // can use `this`. Leaving this out will cause a ReferenceError.
    this.name = "Square";
  }

  get area() {
    return this.height * this.width;
  }

  set area(value) {
    this.height = value ** 0.5;
    this.width = value ** 0.5;
  }
}
</pre></div> </section><section class="content-section" aria-labelledby="calling_super_in_a_constructor_bound_to_a_different_prototype"> <h3 id="calling_super_in_a_constructor_bound_to_a_different_prototype" class="heading">Calling super in a constructor bound to a different prototype</h3> <p><code>super()</code> calls the constructor that's the prototype of the current class. If you change the prototype of the current class itself, <code>super()</code> will call the constructor that's the new prototype. Changing the prototype of the current class's <code>prototype</code> property doesn't affect which constructor <code>super()</code> calls.</p> <div class="code-example"><pre data-language="js">class Polygon {
  constructor() {
    this.name = "Polygon";
  }
}

class Rectangle {
  constructor() {
    this.name = "Rectangle";
  }
}

class Square extends Polygon {
  constructor() {
    super();
  }
}

// Make Square extend Rectangle (which is a base class) instead of Polygon
Object.setPrototypeOf(Square, Rectangle);

const newInstance = new Square();

// newInstance is still an instance of Polygon, because we didn't
// change the prototype of Square.prototype, so the prototype chain
// of newInstance is still
//   newInstance --&gt; Square.prototype --&gt; Polygon.prototype
console.log(newInstance instanceof Polygon); // true
console.log(newInstance instanceof Rectangle); // false

// However, because super() calls Rectangle as constructor, the name property
// of newInstance is initialized with the logic in Rectangle
console.log(newInstance.name); // Rectangle
</pre></div> </section><section class="content-section" aria-labelledby="specifications"> <h2 id="specifications" class="heading">Specifications</h2> <div class="_table"><table> <thead> <tr> <th scope="col">Specification</th> </tr> </thead> <tbody> <tr> <td><a href="https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-static-semantics-constructormethod" rel="noopener" target="_blank">ECMAScript® 2026 Language Specification&gt;<br># sec-static-semantics-constructormethod&gt;</a></td> </tr> </tbody> </table></div> </section><section class="content-section" aria-labelledby="browser_compatibility"> <h2 id="browser_compatibility" class="heading">Browser compatibility</h2> <div class="_table"><table>
<thead>
<tr id="bct-browser-type">
<th></th>
<th colspan="5">Desktop</th>
<th colspan="7">Mobile</th>
<th colspan="3">Server</th>
</tr>
<tr id="bct-browsers">
<th></th>
<th>Chrome</th>
<th>Edge</th>
<th>Firefox</th>
<th>Opera</th>
<th>Safari</th>
<th>Chrome Android</th>
<th>Firefox for Android</th>
<th>Opera Android</th>
<th>Safari on IOS</th>
<th>Samsung Internet</th>
<th>WebView Android</th>
<th>WebView on iOS</th>
<th>Bun</th>
<th>Deno</th>
<th>Node.js</th>
</tr>
</thead>
<tbody><tr>
<th><code>constructor</code></th>
<td class="bc-supports-yes">
<abbr title="Release date: 2016-03-02">49</abbr><details><summary><abbr title="Release date: 2015-04-14">42</abbr>–49</summary>Strict mode is required.</details>
</td>
<td class="bc-supports-yes"><abbr title="Release date: 2015-11-12">13</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2016-03-08">45</abbr></td>
<td class="bc-supports-yes">
<abbr title="Release date: 2016-03-15">36</abbr><details><summary><abbr title="Release date: 2015-04-28">29</abbr>–36</summary>Strict mode is required.</details>
</td>
<td class="bc-supports-yes"><abbr title="Release date: 2015-09-30">9</abbr></td>
<td class="bc-supports-yes">
<abbr title="Release date: 2016-03-09">49</abbr><details><summary><abbr title="Release date: 2015-04-15">42</abbr>–49</summary>Strict mode is required.</details>
</td>
<td class="bc-supports-yes"><abbr title="Release date: 2016-03-08">45</abbr></td>
<td class="bc-supports-yes">
<abbr title="Release date: 2016-03-31">36</abbr><details><summary><abbr title="Release date: 2015-04-28">29</abbr>–36</summary>Strict mode is required.</details>
</td>
<td class="bc-supports-yes"><abbr title="Release date: 2015-09-16">9</abbr></td>
<td class="bc-supports-yes">
<abbr title="Release date: 2016-12-15">5.0</abbr><details><summary><abbr title="Release date: 2016-03-11">4.0</abbr>–5.0</summary>Strict mode is required.</details>
</td>
<td class="bc-supports-yes">
<abbr title="Release date: 2016-03-09">49</abbr><details><summary><abbr title="Release date: 2015-04-15">42</abbr>–49</summary>Strict mode is required.</details>
</td>
<td class="bc-supports-yes"><abbr title="Release date: 2015-09-16">9</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2023-09-08">1.0.0</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-05-13">1.0</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2016-04-26">6.0.0</abbr></td>
</tr></tbody>
</table></div> </section><section class="content-section" aria-labelledby="see_also"> <h2 id="see_also" class="heading">See also</h2> <ul> <li>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_classes">Using classes</a> guide</li> <li><a href="../classes">Classes</a></li> <li><a href="static_initialization_blocks">Static initialization blocks</a></li> <li><a href="../statements/class"><code>class</code></a></li> <li><a href="../operators/super"><code>super()</code></a></li> <li><a href="../global_objects/object/constructor"><code>Object.prototype.constructor</code></a></li> </ul> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2025 MDN contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor</a>
  </p>
</div>
