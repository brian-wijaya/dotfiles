<mdn-survey></mdn-survey> <h1>Iterator.concat()</h1> <section class="content-section"> <p>The <code>Iterator.concat()</code> static method creates a new <a href="../iterator"><code>Iterator</code></a> object from a list of iterable objects. The new iterator yields the values from each of the input iterables in sequence.</p> </section>    <section class="content-section" aria-labelledby="syntax"> <h2 id="syntax" class="heading">Syntax</h2> <div class="code-example"><pre data-language="js">Iterator.concat(it)
Iterator.concat(it1, it2)
Iterator.concat(it1, it2, /* …, */ itN)
</pre></div> </section><section class="content-section" aria-labelledby="parameters"> <h3 id="parameters" class="heading">Parameters</h3> <dl> <dt id="it1"><a href="#it1"><code>it1</code>, <code>it2</code>, …, <code>itN</code></a></dt> <dd> <p>An object that implements the <a href="../../iteration_protocols#the_iterable_protocol">iterable</a> protocol. <a href="../../iteration_protocols#the_iterator_protocol">Iterators</a> which are not also iterable cannot be passed directly to this method; they must first be wrapped using <a href="from"><code>Iterator.from()</code></a>.</p> </dd> </dl> </section><section class="content-section" aria-labelledby="return_value"> <h3 id="return_value" class="heading">Return value</h3> <p>A new <a href="../iterator"><code>Iterator</code></a> object that yields the values from each of the input iterables in sequence.</p> </section><section class="content-section" aria-labelledby="description"> <h2 id="description" class="heading">Description</h2> <p>The <code>Iterator.concat()</code> method is conceptually similar to <code>Array</code>'s <a href="../array/concat"><code>concat()</code></a> method, but it operates on any kind of iterable, and returns an iterator instead of an array. This means that the iterables can be lazily iterated, avoiding unnecessary allocation or computation. It also means that, technically, you can <a href="#concatenating_infinite_iterables">concatenate <em>infinite iterables</em></a>, but results from iterables after the first infinite iterable will never be reached.</p> <p>While each iterable can be infinite, the list of iterables must be finite—and quite limited in number because engines impose a very low limit on the number of function arguments. If you need to concatenate a large—even infinite—number of iterables, use <a href="flatmap"><code>Iterator.prototype.flatMap()</code></a> instead.</p> <div class="code-example"><pre data-language="js">function* infiniteIterables() {
  for (let i = 1; ; i++) {
    yield Array(i).fill(i);
  }
}

// BAD:
// Iterator.concat(...infiniteIterables());
// The spread operator never finishes

// GOOD:
const it = infiniteIterables().flatMap((x) =&gt; x);
// Infinite sequence of numbers: 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, ...
</pre></div> <p>The <code>Iterator.concat()</code> method is similar in functionality to the following function, which uses the <a href="../../operators/yield*"><code>yield*</code></a> operator to yield values from each of the input iterables in sequence:</p> <div class="code-example"><pre data-language="js">function* concat(...iterables) {
  for (const iterable of iterables) {
    yield* iterable;
  }
}
</pre></div> <p>Like <code>yield*</code>, <code>Iterator.concat()</code> doesn't support arguments that are not iterable (i.e., doesn't have the <code>[Symbol.iterator]()</code> method). This is because <code>Iterator.concat()</code> always takes ownership over its iterators and <a href="../../iteration_protocols#returnvalue">closes</a> open iterators when the method exits. With iterable arguments, <code>Iterator.concat()</code> acquires iterators one-by-one and just closes the current iterator when the iteration is stopped. With iterator arguments, it's not clear whether the caller or <code>Iterator.concat()</code> should be responsible for closing the iterators, especially the ones that <code>Iterator.concat()</code> hasn't reached, so the method simply disallows non-iterable arguments.</p> </section><section class="content-section" aria-labelledby="examples"> <h2 id="examples" class="heading">Examples</h2> &gt; </section><section class="content-section" aria-labelledby="combining_maps"> <h3 id="combining_maps" class="heading">Combining maps</h3> <p>In this example, we create a new <a href="../map"><code>Map</code></a> that's the union of three other maps. The <a href="../map/map"><code>Map()</code></a> constructor accepts an iterable of key-value pairs, while the <a href="../map/symbol.iterator">Map iterator</a> yields key-value pairs from the map, so just using <code>Iterator.concat()</code> on the maps is sufficient to create the new map.</p> <div class="code-example"><pre data-language="js">const map1 = new Map([
  ["a", 1],
  ["b", 2],
]);
const map2 = new Map([
  ["c", 3],
  ["d", 4],
]);
const map3 = new Map([
  ["a", 5],
  ["e", 6],
]);

const map = new Map(Iterator.concat(map1, map2, map3));
console.log(map);
// Map(5) {'a' =&gt; 5, 'b' =&gt; 2, 'c' =&gt; 3, 'd' =&gt; 4, 'e' =&gt; 6}
</pre></div> <p>Note that the value of key <code>"a"</code> in the resulting map is <code>5</code>. This is because the <code>Map</code> constructor uses the last value for each key.</p> </section><section class="content-section" aria-labelledby="concatenating_infinite_iterables"> <h3 id="concatenating_infinite_iterables" class="heading">Concatenating infinite iterables</h3> <p>When any of the input iterables is infinite, the resulting iterator will also be infinite. This isn't immediately a problem because iterators can be consumed lazily and closed at any time, but it does mean that iterables after the first infinite iterable will never be reached.</p> <div class="code-example"><pre data-language="js">function* it1() {
  yield 1;
  yield 2;
}

function* it2() {
  let i = 3;
  while (true) {
    yield i++;
  }
}

function* it3() {
  yield "done";
}

const it = Iterator.concat(it1(), it2(), it3());
for (const value of it.take(10)) {
  console.log(value); // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
}
// "done" is never reached
</pre></div> </section><section class="content-section" aria-labelledby="concatenating_iterables_of_different_types"> <h3 id="concatenating_iterables_of_different_types" class="heading">Concatenating iterables of different types</h3> <p>You can concatenate iterables of different types.</p> <div class="code-example"><pre data-language="js">const array = [1, 2, 3];
const set = new Set([4, 5, 6]);
function* gen() {
  yield 7;
  yield 8;
  yield 9;
}

const it = Iterator.concat(array, set, gen());
console.log([...it]); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
</pre></div> <p>The elements of each iterable can also be of different types, just like arrays.</p> <div class="code-example"><pre data-language="js">const array = [1, "two", 3];
const set = new Set([true, {}]);

const it = Iterator.concat(array, set);
console.log([...it]); // [1, "two", 3, true, {}]
</pre></div> </section><section class="content-section" aria-labelledby="concatenating_non-iterable_objects"> <h3 id="concatenating_non-iterable_objects" class="heading">Concatenating non-iterable objects</h3> <p>Non-iterable objects throw a <code>TypeError</code> when passed to <code>Iterator.concat()</code> because they don't have the <code>[Symbol.iterator]()</code> method.</p> <div class="code-example"><pre data-language="js">const nonIterable = {
  next() {
    return { done: true };
  },
};

const it = Iterator.concat(nonIterable); // TypeError: object is not iterable
</pre></div> <p>Because all built-in iterators extend the <a href="../iterator"><code>Iterator</code></a> class, they are all iterable and can be passed to <code>Iterator.concat()</code>.</p> <div class="code-example"><pre data-language="js">const arrayIterator = [1, 2, 3][Symbol.iterator]();

const it = Iterator.concat(arrayIterator); // No error
</pre></div> <p>To pass an iterator that isn't also iterable, you can wrap it using <a href="from"><code>Iterator.from()</code></a>.</p> <div class="code-example"><pre data-language="js">const nonIterable = {
  next() {
    return { done: true };
  },
};

const it = Iterator.concat(Iterator.from(nonIterable)); // No error
</pre></div> <p>Another option is to use <a href="flatmap"><code>Iterator.prototype.flatMap()</code></a> instead, which automatically calls <code>Iterator.from()</code>. But be careful: you need to call <code>flatMap()</code> on an iterator, not on an array, because <a href="../array/flatmap"><code>Array.prototype.flatMap()</code></a> only supports array return values.</p> <div class="code-example"><pre data-language="js">const nonIterable = {
  next() {
    return { done: true };
  },
};

const it = [nonIterable].values().flatMap((x) =&gt; x); // No error
</pre></div> <p>When implementing your own iterators, consider making them iterable by or <a href="iterator#subclassing_iterator">subclassing <code>Iterator</code></a> or adding a <code>[Symbol.iterator]()</code> method that returns <code>this</code>.</p> </section><section class="content-section" aria-labelledby="specifications"> <h2 id="specifications" class="heading">Specifications</h2> <div class="_table"><table> <thead> <tr> <th scope="col">Specification</th> </tr> </thead> <tbody> <tr> <td><a href="https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-iterator.concat" rel="noopener" target="_blank">ECMAScript® 2026 Language Specification&gt;<br># sec-iterator.concat&gt;</a></td> </tr> </tbody> </table></div> </section><section class="content-section" aria-labelledby="browser_compatibility"> <h2 id="browser_compatibility" class="heading">Browser compatibility</h2> <div class="_table"><table>
<thead>
<tr id="bct-browser-type">
<th></th>
<th colspan="5">Desktop</th>
<th colspan="7">Mobile</th>
<th colspan="3">Server</th>
</tr>
<tr id="bct-browsers">
<th></th>
<th>Chrome</th>
<th>Edge</th>
<th>Firefox</th>
<th>Opera</th>
<th>Safari</th>
<th>Chrome Android</th>
<th>Firefox for Android</th>
<th>Opera Android</th>
<th>Safari on IOS</th>
<th>Samsung Internet</th>
<th>WebView Android</th>
<th>WebView on iOS</th>
<th>Bun</th>
<th>Deno</th>
<th>Node.js</th>
</tr>
</thead>
<tbody><tr>
<th><code>concat</code></th>
<td class="bc-supports-no">No</td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-yes"><abbr title="Release date: 2026-01-13">147</abbr></td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-yes"><abbr title="Release date: 2026-01-13">147</abbr></td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-no">No</td>
</tr></tbody>
</table></div> </section><section class="content-section" aria-labelledby="see_also"> <h2 id="see_also" class="heading">See also</h2> <ul> <li><a href="https://github.com/zloirock/core-js#iterator-sequencing" target="_blank">Polyfill of <code>Iterator.concat</code> in <code>core-js</code></a></li> <li><a href="https://www.npmjs.com/package/es-iterator-helpers" target="_blank">es-shims polyfill of <code>Iterator.concat</code></a></li> <li><a href="../iterator"><code>Iterator</code></a></li> <li><a href="from"><code>Iterator.from()</code></a></li> <li><a href="../array/concat"><code>Array.prototype.concat()</code></a></li> </ul> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2025 MDN contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator/concat" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator/concat</a>
  </p>
</div>
