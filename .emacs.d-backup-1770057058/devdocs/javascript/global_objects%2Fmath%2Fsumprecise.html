<mdn-survey></mdn-survey> <h1>Math.sumPrecise()</h1> <details class="baseline-indicator not" data-glean-toggle-open="baseline_toggle_open"> <summary>  <div class="status-title"> <span class="not-bold">Limited availability</span> </div>   </summary> <div class="extra"> <p>This feature is not Baseline because it does not work in some of the most widely-used browsers.</p> <ul> <li> <a href="https://developer.mozilla.org/en-US/docs/Glossary/Baseline/Compatibility" data-glean-id="baseline_link_learn_more" target="_blank" class="learn-more"> Learn more </a> </li> <li> <a href="#browser_compatibility" data-glean-id="baseline_link_bcd_table"> See full compatibility </a> </li> <li> <a href="https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FMath%2FsumPrecise&amp;level=not" data-glean-id="baseline_link_feedback" class="feedback-link" target="_blank" rel="noreferrer"> Report feedback </a> </li> </ul> </div> </details><section class="content-section"> <p>The <code>Math.sumPrecise()</code> static method takes an iterable of numbers and returns the sum of them. It is more precise than summing them up in a loop, because it avoids floating point precision loss in intermediate results.</p> </section>    <section class="content-section" aria-labelledby="try_it"> <h2 id="try_it" class="heading">Try it</h2> <interactive-example name="JavaScript Demo: Math.sumPrecise()"></interactive-example> <div class="code-example"><pre data-language="js">console.log(Math.sumPrecise([1, 2]));
// Expected output: 3

console.log(Math.sumPrecise([1e20, 0.1, -1e20]));
// Expected output: 0.1
</pre></div> </section><section class="content-section" aria-labelledby="syntax"> <h2 id="syntax" class="heading">Syntax</h2> <div class="code-example"><pre data-language="js">Math.sumPrecise(numbers)
</pre></div> </section><section class="content-section" aria-labelledby="parameters"> <h3 id="parameters" class="heading">Parameters</h3> <dl> <dt id="numbers"><a href="#numbers"><code>numbers</code></a></dt> <dd> <p>An <a href="../../iteration_protocols#the_iterable_protocol">iterable</a> (such as an <a href="../array"><code>Array</code></a>) of numbers.</p> </dd> </dl> </section><section class="content-section" aria-labelledby="return_value"> <h3 id="return_value" class="heading">Return value</h3> <p>A number that is the sum of the numbers in the <code>numbers</code> iterable. If the iterable is empty, the return value is <code>-0</code> (<em>not</em> <code>0</code>).</p> </section><section class="content-section" aria-labelledby="exceptions"> <h3 id="exceptions" class="heading">Exceptions</h3> <dl> <dt id="typeerror"><a href="../typeerror"><code>TypeError</code></a></dt> <dd> <p>If <code>numbers</code> is not an iterable, or if any of the numbers in the iterable is not of the number type.</p> </dd> </dl> </section><section class="content-section" aria-labelledby="description"> <h2 id="description" class="heading">Description</h2> <p>Because <code>sumPrecise()</code> is a static method of <code>Math</code>, you always use it as <code>Math.sumPrecise()</code>, rather than as a method of a <code>Math</code> object you created (<code>Math</code> is not a constructor).</p> <p>The method is called <code>Math.sumPrecise()</code> because it is more precise than na√Øvely summing up numbers in a loop. Consider the following example:</p> <div class="code-example"><pre data-language="js">let sum = 0;
const numbers = [1e20, 0.1, -1e20];
for (const number of numbers) {
  sum += number;
}
console.log(sum); // 0
</pre></div> <p>The output is 0. This is because <code>1e20 + 0.1</code> cannot be represented precisely in 64-bit floats, so the intermediate result is rounded to <code>1e20</code>. Then, the sum of <code>1e20</code> and <code>-1e20</code> is <code>0</code>, so the final result is <code>0</code>.</p> <p><code>Math.sumPrecise()</code> avoids this issue by using some specialized summing algorithm. It works as if the floating point numbers are summed up using their precise mathematical values, and the final result is then converted to the nearest representable 64-bit float. This still cannot avoid the <code>0.1 + 0.2</code> precision problem:</p> <div class="code-example"><pre data-language="js">console.log(Math.sumPrecise([0.1, 0.2])); // 0.30000000000000004
</pre></div> <p>Because the floating point literals <code>0.1</code> and <code>0.2</code> already represent mathematical values greater than <code>0.1</code> and <code>0.2</code>, and their sum's closest 64-bit float representation is actually <code>0.30000000000000004</code>.</p> </section><section class="content-section" aria-labelledby="examples"> <h2 id="examples" class="heading">Examples</h2> &gt; </section><section class="content-section" aria-labelledby="using_math.sumprecise"> <h3 id="using_math.sumprecise" class="heading">Using Math.sumPrecise()</h3> <div class="code-example"><pre data-language="js">console.log(Math.sumPrecise([1, 2, 3])); // 6
console.log(Math.sumPrecise([1e20, 0.1, -1e20])); // 0.1
</pre></div> </section><section class="content-section" aria-labelledby="specifications"> <h2 id="specifications" class="heading">Specifications</h2> <div class="_table"><table> <thead> <tr> <th scope="col">Specification</th> </tr> </thead> <tbody> <tr> <td><a href="https://tc39.es/proposal-math-sum/#sec-math.sumprecise" rel="noopener" target="_blank">Math.sumPrecise&gt;<br># sec-math.sumprecise&gt;</a></td> </tr> </tbody> </table></div> </section><section class="content-section" aria-labelledby="browser_compatibility"> <h2 id="browser_compatibility" class="heading">Browser compatibility</h2> <div class="_table"><table>
<thead>
<tr id="bct-browser-type">
<th></th>
<th colspan="5">Desktop</th>
<th colspan="7">Mobile</th>
<th colspan="3">Server</th>
</tr>
<tr id="bct-browsers">
<th></th>
<th>Chrome</th>
<th>Edge</th>
<th>Firefox</th>
<th>Opera</th>
<th>Safari</th>
<th>Chrome Android</th>
<th>Firefox for Android</th>
<th>Opera Android</th>
<th>Safari on IOS</th>
<th>Samsung Internet</th>
<th>WebView Android</th>
<th>WebView on iOS</th>
<th>Bun</th>
<th>Deno</th>
<th>Node.js</th>
</tr>
</thead>
<tbody><tr>
<th><code>sumPrecise</code></th>
<td class="bc-supports-no">No</td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-04-01">137</abbr></td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-12-12">26.2</abbr></td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-04-01">137</abbr></td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-12-12">26.2</abbr></td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-12-12">26.2</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-07-03">1.2.18</abbr></td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-no">No</td>
</tr></tbody>
</table></div> </section><section class="content-section" aria-labelledby="see_also"> <h2 id="see_also" class="heading">See also</h2> <ul> <li><a href="https://github.com/zloirock/core-js#mathsumprecise" target="_blank">Polyfill of <code>Math.sumPrecise</code> in <code>core-js</code></a></li> <li><a href="https://www.npmjs.com/package/math.sumprecise" target="_blank">es-shims polyfill of <code>Math.sumPrecise</code></a></li> <li><a href="../array/reduce"><code>Array.prototype.reduce()</code></a></li> </ul> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2025 MDN contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sumPrecise" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sumPrecise</a>
  </p>
</div>
