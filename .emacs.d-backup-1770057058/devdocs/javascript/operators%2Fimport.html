<mdn-survey></mdn-survey> <h1>import()</h1> <details class="baseline-indicator high" data-glean-toggle-open="baseline_toggle_open"> <summary>  <div class="status-title"> Baseline <span class="not-bold"> Widely available </span> </div>   </summary> <div class="extra"> <p> This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨January 2020⁩. </p> <ul> <li> <a href="https://developer.mozilla.org/en-US/docs/Glossary/Baseline/Compatibility" data-glean-id="baseline_link_learn_more" target="_blank" class="learn-more"> Learn more </a> </li> <li> <a href="#browser_compatibility" data-glean-id="baseline_link_bcd_table"> See full compatibility </a> </li> <li> <a href="https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fimport&amp;level=high" data-glean-id="baseline_link_feedback" class="feedback-link" target="_blank" rel="noreferrer"> Report feedback </a> </li> </ul> </div> </details><section class="content-section"> <p>The <code>import()</code> syntax, commonly called <em>dynamic import</em>, is a function-like expression that allows loading an ECMAScript module asynchronously and dynamically into a potentially non-module environment.</p> <p>Unlike the <a href="../statements/import">declaration-style counterpart</a>, dynamic imports are only evaluated when needed, and permit greater syntactic flexibility.</p> </section>    <section class="content-section" aria-labelledby="syntax"> <h2 id="syntax" class="heading">Syntax</h2> <div class="code-example"><pre data-language="js">import(moduleName)
import(moduleName, options)
</pre></div> <p>The <code>import()</code> call is a syntax that closely resembles a function call, but <code>import</code> itself is a keyword, not a function. You cannot alias it like <code>const myImport = import</code>, which will throw a <a href="../global_objects/syntaxerror"><code>SyntaxError</code></a>.</p> <p><a href="../trailing_commas">Trailing commas</a> are only allowed if the runtime also supports <code>options</code>. Check <a href="#browser_compatibility">browser compatibility</a>.</p> </section><section class="content-section" aria-labelledby="parameters"> <h3 id="parameters" class="heading">Parameters</h3> <dl> <dt id="modulename"><a href="#modulename"><code>moduleName</code></a></dt> <dd> <p>The module to import from. The evaluation of the specifier is host-specified, but always follows the same algorithm as static <a href="../statements/import">import declarations</a>.</p> </dd> <dt id="options"><a href="#options"><code>options</code></a></dt> <dd> <p>An object containing import options. The following key is recognized:</p> <dl> <dt id="with"><a href="#with"><code>with</code></a></dt> <dd> <p>The <a href="../statements/import/with">import attributes</a>.</p> </dd> </dl> </dd> </dl> </section><section class="content-section" aria-labelledby="return_value"> <h3 id="return_value" class="heading">Return value</h3> <p>Returns a promise which:</p> <ul> <li>If the referenced module is loaded and evaluated successfully, fulfills to a <a href="#module_namespace_object">module namespace object</a>: an object containing all exports from <code>moduleName</code>.</li> <li>If the <a href="../global_objects/string#string_coercion">coercion to string</a> of <code>moduleName</code> throws, rejects with the thrown error.</li> <li>If module fetching and loading fails for any reason, rejects with an implementation-defined error (Node uses a generic <code>Error</code>, while all browsers use <code>TypeError</code>). Common causes may include: <ul> <li>In a file-system-based module system (Node.js, for example), if accessing the file system fails (permission denied, file not found, etc.).</li> <li>In a web-based module system (browsers, for example), if the network request fails (not connected to the Internet, CORS issue, etc.) or an HTTP error occurs (404, 500, etc.).</li> </ul> </li> <li>If evaluation of the referenced module throws, rejects with the thrown error.</li> </ul> <div class="notecard note"> <p><strong>Note:</strong> <code>import()</code> never synchronously throws an error.</p> </div> </section><section class="content-section" aria-labelledby="description"> <h2 id="description" class="heading">Description</h2> <p>The import declaration syntax (<code>import something from "somewhere"</code>) is static and will always result in the imported module being evaluated at load time. Dynamic imports allow one to circumvent the syntactic rigidity of import declarations and load a module conditionally or on demand. The following are some reasons why you might need to use dynamic import:</p> <ul> <li>When importing statically significantly slows the loading of your code or increases your program's memory usage, and there is a low likelihood that you will need the code you are importing, or you will not need it until a later time.</li> <li>When the module you are importing does not exist at load time.</li> <li>When the import specifier string needs to be constructed dynamically. (Static import only supports static specifiers.)</li> <li>When the module being imported has side effects, and you do not want those side effects unless some condition is true. (It is recommended not to have any side effects in a module, but you sometimes cannot control this in your module dependencies.)</li> <li>When you are in a non-module environment (for example, <code>eval</code> or a script file).</li> </ul> <p>Use dynamic import only when necessary. The static form is preferable for loading initial dependencies, and can benefit more readily from static analysis tools and <a href="https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking">tree shaking</a>.</p> <p>If your file is not run as a module (if it's referenced in an HTML file, the script tag must have <code>type="module"</code>), you will not be able to use static import declarations. On the other hand, the asynchronous dynamic import syntax is always available, allowing you to import modules into non-module environments.</p> <p>The <code>options</code> parameter allows different kinds of import options. For example, <a href="../statements/import/with">import attributes</a>:</p> <div class="code-example"><pre data-language="js">import("./data.json", { with: { type: "json" } });
</pre></div> <p>Dynamic module import is not permitted in all execution contexts. For example, <code>import()</code> can be used in the main thread, a shared worker, or a dedicated worker, but will throw if called within a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">service worker</a> or a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worklet">worklet</a>.</p> </section><section class="content-section" aria-labelledby="module_namespace_object"> <h3 id="module_namespace_object" class="heading">Module namespace object</h3> <p>A <em>module namespace object</em> is an object that describes all exports from a module. It is a static object that is created when the module is evaluated. There are two ways to access the module namespace object of a module: through a <a href="../statements/import#namespace_import">namespace import</a> (<code>import * as name from moduleName</code>), or through the fulfillment value of a dynamic import.</p> <p>The module namespace object is a <a href="../global_objects/object/issealed">sealed</a> object with <a href="../global_objects/object#null-prototype_objects"><code>null</code> prototype</a>. This means all string keys of the object correspond to the exports of the module and there are never extra keys. All keys are <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Enumerability_and_ownership_of_properties">enumerable</a> in lexicographic order (i.e., the default behavior of <a href="../global_objects/array/sort#description"><code>Array.prototype.sort()</code></a>), with the default export available as a key called <code>default</code>. In addition, the module namespace object has a <a href="../global_objects/symbol/tostringtag"><code>[Symbol.toStringTag]</code></a> property with the value <code>"Module"</code>, used in <a href="../global_objects/object/tostring"><code>Object.prototype.toString()</code></a>.</p> <p>The string properties are non-configurable and writable when you use <a href="../global_objects/object/getownpropertydescriptors"><code>Object.getOwnPropertyDescriptors()</code></a> to get their descriptors. However, they are effectively read-only, because you cannot re-assign a property to a new value. This behavior mirrors the fact that static imports create "<a href="../statements/import#imported_values_can_only_be_modified_by_the_exporter">live bindings</a>" — the values can be re-assigned by the module exporting them, but not by the module importing them. The writability of the properties reflects the possibility of the values changing, because non-configurable and non-writable properties must be constant. For example, you can re-assign the exported value of a variable, and the new value can be observed in the module namespace object.</p> <p>Each (normalized) module specifier corresponds to a unique module namespace object, so the following is generally true:</p> <div class="code-example"><pre data-language="js">import * as mod from "/my-module.js";

import("/my-module.js").then((mod2) =&gt; {
  console.log(mod === mod2); // true
});
</pre></div> <p>Except in one curious case: because a promise never fulfills to a <a href="../global_objects/promise#thenables">thenable</a>, if the <code>my-module.js</code> module exports a function called <code>then()</code>, that function will automatically get called when the dynamic import's promise is fulfilled, as part of the <a href="../global_objects/promise/promise#the_resolve_function">promise resolution</a> process.</p> <div class="code-example"><pre data-language="js">// my-module.js
export function then(resolve) {
  console.log("then() called");
  resolve(1);
}
</pre></div> <div class="code-example"><pre data-language="js">// main.js
import * as mod from "/my-module.js";

import("/my-module.js").then((mod2) =&gt; {
  // Logs "then() called"
  console.log(mod === mod2); // false
});
</pre></div> <div class="notecard warning"> <p><strong>Warning:</strong> Do not export a function called <code>then()</code> from a module. This will cause the module to behave differently when imported dynamically than when imported statically.</p> </div> <p>This aggressive caching ensures that a piece of JavaScript code is never executed more than once, even if it is imported multiple times. Future imports don't even result in HTTP requests or disk access. If you do need to re-import and re-evaluate a module without restarting the entire JavaScript environment, one possible trick is to use a unique query parameter in the module specifier. This works in non-browser runtimes that support URL specifiers too.</p> <div class="code-example"><pre data-language="js">import(`/my-module.js?t=${Date.now()}`);
</pre></div> <p>Note that this can lead to memory leaks in a long-running application, because the engine cannot safely garbage-collect any module namespace objects. Currently, there is no way to manually clear the cache of module namespace objects.</p> <p>You can also use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a> to fetch module source code as text, and then evaluate the module manually depending on the module type:</p> <ul> <li>For JavaScript modules, you can dynamically import the source code as a <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL_static"><code>blob:</code> URL</a> in browsers, or use <a href="https://nodejs.org/docs/latest/api/vm.html#class-vmmodule" target="_blank"><code>vm.Module</code></a> to evaluate it in Node.js.</li> <li>For JSON modules, you can parse the source code using <a href="../global_objects/json/parse"><code>JSON.parse()</code></a>.</li> <li>For CSS modules, you can create a new <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet"><code>CSSStyleSheet</code></a> object and use its <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet/replace"><code>replace()</code></a> method to populate it with the source code.</li> </ul> <p>However, this is semantically not the same as dynamic import, because user-agent settings like <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request/destination">fetch destination</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CSP">CSP</a>, or <a href="import.meta/resolve">module resolution</a> may not be applied correctly.</p> <p>Module namespace object caching only applies to modules that are loaded and linked <em>successfully</em>. A module is imported in three steps: loading (fetching the module), linking (mostly, parsing the module), and evaluating (executing the parsed code). Only evaluation failures are cached; if a module fails to load or link, the next import may try to load and link the module again. The browser may or may not cache the result of the fetch operation, but it should follow typical HTTP semantics, so handling such network failures should not be different from handling <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch"><code>fetch()</code></a> failures.</p> </section><section class="content-section" aria-labelledby="examples"> <h2 id="examples" class="heading">Examples</h2> &gt; </section><section class="content-section" aria-labelledby="import_a_module_for_its_side_effects_only"> <h3 id="import_a_module_for_its_side_effects_only" class="heading">Import a module for its side effects only</h3> <div class="code-example"><pre data-language="js">(async () =&gt; {
  if (somethingIsTrue) {
    // import module for side effects
    await import("/modules/my-module.js");
  }
})();
</pre></div> <p>If your project uses packages that export ESM, you can also import them for side effects only. This will run the code in the package entry point file (and any files it imports) only.</p> </section><section class="content-section" aria-labelledby="importing_defaults"> <h3 id="importing_defaults" class="heading">Importing defaults</h3> <p>If you are destructuring the imported module namespace object, then you must rename the <code>default</code> key because <code>default</code> is a reserved word.</p> <div class="code-example"><pre data-language="js">(async () =&gt; {
  if (somethingIsTrue) {
    const {
      default: myDefault,
      foo,
      bar,
    } = await import("/modules/my-module.js");
  }
})();
</pre></div> </section><section class="content-section" aria-labelledby="importing_on-demand_in_response_to_user_action"> <h3 id="importing_on-demand_in_response_to_user_action" class="heading">Importing on-demand in response to user action</h3> <p>This example shows how to load functionality on to a page based on a user action, in this case a button click, and then call a function within that module. This is not the only way to implement this functionality. The <code>import()</code> function also supports <code>await</code>.</p> <div class="code-example"><pre data-language="js">const main = document.querySelector("main");
for (const link of document.querySelectorAll("nav &gt; a")) {
  link.addEventListener("click", (e) =&gt; {
    e.preventDefault();

    import("/modules/my-module.js")
      .then((module) =&gt; {
        module.loadPageInto(main);
      })
      .catch((err) =&gt; {
        main.textContent = err.message;
      });
  });
}
</pre></div> </section><section class="content-section" aria-labelledby="importing_different_modules_based_on_environment"> <h3 id="importing_different_modules_based_on_environment" class="heading">Importing different modules based on environment</h3> <p>In processes such as server-side rendering, you may need to load different logic on server or in browser because they interact with different globals or modules (for example, browser code has access to web APIs like <code>document</code> and <code>navigator</code>, while server code has access to the server file system). You can do so through a conditional dynamic import.</p> <div class="code-example"><pre data-language="js">let myModule;

if (typeof window === "undefined") {
  myModule = await import("module-used-on-server");
} else {
  myModule = await import("module-used-in-browser");
}
</pre></div> </section><section class="content-section" aria-labelledby="importing_modules_with_a_non-literal_specifier"> <h3 id="importing_modules_with_a_non-literal_specifier" class="heading">Importing modules with a non-literal specifier</h3> <p>Dynamic imports allow any expression as the module specifier, not necessarily string literals.</p> <p>Here, we load 10 modules, <code>/modules/module-0.js</code>, <code>/modules/module-1.js</code>, etc., concurrently, and call the <code>load</code> functions that each one exports.</p> <div class="code-example"><pre data-language="js">Promise.all(
  Array.from({ length: 10 }).map(
    (_, index) =&gt; import(`/modules/module-${index}.js`),
  ),
).then((modules) =&gt; modules.forEach((module) =&gt; module.load()));
</pre></div> </section><section class="content-section" aria-labelledby="using_import_attributes_with_dynamic_import"> <h3 id="using_import_attributes_with_dynamic_import" class="heading">Using import attributes with dynamic import</h3> <p><a href="../statements/import/with">Import attributes</a> are accepted as the second parameter of the <code>import()</code> syntax.</p> <div class="code-example"><pre data-language="js">const data = await import("./data.json", {
  with: { type: "json" },
});
</pre></div> </section><section class="content-section" aria-labelledby="specifications"> <h2 id="specifications" class="heading">Specifications</h2> <div class="_table"><table> <thead> <tr> <th scope="col">Specification</th> </tr> </thead> <tbody> <tr> <td><a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-import-calls" rel="noopener" target="_blank">ECMAScript® 2026 Language Specification&gt;<br># sec-import-calls&gt;</a></td> </tr> </tbody> </table></div> </section><section class="content-section" aria-labelledby="browser_compatibility"> <h2 id="browser_compatibility" class="heading">Browser compatibility</h2> <div class="_table"><table>
<thead>
<tr id="bct-browser-type">
<th></th>
<th colspan="5">Desktop</th>
<th colspan="7">Mobile</th>
<th colspan="3">Server</th>
</tr>
<tr id="bct-browsers">
<th></th>
<th>Chrome</th>
<th>Edge</th>
<th>Firefox</th>
<th>Opera</th>
<th>Safari</th>
<th>Chrome Android</th>
<th>Firefox for Android</th>
<th>Opera Android</th>
<th>Safari on IOS</th>
<th>Samsung Internet</th>
<th>WebView Android</th>
<th>WebView on iOS</th>
<th>Bun</th>
<th>Deno</th>
<th>Node.js</th>
</tr>
</thead>
<tbody>
<tr>
<th><code>import</code></th>
<td class="bc-supports-yes"><abbr title="Release date: 2017-12-06">63</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-01-15">79</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2019-05-21">67</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2018-01-04">50</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2018-04-12">11.1</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2017-12-05">63</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2019-05-21">67</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2018-05-14">46</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2018-03-29">11.3</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2018-07-18">8.0</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2017-12-05">63</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2018-03-29">11.3</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2023-09-08">1.0.0</abbr></td>
<td class="bc-supports-yes"><details><summary><abbr title="Release date: 2020-05-13">1.0</abbr></summary>Bundled Deno applications (using <code>deno compile</code>) do not support dynamic imports</details></td>
<td class="bc-supports-yes">
<details><summary><abbr title="Release date: 2019-11-21">13.2.0</abbr></summary>Dynamic <code>import</code> can be used in either CommonJS or ES module files, to import either CommonJS or ES module files. See Node's <a href="https://nodejs.org/api/esm.html#esm_import_expressions">ECMAScript Modules documentation</a> for more details.</details><details><summary><abbr title="Release date: 2020-05-26">12.17.0</abbr>–13.0.0</summary>Dynamic <code>import</code> can be used in either CommonJS or ES module files, to import either CommonJS or ES module files. See Node's <a href="https://nodejs.org/api/esm.html#esm_import_expressions">ECMAScript Modules documentation</a> for more details.</details>
</td>
</tr>
<tr>
<th><code>options_parameter</code></th>
<td class="bc-supports-yes"><abbr title="Release date: 2021-05-25">91</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2021-05-27">91</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-04-29">138</abbr></td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-yes"><abbr title="Release date: 2021-09-20">15</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2021-05-25">91</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-04-29">138</abbr></td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-yes"><abbr title="Release date: 2021-09-20">15</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2021-11-25">16.0</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2021-05-25">91</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2021-09-20">15</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2024-04-26">1.1.5</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2021-12-16">1.17</abbr></td>
<td class="bc-supports-yes">
<abbr title="Release date: 2022-02-10">17.5.0</abbr><abbr title="Release date: 2022-04-27">16.15.0</abbr>–17.0.0<details><summary><abbr title="Release date: 2022-02-08">16.14.0</abbr>–16.15.0</summary>The second parameter no longer throws a parser error, but the <code>--experimental-json-modules</code> flag is still needed to load JSON modules.</details>
</td>
</tr>
<tr>
<th><code>worker_support</code></th>
<td class="bc-supports-yes"><abbr title="Release date: 2020-02-04">80</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-02-07">80</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2023-06-06">114</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-03-03">67</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2021-09-20">15</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-02-04">80</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2023-06-06">114</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-03-30">57</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2021-09-20">15</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-12-02">13.0</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-02-04">80</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2021-09-20">15</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2023-09-08">1.0.0</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-05-13">1.0</abbr></td>
<td class="bc-supports-yes">
<abbr title="Release date: 2019-11-21">13.2.0</abbr><abbr title="Release date: 2020-05-26">12.17.0</abbr>–13.0.0</td>
</tr>
</tbody>
</table></div> </section><section class="content-section" aria-labelledby="see_also"> <h2 id="see_also" class="heading">See also</h2> <ul> <li><a href="../statements/import"><code>import</code></a></li> </ul> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2025 MDN contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import</a>
  </p>
</div>
