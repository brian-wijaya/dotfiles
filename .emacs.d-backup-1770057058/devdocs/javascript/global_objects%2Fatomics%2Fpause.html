<mdn-survey></mdn-survey> <h1>Atomics.pause()</h1> <details class="baseline-indicator low" data-glean-toggle-open="baseline_toggle_open"> <summary>  <div class="status-title"> Baseline <span class="not-bold"> 2025 </span> </div> <div class="pill">Newly available</div>   </summary> <div class="extra"> <p> Since ⁨April 2025⁩, this feature works across the latest devices and browser versions. This feature might not work in older devices or browsers. </p> <ul> <li> <a href="https://developer.mozilla.org/en-US/docs/Glossary/Baseline/Compatibility" data-glean-id="baseline_link_learn_more" target="_blank" class="learn-more"> Learn more </a> </li> <li> <a href="#browser_compatibility" data-glean-id="baseline_link_bcd_table"> See full compatibility </a> </li> <li> <a href="https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FAtomics%2Fpause&amp;level=low" data-glean-id="baseline_link_feedback" class="feedback-link" target="_blank" rel="noreferrer"> Report feedback </a> </li> </ul> </div> </details><section class="content-section"> <p>The <code>Atomics.pause()</code> static method provides a micro-wait primitive that hints to the CPU that the caller is spinning while waiting on access to a shared resource. This allows the system to reduce the resources allocated to the core (such as power) or thread, without yielding the current thread.</p> <p><code>pause()</code> has no observable behavior other than timing. The exact behavior is dependent on the CPU architecture and the operating system. For example, in Intel x86, it may be a <code>pause</code> instruction as per <a href="https://www.intel.com/content/www/us/en/content-details/671488/intel-64-and-ia-32-architectures-optimization-reference-manual-volume-1.html" target="_blank">Intel's optimization manual</a>. It could be a no-op in certain platforms.</p> </section>    <section class="content-section" aria-labelledby="syntax"> <h2 id="syntax" class="heading">Syntax</h2> <div class="code-example"><pre data-language="js">Atomics.pause()
Atomics.pause(durationHint)
</pre></div> </section><section class="content-section" aria-labelledby="parameters"> <h3 id="parameters" class="heading">Parameters</h3> <dl> <dt id="durationhint"><a href="#durationhint"><code>durationHint</code> <span class="badge inline optional">Optional</span></a></dt> <dd> <p>An integer that an implementation may use to determine how long to wait. For a value <code>n + 1</code>, an implementation waits at least as long as it does for a given value <code>n</code>. The exact number has no physical meaning. There may be an internal upper bound on the maximum amount of time paused on the order of tens to hundreds of nanoseconds. This can be used to implement a <a href="#backoff_strategies">backoff strategy</a> by increasing the <code>durationHint</code> passed in. There is no guarantee that an implementation will make use of this hint.</p> </dd> </dl> </section><section class="content-section" aria-labelledby="return_value"> <h3 id="return_value" class="heading">Return value</h3> <p>None (<a href="../undefined"><code>undefined</code></a>).</p> </section><section class="content-section" aria-labelledby="exceptions"> <h3 id="exceptions" class="heading">Exceptions</h3> <dl> <dt id="typeerror"><a href="../typeerror"><code>TypeError</code></a></dt> <dd> <p>Thrown if <code>durationHint</code> is not an integer or <code>undefined</code>.</p> </dd> </dl> </section><section class="content-section" aria-labelledby="examples"> <h2 id="examples" class="heading">Examples</h2> &gt; </section><section class="content-section" aria-labelledby="using_atomics.pause"> <h3 id="using_atomics.pause" class="heading">Using Atomics.pause()</h3> <p>Calling <a href="wait"><code>Atomics.wait()</code></a> or <a href="waitasync"><code>Atomics.waitAsync()</code></a> in order to wait for access to shared memory causes the thread to be scheduled out of the core and then back in again after the wait. This is efficient during times of high contention, where access to the shared memory could take some time. When contention is low, then it is often more efficient to poll on the lock without yielding the thread: this approach is known as <a href="https://en.wikipedia.org/wiki/Busy_waiting" target="_blank">busy waiting</a> or <a href="https://en.wikipedia.org/wiki/Spinlock" target="_blank">spinlocking</a>. The <code>pause()</code> method allows you to spinlock more efficiently while waiting, by providing a hint to the CPU about what the thread is doing, and hence its low need for resources.</p> <p>To cater for both conditions, a common approach is to first spinlock in the hope that contention is low, and then wait if the lock is not gained after a short time. If we acquired the lock via spinlocking already, then the <code>wait()</code> call will be a no-op.</p> <p>The example below shows how this approach can be used with <code>Atomics.pause()</code> and <code>Atomics.wait()</code>.</p> <div class="notecard warning"> <p><strong>Warning:</strong> Using spinlocking on the main thread is not recommended, as it will freeze the entire page. In general, unless designed very carefully, spinlocks may not actually be more performant than a regular wait.</p> </div> <div class="code-example"><pre data-language="js">// Imagine another thread also has access to this shared memory
const sab = new SharedArrayBuffer(1024);
const i32 = new Int32Array(sab);

// Fast path: spin the CPU for a short while
let spin = 0;
do {
  if (Atomics.compareExchange(i32, 0, 0, 1) === 0) {
    break;
  }
  Atomics.pause();
  spin++;
} while (spin &lt; 10);

// Slow path: wait for the lock
// This can only be called in a worker thread,
// because the main thread cannot be blocked
Atomics.wait(i32, 0, 1);
</pre></div> </section><section class="content-section" aria-labelledby="backoff_strategies"> <h3 id="backoff_strategies" class="heading">Backoff strategies</h3> <p>The <code>durationHint</code> parameter can be used to implement backoff strategies. For example, a thread can start with a small hint and increase it exponentially on each iteration. This is preferable to calling <code>pause()</code> many times because in un-JITed code, function calls themselves have a high overhead.</p> <div class="notecard note"> <p><strong>Note:</strong> Implementations may not actually use <code>durationHint</code> at all and always wait for a constant time.</p> </div> <div class="code-example"><pre data-language="js">// Exponential backoff
for (let hint = 1; hint &lt; 1000; hint *= 2) {
  Atomics.pause(hint);
}

// Linear backoff
for (let hint = 1; hint &lt; 100; hint++) {
  Atomics.pause(hint);
}
</pre></div> </section><section class="content-section" aria-labelledby="specifications"> <h2 id="specifications" class="heading">Specifications</h2> <div class="_table"><table> <thead> <tr> <th scope="col">Specification</th> </tr> </thead> <tbody> <tr> <td><a href="https://tc39.es/proposal-atomics-microwait/#Atomics.pause" rel="noopener" target="_blank">Atomics.pause&gt;<br># Atomics.pause&gt;</a></td> </tr> </tbody> </table></div> </section><section class="content-section" aria-labelledby="browser_compatibility"> <h2 id="browser_compatibility" class="heading">Browser compatibility</h2> <div class="_table"><table>
<thead>
<tr id="bct-browser-type">
<th></th>
<th colspan="5">Desktop</th>
<th colspan="7">Mobile</th>
<th colspan="3">Server</th>
</tr>
<tr id="bct-browsers">
<th></th>
<th>Chrome</th>
<th>Edge</th>
<th>Firefox</th>
<th>Opera</th>
<th>Safari</th>
<th>Chrome Android</th>
<th>Firefox for Android</th>
<th>Opera Android</th>
<th>Safari on IOS</th>
<th>Samsung Internet</th>
<th>WebView Android</th>
<th>WebView on iOS</th>
<th>Bun</th>
<th>Deno</th>
<th>Node.js</th>
</tr>
</thead>
<tbody><tr>
<th><code>pause</code></th>
<td class="bc-supports-yes"><abbr title="Release date: 2025-02-04">133</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-02-06">133</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-04-01">137</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-04-15">118</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-03-31">18.4</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-02-04">133</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-04-01">137</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-03-19">88</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-03-31">18.4</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-10-25">29.0</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-02-04">133</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-03-31">18.4</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2024-10-18">1.1.31</abbr></td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-no">No</td>
</tr></tbody>
</table></div> </section><section class="content-section" aria-labelledby="see_also"> <h2 id="see_also" class="heading">See also</h2> <ul> <li><a href="../atomics"><code>Atomics</code></a></li> <li><a href="wait"><code>Atomics.wait()</code></a></li> <li><a href="waitasync"><code>Atomics.waitAsync()</code></a></li> </ul> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2025 MDN contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/pause" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/pause</a>
  </p>
</div>
