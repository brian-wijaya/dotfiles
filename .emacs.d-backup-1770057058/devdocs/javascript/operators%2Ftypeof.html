<mdn-survey></mdn-survey> <h1>typeof</h1> <details class="baseline-indicator high" data-glean-toggle-open="baseline_toggle_open"> <summary>  <div class="status-title"> Baseline <span class="not-bold"> Widely available </span> </div>   </summary> <div class="extra"> <p> This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩. </p> <ul> <li> <a href="https://developer.mozilla.org/en-US/docs/Glossary/Baseline/Compatibility" data-glean-id="baseline_link_learn_more" target="_blank" class="learn-more"> Learn more </a> </li> <li> <a href="#browser_compatibility" data-glean-id="baseline_link_bcd_table"> See full compatibility </a> </li> <li> <a href="https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Ftypeof&amp;level=high" data-glean-id="baseline_link_feedback" class="feedback-link" target="_blank" rel="noreferrer"> Report feedback </a> </li> </ul> </div> </details><section class="content-section"> <p>The <code>typeof</code> operator returns a string indicating the type of the operand's value.</p> </section>    <section class="content-section" aria-labelledby="try_it"> <h2 id="try_it" class="heading">Try it</h2> <interactive-example name="JavaScript Demo: typeof operator"></interactive-example> <div class="code-example"><pre data-language="js">console.log(typeof 42);
// Expected output: "number"

console.log(typeof "blubber");
// Expected output: "string"

console.log(typeof true);
// Expected output: "boolean"

console.log(typeof undeclaredVariable);
// Expected output: "undefined"
</pre></div> </section><section class="content-section" aria-labelledby="syntax"> <h2 id="syntax" class="heading">Syntax</h2> <div class="code-example"><pre data-language="js">typeof operand
</pre></div> </section><section class="content-section" aria-labelledby="parameters"> <h3 id="parameters" class="heading">Parameters</h3> <dl> <dt id="operand"><a href="#operand"><code>operand</code></a></dt> <dd> <p>An expression representing the object or <a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">primitive</a> whose type is to be returned.</p> </dd> </dl> </section><section class="content-section" aria-labelledby="description"> <h2 id="description" class="heading">Description</h2> <p>The following table summarizes the possible return values of <code>typeof</code>. For more information about types and primitives, see also the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Data_structures">JavaScript data structure</a> page.</p> <figure class="table-container"><div class="_table"><table> <thead> <tr> <th>Type</th> <th>Result</th> </tr> </thead> <tbody> <tr> <td><a href="../global_objects/undefined">Undefined</a></td> <td><code>"undefined"</code></td> </tr> <tr> <td><a href="null">Null</a></td> <td>
<code>"object"</code> (<a href="#typeof_null">reason</a>)</td> </tr> <tr> <td><a href="../global_objects/boolean">Boolean</a></td> <td><code>"boolean"</code></td> </tr> <tr> <td><a href="../global_objects/number">Number</a></td> <td><code>"number"</code></td> </tr> <tr> <td><a href="../global_objects/bigint">BigInt</a></td> <td><code>"bigint"</code></td> </tr> <tr> <td><a href="../global_objects/string">String</a></td> <td><code>"string"</code></td> </tr> <tr> <td><a href="../global_objects/symbol">Symbol</a></td> <td><code>"symbol"</code></td> </tr> <tr> <td>
<a href="../global_objects/function">Function</a> (implements [[Call]] in ECMA-262 terms; <a href="../statements/class">classes</a> are functions as well)</td> <td><code>"function"</code></td> </tr> <tr> <td>Any other object</td> <td><code>"object"</code></td> </tr> </tbody> </table></div></figure> <p>This list of values is exhaustive. No spec-compliant engines are reported to produce (or had historically produced) values other than those listed.</p> </section><section class="content-section" aria-labelledby="examples"> <h2 id="examples" class="heading">Examples</h2> &gt; </section><section class="content-section" aria-labelledby="basic_usage"> <h3 id="basic_usage" class="heading">Basic usage</h3> <div class="code-example"><pre data-language="js">// Numbers
typeof 37 === "number";
typeof 3.14 === "number";
typeof 42 === "number";
typeof Math.LN2 === "number";
typeof Infinity === "number";
typeof NaN === "number"; // Despite being "Not-A-Number"
typeof Number("1") === "number"; // Number tries to parse things into numbers
typeof Number("shoe") === "number"; // including values that cannot be type coerced to a number

typeof 42n === "bigint";

// Strings
typeof "" === "string";
typeof "bla" === "string";
typeof `template literal` === "string";
typeof "1" === "string"; // note that a number within a string is still typeof string
typeof typeof 1 === "string"; // typeof always returns a string
typeof String(1) === "string"; // String converts anything into a string, safer than toString

// Booleans
typeof true === "boolean";
typeof false === "boolean";
typeof Boolean(1) === "boolean"; // Boolean() will convert values based on if they're truthy or falsy
typeof !!1 === "boolean"; // two calls of the ! (logical NOT) operator are equivalent to Boolean()

// Symbols
typeof Symbol() === "symbol";
typeof Symbol("foo") === "symbol";
typeof Symbol.iterator === "symbol";

// Undefined
typeof undefined === "undefined";
typeof declaredButUndefinedVariable === "undefined";
typeof undeclaredVariable === "undefined";

// Objects
typeof { a: 1 } === "object";

// use Array.isArray or Object.prototype.toString.call
// to differentiate regular objects from arrays
typeof [1, 2, 4] === "object";

typeof new Date() === "object";
typeof /regex/ === "object";

// The following are confusing, dangerous, and wasteful. Avoid them.
typeof new Boolean(true) === "object";
typeof new Number(1) === "object";
typeof new String("abc") === "object";

// Functions
typeof function () {} === "function";
typeof class C {} === "function";
typeof Math.sin === "function";
</pre></div> </section><section class="content-section" aria-labelledby="typeof_null"> <h3 id="typeof_null" class="heading">typeof null</h3> <div class="code-example"><pre data-language="js">// This stands since the beginning of JavaScript
typeof null === "object";
</pre></div> <p>In the first implementation of JavaScript, JavaScript values were represented as a type tag and a value. The type tag for objects was <code>0</code>. <code>null</code> was represented as the NULL pointer (<code>0x00</code> in most platforms). Consequently, <code>null</code> had <code>0</code> as type tag, hence the <code>typeof</code> return value <code>"object"</code>. (<a href="https://2ality.com/2013/10/typeof-null.html" target="_blank">reference</a>)</p> <p>A fix was proposed for ECMAScript (via an opt-in), but <a href="https://web.archive.org/web/20160331031419/http://wiki.ecmascript.org:80/doku.php?id=harmony:typeof_null" target="_blank">was rejected</a>. It would have resulted in <code>typeof null === "null"</code>.</p> </section><section class="content-section" aria-labelledby="using_new_operator"> <h3 id="using_new_operator" class="heading">Using new operator</h3> <p>All constructor functions called with <a href="new"><code>new</code></a> will return non-primitives (<code>"object"</code> or <code>"function"</code>). Most return objects, with the notable exception being <a href="../global_objects/function"><code>Function</code></a>, which returns a function.</p> <div class="code-example"><pre data-language="js">const str = new String("String");
const num = new Number(100);

typeof str; // "object"
typeof num; // "object"

const func = new Function();

typeof func; // "function"
</pre></div> </section><section class="content-section" aria-labelledby="need_for_parentheses_in_syntax"> <h3 id="need_for_parentheses_in_syntax" class="heading">Need for parentheses in syntax</h3> <p>The <code>typeof</code> operator has higher <a href="operator_precedence">precedence</a> than binary operators like addition (<code>+</code>). Therefore, parentheses are needed to evaluate the type of an addition result.</p> <div class="code-example"><pre data-language="js">// Parentheses can be used for determining the data type of expressions.
const someData = 99;

typeof someData + " foo"; // "number foo"
typeof (someData + " foo"); // "string"
</pre></div> </section><section class="content-section" aria-labelledby="interaction_with_undeclared_and_uninitialized_variables"> <h3 id="interaction_with_undeclared_and_uninitialized_variables" class="heading">Interaction with undeclared and uninitialized variables</h3> <p><code>typeof</code> works with undeclared identifiers, returning <code>"undefined"</code> instead of throwing an error.</p> <div class="code-example"><pre data-language="js">typeof undeclaredVariable; // "undefined"
</pre></div> <p>However, using <code>typeof</code> on lexical declarations (<a href="../statements/let"><code>let</code></a> <a href="../statements/const"><code>const</code></a>, <a href="../statements/using"><code>using</code></a> <a href="../statements/await_using"><code>await using</code></a>, and <a href="../statements/class"><code>class</code></a>) in the same block before the place of declaration will throw a <a href="../global_objects/referenceerror"><code>ReferenceError</code></a>. Block scoped variables are in a <em><a href="../statements/let#temporal_dead_zone_tdz">temporal dead zone</a></em> from the start of the block until the initialization is processed, during which it will throw an error if accessed.</p> <div class="code-example"><pre data-language="js">typeof newLetVariable; // ReferenceError
typeof newConstVariable; // ReferenceError
typeof newClass; // ReferenceError

let newLetVariable;
const newConstVariable = "hello";
class newClass {}
</pre></div> <p>See <a href="../global_objects/undefined#typeof_operator_and_undefined"><code>typeof</code> operator and <code>undefined</code></a> for more details.</p> </section><section class="content-section" aria-labelledby="exceptional_behavior_of_document.all"> <h3 id="exceptional_behavior_of_document.all" class="heading">Exceptional behavior of document.all</h3> <p>All current browsers expose a non-standard host object <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/all"><code>document.all</code></a> with type <code>undefined</code>.</p> <div class="code-example"><pre data-language="js">typeof document.all === "undefined";
</pre></div> <p>Although <code>document.all</code> is also <a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy">falsy</a> and <a href="equality">loosely equal</a> to <code>undefined</code>, it is not <a href="../global_objects/undefined"><code>undefined</code></a>. The case of <code>document.all</code> having type <code>"undefined"</code> is classified in the web standards as a "willful violation" of the original ECMAScript standard for web compatibility.</p> </section><section class="content-section" aria-labelledby="custom_method_that_gets_a_more_specific_type"> <h3 id="custom_method_that_gets_a_more_specific_type" class="heading">Custom method that gets a more specific type</h3> <p><code>typeof</code> is very useful, but it's not as versatile as might be required. For example, <code>typeof []</code> is <code>"object"</code>, as well as <code>typeof new Date()</code>, <code>typeof /abc/</code>, etc.</p> <p>For greater specificity in checking types, here we present a custom <code>type(value)</code> function, which mostly mimics the behavior of <code>typeof</code>, but for non-primitives (i.e., objects and functions), it returns a more granular type name where possible.</p> <div class="code-example"><pre data-language="js">function type(value) {
  if (value === null) {
    return "null";
  }
  const baseType = typeof value;
  // Primitive types
  if (!["object", "function"].includes(baseType)) {
    return baseType;
  }

  // Symbol.toStringTag often specifies the "display name" of the
  // object's class. It's used in Object.prototype.toString().
  const tag = value[Symbol.toStringTag];
  if (typeof tag === "string") {
    return tag;
  }

  // If it's a function whose source code starts with the "class" keyword
  if (
    baseType === "function" &amp;&amp;
    Function.prototype.toString.call(value).startsWith("class")
  ) {
    return "class";
  }

  // The name of the constructor; for example `Array`, `GeneratorFunction`,
  // `Number`, `String`, `Boolean` or `MyCustomClass`
  const className = value.constructor.name;
  if (typeof className === "string" &amp;&amp; className !== "") {
    return className;
  }

  // At this point there's no robust way to get the type of value,
  // so we use the base implementation.
  return baseType;
}
</pre></div> <p>For checking potentially non-existent variables that would otherwise throw a <a href="../global_objects/referenceerror"><code>ReferenceError</code></a>, use <code>typeof nonExistentVar === "undefined"</code> because this behavior cannot be mimicked with custom code.</p> </section><section class="content-section" aria-labelledby="specifications"> <h2 id="specifications" class="heading">Specifications</h2> <div class="_table"><table> <thead> <tr> <th scope="col">Specification</th> </tr> </thead> <tbody> <tr> <td><a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-typeof-operator" rel="noopener" target="_blank">ECMAScript® 2026 Language Specification&gt;<br># sec-typeof-operator&gt;</a></td> </tr> </tbody> </table></div> </section><section class="content-section" aria-labelledby="browser_compatibility"> <h2 id="browser_compatibility" class="heading">Browser compatibility</h2> <div class="_table"><table>
<thead>
<tr id="bct-browser-type">
<th></th>
<th colspan="5">Desktop</th>
<th colspan="7">Mobile</th>
<th colspan="3">Server</th>
</tr>
<tr id="bct-browsers">
<th></th>
<th>Chrome</th>
<th>Edge</th>
<th>Firefox</th>
<th>Opera</th>
<th>Safari</th>
<th>Chrome Android</th>
<th>Firefox for Android</th>
<th>Opera Android</th>
<th>Safari on IOS</th>
<th>Samsung Internet</th>
<th>WebView Android</th>
<th>WebView on iOS</th>
<th>Bun</th>
<th>Deno</th>
<th>Node.js</th>
</tr>
</thead>
<tbody><tr>
<th><code>typeof</code></th>
<td class="bc-supports-yes"><abbr title="Release date: 2008-12-11">1</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2015-07-29">12</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2004-11-09">1</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 1997-12-01">3</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2003-06-23">1</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2012-06-27">18</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2011-03-29">4</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2010-11-09">10.1</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2007-06-29">1</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2013-04-27">1.0</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2013-12-09">4.4</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2007-06-29">1</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2023-09-08">1.0.0</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-05-13">1.0</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2013-03-11">0.10.0</abbr></td>
</tr></tbody>
</table></div> </section><section class="content-section" aria-labelledby="see_also"> <h2 id="see_also" class="heading">See also</h2> <ul> <li><a href="instanceof"><code>instanceof</code></a></li> <li><a href="https://github.com/tc39/ecma262/issues/668" target="_blank"><code>document.all</code> willful violation of the standard</a></li> </ul> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2025 MDN contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof</a>
  </p>
</div>
