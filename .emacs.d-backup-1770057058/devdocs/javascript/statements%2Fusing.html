<mdn-survey></mdn-survey> <h1>using</h1> <details class="baseline-indicator not" data-glean-toggle-open="baseline_toggle_open"> <summary>  <div class="status-title"> <span class="not-bold">Limited availability</span> </div>   </summary> <div class="extra"> <p>This feature is not Baseline because it does not work in some of the most widely-used browsers.</p> <ul> <li> <a href="https://developer.mozilla.org/en-US/docs/Glossary/Baseline/Compatibility" data-glean-id="baseline_link_learn_more" target="_blank" class="learn-more"> Learn more </a> </li> <li> <a href="#browser_compatibility" data-glean-id="baseline_link_bcd_table"> See full compatibility </a> </li> <li> <a href="https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Fusing&amp;level=not" data-glean-id="baseline_link_feedback" class="feedback-link" target="_blank" rel="noreferrer"> Report feedback </a> </li> </ul> </div> </details><section class="content-section"> <p>The <code>using</code> declaration declares block-scoped local variables that are <em>synchronously disposed</em>. Like <a href="const"><code>const</code></a>, variables declared with <code>using</code> must be initialized and cannot be reassigned. The variable's value must be either <code>null</code>, <code>undefined</code>, or an object with a <a href="../global_objects/symbol/dispose"><code>[Symbol.dispose]()</code></a> method. When the variable goes out of scope, the <code>[Symbol.dispose]()</code> method of the object is called, to ensure that resources are freed.</p> </section>    <section class="content-section" aria-labelledby="syntax"> <h2 id="syntax" class="heading">Syntax</h2> <div class="code-example"><pre data-language="js">using name1 = value1;
using name1 = value1, name2 = value2;
using name1 = value1, name2 = value2, /* …, */ nameN = valueN;
</pre></div> <dl> <dt id="namen"><a href="#namen"><code>nameN</code></a></dt> <dd> <p>The name of the variable to declare. Each must be a legal JavaScript <a href="../lexical_grammar#identifiers">identifier</a> and <em>not</em> a <a href="../operators/destructuring">destructuring binding pattern</a>.</p> </dd> <dt id="valuen"><a href="#valuen"><code>valueN</code></a></dt> <dd> <p>Initial value of the variable. It can be any legal expression but its value must be either <code>null</code>, <code>undefined</code>, or an object with a <code>[Symbol.dispose]()</code> method.</p> </dd> </dl> </section><section class="content-section" aria-labelledby="description"> <h2 id="description" class="heading">Description</h2> <p>This declaration can be used:</p> <ul> <li>Inside a <a href="block">block</a>
</li> <li>Inside any <a href="function">function body</a> or <a href="../classes/static_initialization_blocks">class static initialization block</a>
</li> <li>At the top level of a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">module</a>
</li> <li>In the initializer of a <a href="for"><code>for</code></a>, <a href="for...of"><code>for...of</code></a>, or <a href="for-await...of"><code>for await...of</code></a> loop</li> </ul> <p>Most notably, it cannot be used:</p> <ul> <li>At the top level of a script, because script scopes are persistent.</li> <li>At the top level of a <a href="switch"><code>switch</code></a> statement.</li> <li>In the initializer of a <a href="for...in"><code>for...in</code></a> loop. Because the loop variable can only be a string or symbol, this doesn't make sense.</li> </ul> <p>A <code>using</code> declares a disposable resource that's tied to the lifetime of the variable's scope (block, function, module, etc.). When the scope exits, the resource is disposed of synchronously. The variable is allowed to have value <code>null</code> or <code>undefined</code>, so the resource can be optionally present.</p> <p>When the variable is first declared and its value is non-nullish, a <em>disposer</em> is retrieved from the object. If the <code>[Symbol.dispose]</code> property doesn't contain a function, a <code>TypeError</code> is thrown. This disposer is saved to the scope.</p> <p>When the variable goes out of scope, the disposer is called. If the scope contains multiple <code>using</code> or <a href="await_using"><code>await using</code></a> declarations, all disposers are run in the reverse order of declaration, regardless of the type of declaration. All disposers are guaranteed to run (much like the <code>finally</code> block in <a href="try...catch"><code>try...catch...finally</code></a>). All errors thrown during disposal, including the initial error that caused the scope exit (if applicable), are all aggregated inside one <a href="../global_objects/suppressederror"><code>SuppressedError</code></a>, with each earlier exception as the <code>suppressed</code> property and the later exception as the <code>error</code> property. This <code>SuppressedError</code> is thrown after disposal is complete.</p> <p><code>using</code> ties resource management to lexical scopes, which is both convenient and sometimes confusing. There are many ways to preserve the variable's value when the variable itself is out of scope, so you may hold a reference to an already-disposed resource. See below for some examples where it may not behave how you expect. If you want to hand-manage resource disposal, while maintaining the same error handling guarantees, you can use <a href="../global_objects/disposablestack"><code>DisposableStack</code></a> instead.</p> </section><section class="content-section" aria-labelledby="examples"> <h2 id="examples" class="heading">Examples</h2> <p>In the following examples, we assume a simple <code>Resource</code> class that has a <code>getValue</code> method and a <code>[Symbol.dispose]()</code> method:</p> <div class="code-example"><pre data-language="js">class Resource {
  value = Math.random();
  #isDisposed = false;

  getValue() {
    if (this.#isDisposed) {
      throw new Error("Resource is disposed");
    }
    return this.value;
  }

  [Symbol.dispose]() {
    this.#isDisposed = true;
    console.log("Resource disposed");
  }
}
</pre></div> </section><section class="content-section" aria-labelledby="using_in_a_block"> <h3 id="using_in_a_block" class="heading">
<code>using</code> in a block</h3> <p>The resource declared with <code>using</code> is disposed when exiting the block.</p> <div class="code-example"><pre data-language="js">{
  using resource = new Resource();
  console.log(resource.getValue());
  // resource disposed here
}
</pre></div> </section><section class="content-section" aria-labelledby="using_in_a_function"> <h3 id="using_in_a_function" class="heading">
<code>using</code> in a function</h3> <p>You can use <code>using</code> in a function body. In this case, the resource is disposed when the function finishes executing, immediately before the function returns.</p> <div class="code-example"><pre data-language="js">function example() {
  using resource = new Resource();
  return resource.getValue();
}
</pre></div> <p>Here, <code>resource[Symbol.dispose]()</code> will be called after <code>getValue()</code>, before the <code>return</code> statement executes.</p> <p>The resource may outlive the declaration, in case it's captured by a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures">closure</a>:</p> <div class="code-example"><pre data-language="js">function example() {
  using resource = new Resource();
  return () =&gt; resource.getValue();
}
</pre></div> <p>In this case, if you call <code>example()()</code>, you will always execute <code>getValue</code> on a resource that's already disposed, because the resource was disposed when <code>example</code> returns. In case you want to dispose the resource immediately after the callback has been called once, consider this pattern:</p> <div class="code-example"><pre data-language="js">function example() {
  const resource = new Resource();
  return () =&gt; {
    using resource2 = resource;
    return resource2.getValue();
  };
}
</pre></div> <p>Here, we <em>alias</em> a <code>const</code>-declared resource to a <code>using</code>-declared resource, so that the resource is only disposed after the callback is called; note that if it is never called then the resource will never be cleaned up.</p> </section><section class="content-section" aria-labelledby="using_in_a_module"> <h3 id="using_in_a_module" class="heading">
<code>using</code> in a module</h3> <p>You can use <code>using</code> at the top level of a module. In this case, the resource is disposed when the module finishes executing.</p> <div class="code-example"><pre data-language="js">using resource = new Resource();
export const value = resource.getValue();
// resource disposed here
</pre></div> <p><code>export using</code> is invalid syntax, but you can <code>export</code> a variable declared elsewhere using <code>using</code>:</p> <div class="code-example"><pre data-language="js">using resource = new Resource();
export { resource };
</pre></div> <p>This is still discouraged, because the importer will always receive a disposed resource. Similar to the closure problem, this causes the value of resource to live longer than the variable.</p> </section><section class="content-section" aria-labelledby="using_with_for...of"> <h3 id="using_with_for...of" class="heading">
<code>using</code> with <code>for...of</code>
</h3> <p>You can use <code>using</code> in the initializer of a <code>for...of</code> loop. In this case, the resource is disposed on every loop iteration.</p> <div class="code-example"><pre data-language="js">const resources = [new Resource(), new Resource(), new Resource()];
for (using resource of resources) {
  console.log(resource.getValue());
  // resource disposed here
}
</pre></div> </section><section class="content-section" aria-labelledby="multiple_using"> <h3 id="multiple_using" class="heading">Multiple <code>using</code>
</h3> <p>The following are two equivalent ways to declare multiple disposable resources:</p> <div class="code-example"><pre data-language="js">using resource1 = new Resource(),
  resource2 = new Resource();

// OR

using resource1 = new Resource();
using resource2 = new Resource();
</pre></div> <p>In both cases, when the scope exits, <code>resource2</code> is disposed before <code>resource1</code>. This is because <code>resource2</code> may have a dependency on <code>resource1</code>, so it's disposed first to ensure that <code>resource1</code> is still available when <code>resource2</code> is disposed.</p> </section><section class="content-section" aria-labelledby="optional_using"> <h3 id="optional_using" class="heading">Optional <code>using</code>
</h3> <p><code>using</code> allows the variable to have value <code>null</code> or <code>undefined</code>, so the resource can be optionally present. This means you don't have to do this:</p> <div class="code-example"><pre data-language="js">function acquireResource() {
  // Imagine some real-world relevant condition here,
  // such as whether there's space to allocate for this resource
  if (Math.random() &lt; 0.5) {
    return null;
  }
  return new Resource();
}

const maybeResource = acquireResource();

if (maybeResource) {
  using resource = maybeResource;
  console.log(resource.getValue());
} else {
  console.log(undefined);
}
</pre></div> <p>But can do this:</p> <div class="code-example"><pre data-language="js">using resource = acquireResource();
console.log(resource?.getValue());
</pre></div> </section><section class="content-section" aria-labelledby="using_declaration_without_using_the_variable"> <h3 id="using_declaration_without_using_the_variable" class="heading">
<code>using</code> declaration without using the variable</h3> <p>You can achieve automatic resource disposing using <code>using</code>, without even using the variable. This is very useful for setting up a context within a block, such as creating a lock:</p> <div class="code-example"><pre data-language="js">{
  using _ = new Lock();
  // Perform concurrent operations here
  // Lock disposed (released) here
}
</pre></div> <p>Note that <code>_</code> is a normal identifier, but it's a convention to use it as a "throwaway" variable. To create multiple unused variables, you need to use distinct names, for example by using a variable name prefixed with <code>_</code>.</p> </section><section class="content-section" aria-labelledby="initialization_and_temporal_dead_zones"> <h3 id="initialization_and_temporal_dead_zones" class="heading">Initialization and temporal dead zones</h3> <p><code>using</code> variables are subject to the same <a href="let#temporal_dead_zone_tdz">temporal dead zone</a> restriction as <code>let</code> and <code>const</code> variables. This means that you can't access the variable before the initialization—the valid lifetime of the resource is strictly from its initialization to the end of its scope. This is enables <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization" target="_blank">RAII</a>-style resource management.</p> <div class="code-example"><pre data-language="js">let useResource;
{
  useResource = () =&gt; resource.getValue();
  useResource(); // Error: Cannot access 'resource' before initialization
  using resource = new Resource();
  useResource(); // Valid
}
useResource(); // Error: Resource is disposed
</pre></div> </section><section class="content-section" aria-labelledby="error_handling"> <h3 id="error_handling" class="heading">Error handling</h3> <p>The <code>using</code> declaration is the most useful for managing resource disposal in the presence of errors. If you are not careful, some resources may leak because the error prevents code afterwards from executing.</p> <div class="code-example"><pre data-language="js">function handleResource(resource) {
  if (resource.getValue() &gt; 0.5) {
    throw new Error("Resource value too high");
  }
}

try {
  using resource = new Resource();
  handleResource(resource);
} catch (e) {
  console.error(e);
}
</pre></div> <p>This will successfully catch the error thrown by <code>handleResource</code> and log it, and no matter if <code>handleResource</code> throws an error or not, the resource is disposed before exiting the <code>try</code> block.</p> <p>Here, if you don't use <code>using</code>, you may do something like:</p> <div class="code-example"><pre data-language="js">try {
  const resource = new Resource();
  handleResource(resource);
  resource[Symbol.dispose]();
} catch (e) {
  console.error(e);
}
</pre></div> <p>But, if <code>handleResource()</code> throws an error, then control never reaches <code>resource[Symbol.dispose]()</code>, and the resource is leaked. Furthermore, if you have two resources, then errors thrown in earlier disposals may prevent later disposals from running, leading to more leaks.</p> <p>Consider a more complicated case where the disposer itself throws an error:</p> <div class="code-example"><pre data-language="js">class CantDisposeMe {
  #name;
  constructor(name) {
    this.#name = name;
  }
  [Symbol.dispose]() {
    throw new Error(`Can't dispose ${this.#name}`);
  }
}

let error;

try {
  using resource1 = new CantDisposeMe("resource1");
  using resource2 = new CantDisposeMe("resource2");
  throw new Error("Error in main block");
} catch (e) {
  error = e;
}
</pre></div> <p>You can inspect the error thrown in your browser's console. It has the following structure:</p> <pre data-language="plain">SuppressedError: An error was suppressed during disposal
  suppressed: SuppressedError: An error was suppressed during disposal
    suppressed: Error: Can't dispose resource1
    error: Error: Error in main block
  error: Error: Can't dispose resource2
</pre> <p>As you can see, <code>error</code> contains all the errors that were thrown during disposal, as a <a href="../global_objects/suppressederror"><code>SuppressedError</code></a>. Each additional error is added as the <code>error</code> property, and the original error is added as the <code>suppressed</code> property.</p> </section><section class="content-section" aria-labelledby="specifications"> <h2 id="specifications" class="heading">Specifications</h2> <div class="_table"><table> <thead> <tr> <th scope="col">Specification</th> </tr> </thead> <tbody> <tr> <td><a href="https://tc39.es/proposal-async-explicit-resource-management/#prod-UsingDeclaration" rel="noopener" target="_blank">ECMAScript Async Explicit Resource Management&gt;<br># prod-UsingDeclaration&gt;</a></td> </tr> </tbody> </table></div> </section><section class="content-section" aria-labelledby="browser_compatibility"> <h2 id="browser_compatibility" class="heading">Browser compatibility</h2> <div class="_table"><table>
<thead>
<tr id="bct-browser-type">
<th></th>
<th colspan="5">Desktop</th>
<th colspan="7">Mobile</th>
<th colspan="3">Server</th>
</tr>
<tr id="bct-browsers">
<th></th>
<th>Chrome</th>
<th>Edge</th>
<th>Firefox</th>
<th>Opera</th>
<th>Safari</th>
<th>Chrome Android</th>
<th>Firefox for Android</th>
<th>Opera Android</th>
<th>Safari on IOS</th>
<th>Samsung Internet</th>
<th>WebView Android</th>
<th>WebView on iOS</th>
<th>Bun</th>
<th>Deno</th>
<th>Node.js</th>
</tr>
</thead>
<tbody><tr>
<th><code>using</code></th>
<td class="bc-supports-yes"><abbr title="Release date: 2025-03-04">134</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-03-06">134</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-07-22">141</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-05-13">119</abbr></td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-03-04">134</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-07-22">141</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-03-19">88</abbr></td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-10-25">29.0</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-03-04">134</abbr></td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-yes"><abbr title="Release date: 2024-01-16">1.0.23</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2023-09-20">1.37</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-05-06">24.0.0</abbr></td>
</tr></tbody>
</table></div> </section><section class="content-section" aria-labelledby="see_also"> <h2 id="see_also" class="heading">See also</h2> <ul> <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Resource_management">JavaScript resource management</a></li> <li><a href="const"><code>const</code></a></li> <li><a href="let"><code>let</code></a></li> <li><a href="await_using"><code>await using</code></a></li> <li><a href="../global_objects/symbol/dispose"><code>Symbol.dispose</code></a></li> <li><a href="../global_objects/disposablestack"><code>DisposableStack</code></a></li> </ul> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2025 MDN contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/using" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/using</a>
  </p>
</div>
