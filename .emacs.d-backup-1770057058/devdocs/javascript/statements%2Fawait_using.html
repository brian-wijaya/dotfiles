<mdn-survey></mdn-survey> <h1>await using</h1> <details class="baseline-indicator not" data-glean-toggle-open="baseline_toggle_open"> <summary>  <div class="status-title"> <span class="not-bold">Limited availability</span> </div>   </summary> <div class="extra"> <p>This feature is not Baseline because it does not work in some of the most widely-used browsers.</p> <ul> <li> <a href="https://developer.mozilla.org/en-US/docs/Glossary/Baseline/Compatibility" data-glean-id="baseline_link_learn_more" target="_blank" class="learn-more"> Learn more </a> </li> <li> <a href="#browser_compatibility" data-glean-id="baseline_link_bcd_table"> See full compatibility </a> </li> <li> <a href="https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Fawait_using&amp;level=not" data-glean-id="baseline_link_feedback" class="feedback-link" target="_blank" rel="noreferrer"> Report feedback </a> </li> </ul> </div> </details><section class="content-section"> <p>The <code>await using</code> declaration declares block-scoped local variables that are <em>asynchronously disposed</em>. Like <a href="const"><code>const</code></a>, variables declared with <code>await using</code> must be initialized and cannot be reassigned. The variable's value must be either <code>null</code>, <code>undefined</code>, or an object with a <a href="../global_objects/symbol/asyncdispose"><code>[Symbol.asyncDispose]()</code></a> or <a href="../global_objects/symbol/dispose"><code>[Symbol.dispose]()</code></a> method. When the variable goes out of scope, the <code>[Symbol.asyncDispose]()</code> or <code>[Symbol.dispose]()</code> method of the object is called and awaited, to ensure that resources are freed.</p> </section>    <section class="content-section" aria-labelledby="syntax"> <h2 id="syntax" class="heading">Syntax</h2> <div class="code-example"><pre data-language="js">await using name1 = value1;
await using name1 = value1, name2 = value2;
await using name1 = value1, name2 = value2, /* â€¦, */ nameN = valueN;
</pre></div> <dl> <dt id="namen"><a href="#namen"><code>nameN</code></a></dt> <dd> <p>The name of the variable to declare. Each must be a legal JavaScript <a href="../lexical_grammar#identifiers">identifier</a> and <em>not</em> a <a href="../operators/destructuring">destructuring binding pattern</a>.</p> </dd> <dt id="valuen"><a href="#valuen"><code>valueN</code></a></dt> <dd> <p>Initial value of the variable. It can be any legal expression but its value must be either <code>null</code>, <code>undefined</code>, or an object with a <a href="../global_objects/symbol/asyncdispose"><code>[Symbol.asyncDispose]()</code></a> or <a href="../global_objects/symbol/dispose"><code>[Symbol.dispose]()</code></a> method.</p> </dd> </dl> </section><section class="content-section" aria-labelledby="description"> <h2 id="description" class="heading">Description</h2> <p>This declaration can only be used in places where both <a href="../operators/await"><code>await</code></a> and <a href="using"><code>using</code></a> can be used, which include:</p> <ul> <li>Inside a <a href="block">block</a> (if the block is also in an async context)</li> <li>Inside an <a href="async_function">async function</a> or async generator function body</li> <li>At the top level of a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">module</a>
</li> <li>In the initializer of a <a href="for"><code>for</code></a>, <a href="for...of"><code>for...of</code></a> (if the <code>for</code> loop is also in an async context), or <a href="for-await...of"><code>for await...of</code></a> loop</li> </ul> <p>An <code>await using</code> declares an async disposable resource that's tied to the lifetime of the variable's scope (block, function, module, etc.). When the scope exits, the resource is disposed of asynchronously. Its syntax may be somewhat confusing, because the <code>await</code> does not have an awaiting effect when the variable is first declared, but only when the variable goes out of scope.</p> <p>When a variable is first declared and its value is non-nullish, a <em>disposer</em> is retrieved from the object. The <code>[Symbol.asyncDispose]</code> property is tried first, and falls back to <code>[Symbol.dispose]</code> if <code>[Symbol.asyncDispose]</code> is <code>undefined</code>. If neither property contains a function, a <code>TypeError</code> is thrown. Notably, the <code>[Symbol.dispose]()</code> method is wrapped into a function that looks like <code>async () =&gt; { object[Symbol.dispose](); }</code>, which means if it returns a promise, that promise is <em>not</em> awaited. This disposer is saved to the scope.</p> <p>When the variable goes out of scope, the disposer is called and awaited. If the scope contains multiple <a href="using"><code>using</code></a> or <code>await using</code> declarations, all disposers are run in sequence in the reverse order of declaration, regardless of the type of declaration. All disposers are guaranteed to run (much like the <code>finally</code> block in <a href="try...catch"><code>try...catch...finally</code></a>). All errors thrown during disposal, including the initial error that caused the scope exit (if applicable), are all aggregated inside one <a href="../global_objects/suppressederror"><code>SuppressedError</code></a>, with each earlier exception as the <code>suppressed</code> property and the later exception as the <code>error</code> property. This <code>SuppressedError</code> is thrown after disposal is complete.</p> <p>The variable is allowed to have value <code>null</code> or <code>undefined</code>, so the resource can be optionally present. As long as one <code>await using</code> variable is declared in this scope, at least one <code>await</code> is guaranteed to happen on scope exit, even if the variable actually has value <code>null</code> or <code>undefined</code>. This prevents the disposal from happening synchronously, causing timing issues (see <a href="../operators/await#control_flow_effects_of_await">control flow effects of <code>await</code></a>).</p> <p><code>await using</code> ties resource management to lexical scopes, which is both convenient and sometimes confusing. See below for some examples where it may not behave how you expect. If you want to hand-manage resource disposal, while maintaining the same error handling guarantees, you can use <a href="../global_objects/asyncdisposablestack"><code>AsyncDisposableStack</code></a> instead.</p> </section><section class="content-section" aria-labelledby="examples"> <h2 id="examples" class="heading">Examples</h2> <p>You should also check <a href="using"><code>using</code></a> for more examples, especially some general caveats with respect to scope-based resource management.</p> </section><section class="content-section" aria-labelledby="basic_usage"> <h3 id="basic_usage" class="heading">Basic usage</h3> <p>Usually, you use <code>await using</code> on some library-provided resource that already implements the async disposable protocol. For example, the Node.js <a href="https://nodejs.org/api/fs.html#filehandlesymbolasyncdispose" target="_blank"><code>FileHandle</code></a> is async disposable:</p> <div class="code-example"><pre data-language="js">import fs from "node:fs/promises";

async function example() {
  await using file = await fs.open("example.txt", "r");
  console.log(await file.read());
  // Before `file` goes out of scope, it is disposed by calling `file[Symbol.asyncDispose]()` and awaited.
}
</pre></div> <p>Note that there are two <code>await</code> operations in the declaration for <code>file</code>, which do different things and are both necessary. <code>await fs.open()</code> causes an await during <em>acquisition</em>: it waits for the file to be opened and unwraps the returned promise into a <code>FileHandle</code> object. <code>await using file</code> causes an await during <em>disposal</em>: it makes <code>file</code> disposed asynchronously when the variable goes out of scope.</p> </section><section class="content-section" aria-labelledby="await_using_with_for_await...of"> <h3 id="await_using_with_for_await...of" class="heading">
<code>await using</code> with <code>for await...of</code>
</h3> <p>It's very easy to confuse the following three syntaxes:</p> <ul> <li><code>for await (using x of y) { ... }</code></li> <li><code>for (await using x of y) { ... }</code></li> <li><code>for (using x of await y) { ... }</code></li> </ul> <p>It may be even more confusing to know that they can be used together.</p> <div class="code-example"><pre data-language="js">for await (await using x of await y) {
  // ...
}
</pre></div> <p>First, <code>await y</code> does what you expect: we <a href="../operators/await"><code>await</code></a> the promise <code>y</code>, which is expected to resolve to an object we iterate over. Let us set this variant aside.</p> <p>The <a href="for-await...of"><code>for await...of</code></a> loop requires the <code>y</code> object to be an <em>async iterable</em>. This means that the object must have a <code>[Symbol.asyncIterator]</code> method that returns an <em>async iterator</em>, whose <code>next()</code> method returns a promise representing the result. This is for when the iterable doesn't know what the next value is, or even if it's done yet, until some async operation is complete.</p> <p>On the other hand, the <code>await using x</code> syntax requires the <code>x</code> object, as yielded from the iterable, to be an <em>async disposable</em>. This means that the object must have a <code>[Symbol.asyncDispose]</code> method that returns a promise representing the disposal operation. This is a separate concern from the iteration itself, and is only called when the variable <code>x</code> goes out of scope.</p> <p>In other words, all of the following four combinations are valid and do different things:</p> <ul> <li>
<code>for (using x of y)</code>: <code>y</code> is synchronously iterated, yielding one result at a time, which can be disposed synchronously.</li> <li>
<code>for await (using x of y)</code>: <code>y</code> is asynchronously iterated, yielding one result at a time after awaiting, but the result value can be disposed synchronously.</li> <li>
<code>for (await using x of y)</code>: <code>y</code> is synchronously iterated, yielding one result at a time, but the result value can only be disposed asynchronously.</li> <li>
<code>for await (await using x of y)</code>: <code>y</code> is asynchronously iterated, yielding one result at a time after awaiting, and the result value can only be disposed asynchronously.</li> </ul> <p>Below, we create some fictitious values of <code>y</code> to demonstrate their use cases. For asynchronous APIs, we base our code on the Node.js <a href="https://nodejs.org/api/fs.html#promises-api" target="_blank"><code>fs/promises</code></a> module.</p> <div class="code-example"><pre data-language="js">const syncIterableOfSyncDisposables = [
  stream1.getReader(),
  stream2.getReader(),
];
for (using reader of syncIterableOfSyncDisposables) {
  console.log(reader.read());
}
</pre></div> <div class="code-example"><pre data-language="js">async function* requestMany(urls) {
  for (const url of urls) {
    const res = await fetch(url);
    yield res.body.getReader();
  }
}
const asyncIterableOfSyncDisposables = requestMany([
  "https://example.com",
  "https://example.org",
]);
for await (using reader of asyncIterableOfSyncDisposables) {
  console.log(reader.read());
}
</pre></div> <div class="code-example"><pre data-language="js">const syncIterableOfAsyncDisposables = await Promise.all(
  fs.globSync("*.txt").map((path) =&gt; fs.open(path, "r")),
);
for (await using file of syncIterableOfAsyncDisposables) {
  console.log(await file.read());
}
</pre></div> <div class="code-example"><pre data-language="js">async function* globHandles(pattern) {
  for await (const path of fs.glob(pattern)) {
    yield await fs.open(path, "r");
  }
}
const asyncIterableOfAsyncDisposables = globHandles("*.txt");
for await (await using file of asyncIterableOfAsyncDisposables) {
  console.log(await file.read());
}
</pre></div> </section><section class="content-section" aria-labelledby="implicit_await_on_scope_exit"> <h3 id="implicit_await_on_scope_exit" class="heading">Implicit await on scope exit</h3> <p>As soon as one <code>await using</code> is declared in a scope, the scope will always have an <code>await</code> on exit, even if the variable is <code>null</code> or <code>undefined</code>. This ensures stable execution order and error handling. The <a href="../operators/await#control_flow_effects_of_await">Control flow effects of await</a> examples have more details on this.</p> <p>In the example below, the <code>example()</code> call below doesn't resolve until one tick after, because of an implicit <code>await</code> when the function returns.</p> <div class="code-example"><pre data-language="js">async function example() {
  await using nothing = null;
  console.log("Example call");
}

example().then(() =&gt; console.log("Example done"));
Promise.resolve().then(() =&gt; console.log("Microtask done"));
// Output:
// Example call
// Microtask done
// Example done
</pre></div> <p>Consider the same code but with a synchronous <a href="using"><code>using</code></a> instead. This time, the <code>example()</code> call immediately resolves, so the two <code>then()</code> handlers are called in the same tick.</p> <div class="code-example"><pre data-language="js">async function example() {
  using nothing = null;
  console.log("Example call");
}

example().then(() =&gt; console.log("Example done"));
Promise.resolve().then(() =&gt; console.log("Microtask done"));
// Output:
// Example call
// Example done
// Microtask done
</pre></div> <p>For a more realistic example, consider two concurrent calls to a function:</p> <div class="code-example"><pre data-language="js">class Resource {
  #name;
  constructor(name) {
    this.#name = name;
  }
  async [Symbol.asyncDispose]() {
    console.log(`Disposing resource ${this.#name}`);
  }
}

async function example(id, createOptionalResource) {
  await using required = new Resource(`required ${id}`);
  await using optional = createOptionalResource
    ? new Resource("optional")
    : null;
  await using another = new Resource(`another ${id}`);
}

example(1, true);
example(2, false);
// Output:
// Disposing resource another 1
// Disposing resource another 2
// Disposing resource optional
// Disposing resource required 1
// Disposing resource required 2
</pre></div> <p>As you can see, the <code>required 2</code> resource is disposed in the same tick as <code>required 1</code>. If the <code>optional</code> resource did not cause a redundant <code>await</code>, then <code>required 2</code> would have been disposed earlier, which would be simultaneous with <code>optional</code>.</p> </section><section class="content-section" aria-labelledby="specifications"> <h2 id="specifications" class="heading">Specifications</h2> <div class="_table"><table> <thead> <tr> <th scope="col">Specification</th> </tr> </thead> <tbody> <tr> <td><a href="https://tc39.es/proposal-async-explicit-resource-management/#prod-AwaitUsingDeclaration" rel="noopener" target="_blank">ECMAScript Async Explicit Resource Management&gt;<br># prod-AwaitUsingDeclaration&gt;</a></td> </tr> </tbody> </table></div> </section><section class="content-section" aria-labelledby="browser_compatibility"> <h2 id="browser_compatibility" class="heading">Browser compatibility</h2> <div class="_table"><table>
<thead>
<tr id="bct-browser-type">
<th></th>
<th colspan="5">Desktop</th>
<th colspan="7">Mobile</th>
<th colspan="3">Server</th>
</tr>
<tr id="bct-browsers">
<th></th>
<th>Chrome</th>
<th>Edge</th>
<th>Firefox</th>
<th>Opera</th>
<th>Safari</th>
<th>Chrome Android</th>
<th>Firefox for Android</th>
<th>Opera Android</th>
<th>Safari on IOS</th>
<th>Samsung Internet</th>
<th>WebView Android</th>
<th>WebView on iOS</th>
<th>Bun</th>
<th>Deno</th>
<th>Node.js</th>
</tr>
</thead>
<tbody><tr>
<th><code>await_using</code></th>
<td class="bc-supports-yes"><abbr title="Release date: 2025-03-04">134</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-03-06">134</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-07-22">141</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-05-13">119</abbr></td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-03-04">134</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-07-22">141</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-03-19">88</abbr></td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-10-25">29.0</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2025-03-04">134</abbr></td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-yes"><abbr title="Release date: 2024-01-16">1.0.23</abbr></td>
<td class="bc-supports-no">No</td>
<td class="bc-supports-no">No</td>
</tr></tbody>
</table></div> </section><section class="content-section" aria-labelledby="see_also"> <h2 id="see_also" class="heading">See also</h2> <ul> <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Resource_management">JavaScript resource management</a></li> <li><a href="const"><code>const</code></a></li> <li><a href="let"><code>let</code></a></li> <li><a href="using"><code>using</code></a></li> <li><a href="../global_objects/symbol/asyncdispose"><code>Symbol.asyncDispose</code></a></li> <li><a href="../global_objects/asyncdisposablestack"><code>AsyncDisposableStack</code></a></li> </ul> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2025 MDN contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/await_using" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/await_using</a>
  </p>
</div>
