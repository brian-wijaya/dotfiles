<mdn-survey></mdn-survey> <h1>Optional chaining (?.)</h1> <details class="baseline-indicator high" data-glean-toggle-open="baseline_toggle_open"> <summary>  <div class="status-title"> Baseline <span class="not-bold"> Widely available </span> </div>   </summary> <div class="extra"> <p> This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2020⁩. </p> <ul> <li> <a href="https://developer.mozilla.org/en-US/docs/Glossary/Baseline/Compatibility" data-glean-id="baseline_link_learn_more" target="_blank" class="learn-more"> Learn more </a> </li> <li> <a href="#browser_compatibility" data-glean-id="baseline_link_bcd_table"> See full compatibility </a> </li> <li> <a href="https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FOptional_chaining&amp;level=high" data-glean-id="baseline_link_feedback" class="feedback-link" target="_blank" rel="noreferrer"> Report feedback </a> </li> </ul> </div> </details><section class="content-section"> <p>The <code>?.</code> operator accesses an object's property or calls a function. If the object accessed or function called using this operator is <a href="../global_objects/undefined"><code>undefined</code></a> or <a href="null"><code>null</code></a>, the expression short circuits and evaluates to <a href="../global_objects/undefined"><code>undefined</code></a> instead of throwing an error.</p> </section>    <section class="content-section" aria-labelledby="try_it"> <h2 id="try_it" class="heading">Try it</h2> <interactive-example name="JavaScript Demo: Optional chaining (?.) operator" height="taller"></interactive-example> <div class="code-example"><pre data-language="js">const adventurer = {
  name: "Alice",
  cat: {
    name: "Dinah",
  },
};

const dogName = adventurer.dog?.name;
console.log(dogName);
// Expected output: undefined

console.log(adventurer.someNonExistentMethod?.());
// Expected output: undefined
</pre></div> </section><section class="content-section" aria-labelledby="syntax"> <h2 id="syntax" class="heading">Syntax</h2> <div class="code-example"><pre data-language="js">obj?.prop
obj?.[expr]
func?.(args)
</pre></div> </section><section class="content-section" aria-labelledby="description"> <h2 id="description" class="heading">Description</h2> <p>The <code>?.</code> operator is like the <code>.</code> chaining operator, except that instead of causing an error if a reference is <a href="https://developer.mozilla.org/en-US/docs/Glossary/Nullish">nullish</a> (<a href="null"><code>null</code></a> or <a href="../global_objects/undefined"><code>undefined</code></a>), the expression short-circuits with a return value of <code>undefined</code>. When used with function calls, it returns <code>undefined</code> if the given function does not exist.</p> <p>This results in shorter and simpler expressions when accessing chained properties when the possibility exists that a reference may be missing. It can also be helpful while exploring the content of an object when there's no known guarantee as to which properties are required.</p> <p>For example, consider an object <code>obj</code> which has a nested structure. Without optional chaining, looking up a deeply-nested subproperty requires validating the references in between, such as:</p> <div class="code-example"><pre data-language="js">const nestedProp = obj.first &amp;&amp; obj.first.second;
</pre></div> <p>The value of <code>obj.first</code> is confirmed to be non-<code>null</code> (and non-<code>undefined</code>) before accessing the value of <code>obj.first.second</code>. This prevents the error that would occur if you accessed <code>obj.first.second</code> directly without testing <code>obj.first</code>.</p> <p>This is an idiomatic pattern in JavaScript, but it gets verbose when the chain is long, and it's not safe. For example, if <code>obj.first</code> is a <a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy">Falsy</a> value that's not <code>null</code> or <code>undefined</code>, such as <code>0</code>, it would still short-circuit and make <code>nestedProp</code> become <code>0</code>, which may not be desirable.</p> <p>With the optional chaining operator (<code>?.</code>), however, you don't have to explicitly test and short-circuit based on the state of <code>obj.first</code> before trying to access <code>obj.first.second</code>:</p> <div class="code-example"><pre data-language="js">const nestedProp = obj.first?.second;
</pre></div> <p>By using the <code>?.</code> operator instead of just <code>.</code>, JavaScript knows to implicitly check to be sure <code>obj.first</code> is not <code>null</code> or <code>undefined</code> before attempting to access <code>obj.first.second</code>. If <code>obj.first</code> is <code>null</code> or <code>undefined</code>, the expression automatically short-circuits, returning <code>undefined</code>.</p> <p>This is equivalent to the following, except that the temporary variable is in fact not created:</p> <div class="code-example"><pre data-language="js">const temp = obj.first;
const nestedProp =
  temp === null || temp === undefined ? undefined : temp.second;
</pre></div> <p>Optional chaining cannot be used on a non-declared root object, but can be used with a root object with value <code>undefined</code>.</p> <div class="code-example"><pre data-language="js">undeclaredVar?.prop; // ReferenceError: undeclaredVar is not defined
</pre></div> </section><section class="content-section" aria-labelledby="optional_chaining_with_function_calls"> <h3 id="optional_chaining_with_function_calls" class="heading">Optional chaining with function calls</h3> <p>You can use optional chaining when attempting to call a method which may not exist. This can be helpful, for example, when using an API in which a method might be unavailable, either due to the age of the implementation or because of a feature which isn't available on the user's device.</p> <p>Using optional chaining with function calls causes the expression to automatically return <code>undefined</code> instead of throwing an exception if the method isn't found:</p> <div class="code-example"><pre data-language="js">const result = someInterface.customMethod?.();
</pre></div> <p>However, if there is a property with such a name which is not a function, using <code>?.</code> will still raise a <a href="../global_objects/typeerror"><code>TypeError</code></a> exception "someInterface.customMethod is not a function".</p> <div class="notecard note"> <p><strong>Note:</strong> If <code>someInterface</code> itself is <code>null</code> or <code>undefined</code>, a <a href="../global_objects/typeerror"><code>TypeError</code></a> exception will still be raised ("someInterface is null"). If you expect that <code>someInterface</code> itself may be <code>null</code> or <code>undefined</code>, you have to use <code>?.</code> at this position as well: <code>someInterface?.customMethod?.()</code>.</p> </div> <p><code>eval?.()</code> is the shortest way to enter <a href="../global_objects/eval#direct_and_indirect_eval"><em>indirect eval</em></a> mode.</p> </section><section class="content-section" aria-labelledby="optional_chaining_with_expressions"> <h3 id="optional_chaining_with_expressions" class="heading">Optional chaining with expressions</h3> <p>You can also use the optional chaining operator with <a href="property_accessors#bracket_notation">bracket notation</a>, which allows passing an expression as the property name:</p> <div class="code-example"><pre data-language="js">const propName = "x";
const nestedProp = obj?.[propName];
</pre></div> <p>This is particularly useful for arrays, since array indices must be accessed with square brackets.</p> <div class="code-example"><pre data-language="js">function printMagicIndex(arr) {
  console.log(arr?.[42]);
}

printMagicIndex([0, 1, 2, 3, 4, 5]); // undefined
printMagicIndex(); // undefined; if not using ?., this would throw an error: "Cannot read properties of undefined (reading '42')"
</pre></div> </section><section class="content-section" aria-labelledby="invalid_optional_chaining"> <h3 id="invalid_optional_chaining" class="heading">Invalid optional chaining</h3> <p>It is invalid to try to assign to the result of an optional chaining expression:</p> <div class="code-example"><pre data-language="js">const object = {};
object?.property = 1; // SyntaxError: Invalid left-hand side in assignment
</pre></div> <p><a href="../template_literals#tagged_templates">Template literal tags</a> cannot be an optional chain (see <a href="../errors/bad_optional_template">SyntaxError: tagged template cannot be used with optional chain</a>):</p> <div class="code-example"><pre data-language="js">String?.raw`Hello, world!`;
String.raw?.`Hello, world!`; // SyntaxError: Invalid tagged template on optional chain
</pre></div> <p>The constructor of <a href="new"><code>new</code></a> expressions cannot be an optional chain (see <a href="../errors/bad_new_optional">SyntaxError: new keyword cannot be used with an optional chain</a>):</p> <div class="code-example"><pre data-language="js">new Intl?.DateTimeFormat(); // SyntaxError: Invalid optional chain from new expression
new Map?.();
</pre></div> </section><section class="content-section" aria-labelledby="short-circuiting"> <h3 id="short-circuiting" class="heading">Short-circuiting</h3> <p>When using optional chaining with expressions, if the left operand is <code>null</code> or <code>undefined</code>, the expression will not be evaluated. For instance:</p> <div class="code-example"><pre data-language="js">const potentiallyNullObj = null;
let x = 0;
const prop = potentiallyNullObj?.[x++];

console.log(x); // 0 as x was not incremented
</pre></div> <p>Subsequent property accesses will not be evaluated either.</p> <div class="code-example"><pre data-language="js">const potentiallyNullObj = null;
const prop = potentiallyNullObj?.a.b;
// This does not throw, because evaluation has already stopped at
// the first optional chain
</pre></div> <p>This is equivalent to:</p> <div class="code-example"><pre data-language="js">const potentiallyNullObj = null;
const prop =
  potentiallyNullObj === null || potentiallyNullObj === undefined
    ? undefined
    : potentiallyNullObj.a.b;
</pre></div> <p>However, this short-circuiting behavior only happens along one continuous "chain" of property accesses. If you <a href="grouping">group</a> one part of the chain, then subsequent property accesses will still be evaluated.</p> <div class="code-example"><pre data-language="js">const potentiallyNullObj = null;
const prop = (potentiallyNullObj?.a).b;
// TypeError: Cannot read properties of undefined (reading 'b')
</pre></div> <p>This is equivalent to:</p> <div class="code-example"><pre data-language="js">const potentiallyNullObj = null;
const temp = potentiallyNullObj?.a;
const prop = temp.b;
</pre></div> <p>Except the <code>temp</code> variable isn't created.</p> </section><section class="content-section" aria-labelledby="examples"> <h2 id="examples" class="heading">Examples</h2> &gt; </section><section class="content-section" aria-labelledby="basic_example"> <h3 id="basic_example" class="heading">Basic example</h3> <p>This example looks for the value of the <code>name</code> property for the member <code>CSS</code> in a map when there is no such member. The result is therefore <code>undefined</code>.</p> <div class="code-example"><pre data-language="js">const myMap = new Map();
myMap.set("JS", { name: "Josh", desc: "I maintain things" });

const nameBar = myMap.get("CSS")?.name;
</pre></div> </section><section class="content-section" aria-labelledby="dealing_with_optional_callbacks_or_event_handlers"> <h3 id="dealing_with_optional_callbacks_or_event_handlers" class="heading">Dealing with optional callbacks or event handlers</h3> <p>If you use callbacks or fetch methods from an object with a <a href="destructuring#object_destructuring">destructuring</a> pattern, you may have non-existent values that you cannot call as functions unless you have tested their existence. Using <code>?.</code>, you can avoid this extra test:</p> <div class="code-example"><pre data-language="js">// Code written without optional chaining
function doSomething(onContent, onError) {
  try {
    // Do something with the data
  } catch (err) {
    // Testing if onError really exists
    if (onError) {
      onError(err.message);
    }
  }
}
</pre></div> <div class="code-example"><pre data-language="js">// Using optional chaining with function calls
function doSomething(onContent, onError) {
  try {
    // Do something with the data
  } catch (err) {
    onError?.(err.message); // No exception if onError is undefined
  }
}
</pre></div> </section><section class="content-section" aria-labelledby="stacking_the_optional_chaining_operator"> <h3 id="stacking_the_optional_chaining_operator" class="heading">Stacking the optional chaining operator</h3> <p>With nested structures, it is possible to use optional chaining multiple times:</p> <div class="code-example"><pre data-language="js">const customer = {
  name: "Carl",
  details: {
    age: 82,
    location: "Paradise Falls", // Detailed address is unknown
  },
};
const customerCity = customer.details?.address?.city;

// This also works with optional chaining function call
const customerName = customer.name?.getName?.(); // Method does not exist, customerName is undefined
</pre></div> </section><section class="content-section" aria-labelledby="combining_with_the_nullish_coalescing_operator"> <h3 id="combining_with_the_nullish_coalescing_operator" class="heading">Combining with the nullish coalescing operator</h3> <p>The <a href="nullish_coalescing">nullish coalescing operator</a> may be used after optional chaining in order to build a default value when none was found:</p> <div class="code-example"><pre data-language="js">function printCustomerCity(customer) {
  const customerCity = customer?.city ?? "Unknown city";
  console.log(customerCity);
}

printCustomerCity({
  name: "Nathan",
  city: "Paris",
}); // "Paris"
printCustomerCity({
  name: "Carl",
  details: { age: 82 },
}); // "Unknown city"
</pre></div> </section><section class="content-section" aria-labelledby="specifications"> <h2 id="specifications" class="heading">Specifications</h2> <div class="_table"><table> <thead> <tr> <th scope="col">Specification</th> </tr> </thead> <tbody> <tr> <td><a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-OptionalExpression" rel="noopener" target="_blank">ECMAScript® 2026 Language Specification&gt;<br># prod-OptionalExpression&gt;</a></td> </tr> </tbody> </table></div> </section><section class="content-section" aria-labelledby="browser_compatibility"> <h2 id="browser_compatibility" class="heading">Browser compatibility</h2> <div class="_table"><table>
<thead>
<tr id="bct-browser-type">
<th></th>
<th colspan="5">Desktop</th>
<th colspan="7">Mobile</th>
<th colspan="3">Server</th>
</tr>
<tr id="bct-browsers">
<th></th>
<th>Chrome</th>
<th>Edge</th>
<th>Firefox</th>
<th>Opera</th>
<th>Safari</th>
<th>Chrome Android</th>
<th>Firefox for Android</th>
<th>Opera Android</th>
<th>Safari on IOS</th>
<th>Samsung Internet</th>
<th>WebView Android</th>
<th>WebView on iOS</th>
<th>Bun</th>
<th>Deno</th>
<th>Node.js</th>
</tr>
</thead>
<tbody><tr>
<th><code>Optional_chaining</code></th>
<td class="bc-supports-yes"><abbr title="Release date: 2020-02-04">80</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-02-07">80</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-03-10">74</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-03-03">67</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-03-24">13.1</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-02-04">80</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-07-28">79</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-03-30">57</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-03-24">13.4</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-12-02">13.0</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-02-04">80</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-03-24">13.4</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2023-09-08">1.0.0</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-05-13">1.0</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-04-21">14.0.0</abbr></td>
</tr></tbody>
</table></div> </section><section class="content-section" aria-labelledby="see_also"> <h2 id="see_also" class="heading">See also</h2> <ul> <li><a href="nullish_coalescing">Nullish coalescing operator (<code>??</code>)</a></li> </ul> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2025 MDN contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining</a>
  </p>
</div>
