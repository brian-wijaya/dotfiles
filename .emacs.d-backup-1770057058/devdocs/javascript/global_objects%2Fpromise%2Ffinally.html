<mdn-survey></mdn-survey> <h1>Promise.prototype.finally()</h1> <details class="baseline-indicator high" data-glean-toggle-open="baseline_toggle_open"> <summary>  <div class="status-title"> Baseline <span class="not-bold"> Widely available </span> </div>   </summary> <div class="extra"> <p> This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨October 2018⁩. </p> <ul> <li> <a href="https://developer.mozilla.org/en-US/docs/Glossary/Baseline/Compatibility" data-glean-id="baseline_link_learn_more" target="_blank" class="learn-more"> Learn more </a> </li> <li> <a href="#browser_compatibility" data-glean-id="baseline_link_bcd_table"> See full compatibility </a> </li> <li> <a href="https://survey.alchemer.com/s3/7634825/MDN-baseline-feedback?page=%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FPromise%2Ffinally&amp;level=high" data-glean-id="baseline_link_feedback" class="feedback-link" target="_blank" rel="noreferrer"> Report feedback </a> </li> </ul> </div> </details><section class="content-section"> <p>The <code>finally()</code> method of <a href="../promise"><code>Promise</code></a> instances schedules a function to be called when the promise is settled (either fulfilled or rejected). It immediately returns another <a href="../promise"><code>Promise</code></a> object, allowing you to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises#chaining">chain</a> calls to other promise methods.</p> <p>Like the <a href="../../statements/try...catch#the_finally_block"><code>finally</code></a> block, this method is usually intended for cleanup actions, regardless of the promise's outcome. It lets you avoid duplicating code in both the promise's <a href="then"><code>then()</code></a> and <a href="catch"><code>catch()</code></a> handlers.</p> </section>    <section class="content-section" aria-labelledby="try_it"> <h2 id="try_it" class="heading">Try it</h2> <interactive-example name="JavaScript Demo: Promise.prototype.finally()" height="taller"></interactive-example> <div class="code-example"><pre data-language="js">function checkMail() {
  return new Promise((resolve, reject) =&gt; {
    if (Math.random() &gt; 0.5) {
      resolve("Mail has arrived");
    } else {
      reject(new Error("Failed to arrive"));
    }
  });
}

checkMail()
  .then((mail) =&gt; {
    console.log(mail);
  })
  .catch((err) =&gt; {
    console.error(err);
  })
  .finally(() =&gt; {
    console.log("Experiment completed");
  });
</pre></div> </section><section class="content-section" aria-labelledby="syntax"> <h2 id="syntax" class="heading">Syntax</h2> <div class="code-example"><pre data-language="js">promiseInstance.finally(onFinally)
</pre></div> </section><section class="content-section" aria-labelledby="parameters"> <h3 id="parameters" class="heading">Parameters</h3> <dl> <dt id="onfinally"><a href="#onfinally"><code>onFinally</code></a></dt> <dd> <p>A function to asynchronously execute when this promise becomes settled. If the function returns a promise, the resulting promise will wait for that promise to settle before continuing. If the returned promise is rejected, the resulting promise is rejected with the same reason. Any other returned value, or the fulfilled value of the returned promise, is ignored.</p> </dd> </dl> </section><section class="content-section" aria-labelledby="return_value"> <h3 id="return_value" class="heading">Return value</h3> <p>Returns a new <a href="../promise"><code>Promise</code></a> immediately. This new promise is always pending when returned, regardless of the current promise's status. If <code>onFinally</code> throws an error or returns a rejected promise, the new promise will reject with that value. Otherwise, the new promise will settle with the same state as the current promise.</p> </section><section class="content-section" aria-labelledby="description"> <h2 id="description" class="heading">Description</h2> <p>The <code>finally()</code> method can be useful if you want to do some processing or cleanup once the promise is settled, regardless of its outcome.</p> <p>The <code>finally()</code> method is very similar to calling <a href="then"><code>then(onFinally, onFinally)</code></a>. However, there are a couple of differences:</p> <ul> <li>When creating a function inline, you can pass it once, instead of being forced to either declare it twice, or create a variable for it.</li> <li>The <code>onFinally</code> callback does not receive any argument. This use case is for precisely when you <em>do not care</em> about the rejection reason or the fulfillment value, and so there's no need to provide it.</li> <li>A <code>finally()</code> call is usually transparent and reflects the eventual state of the original promise. So for example: <ul> <li>Unlike <code>Promise.resolve(2).then(() =&gt; 77, () =&gt; 77)</code>, which returns a promise eventually fulfilled with the value <code>77</code>, <code>Promise.resolve(2).finally(() =&gt; 77)</code> returns a promise eventually fulfilled with the value <code>2</code>.</li> <li>Similarly, unlike <code>Promise.reject(3).then(() =&gt; 88, () =&gt; 88)</code>, which returns a promise eventually fulfilled with the value <code>88</code>, <code>Promise.reject(3).finally(() =&gt; 88)</code> returns a promise eventually rejected with the reason <code>3</code>.</li> </ul> </li> </ul> <div class="notecard note"> <p><strong>Note:</strong> A <code>throw</code> (or returning a rejected promise) in the <code>finally</code> callback still rejects the returned promise. For example, both <code>Promise.reject(3).finally(() =&gt; { throw 99; })</code> and <code>Promise.reject(3).finally(() =&gt; Promise.reject(99))</code> reject the returned promise with the reason <code>99</code>.</p> </div> <p>Like <a href="catch"><code>catch()</code></a>, <code>finally()</code> internally calls the <code>then</code> method on the object upon which it was called. If <code>onFinally</code> is not a function, <code>then()</code> is called with <code>onFinally</code> as both arguments — which, for <a href="then"><code>Promise.prototype.then()</code></a>, means that no useful handler is attached. Otherwise, <code>then()</code> is called with two internally created functions, which behave like the following:</p> <div class="notecard warning"> <p><strong>Warning:</strong> This is only for demonstration purposes and is not a polyfill.</p> </div> <div class="code-example"><pre data-language="js">promise.then(
  (value) =&gt; Promise.resolve(onFinally()).then(() =&gt; value),
  (reason) =&gt;
    Promise.resolve(onFinally()).then(() =&gt; {
      throw reason;
    }),
);
</pre></div> <p>Because <code>finally()</code> calls <code>then()</code>, it supports subclassing. Moreover, notice the <a href="resolve"><code>Promise.resolve()</code></a> call above — in reality, <code>onFinally()</code>'s return value is resolved using the same algorithm as <code>Promise.resolve()</code>, but the actual constructor used to construct the resolved promise will be the subclass. <code>finally()</code> gets this constructor through <a href="symbol.species"><code>promise.constructor[Symbol.species]</code></a>.</p> </section><section class="content-section" aria-labelledby="examples"> <h2 id="examples" class="heading">Examples</h2> &gt; </section><section class="content-section" aria-labelledby="using_finally"> <h3 id="using_finally" class="heading">Using finally()</h3> <div class="code-example"><pre data-language="js">let isLoading = true;

fetch(myRequest)
  .then((response) =&gt; {
    const contentType = response.headers.get("content-type");
    if (contentType &amp;&amp; contentType.includes("application/json")) {
      return response.json();
    }
    throw new TypeError("Oops, we haven't got JSON!");
  })
  .then((json) =&gt; {
    /* process your JSON further */
  })
  .catch((error) =&gt; {
    console.error(error); // this line can also throw, e.g. when console = {}
  })
  .finally(() =&gt; {
    isLoading = false;
  });
</pre></div> </section><section class="content-section" aria-labelledby="specifications"> <h2 id="specifications" class="heading">Specifications</h2> <div class="_table"><table> <thead> <tr> <th scope="col">Specification</th> </tr> </thead> <tbody> <tr> <td><a href="https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-promise.prototype.finally" rel="noopener" target="_blank">ECMAScript® 2026 Language Specification&gt;<br># sec-promise.prototype.finally&gt;</a></td> </tr> </tbody> </table></div> </section><section class="content-section" aria-labelledby="browser_compatibility"> <h2 id="browser_compatibility" class="heading">Browser compatibility</h2> <div class="_table"><table>
<thead>
<tr id="bct-browser-type">
<th></th>
<th colspan="5">Desktop</th>
<th colspan="7">Mobile</th>
<th colspan="3">Server</th>
</tr>
<tr id="bct-browsers">
<th></th>
<th>Chrome</th>
<th>Edge</th>
<th>Firefox</th>
<th>Opera</th>
<th>Safari</th>
<th>Chrome Android</th>
<th>Firefox for Android</th>
<th>Opera Android</th>
<th>Safari on IOS</th>
<th>Samsung Internet</th>
<th>WebView Android</th>
<th>WebView on iOS</th>
<th>Bun</th>
<th>Deno</th>
<th>Node.js</th>
</tr>
</thead>
<tbody><tr>
<th><code>finally</code></th>
<td class="bc-supports-yes"><abbr title="Release date: 2017-12-06">63</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2018-10-02">18</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2018-01-23">58</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2018-01-04">50</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2018-04-12">11.1</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2017-12-05">63</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2018-01-22">58</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2018-05-14">46</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2018-03-29">11.3</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2018-07-18">8.0</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2017-12-05">63</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2018-03-29">11.3</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2023-09-08">1.0.0</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2020-05-13">1.0</abbr></td>
<td class="bc-supports-yes"><abbr title="Release date: 2018-04-24">10.0.0</abbr></td>
</tr></tbody>
</table></div> </section><section class="content-section" aria-labelledby="see_also"> <h2 id="see_also" class="heading">See also</h2> <ul> <li><a href="https://github.com/zloirock/core-js#ecmascript-promise" target="_blank">Polyfill of <code>Promise.prototype.finally</code> in <code>core-js</code></a></li> <li><a href="https://www.npmjs.com/package/promise.prototype.finally" target="_blank">es-shims polyfill of <code>Promise.prototype.finally</code></a></li> <li><a href="../promise"><code>Promise</code></a></li> <li><a href="then"><code>Promise.prototype.then()</code></a></li> <li><a href="catch"><code>Promise.prototype.catch()</code></a></li> </ul> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2025 MDN contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally</a>
  </p>
</div>
