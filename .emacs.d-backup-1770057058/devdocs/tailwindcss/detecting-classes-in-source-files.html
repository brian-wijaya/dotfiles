<h1 data-title="true">Detecting classes in source files</h1>
<div hidden=""></div>
<template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div><div><div>
<div><div><div><div></div></div></div></div>
<div></div>
<div>
<div hidden=""></div>
<div><div>
<p data-description="true">Understanding and customizing how Tailwind scans your source files.</p>
<div data-content="true">
<h2 id="overview">Overview</h2> <p>Tailwind works by scanning your project for utility classes, then generating all of the necessary CSS based on the classes you've actually used.</p> <p>This makes sure your CSS is as small as possible, and is also what makes features like <a href="adding-custom-styles#using-arbitrary-values">arbitrary values</a> possible.</p> <h3 id="how-classes-are-detected">How classes are detected</h3> <p>Tailwind treats all of your source files as plain text, and doesn't attempt to actually parse your files as code in any way.</p> <p>Instead it just looks for any tokens in your file that could be classes based on which characters Tailwind is expecting in class names:</p> <div><div><div><div><pre style="background-color:transparent;color:var(--color-slate-50)" tabindex="0" data-language="jsx">export function Button({ color, children }) {
  const colors = {
    black: "bg-black text-white",
    blue: "bg-blue-500 text-white",
    white: "bg-white text-black",
  };

  return (
    &lt;button className={`${colors[color]} rounded-full px-2 py-1.5 font-sans text-sm/6 font-medium shadow`}&gt;
      {children}
    &lt;/button&gt;
  );
}
</pre></div></div></div></div> <p>Then it tries to generate the CSS for all of these tokens, throwing away any tokens that don't map to a utility class the framework knows about.</p> <h3 id="dynamic-class-names">Dynamic class names</h3> <p>Since Tailwind scans your source files as plain text, it has no way of understanding string concatenation or interpolation in the programming language you're using.</p> <div>
<div></div>
<p>Don't construct class names dynamically</p>
</div> <div><div><div><div><pre style="background-color:transparent;color:var(--color-slate-50)" tabindex="0" data-language="html">&lt;div class="text-{{ error ? 'red' : 'green' }}-600"&gt;&lt;/div&gt;
</pre></div></div></div></div> <p>In the example above, the strings <code>text-red-600</code> and <code>text-green-600</code> do not exist, so Tailwind will not generate those classes.</p> <p>Instead, make sure any class names you’re using exist in full:</p> <div>
<div></div>
<p>Always use complete class names</p>
</div> <div><div><div><div><pre style="background-color:transparent;color:var(--color-slate-50)" tabindex="0" data-language="html">&lt;div class="{{ error ? 'text-red-600' : 'text-green-600' }}"&gt;&lt;/div&gt;
</pre></div></div></div></div> <p>If you're using a component library like React or Vue, this means you shouldn't use props to dynamically construct classes:</p> <div>
<div></div>
<p>Don't use props to build class names dynamically</p>
</div> <div><div><div><div><pre style="background-color:transparent;color:var(--color-slate-50)" tabindex="0" data-language="jsx">function Button({ color, children }) {
  return &lt;button className={`bg-${color}-600 hover:bg-${color}-500 ...`}&gt;{children}&lt;/button&gt;;
}
</pre></div></div></div></div> <p>Instead, map props to complete class names that are statically detectable at build-time:</p> <div>
<div></div>
<p>Always map props to static class names</p>
</div> <div><div><div><div><pre style="background-color:transparent;color:var(--color-slate-50)" tabindex="0" data-language="jsx">function Button({ color, children }) {
  const colorVariants = {
    blue: "bg-blue-600 hover:bg-blue-500",
    red: "bg-red-600 hover:bg-red-500",
  };

  return &lt;button className={`${colorVariants[color]} ...`}&gt;{children}&lt;/button&gt;;
}
</pre></div></div></div></div> <p>This has the added benefit of letting you map different prop values to different color shades for example:</p> <div><div><div><div><pre style="background-color:transparent;color:var(--color-slate-50)" tabindex="0" data-language="jsx">function Button({ color, children }) {
  const colorVariants = {
    blue: "bg-blue-600 hover:bg-blue-500 text-white",
    red: "bg-red-500 hover:bg-red-400 text-white",
    yellow: "bg-yellow-300 hover:bg-yellow-400 text-black",
  };

  return &lt;button className={`${colorVariants[color]} ...`}&gt;{children}&lt;/button&gt;;
}
</pre></div></div></div></div> <p>As long as you always use complete class names in your code, Tailwind will generate all of your CSS perfectly every time.</p> <h3 id="which-files-are-scanned">Which files are scanned</h3> <p>Tailwind will scan every file in your project for class names, except in the following cases:</p> <ul> <li>Files that are in your <code>.gitignore</code> file</li> <li>Files in the <code>node_modules</code> directory</li> <li>Binary files like images, videos, or zip files</li> <li>CSS files</li> <li>Common package manager lock files</li> </ul> <p>If you need to scan any files that Tailwind is ignoring by default, you can <a href="#explicitly-registering-sources">explicitly register</a> those sources.</p> <h2 id="explicitly-registering-sources">Explicitly registering sources</h2> <p>Use <code>@source</code> to explicitly register source paths relative to the stylesheet:</p> <div><div><div><div><pre style="background-color:transparent;color:var(--color-slate-50)" tabindex="0" data-language="css">@import "tailwindcss";
@source "../node_modules/@acmecorp/ui-lib";
</pre></div></div></div></div> <p>This is especially useful when you need to scan an external library that is built with Tailwind, since dependencies are usually listed in your <code>.gitignore</code> file and ignored by Tailwind by default.</p> <h3 id="setting-your-base-path">Setting your base path</h3> <p>Tailwind uses the current working directory as its starting point when scanning for class names by default.</p> <p>To set the base path for source detection explicitly, use the <code>source()</code> function when importing Tailwind in your CSS:</p> <div><div><div><div><pre style="background-color:transparent;color:var(--color-slate-50)" tabindex="0" data-language="css">@import "tailwindcss" source("../src");
</pre></div></div></div></div> <p>This can be useful when working with monorepos where your build commands run from the root of the monorepo instead of the root of each project.</p> <h3 id="ignoring-specific-paths">Ignoring specific paths</h3> <p>Use <code>@source not</code> to ignore specific paths, relative to the stylesheet, when scanning for class names:</p> <div><div><div><div><pre style="background-color:transparent;color:var(--color-slate-50)" tabindex="0" data-language="css">@import "tailwindcss";
@source not "../src/components/legacy";
</pre></div></div></div></div> <p>This is useful when you have large directories in your project that you know don't use Tailwind classes, like legacy components or third-party libraries.</p> <h3 id="disabling-automatic-detection">Disabling automatic detection</h3> <p>Use <code>source(none)</code> to completely disable automatic source detection if you want to register all of your sources explicitly:</p> <div><div><div><div><pre style="background-color:transparent;color:var(--color-slate-50)" tabindex="0" data-language="css">@import "tailwindcss" source(none);

@source "../admin";
@source "../shared";
</pre></div></div></div></div> <p>This can be useful in projects that have multiple Tailwind stylesheets where you want to make sure each one only includes the classes each stylesheet needs.</p> <h2 id="safelisting-specific-utilities">Safelisting specific utilities</h2> <p>If you need to make sure Tailwind generates certain class names that don’t exist in your content files, use <code>@source inline()</code> to force them to be generated:</p> <div data-stack="true"><div>
<div><div><div><div><pre style="background-color:transparent;color:var(--color-slate-50)" tabindex="0" data-language="css">@import "tailwindcss";
@source inline("underline");
</pre></div></div></div></div>
<div><div><div><div><pre style="background-color:transparent;color:var(--color-slate-50)" tabindex="0" data-language="css">.underline {
  text-decoration: underline;
}
</pre></div></div></div></div>
</div></div> <h3 id="safelisting-variants">Safelisting variants</h3> <p>You can also use <code>@source inline()</code> to generate classes with variants. For example, to generate the <code>underline</code> class with hover and focus variants, add <code>{hover:,focus:,}</code> to the source input:</p> <div data-stack="true"><div>
<div><div><div><div><pre style="background-color:transparent;color:var(--color-slate-50)" tabindex="0" data-language="css">@import "tailwindcss";
@source inline("{hover:,focus:,}underline");
</pre></div></div></div></div>
<div><div><div><div><pre style="background-color:transparent;color:var(--color-slate-50)" tabindex="0" data-language="css">.underline {
  text-decoration: underline;
}
@media (hover: hover) {
  .hover\:underline:hover {
    text-decoration: underline;
  }
}
@media (focus: focus) {
  .focus\:underline:focus {
    text-decoration: underline;
  }
}
</pre></div></div></div></div>
</div></div> <h3 id="safelisting-with-ranges">Safelisting with ranges</h3> <p>The source input is <a href="https://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html">brace expanded</a>, so you can generate multiple classes at once. For example, to generate all the red background colors with hover variants, use a range:</p> <div data-stack="true"><div>
<div><div><div><div><pre style="background-color:transparent;color:var(--color-slate-50)" tabindex="0" data-language="css">@import "tailwindcss";
@source inline("{hover:,}bg-red-{50,{100..900..100},950}");
</pre></div></div></div></div>
<div><div><div><div><pre style="background-color:transparent;color:var(--color-slate-50)" tabindex="0" data-language="css">.bg-red-50 {
  background-color: var(--color-red-50);
}
.bg-red-100 {
  background-color: var(--color-red-100);
}
.bg-red-200 {
  background-color: var(--color-red-200);
}

/* ... */

.bg-red-800 {
  background-color: var(--color-red-800);
}
.bg-red-900 {
  background-color: var(--color-red-900);
}
.bg-red-950 {
  background-color: var(--color-red-950);
}
@media (hover: hover) {
  .hover\:bg-red-50:hover {
    background-color: var(--color-red-50);
  }

  /* ... */

  .hover\:bg-red-950:hover {
    background-color: var(--color-red-950);
  }
}
</pre></div></div></div></div>
</div></div> <p>This generates red background colors from 100 to 900 in increments of 100, along with the first and last shades of 50 and 950. It also adds the <code>hover:</code> variant for each of those classes.</p> <h3 id="explicitly-excluding-classes">Explicitly excluding classes</h3> <p>Use <code>@source not inline()</code> to prevent specific classes from being generated, even if they are detected in your source files:</p> <div><div><div><div><pre style="background-color:transparent;color:var(--color-slate-50)" tabindex="0" data-language="css">@import "tailwindcss";
@source not inline("{hover:,focus:,}bg-red-{50,{100..900..100},950}");
</pre></div></div></div></div> <p>This will explicitly exclude the red background utilities, along with their hover and focus variants, from being generated.</p>
</div>
</div></div>
</div>
<div></div>
<div></div>
<div></div>
<div></div>
</div></div></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Tailwind Labs Inc.<br>
    <a href="https://tailwindcss.com/docs/detecting-classes-in-source-files" class="_attribution-link">https://tailwindcss.com/docs/detecting-classes-in-source-files</a>
  </p>
</div>
