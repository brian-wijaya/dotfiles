<div id="language.types.callable" class="sect1"> <h2 class="title">Callables</h2> <p class="simpara"> A callable is a reference to a function or method that is passed to another function as an argument. They are represented with the <span class="type"><a href="language.types.callable" class="type callable">callable</a></span> type declaration. </p> <div class="informalexample"> <div class="example-contents"> <pre class="annotation-non-interactive phpcode" data-language="php">&lt;?php
function foo(callable $callback) {
    $callback();
}
?&gt;</pre> </div> </div> <p class="simpara"> Some functions accept callback functions as a parameter, e.g. <span class="function"><a href="function.array-map" class="function">array_map()</a></span>, <span class="function"><a href="function.usort" class="function">usort()</a></span>, or <span class="function"><a href="function.preg-replace-callback" class="function">preg_replace_callback()</a></span>. </p> <div class="sect2" id="language.types.callable.passing"> <h3 class="title">Creation of callables</h3> <p class="simpara"> A callable is a type that represents something that can be invoked. Callables can be passed as arguments to functions or methods which expect a callback parameter or they can be invoked directly. The <span class="type"><a href="language.types.callable" class="type callable">callable</a></span> type cannot be used as a type declaration for class properties. Instead, use a <span class="classname"><a href="class.closure" class="classname">Closure</a></span> type declaration. </p> <p class="simpara"> Callables can be created in several different ways: </p> <ul class="itemizedlist"> <li class="listitem"> <span class="simpara"><span class="classname"><a href="class.closure" class="classname">Closure</a></span> object</span> </li> <li class="listitem"> <span class="simpara"><span class="type"><a href="language.types.string" class="type string">string</a></span> containing the name of a function or a method</span> </li> <li class="listitem"> <span class="simpara"> <span class="type"><a href="language.types.array" class="type array">array</a></span> containing a class name or an <span class="type"><a href="language.types.object" class="type object">object</a></span> in index 0 and the method name in index 1 </span> </li> <li class="listitem"> <span class="simpara"> <span class="type"><a href="language.types.object" class="type object">object</a></span> implementing the <a href="language.oop5.magic#object.invoke" class="link">__invoke()</a> magic method </span> </li> </ul> <p class="simpara"> A <span class="classname"><a href="class.closure" class="classname">Closure</a></span> object can be created using <a href="functions.anonymous" class="link">anonymous function</a> syntax, <a href="functions.arrow" class="link">arrow function</a> syntax, <a href="functions.first_class_callable_syntax" class="link">first-class callable syntax</a>, or the <span class="methodname"><a href="closure.fromcallable" class="methodname">Closure::fromCallable()</a></span> method. </p> <blockquote class="note"><p><strong class="note">Note</strong>: <span class="simpara"> The <a href="functions.first_class_callable_syntax" class="link">first-class callable syntax</a> is only available as of PHP 8.1.0. </span> </p></blockquote> <div class="example" id="example-1"> <p><strong>Example #1 Callback example using a <span class="classname"><a href="class.closure" class="classname">Closure</a></span> </strong></p> <div class="example-contents"> <pre class="annotation-interactive phpcode" data-language="php">&lt;?php
// Using anonymous function syntax
$double1 = function ($a) {
    return $a * 2;
};

// Using first-class callable syntax
function double_function($a) {
    return $a * 2;
}
$double2 = double_function(...);

// Using arrow function syntax
$double3 = fn($a) =&gt; $a * 2;

// Using Closure::fromCallable
$double4 = Closure::fromCallable('double_function');

// Use the closure as a callback here to
// double the size of each element in our range
$new_numbers = array_map($double1, range(1, 5));
print implode(' ', $new_numbers) . PHP_EOL;

$new_numbers = array_map($double2, range(1, 5));
print implode(' ', $new_numbers) . PHP_EOL;

$new_numbers = array_map($double3, range(1, 5));
print implode(' ', $new_numbers) . PHP_EOL;

$new_numbers = array_map($double4, range(1, 5));
print implode(' ', $new_numbers);

?&gt;</pre> </div> <div class="example-contents"><p>Output of the above example in PHP 8.1:</p></div> <div class="example-contents screen"> <div class="annotation-interactive cdata"><pre>
2 4 6 8 10
2 4 6 8 10
2 4 6 8 10
2 4 6 8 10
</pre></div> </div> </div> <p class="simpara"> A callable can also be a string containing the name of a function or a static method. Any built-in or user-defined function can be used, except language constructs such as: <span class="function"><a href="function.array" class="function">array()</a></span>, <span class="function"><a href="function.echo" class="function">echo</a></span>, <span class="function"><a href="function.empty" class="function">empty()</a></span>, <span class="function"><a href="function.eval" class="function">eval()</a></span>, <span class="function"><a href="function.isset" class="function">isset()</a></span>, <span class="function"><a href="function.list" class="function">list()</a></span>, <span class="function"><a href="function.print" class="function">print</a></span> or <span class="function"><a href="function.unset" class="function">unset()</a></span>. </p> <p class="simpara"> Static class methods can be used without instantiating an <span class="type"><a href="language.types.object" class="type object">object</a></span> of that class by either, creating an array with the class name at index 0 and the method name at index 1, or by using the special syntax with the scope resolution operator <code class="literal">::</code>, as in <code class="literal">'ClassName::methodName'</code>. </p> <p class="simpara"> A method of an instantiated <span class="type"><a href="language.types.object" class="type object">object</a></span> can be a callable when provided as an array with the <span class="type"><a href="language.types.object" class="type object">object</a></span> at index 0 and the method name at index 1. </p> <p class="simpara"> The main difference between a <span class="classname"><a href="class.closure" class="classname">Closure</a></span> object and the <span class="type"><a href="language.types.callable" class="type callable">callable</a></span> type is that a <span class="classname"><a href="class.closure" class="classname">Closure</a></span> object is scope-independent and can always be invoked, whereas a callable type may be scope-dependent and may not be directly invoked. <span class="classname"><a href="class.closure" class="classname">Closure</a></span> is the preferred way to create callables. </p> <blockquote class="note"><p><strong class="note">Note</strong>: <span class="simpara"> While <span class="classname"><a href="class.closure" class="classname">Closure</a></span> objects are bound to the scope where they are created, callables referencing class methods as strings or arrays are resolved in the scope where they are called. To create a callable from a private or protected method, which can then be invoked from outside the class scope, use <span class="methodname"><a href="closure.fromcallable" class="methodname">Closure::fromCallable()</a></span> or the <a href="functions.first_class_callable_syntax" class="link">first-class callable syntax</a>. </span> </p></blockquote> <p class="simpara"> PHP allows the creation of callables which can be used as a callback argument but cannot be called directly. These are context-dependent callables which reference a class method in the inheritance hierarchy of a class, e.g. <code class="literal">'parent::method'</code> or <code class="literal">["static", "method"]</code>. </p> <blockquote class="note"><p><strong class="note">Note</strong>: <span class="simpara"> As of PHP 8.2.0, context-dependent callables are deprecated. Remove the context dependency by replacing <code class="literal">'parent::method'</code> with <code class="literal">parent::class . '::method'</code> or use the <a href="functions.first_class_callable_syntax" class="link">first-class callable syntax</a>. </span> </p></blockquote> <div class="example" id="example-2"> <p><strong>Example #2 Calling various types of callables with <span class="function"><strong>call_user_function()</strong></span> </strong></p> <div class="example-contents"> <pre class="annotation-interactive phpcode" data-language="php">&lt;?php

// An example callback function
function my_callback_function() {
    echo 'hello world!', PHP_EOL;
}

// An example callback method
class MyClass {
    static function myCallbackMethod() {
        echo 'Hello World!', PHP_EOL;
    }
}

// Type 1: Simple callback
call_user_func('my_callback_function');

// Type 2: Static class method call
call_user_func(['MyClass', 'myCallbackMethod']);

// Type 3: Object method call
$obj = new MyClass();
call_user_func([$obj, 'myCallbackMethod']);

// Type 4: Static class method call
call_user_func('MyClass::myCallbackMethod');

// Type 5: Static class method call using ::class keyword
call_user_func([MyClass::class, 'myCallbackMethod']);

// Type 6: Relative static class method call
class A {
    public static function who() {
        echo 'A', PHP_EOL;
    }
}

class B extends A {
    public static function who() {
        echo 'B', PHP_EOL;
    }
}

call_user_func(['B', 'parent::who']); // deprecated as of PHP 8.2.0

// Type 7: Objects implementing __invoke can be used as callables
class C {
    public function __invoke($name) {
        echo 'Hello ', $name;
    }
}

$c = new C();
call_user_func($c, 'PHP!');
?&gt;</pre> </div> <div class="example-contents"><p>The above example will output:</p></div> <div class="example-contents screen"> <div class="annotation-interactive cdata"><pre>
hello world!
Hello World!
Hello World!
Hello World!
Hello World!

Deprecated: Callables of the form ["B", "parent::who"] are deprecated in script on line 41
A
Hello PHP!
</pre></div> </div> </div> <blockquote class="note">
<p><strong class="note">Note</strong>: </p>
<p class="para">Callbacks registered with functions such as <span class="function"><a href="function.call-user-func" class="function">call_user_func()</a></span> and <span class="function"><a href="function.call-user-func-array" class="function">call_user_func_array()</a></span> will not be called if there is an uncaught exception thrown in a previous callback.</p>
</blockquote> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1997&ndash;2025 The PHP Documentation Group<br>Licensed under the Creative Commons Attribution License v3.0 or later.<br>
    <a href="https://www.php.net/manual/en/language.types.callable.php" class="_attribution-link">https://www.php.net/manual/en/language.types.callable.php</a>
  </p>
</div>
