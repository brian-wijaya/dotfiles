<h1>Tensor Module</h1>      <div>  <p>This module provides a Tensor class for storing arbitrarily indexed objects.</p> <pre data-language="cpp"><span>#include &lt;Eigen/CXX11/Tensor&gt;</span>
</pre>
<p>Much of the documentation can be found <a href="eigen_tensors">here</a>. </p> <table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensor">Eigen::Tensor&lt; Scalar_, NumIndices_, Options_, IndexType_ &gt;</a></td>
</tr> <tr>
<td> </td>
<td>The tensor class. <a href="classeigen_1_1tensor#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorassign">TensorAssign</a></td>
</tr> <tr>
<td> </td>
<td>The tensor assignment class. <a href="classtensorassign#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorasyncdevice">Eigen::TensorAsyncDevice&lt; ExpressionType, DeviceType, DoneCallback &gt;</a></td>
</tr> <tr>
<td> </td>
<td>Pseudo expression providing an operator = that will evaluate its argument asynchronously on the specified device. Currently only ThreadPoolDevice implements proper asynchronous execution, while the default and GPU devices just run the expression synchronously and call m_done() on completion.. <a href="classeigen_1_1tensorasyncdevice#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorbase">Eigen::TensorBase&lt; Derived, AccessLevel &gt;</a></td>
</tr> <tr>
<td> </td>
<td>The tensor base class. <a href="classeigen_1_1tensorbase#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorbroadcasting">TensorBroadcasting</a></td>
</tr> <tr>
<td> </td>
<td>Tensor broadcasting class. <a href="classtensorbroadcasting#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorconcatenationop">Eigen::TensorConcatenationOp&lt; Axis, LhsXprType, RhsXprType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor" title="The tensor class.">Tensor</a> concatenation class. <a href="classeigen_1_1tensorconcatenationop#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorcontraction">TensorContraction</a></td>
</tr> <tr>
<td> </td>
<td>Tensor contraction class. <a href="classtensorcontraction#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorconversionop">Eigen::TensorConversionOp&lt; TargetType, XprType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor" title="The tensor class.">Tensor</a> conversion class. This class makes it possible to vectorize type casting operations when the number of scalars per packet in the source and the destination type differ. <a href="classeigen_1_1tensorconversionop#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorconvolution">TensorConvolution</a></td>
</tr> <tr>
<td> </td>
<td>Tensor convolution class. <a href="classtensorconvolution#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorcustombinaryop">Eigen::TensorCustomBinaryOp&lt; CustomBinaryFunc, LhsXprType, RhsXprType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor" title="The tensor class.">Tensor</a> custom class. <a href="classeigen_1_1tensorcustombinaryop#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorcustomunaryop">Eigen::TensorCustomUnaryOp&lt; CustomUnaryFunc, XprType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor" title="The tensor class.">Tensor</a> custom class. <a href="classeigen_1_1tensorcustomunaryop#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensordevice">Eigen::TensorDevice&lt; ExpressionType, DeviceType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>Pseudo expression providing an operator = that will evaluate its argument on the specified computing 'device' (GPU, thread pool, ...) <a href="classeigen_1_1tensordevice#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="structeigen_1_1tensorevaluator">Eigen::TensorEvaluator&lt; Derived, Device &gt;</a></td>
</tr> <tr>
<td> </td>
<td>A cost model used to limit the number of threads used for evaluating tensor expression. <a href="structeigen_1_1tensorevaluator#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorexecutor">TensorExecutor</a></td>
</tr> <tr>
<td> </td>
<td>The tensor executor class. <a href="classtensorexecutor#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorexpr">TensorExpr</a></td>
</tr> <tr>
<td> </td>
<td>Tensor expression classes. <a href="classtensorexpr#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorfft">TensorFFT</a></td>
</tr> <tr>
<td> </td>
<td>Tensor FFT class. <a href="classtensorfft#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorfixedsize">Eigen::TensorFixedSize&lt; Scalar_, Dimensions_, Options_, IndexType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>The fixed sized version of the tensor class. <a href="classeigen_1_1tensorfixedsize#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorforcedeval">TensorForcedEval</a></td>
</tr> <tr>
<td> </td>
<td>Tensor reshaping class. <a href="classtensorforcedeval#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorgeneratorop">Eigen::TensorGeneratorOp&lt; Generator, XprType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor" title="The tensor class.">Tensor</a> generator class. <a href="classeigen_1_1tensorgeneratorop#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorimagepatch">TensorImagePatch</a></td>
</tr> <tr>
<td> </td>
<td>Patch extraction specialized for image processing. This assumes that the input has a least 3 dimensions ordered as follow: 1st dimension: channels (of size d) 2nd dimension: rows (of size r) 3rd dimension: columns (of size c) There can be additional dimensions such as time (for video) or batch (for bulk processing after the first 3. Calling the image patch code with patch_rows and patch_cols is equivalent to calling the regular patch extraction code with parameters d, patch_rows, patch_cols, and 1 for all the additional dimensions. <a href="classtensorimagepatch#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorindextuple">TensorIndexTuple</a></td>
</tr> <tr>
<td> </td>
<td>Tensor + Index Tuple class. <a href="classtensorindextuple#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorinflation">TensorInflation</a></td>
</tr> <tr>
<td> </td>
<td>Tensor inflation class. <a href="classtensorinflation#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorkchippingreshaping">TensorKChippingReshaping</a></td>
</tr> <tr>
<td> </td>
<td>A chip is a thin slice, corresponding to a column or a row in a 2-d tensor. <a href="classtensorkchippingreshaping#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorlayoutswap">TensorLayoutSwap</a></td>
</tr> <tr>
<td> </td>
<td>Swap the layout from col-major to row-major, or row-major to col-major, and invert the order of the dimensions. <a href="classtensorlayoutswap#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensormap">Eigen::TensorMap&lt; PlainObjectType, Options_, MakePointer_ &gt;</a></td>
</tr> <tr>
<td> </td>
<td>A tensor expression mapping an existing array of data. <a href="classeigen_1_1tensormap#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorpadding">TensorPadding</a></td>
</tr> <tr>
<td> </td>
<td>Tensor padding class. At the moment only padding with a constant value is supported. <a href="classtensorpadding#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorpatch">TensorPatch</a></td>
</tr> <tr>
<td> </td>
<td>Tensor patch class. <a href="classtensorpatch#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorreduction">TensorReduction</a></td>
</tr> <tr>
<td> </td>
<td>Tensor reduction class. <a href="classtensorreduction#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorref">Eigen::TensorRef&lt; PlainObjectType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>A reference to a tensor expression The expression will be evaluated lazily (as much as possible). <a href="classeigen_1_1tensorref#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorreshaping">TensorReshaping</a></td>
</tr> <tr>
<td> </td>
<td>Tensor reshaping class. <a href="classtensorreshaping#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorreverse">TensorReverse</a></td>
</tr> <tr>
<td> </td>
<td>Tensor reverse elements class. <a href="classtensorreverse#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorscan">TensorScan</a></td>
</tr> <tr>
<td> </td>
<td>Tensor scan class. <a href="classtensorscan#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorshuffling">TensorShuffling</a></td>
</tr> <tr>
<td> </td>
<td>Tensor shuffling class. <a href="classtensorshuffling#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorslicing">TensorSlicing</a></td>
</tr> <tr>
<td> </td>
<td>Tensor slicing class. <a href="classtensorslicing#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorstriding">TensorStriding</a></td>
</tr> <tr>
<td> </td>
<td>Tensor striding class. <a href="classtensorstriding#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensortrace">TensorTrace</a></td>
</tr> <tr>
<td> </td>
<td>Tensor Trace class. <a href="classtensortrace#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensortupleindex">TensorTupleIndex</a></td>
</tr> <tr>
<td> </td>
<td>Converts to Tensor&lt;Tuple&lt;Index, Scalar&gt; &gt; and reduces to Tensor&lt;Index&gt;. <a href="classtensortupleindex#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorvolumepatch">TensorVolumePatch</a></td>
</tr> <tr>
<td> </td>
<td>Patch extraction specialized for processing of volumetric data. This assumes that the input has a least 4 dimensions ordered as follows: <a href="classtensorvolumepatch#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> </table> </div> <div class="_attribution">
  <p class="_attribution-p">
    &copy; Eigen.<br>Licensed under the MPL2 License.<br>
    <a href="https://eigen.tuxfamily.org/dox/unsupported/group__CXX11__Tensor__Module.html" class="_attribution-link">https://eigen.tuxfamily.org/dox/unsupported/group__CXX11__Tensor__Module.html</a>
  </p>
</div>
