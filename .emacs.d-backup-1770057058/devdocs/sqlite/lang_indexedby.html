     <h1 class="fancy_title"> The INDEXED BY Clause </h1>  <h2 id="how_indexed_by_works">
<span>1. </span>How INDEXED BY Works</h2> <p>The INDEXED BY phrase forces the <a href="optoverview">SQLite query planner</a> to use a particular named index on a <a href="lang_delete">DELETE</a>, <a href="lang_select">SELECT</a>, or <a href="lang_update">UPDATE</a> statement. The INDEXED BY phrase is an SQLite extension and is not portable to other SQL database engines.</p> <p><b><a href="syntax/qualified-table-name">qualified-table-name:</a></b> <button id="xa98d816f" class="_btn" data-toggle="xa8511163">hide</button></p> <div id="xa8511163"> <div style="max-width:599px">
<svg xmlns="http://www.w3.org/2000/svg" class="pikchr" viewbox="0 0 599.746 182.736" data-pikchr-date="20250319161943"> <circle cx="5.76" cy="17.28" r="3.6" class="stroke"></circle> <polygon points="45.36,17.28 33.84,21.6 33.84,12.96" class="fill"></polygon> <path d="M9.36,17.28L39.6,17.28" class="stroke"></path> <path d="M60.48,32.4L156.845,32.4A15.12 15.12 0 0 0 171.965 17.28A15.12 15.12 0 0 0 156.845 2.16L60.48,2.16A15.12 15.12 0 0 0 45.36 17.28A15.12 15.12 0 0 0 60.48 32.4Z" class="stroke"></path> <text x="108.662" y="17.28" text-anchor="middle" dominant-baseline="central" class="fill">schema-name</text> <polygon points="195.005,17.28 183.485,21.6 183.485,12.96" class="fill"></polygon> <path d="M171.965,17.28L189.245,17.28" class="stroke"></path> <path d="M210.125,32.4A15.12 15.12 0 0 0 225.245 17.28A15.12 15.12 0 0 0 210.125 2.16A15.12 15.12 0 0 0 195.005 17.28A15.12 15.12 0 0 0 210.125 32.4Z" class="stroke"></path> <text x="210.125" y="17.28" text-anchor="middle" font-weight="bold" dominant-baseline="central" class="fill">.</text> <polygon points="261.245,17.28 249.725,21.6 249.725,12.96" class="fill"></polygon> <path d="M225.245,17.28L255.485,17.28" class="stroke"></path> <path d="M276.365,32.4L351.533,32.4A15.12 15.12 0 0 0 366.653 17.28A15.12 15.12 0 0 0 351.533 2.16L276.365,2.16A15.12 15.12 0 0 0 261.245 17.28A15.12 15.12 0 0 0 276.365 32.4Z" class="stroke"></path> <text x="313.949" y="17.28" text-anchor="middle" dominant-baseline="central" class="fill">table-name</text> <polygon points="408.173,44.496 396.653,48.816 396.653,40.176" class="fill"></polygon> <path d="M366.653,17.28 L 374.153,17.28 Q 381.653,17.28 381.653,30.888 Q 381.653,44.496 392.033,44.496 L 402.413,44.496" class="stroke"></path> <path d="M423.293,59.616L427.267,59.616A15.12 15.12 0 0 0 442.387 44.496L442.387,44.496A15.12 15.12 0 0 0 427.267 29.376L423.293,29.376A15.12 15.12 0 0 0 408.173 44.496L408.173,44.496A15.12 15.12 0 0 0 423.293 59.616Z" class="stroke"></path> <text x="425.28" y="44.496" text-anchor="middle" dominant-baseline="central" class="fill">AS</text> <polygon points="465.427,44.496 453.907,48.816 453.907,40.176" class="fill"></polygon> <path d="M442.387,44.496L459.667,44.496" class="stroke"></path> <path d="M480.547,59.616L501.226,59.616A15.12 15.12 0 0 0 516.346 44.496L516.346,44.496A15.12 15.12 0 0 0 501.226 29.376L480.547,29.376A15.12 15.12 0 0 0 465.427 44.496L465.427,44.496A15.12 15.12 0 0 0 480.547 59.616Z" class="stroke"></path> <text x="490.886" y="44.496" text-anchor="middle" dominant-baseline="central" class="fill">alias</text> <polygon points="539.386,44.496 527.866,48.816 527.866,40.176" class="fill"></polygon> <path d="M516.346,44.496L533.626,44.496" class="stroke"></path> <path d="M539.386,44.496 L 546.886,44.496 Q 554.386,44.496 554.386,51.996 L 554.386,59.496" class="stroke"></path> <polygon points="453.907,17.28 442.387,21.6 442.387,12.96" class="fill"></polygon> <path d="M366.653,17.28L448.147,17.28" class="stroke"></path> <polygon points="108.662,44.496 97.1424,48.816 97.1424,40.176" class="fill"></polygon> <path d="M9.36,17.28 L 16.86,17.28 Q 24.36,17.28 24.36,30.888 Q 24.36,44.496 39.36,44.496 L 87.9024,44.496 L 102.902,44.496" class="stroke"></path> <path d="M108.662,44.496 L 225.245,44.496 Q 240.245,44.496 240.245,30.888 Q 240.245,17.28 247.745,17.28 L 255.245,17.28" class="stroke"></path> <path d="M236.645,142.776L301.214,142.776A15.12 15.12 0 0 0 316.334 127.656A15.12 15.12 0 0 0 301.214 112.536L236.645,112.536A15.12 15.12 0 0 0 221.525 127.656A15.12 15.12 0 0 0 236.645 142.776Z" class="stroke"></path> <text x="268.93" y="127.656" text-anchor="middle" dominant-baseline="central" class="fill">INDEXED</text> <polygon points="339.374,127.656 327.854,131.976 327.854,123.336" class="fill"></polygon> <path d="M316.334,127.656L333.614,127.656" class="stroke"></path> <path d="M354.494,142.776L358.584,142.776A15.12 15.12 0 0 0 373.704 127.656A15.12 15.12 0 0 0 358.584 112.536L354.494,112.536A15.12 15.12 0 0 0 339.374 127.656A15.12 15.12 0 0 0 354.494 142.776Z" class="stroke"></path> <text x="356.539" y="127.656" text-anchor="middle" dominant-baseline="central" class="fill">BY</text> <polygon points="396.744,127.656 385.224,131.976 385.224,123.336" class="fill"></polygon> <path d="M373.704,127.656L390.984,127.656" class="stroke"></path> <path d="M411.864,142.776L490.258,142.776A15.12 15.12 0 0 0 505.378 127.656A15.12 15.12 0 0 0 490.258 112.536L411.864,112.536A15.12 15.12 0 0 0 396.744 127.656A15.12 15.12 0 0 0 411.864 142.776Z" class="stroke"></path> <text x="451.061" y="127.656" text-anchor="middle" dominant-baseline="central" class="fill">index-name</text> <path d="M236.645,180.576L256.747,180.576A15.12 15.12 0 0 0 271.867 165.456A15.12 15.12 0 0 0 256.747 150.336L236.645,150.336A15.12 15.12 0 0 0 221.525 165.456A15.12 15.12 0 0 0 236.645 180.576Z" class="stroke"></path> <text x="246.696" y="165.456" text-anchor="middle" dominant-baseline="central" class="fill">NOT</text> <polygon points="294.907,165.456 283.387,169.776 283.387,161.136" class="fill"></polygon> <path d="M271.867,165.456L289.147,165.456" class="stroke"></path> <path d="M310.027,180.576L374.597,180.576A15.12 15.12 0 0 0 389.717 165.456A15.12 15.12 0 0 0 374.597 150.336L310.027,150.336A15.12 15.12 0 0 0 294.907 165.456A15.12 15.12 0 0 0 310.027 180.576Z" class="stroke"></path> <text x="342.312" y="165.456" text-anchor="middle" dominant-baseline="central" class="fill">INDEXED</text> <polygon points="554.386,74.496 550.066,62.976 558.706,62.976" class="fill"></polygon> <path d="M453.907,17.28 L 539.386,17.28 Q 554.386,17.28 554.386,32.28 L 554.386,53.736 L 554.386,68.736" class="stroke"></path> <polygon points="313.949,89.856 325.469,85.536 325.469,94.176" class="fill"></polygon> <path d="M554.386,74.496 L 554.386,82.176 Q 554.386,89.856 539.386,89.856 L 334.709,89.856 L 319.709,89.856" class="stroke"></path> <polygon points="221.525,127.656 210.005,131.976 210.005,123.336" class="fill"></polygon> <path d="M313.949,89.856 L 210.005,89.856 Q 195.005,89.856 195.005,104.856 L 195.005,112.656 Q 195.005,127.656 205.385,127.656 L 215.765,127.656" class="stroke"></path> <polygon points="221.525,165.456 210.005,169.776 210.005,161.136" class="fill"></polygon> <path d="M195.005,112.536 L 195.005,150.456 Q 195.005,165.456 205.385,165.456 L 215.765,165.456" class="stroke"></path> <polygon points="554.386,114.516 550.066,102.996 558.706,102.996" class="fill"></polygon> <path d="M554.386,74.496L554.386,108.756" class="stroke"></path> <polygon points="590.386,165.456 578.866,169.776 578.866,161.136" class="fill"></polygon> <path d="M554.386,114.516 L 554.386,150.456 Q 554.386,165.456 569.386,165.456 L 569.626,165.456 L 584.626,165.456" class="stroke"></path> <circle cx="593.986" cy="165.456" r="3.6" class="stroke"></circle> <polygon points="539.386,127.656 527.866,131.976 527.866,123.336" class="fill"></polygon> <path d="M505.378,127.656L533.626,127.656" class="stroke"></path> <path d="M539.386,127.656 L 546.886,127.656 Q 554.386,127.656 554.386,135.156 L 554.386,142.656" class="stroke"></path> <path d="M389.717,165.456L578.866,165.456" class="stroke"></path> </svg> </div> </div> <p>The "INDEXED BY <span class="yyterm">index-name</span>" phrase specifies that the named index must be used in order to look up values on the preceding table. If <span class="yyterm">index-name</span> does not exist or cannot be used for the query, then the preparation of the SQL statement fails. The "NOT INDEXED" clause specifies that no index shall be used when accessing the preceding table, including implied indices create by UNIQUE and PRIMARY KEY constraints. However, the <a href="lang_createtable#rowid">rowid</a> can still be used to look up entries even when "NOT INDEXED" is specified.</p> <p>Some SQL database engines provide non-standard "hint" mechanisms which can be used to give the query optimizer clues about what indices it should use for a particular statement. The INDEXED BY clause of SQLite is <em>not</em> a hinting mechanism and it should not be used as such. The INDEXED BY clause does not give the optimizer hints about which index to use; it gives the optimizer a requirement of which index to use. If the query optimizer is unable to use the index specified by the INDEXED BY clause, then the query will fail with an error.</p> <p>The INDEXED BY clause is <em>not</em> intended for use in tuning the performance of a query. The intent of the INDEXED BY clause is to raise a run-time error if a schema change, such as dropping or creating an index, causes the query plan for a time-sensitive query to change. The INDEXED BY clause is designed to help detect undesirable query plan changes during regression testing. Application developers are admonished to omit all use of INDEXED BY during application design, implementation, testing, and tuning. If INDEXED BY is to be used at all, it should be inserted at the very end of the development process when "locking down" a design.</p> <h2 id="see_also">
<span>2. </span>See Also</h2> <ol> <li>
<p>The <a href="queryplanner-ng#howtofix">query planner checklist</a> describes steps that application developers should follow to resolve query planner problems. Notice the that the use of INDEXED BY is a last resort, to be used only when all other measures fail.</p> </li>
<li>
<p><a href="optoverview#uplus">The unary "+" operator</a> can be used to disqualify terms in the WHERE clause from use by indices. Careful use of unary + can sometimes help prevent the query planner from choosing a poor index without restricting it to using one specific index. Careful placement of unary + operators is a better method for controlling which indices are used by a query.</p> </li>
<li>
<p>The <a href="c3ref/stmt_status">sqlite3_stmt_status()</a> C/C++ interface together with the <a href="c3ref/c_stmtstatus_counter#sqlitestmtstatusfullscanstep">SQLITE_STMTSTATUS_FULLSCAN_STEP</a> and <a href="c3ref/c_stmtstatus_counter#sqlitestmtstatussort">SQLITE_STMTSTATUS_SORT</a> verbs can be used to detect at run-time when an SQL statement is not making effective use of indices. Many applications may prefer to use the <a href="c3ref/stmt_status">sqlite3_stmt_status()</a> interface to detect index misuse rather than the INDEXED BY phrase described here.</p> </li>
</ol> <p><small><i>This page was last updated on 2025-07-12 15:11:36Z </i></small></p> <div class="_attribution">
  <p class="_attribution-p">
    SQLite is in the Public Domain.<br>
    <a href="https://sqlite.org/lang_indexedby.html" class="_attribution-link">https://sqlite.org/lang_indexedby.html</a>
  </p>
</div>
