     <h1 class="fancy_title"> Database Remote-Copy Tool For SQLite </h1> <details class="fancy_toc"> <summary>Table Of Contents</summary> <div id="toc_sub">
<div class="fancy-toc1"><a href="#overview">1. Overview</a></div> <div class="fancy-toc1"><a href="#features">2. Features</a></div> <div class="fancy-toc1"><a href="#limitations">3. Limitations</a></div> <div class="fancy-toc1"><a href="#how_to_install">4. How To Install</a></div> <div class="fancy-toc2"><a href="#backwards_compatibility_issues">4.1. Backwards-Compatibility Issues</a></div> <div class="fancy-toc1"><a href="#network_bandwidth">5. Network Bandwidth</a></div> <div class="fancy-toc1"><a href="#why_can_t_i_just_use_ordinary_rsync_">6. Why Can't I Just Use Ordinary rsync?</a></div> </div> </details>   <h1 id="overview">
<span>1. </span>Overview</h1> <p id="intro">The following command causes REPLICA to become a copy of ORIGIN: </p>
<pre data-language="sql">$ sqlite3_rsync ORIGIN REPLICA ?OPTIONS?
</pre> <p>Use the <code>--help</code> or <code>-?</code> flag to see the complete list of options. Option flags may appear before, after, or between the ORIGIN and REPLICA arguments.</p> <p>Add the <code>-v</code> option to see more output, in a format similar to "rsync". </p>
<h1 id="features">
<span>2. </span>Features</h1> <ol> <li>One or the other of ORIGIN or REPLICA may be of the form "USER@HOST:PATH". The other is just a simple PATH. This utility causes REPLICA to become a copy of ORIGIN. <ol type="a"> <li><p>If REPLICA does not already exist, it is created.</p></li> <li><p><a href="https://en.wikipedia.org/wiki/Secure_Shell">ssh</a> is used for communication, so "USER@HOST" may be an SSH alias.</p></li> <li><p>It is not required that one of ORIGIN or REPLICA be remote. The sqlite3_rsync utility works fine if both ORIGIN and REPLICA are local. </p></li>
</ol> </li> <li>
<p>Both databases may be "live" while this utility is running. Other programs can have active connections to the databases on either end while this utility is running. Other programs can write to ORIGIN and can read from REPLICA while this utility runs. </p>
<p> REPLICA becomes a copy of a snapshot of ORIGIN as it existed when the sqlite3_rsync command started. If other processes change the content of ORIGIN while this command is running, those changes will be applied to ORIGIN, but they are not transferred to REPLICA Thus, REPLICA ends up as a fully-consistent snapshot of ORIGIN at an instant in time. </p>
</li> <li><p>The synchronization uses a bandwidth-efficient protocol, similar to <a href="https://rsync.samba.org">rsync</a> (from which its name is derived).</p></li> </ol> <h1 id="limitations">
<span>3. </span>Limitations</h1> <ol> <li>
<p></p>
<s>The database files must both be in <a href="wal">WAL</a> mode, and must have the same page-size.</s> ‚Üê These limitations were removed in version 3.50.0 (2025-05-29).</li> <li><p>While sqlite3_rsync is running, REPLICA is read-only. Queries can be run against REPLICA while this utility is running, just not write transactions.</p></li> <li><p>Only a single database is synchronized for each invocation of this utility. It is not (yet) possible to synchronize many different databases using wildcards, as it is with standard "rsync". </p></li>
<li><p>At least one of ORIGIN or REPLICA must be on the local machine. They cannot both be databases on other machines. </p></li>
<li><p>On the remote system, this utility must be installed in one of the directories in the default $PATH for SSH. The <code>/usr/local/bin</code> directory is often a good choice. Alternately, the <code>--exe
  NAME</code> flag may be used to specify a remote location for the binary, e.g. <code>--exe /opt/bin/sqlite3_rsync</code>.</p></li> <li>
<p>The replica will be a very close copy of the origin, but not an exact copy. All of the table (and index) content will be byte-for-byte identical in the replica. However, there can be some minor changes in the <a href="fileformat2#database_header">database header</a>. In particular, the replica will have the following differences from the origin: </p>
<ol type="a"> <li><p> The <a href="fileformat2#chngctr">change counter</a> in bytes 24 through 27 of the database header might be incremented in the replica. </p></li>
<li><p> The <a href="fileformat2#validfor">version-valid-for number</a> in bytes in 96 through 99 of the database header will be the SQLite version number of the sqlite3_rsync program that made the copy, not the version number of the last writer to the origin database. </p></li>
</ol> </li>
<li><p>On Windows, a single-letter HOST without a USER@ prefix will be interpreted as a Windows drive-letter, not as a hostname.</p></li> </ol> <h1 id="how_to_install">
<span>4. </span>How To Install</h1> <p>Install sqlite3_rsync simply by putting the executable somewhere on your $PATH. If you are synchronizing with a remote system, the sqlite3_rsync executable must be installed on both the local and the remote system. When installing the sqlite3_rsync executable on the remote system, ensure that it is found on the $PATH used by SSH. Putting the sqlite3_rsync executable in the /usr/local/bin directory is often a good choice. </p>
<p>Unfortunately, on MacOS, the default PATH for ssh is "/usr/bin:/bin:/usr/sbin:/sbin" and MacOS does not allow you to add new programs to any of those directories. As a work-around, sqlite3_rsync will attempt to augment the PATH like this: </p>
<blockquote> PATH=$HOME/bin:/usr/local/bin:/opt/homebrew/bin:$PATH </blockquote> <p>So if you are trying to sync with a remote Mac, it should suffice to install the sqlite3_rsync binary in any of the three new PATH locations: </p>
<ul> <li> $HOME/bin </li>
<li> /usr/local/bin </li>
<li> /opt/homebrew/bin </li>
</ul> <p>If you need to install sqlite3_rsync in some other (non-standard) place on the remote machine, simply use the --exe option on the command line to specify its precise location. For example: </p>
<blockquote> sqlite3_rsync sample.db mac:sample.db --exe /some/weird/place/sqlite3_rsync </blockquote> <p>The writer of this document has never had any success in getting SSHD to run on Windows. Perhaps he will figure that out and be able to provide instructions for syncing a database to or from a remote Windows machine in a future release. </p>
<h2 id="backwards_compatibility_issues">
<span>4.1. </span>Backwards-Compatibility Issues</h2> <p>The sqlite3_rsync program is designed to negotiate the details of the sync algorithm between the origin and the replica at startup, and to use the most advanced algorithm available on both sides. However, due to a bug in this algorithm negotiation logic (a missing fflush() call) it is possible for the application to hang if you try to use sqlite3_rsync with version 3.50.0 or later on the local side of the connection with version 3.49.1 or earlier on the remote side. Your best solution to this is to install the latest version of sqlite3_rsync on both sides. But if that is not possible, you can work around the problem by adding the "--protocol 1" option to the sqlite3_rsync command-line. </p>
<h1 id="network_bandwidth">
<span>5. </span>Network Bandwidth</h1> <p>The core idea behind the protocol is that the replica sends cryptographic hashes for pages or groups of pages over to the origin side. The origin sends back page content that differs, or requests finer-grain hashes if a multi-page hash does not match. If the origin and replica start out being vastly different, the total network bandwidth can exceed the size of the entire database, due to the overhead of exchanging hashes, but the excess bandwidth is not great - a few percent at most. On the other hand, if the origin and replica start out being very similar (the usual case) then the total bandwidth is often less than 0.01% of the database size. In tests, a 500MB database will typically synchronize with about 20KB of network traffic. </p>
<p>Prior to version 3.50.0 (2025-05-29), the protocol would only send hashes of individual pages, not groups of pages. The meant that the bandwidth requirements were usually at least about 0.5% of the database size, even if the two sides started out being identical. Version 3.50.0 and later is more bandwidth efficient if there are few differences between the origin and replica. However, both sides of the connection must have sqlite3_rsync version 3.50.0 or later installed or else the protocol falls back to the older and less bandwidth-efficient algorithm. </p>
<h1 id="why_can_t_i_just_use_ordinary_rsync_">
<span>6. </span>Why Can't I Just Use Ordinary <code>rsync</code>?</h1> <p>Ordinary rsync does not understand SQLite transactions. Rsync will make a copy of ORIGIN into REPLICA, however the copy might not be consistent. Parts of the copy might be from one transaction, while other parts might be from a different transaction. The database copy might be corrupt. </p>
<p>If no other processes are connected to the database for the entire time that rsync is running, and if the database does not have a <a href="fileformat2#hotjrnl">hot journal</a>, then rsync will make a consistent copy of the database. But if you cannot guarantee that both of those conditions are met, then rsync might generate a corrupt copy. The sqlite3_rsync utility, on the other hand, always generates a consistent copy. </p>
<p><small><i>This page was last updated on 2025-11-13 07:12:58Z </i></small></p> <div class="_attribution">
  <p class="_attribution-p">
    SQLite is in the Public Domain.<br>
    <a href="https://sqlite.org/rsync.html" class="_attribution-link">https://sqlite.org/rsync.html</a>
  </p>
</div>
