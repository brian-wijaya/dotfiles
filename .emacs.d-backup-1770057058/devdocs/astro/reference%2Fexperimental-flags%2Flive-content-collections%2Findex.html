<h1 id="_top" class="astro-62i6xxx4">Experimental live content collections</h1> <div class="content-panel astro-2mug3n2c"> <div class="sl-container astro-2mug3n2c"> <div class="sl-markdown-content"> 
<p><strong>Type:</strong> <code dir="auto">boolean</code><br> <strong>Default:</strong> <code dir="auto">false</code><br></p>
<span> <strong>Added in:</strong> <code>astro@5.10.0</code> </span> <p>Enables support for live content collections in your project.</p> <p>Live content collections are a new type of <a href="../../../guides/content-collections/index">content collection</a> that fetch their data at runtime rather than build time. This allows you to access frequently updated data from CMSs, APIs, databases, or other sources using a unified API, without needing to rebuild your site when the data changes.</p> <div class="sl-heading-wrapper level-h2">
<h2 id="basic-usage">Basic usage</h2>
<a class="sl-anchor-link" href="#basic-usage"><span aria-hidden="true" class="sl-anchor-icon"><svg width="16" height="16" viewbox="0 0 24 24"><path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path></svg></span><span class="sr-only">Section titled “Basic usage”</span></a>
</div> <p>To enable the feature, make sure you have an adapter configured for <a href="../../../guides/on-demand-rendering/index">on-demand rendering</a> and add the <code dir="auto">experimental.liveContentCollections</code> flag to your <code dir="auto">astro.config.mjs</code> file:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">astro.config.mjs</span></div>
<pre data-language="js">{
  experimental: {
    liveContentCollections: true,
  },
}</pre>

</div> <p>Then create a new <code dir="auto">src/live.config.ts</code> file (alongside your <code dir="auto">src/content.config.ts</code> if you have one) to define your live collections with a <a href="#creating-a-live-loader">live loader</a> and optionally a <a href="#using-zod-schemas">schema</a> using the new <code dir="auto">defineLiveCollection()</code> function from the <code dir="auto">astro:content</code> module.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/live.config.ts</span></div>
<pre data-language="ts">import { defineLiveCollection } from 'astro:content';
import { storeLoader } from '@mystore/astro-loader';


const products = defineLiveCollection({
  loader: storeLoader({
    apiKey: process.env.STORE_API_KEY,
    endpoint: 'https://api.mystore.com/v1',
  }),
});


export const collections = { products };</pre>

</div> <p>You can then use the dedicated <code dir="auto">getLiveCollection()</code> and <code dir="auto">getLiveEntry()</code> functions to access your live data:</p> <div class="expressive-code">

<pre data-language="astro">---
export const prerender = false; // Not needed in 'server' mode


import { getLiveCollection, getLiveEntry } from 'astro:content';


// Get all products
const { entries: allProducts, error } = await getLiveCollection('products');
if (error) {
  // Handle error appropriately
  console.error(error.message);
}


// Get products with a filter (if supported by your loader)
const { entries: electronics } = await getLiveCollection('products', { category: 'electronics' });


// Get a single product by ID (string syntax)
const { entry: product, error: productError } = await getLiveEntry('products', Astro.params.id);
if (productError) {
  return Astro.redirect('/404');
}


// Get a single product with a custom query (if supported by your loader) using a filter object
const { entry: productBySlug } = await getLiveEntry('products', { slug: Astro.params.slug });
---</pre>

</div> <div class="sl-heading-wrapper level-h2">
<h2 id="when-to-use-live-content-collections">When to use live content collections</h2>
<a class="sl-anchor-link" href="#when-to-use-live-content-collections"><span aria-hidden="true" class="sl-anchor-icon"><svg width="16" height="16" viewbox="0 0 24 24"><path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path></svg></span><span class="sr-only">Section titled “When to use live content collections”</span></a>
</div> <p>Live content collections are designed for data that changes frequently and needs to be up-to-date when a page is requested. Consider using them when:</p> <ul> <li>
<strong>You need real-time information</strong> (e.g. user-specific data, current stock levels)</li> <li>
<strong>You want to avoid constant rebuilds</strong> for content that changes often</li> <li>
<strong>Your data updates frequently</strong> (e.g. up-to-the-minute product inventory, prices, availability)</li> <li>
<strong>You need to pass dynamic filters</strong> to your data source based on user input or request parameters</li> <li>
<strong>You’re building preview functionality</strong> for a CMS where editors need to see draft content immediately</li> </ul> <p>In contrast, use build-time content collections when:</p> <ul> <li>
<strong>Performance is critical</strong> and you want to pre-render data at build time</li> <li>
<strong>Your data is relatively static</strong> (e.g., blog posts, documentation, product descriptions)</li> <li>
<strong>You want to benefit from build-time optimization</strong> and caching</li> <li>
<strong>You need to process MDX</strong> or perform image optimization</li> <li>
<strong>Your data can be fetched once and reused</strong> across multiple builds</li> </ul> <p>See the <a href="#live-collection-limitations">limitations of experimental live collections</a> and <a href="#differences-from-build-time-collections">key differences from build-time collections</a> for more details on choosing between live and preloaded collections.</p> <div class="sl-heading-wrapper level-h2">
<h2 id="using-live-collections">Using live collections</h2>
<a class="sl-anchor-link" href="#using-live-collections"><span aria-hidden="true" class="sl-anchor-icon"><svg width="16" height="16" viewbox="0 0 24 24"><path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path></svg></span><span class="sr-only">Section titled “Using live collections”</span></a>
</div> <p>You can <a href="#creating-a-live-loader">create your own live loaders</a> for your data source, or you can use community loaders distributed as npm packages. Here’s how you could use example CMS and e-commerce loaders:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/live.config.ts</span></div>
<pre data-language="ts">import { defineLiveCollection } from 'astro:content';
import { cmsLoader } from '@example/cms-astro-loader';
import { productLoader } from '@example/store-astro-loader';


const articles = defineLiveCollection({
  loader: cmsLoader({
    apiKey: process.env.CMS_API_KEY,
    contentType: 'article',
  }),
});


const products = defineLiveCollection({
  loader: productLoader({
    apiKey: process.env.STORE_API_KEY,
  }),
});


export const collections = { articles, products };</pre>

</div> <p>You can then get content from both loaders with a unified API:</p> <div class="expressive-code">

<pre data-language="astro">---
export const prerender = false; // Not needed in 'server' mode


import { getLiveCollection, getLiveEntry } from 'astro:content';


// Use loader-specific filters
const { entries: draftArticles } = await getLiveCollection('articles', {
  status: 'draft',
  author: 'john-doe',
});


// Get a specific product by ID
const { entry: product } = await getLiveEntry('products', Astro.params.slug);
---</pre>

</div> <div class="sl-heading-wrapper level-h3">
<h3 id="error-handling">Error handling</h3>
<a class="sl-anchor-link" href="#error-handling"><span aria-hidden="true" class="sl-anchor-icon"><svg width="16" height="16" viewbox="0 0 24 24"><path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path></svg></span><span class="sr-only">Section titled “Error handling”</span></a>
</div> <p>Live loaders can fail due to network issues, API errors, or validation problems. The API is designed to make error handling explicit.</p> <p>When you call <code dir="auto">getLiveCollection()</code> or <code dir="auto">getLiveEntry()</code>, the error will be one of:</p> <ul> <li>The error type defined by the loader (if it returned an error)</li> <li>A <code dir="auto">LiveEntryNotFoundError</code> if the entry was not found</li> <li>A <code dir="auto">LiveCollectionValidationError</code> if the collection data does not match the expected schema</li> <li>A <code dir="auto">LiveCollectionCacheHintError</code> if the cache hint is invalid</li> <li>A <code dir="auto">LiveCollectionError</code> for other errors, such as uncaught errors thrown in the loader</li> </ul> <p>These errors have a static <code dir="auto">is()</code> method that you can use to check the type of error at runtime:</p> <div class="expressive-code">

<pre data-language="astro">---
export const prerender = false; // Not needed in 'server' mode


import { getLiveEntry, LiveEntryNotFoundError } from 'astro:content';


const { entry, error } = await getLiveEntry('products', Astro.params.id);


if (error) {
  if (LiveEntryNotFoundError.is(error)) {
    console.error(`Product not found: ${error.message}`);
    Astro.response.status = 404;
  } else {
    console.error(`Error loading product: ${error.message}`);
    return Astro.redirect('/500');
  }
}
---</pre>

</div> <div class="sl-heading-wrapper level-h2">
<h2 id="creating-a-live-loader">Creating a live loader</h2>
<a class="sl-anchor-link" href="#creating-a-live-loader"><span aria-hidden="true" class="sl-anchor-icon"><svg width="16" height="16" viewbox="0 0 24 24"><path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path></svg></span><span class="sr-only">Section titled “Creating a live loader”</span></a>
</div> <p>A live loader is an object with two methods: <code dir="auto">loadCollection()</code> and <code dir="auto">loadEntry()</code>. These methods should handle errors gracefully and return either data or an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">Error</a> object.</p> <p>The standard pattern is to export a function that returns this loader object, allowing you to pass configuration options like API keys or endpoints.</p> <p>Here’s a basic example:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">myloader.ts</span></div>
<pre data-language="ts">import type { LiveLoader } from 'astro/loaders';
import { fetchFromCMS } from './cms-client.js';


interface Article {
  id: string;
  title: string;
  content: string;
  author: string;
}


export function articleLoader(config: { apiKey: string }): LiveLoader&lt;Article&gt; {
  return {
    name: 'article-loader',
    loadCollection: async ({ filter }) =&gt; {
      try {
        const articles = await fetchFromCMS({
          apiKey: config.apiKey,
          type: 'article',
          filter,
        });


        return {
          entries: articles.map((article) =&gt; ({
            id: article.id,
            data: article,
          })),
        };
      } catch (error) {
        return {
          error: new Error(`Failed to load articles: ${error.message}`),
        };
      }
    },
    loadEntry: async ({ filter }) =&gt; {
      try {
        // filter will be { id: "some-id" } when called with a string
        const article = await fetchFromCMS({
          apiKey: config.apiKey,
          type: 'article',
          id: filter.id,
        });


        if (!article) {
          return {
            error: new Error('Article not found'),
          };
        }


        return {
          id: article.id,
          data: article,
        };
      } catch (error) {
        return {
          error: new Error(`Failed to load article: ${error.message}`),
        };
      }
    },
  };
}</pre>

</div> <div class="sl-heading-wrapper level-h3">
<h3 id="rendering-content">Rendering content</h3>
<a class="sl-anchor-link" href="#rendering-content"><span aria-hidden="true" class="sl-anchor-icon"><svg width="16" height="16" viewbox="0 0 24 24"><path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path></svg></span><span class="sr-only">Section titled “Rendering content”</span></a>
</div> <p>A loader can add support for directly rendered content by returning <a href="../../content-loader-reference/index#rendered">a <code dir="auto">rendered</code> property</a> in the entry. This allows you to use <a href="../../../guides/content-collections/index#rendering-body-content">the <code dir="auto">render()</code> function and <code dir="auto">&lt;Content /&gt;</code> component</a> to render the content directly in your pages. If the loader does not return a <code dir="auto">rendered</code> property for an entry, the <code dir="auto">&lt;Content /&gt;</code> component will render nothing.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">myloader.ts</span></div>
<pre data-language="ts">// ...
export function articleLoader(config: { apiKey: string }): LiveLoader&lt;Article&gt; {
  return {
    name: 'article-loader',
    loadEntry: async ({ filter }) =&gt; {
      try {
        const article = await fetchFromCMS({
          apiKey: config.apiKey,
          type: 'article',
          id: filter.id,
        });


        return {
          id: article.id,
          data: article,
          rendered: {
            // Assuming the CMS returns HTML content
            html: article.htmlContent,
          },
        };
      } catch (error) {
        return {
          error: new Error(`Failed to load article: ${error.message}`),
        };
      }
    },
    // ...
  };
}</pre>

</div> <p>You can then render both content and metadata from live collection entries in pages using the same method as built-time collections. You also have access to any <a href="#error-handling-in-loaders">error returned by the live loader</a>, for example, to rewrite to a 404 page when content cannot be displayed:</p> <div class="expressive-code">

<pre data-language="astro">---
export const prerender = false; // Not needed in 'server' mode


import { getLiveEntry, render } from 'astro:content';
const { entry, error } = await getLiveEntry('articles', Astro.params.id);
if (error) {
  return Astro.rewrite('/404');
}


const { Content } = await render(entry);
---


&lt;h1&gt;{entry.data.title}&lt;/h1&gt;
&lt;Content /&gt;</pre>

</div> <div class="sl-heading-wrapper level-h3">
<h3 id="error-handling-in-loaders">Error handling in loaders</h3>
<a class="sl-anchor-link" href="#error-handling-in-loaders"><span aria-hidden="true" class="sl-anchor-icon"><svg width="16" height="16" viewbox="0 0 24 24"><path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path></svg></span><span class="sr-only">Section titled “Error handling in loaders”</span></a>
</div> <p>Loaders should handle all errors and return an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">Error</a> subclass for errors. You can create custom error types and use them for more specific error handling if needed. If an error is thrown in the loader, it will be caught and returned, wrapped in a <code dir="auto">LiveCollectionError</code>. You can also create <a href="#custom-error-types">custom error types</a> for proper typing.</p> <p>Astro will generate some errors itself, depending on the response from the loader:</p> <ul> <li>If <code dir="auto">loadEntry</code> returns <code dir="auto">undefined</code>, Astro will return a <code dir="auto">LiveEntryNotFoundError</code> to the user.</li> <li>If a schema is defined for the collection and the data does not match the schema, Astro will return a <code dir="auto">LiveCollectionValidationError</code>.</li> <li>If the loader returns an invalid cache hint, Astro will return a <code dir="auto">LiveCollectionCacheHintError</code>. The <code dir="auto">cacheHint</code> field is optional, so if you do not have valid data to return, you can simply omit it.</li> </ul> <div class="expressive-code">
<div class="_pre-heading"><span class="title">my-loader.ts</span></div>
<pre data-language="ts">import type { LiveLoader } from 'astro/loaders';
import { MyLoaderError } from './errors.js';


export function myLoader(config): LiveLoader&lt;MyData, undefined, undefined, MyLoaderError&gt; {
  return {
    name: 'my-loader',
    loadCollection: async ({ filter }) =&gt; {
      // Return your custom error type
      return {
        error: new MyLoaderError('Failed to load', 'LOAD_ERROR'),
      };
    },
    // ...
  };
}</pre>

</div> <div class="sl-heading-wrapper level-h3">
<h3 id="distributing-your-loader">Distributing your loader</h3>
<a class="sl-anchor-link" href="#distributing-your-loader"><span aria-hidden="true" class="sl-anchor-icon"><svg width="16" height="16" viewbox="0 0 24 24"><path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path></svg></span><span class="sr-only">Section titled “Distributing your loader”</span></a>
</div> <p>Loaders can be defined in your site or as a separate npm package. If you want to share your loader with the community, you can <a href="../../publish-to-npm/index#packagejson-data">publish it to NPM with the <code dir="auto">astro-component</code> and <code dir="auto">astro-loader</code> keywords</a>.</p> <p>The loader should export a function that returns the <code dir="auto">LiveLoader</code> object, allowing users to configure it with their own settings.</p> <div class="sl-heading-wrapper level-h2">
<h2 id="type-safety">Type safety</h2>
<a class="sl-anchor-link" href="#type-safety"><span aria-hidden="true" class="sl-anchor-icon"><svg width="16" height="16" viewbox="0 0 24 24"><path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path></svg></span><span class="sr-only">Section titled “Type safety”</span></a>
</div> <p>Like regular content collections, live collections can be typed to ensure type safety in your data. <a href="#using-zod-schemas">Using Zod schemas</a> is supported, but not required to define types for live collections. Unlike preloaded collections defined at build time, live loaders can instead choose to pass generic types to the <code dir="auto">LiveLoader</code> interface. You can define the types for your collection and entry data, as well as custom filter types for querying, and custom error types for error handling.</p> <div class="sl-heading-wrapper level-h3">
<h3 id="type-safe-data">Type-safe data</h3>
<a class="sl-anchor-link" href="#type-safe-data"><span aria-hidden="true" class="sl-anchor-icon"><svg width="16" height="16" viewbox="0 0 24 24"><path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path></svg></span><span class="sr-only">Section titled “Type-safe data”</span></a>
</div> <p>Live loaders can define types for the data they return. This allows TypeScript to provide type checking and autocompletion when working with the data in your components.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">store-loader.ts</span></div>
<pre data-language="ts">import type { LiveLoader } from 'astro/loaders';
import { fetchProduct, fetchCategory, type Product } from './store-client';


export function storeLoader(): LiveLoader&lt;Product&gt; {
  // ...
}</pre>

</div> <p>When you use <code dir="auto">getLiveCollection()</code> or <code dir="auto">getLiveEntry()</code>, TypeScript will infer the types based on the loader’s definition:</p> <div class="expressive-code">

<pre data-language="astro">---
export const prerender = false; // Not needed in 'server' mode


import { getLiveEntry } from 'astro:content';
const { entry: product } = await getLiveEntry('products', '123');
// TypeScript knows product.data is of type Product
console.log(product?.data.name);
---</pre>

</div> <div class="sl-heading-wrapper level-h3">
<h3 id="type-safe-filters">Type-safe filters</h3>
<a class="sl-anchor-link" href="#type-safe-filters"><span aria-hidden="true" class="sl-anchor-icon"><svg width="16" height="16" viewbox="0 0 24 24"><path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path></svg></span><span class="sr-only">Section titled “Type-safe filters”</span></a>
</div> <p>Live loaders can define custom filter types for both <code dir="auto">getLiveCollection()</code> and <code dir="auto">getLiveEntry()</code>. This enables type-safe querying that matches your API’s capabilities, making it easier for users to discover available filters and ensure they are used correctly. If you include JSDoc comments in your filter types, the user will see these in their IDE as hints when using the loader.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">store-loader.ts</span></div>
<pre data-language="ts">import type { LiveLoader } from 'astro/loaders';
import { fetchProduct, fetchCategory, type Product } from './store-client';


interface CollectionFilter {
  category?: string;
  /** Minimum price to filter products */
  minPrice?: number;
  /** Maximum price to filter products */
  maxPrice?: number;
}


interface EntryFilter {
  /** Alias for `sku` */
  id?: string;
  slug?: string;
  sku?: string;
}


export function productLoader(config: {
  apiKey: string;
  endpoint: string;
}): LiveLoader&lt;Product, EntryFilter, CollectionFilter&gt; {
  return {
    name: 'product-loader',
    loadCollection: async ({ filter }) =&gt; {
      // filter is typed as CollectionFilter
      const data = await fetchCategory({
        apiKey: config.apiKey,
        category: filter?.category ?? 'all',
        minPrice: filter?.minPrice,
        maxPrice: filter?.maxPrice,
      });


      return {
        entries: data.products.map((product) =&gt; ({
          id: product.sku,
          data: product,
        })),
      };
    },
    loadEntry: async ({ filter }) =&gt; {
      // filter is typed as EntryFilter | { id: string }
      const product = await fetchProduct({
        apiKey: config.apiKey,
        slug: filter.slug,
        sku: filter.sku || filter.id,
      });
      if (!product) {
        return {
          error: new Error('Product not found'),
        };
      }
      return {
        id: product.sku,
        entry: product,
      };
    },
  };
}</pre>

</div> <div class="sl-heading-wrapper level-h3">
<h3 id="custom-error-types">Custom error types</h3>
<a class="sl-anchor-link" href="#custom-error-types"><span aria-hidden="true" class="sl-anchor-icon"><svg width="16" height="16" viewbox="0 0 24 24"><path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path></svg></span><span class="sr-only">Section titled “Custom error types”</span></a>
</div> <p>You can create custom error types for <a href="#error-handling-in-loaders">errors returned by your loader</a> and pass them as a generic to get proper typing:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">my-loader.ts</span></div>
<pre data-language="ts">class MyLoaderError extends Error {
  constructor(
    message: string,
    public code?: string
  ) {
    super(message);
    this.name = 'MyLoaderError';
  }
}


export function myLoader(config): LiveLoader&lt;MyData, undefined, undefined, MyLoaderError&gt; {
  return {
    name: 'my-loader',
    loadCollection: async ({ filter }) =&gt; {
      // Return your custom error type
      return {
        error: new MyLoaderError('Failed to load', 'LOAD_ERROR'),
      };
    },
    // ...
  };
}</pre>

</div> <p>When you use <code dir="auto">getLiveCollection()</code> or <code dir="auto">getLiveEntry()</code>, TypeScript will infer the custom error type, allowing you to handle it appropriately:</p> <div class="expressive-code">

<pre data-language="astro">---
export const prerender = false; // Not needed in 'server' mode


import { getLiveEntry } from 'astro:content';


const { entry, error } = await getLiveEntry('products', '123');


if (error) {
  if (error.name === 'MyLoaderError') {
    console.error(`Loader error: ${error.message} (code: ${error.code})`);
  } else {
    console.error(`Unexpected error: ${error.message}`);
  }
  return Astro.rewrite('/500');
}
---</pre>

</div> <div class="sl-heading-wrapper level-h2">
<h2 id="using-zod-schemas">Using Zod schemas</h2>
<a class="sl-anchor-link" href="#using-zod-schemas"><span aria-hidden="true" class="sl-anchor-icon"><svg width="16" height="16" viewbox="0 0 24 24"><path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path></svg></span><span class="sr-only">Section titled “Using Zod schemas”</span></a>
</div> <p>Just like with build-time collections, you can use <a href="../../../guides/content-collections/index#defining-the-collection-schema">Zod schemas</a> with live collections to validate and transform data at runtime. When you define a schema, it takes precedence over <a href="#type-safe-data">the loader’s types</a> when you query the collection:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/live.config.ts</span></div>
<pre data-language="ts">import { defineLiveCollection } from 'astro:content';
import { z } from 'astro/zod';
import { apiLoader } from './loaders/api-loader';


const products = defineLiveCollection({
  loader: apiLoader({ endpoint: process.env.API_URL }),
  schema: z
    .object({
      id: z.string(),
      name: z.string(),
      price: z.number(),
      // Transform the API's category format
      category: z.string().transform((str) =&gt; str.toLowerCase().replace(/\s+/g, '-')),
      // Coerce the date to a Date object
      createdAt: z.coerce.date(),
    })
    .transform((data) =&gt; ({
      ...data,
      // Add a formatted price field
      displayPrice: `$${data.price.toFixed(2)}`,
    })),
});


export const collections = { products };</pre>

</div> <p>When using Zod schemas, validation errors are automatically caught and returned as <code dir="auto">AstroError</code> objects:</p> <div class="expressive-code">

<pre data-language="astro">---
export const prerender = false; // Not needed in 'server' mode


import { getLiveEntry, LiveCollectionValidationError } from 'astro:content';


const { entry, error } = await getLiveEntry('products', '123');


// You can handle validation errors specifically
if (LiveCollectionValidationError.is(error)) {
  console.error(error.message);
  return Astro.rewrite('/500');
}


// TypeScript knows entry.data matches your Zod schema, not the loader's type
console.log(entry?.data.displayPrice); // e.g., "$29.99"
---</pre>

</div> <div class="sl-heading-wrapper level-h2">
<h2 id="cache-hints">Cache hints</h2>
<a class="sl-anchor-link" href="#cache-hints"><span aria-hidden="true" class="sl-anchor-icon"><svg width="16" height="16" viewbox="0 0 24 24"><path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path></svg></span><span class="sr-only">Section titled “Cache hints”</span></a>
</div> <p>Live loaders can provide cache hints to help with response caching. You can use this data to send HTTP cache headers or otherwise inform your caching strategy.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">my-loader.ts</span></div>
<pre data-language="ts">import type { LiveLoader } from "astro/loaders";
import { loadStoreProduct, loadStoreProducts, getLastModifiedDate } from "./store";
import type { MyData } from "./types";


export function myLoader(config): LiveLoader&lt;MyData&gt; {
  return {
    name: 'cached-loader',
    loadCollection: async ({ filter }) =&gt; {
      const products = await loadStoreProducts(filter);
      return {
        entries: products.map((item) =&gt; ({
          id: item.id,
          data: item,
          // You can optionally provide cache hints for each entry
          cacheHint: {
            tags: [`product-${item.id}`, `category-${item.category}`],
          },
        })),
        cacheHint: {
          // All fields are optional, and are combined with each entry's cache hints
          // tags are merged from all entries
          // lastModified is the most recent lastModified of all entries and the collection
          lastModified: getLastModifiedDate(products),
          tags: ['products'],
        },
      };
    },
    loadEntry: async ({ filter }) =&gt; {
      const item = await loadStoreProduct(filter);
      return {
        id: item.id,
        data: item,
        cacheHint: {
          lastModified: new Date(item.lastModified),
          tags: [`product-${item.id}`, `category-${item.category}`],
        },
      };
    },
  };
}</pre>

</div> <p>You can then use these hints in your pages:</p> <div class="expressive-code">

<pre data-language="astro">---
export const prerender = false; // Not needed in 'server' mode


import { getLiveEntry } from 'astro:content';


const { entry, error, cacheHint } = await getLiveEntry('products', Astro.params.id);


if (error) {
  return Astro.redirect('/404');
}


// Apply cache hints to response headers
if (cacheHint?.tags) {
  Astro.response.headers.set('Cache-Tag', cacheHint.tags.join(','));
}
if (cacheHint?.lastModified) {
  Astro.response.headers.set('Last-Modified', cacheHint.lastModified.toUTCString());
}
---


&lt;h1&gt;{entry.data.name}&lt;/h1&gt;
&lt;p&gt;{entry.data.description}&lt;/p&gt;</pre>

</div> <aside aria-label="Note" class="starlight-aside starlight-aside--note"><p class="starlight-aside__title" aria-hidden="true"><svg viewbox="0 0 24 24" width="16" height="16" fill="currentColor" class="starlight-aside__icon"><path d="M12 11C11.7348 11 11.4804 11.1054 11.2929 11.2929C11.1054 11.4804 11 11.7348 11 12V16C11 16.2652 11.1054 16.5196 11.2929 16.7071C11.4804 16.8946 11.7348 17 12 17C12.2652 17 12.5196 16.8946 12.7071 16.7071C12.8946 16.5196 13 16.2652 13 16V12C13 11.7348 12.8946 11.4804 12.7071 11.2929C12.5196 11.1054 12.2652 11 12 11ZM12.38 7.08C12.1365 6.97998 11.8635 6.97998 11.62 7.08C11.4973 7.12759 11.3851 7.19896 11.29 7.29C11.2017 7.3872 11.1306 7.49882 11.08 7.62C11.024 7.73868 10.9966 7.86882 11 8C10.9992 8.13161 11.0245 8.26207 11.0742 8.38391C11.124 8.50574 11.1973 8.61656 11.29 8.71C11.3872 8.79833 11.4988 8.86936 11.62 8.92C11.7715 8.98224 11.936 9.00632 12.099 8.99011C12.2619 8.97391 12.4184 8.91792 12.5547 8.82707C12.691 8.73622 12.8029 8.61328 12.8805 8.46907C12.9582 8.32486 12.9992 8.16378 13 8C12.9963 7.73523 12.8927 7.48163 12.71 7.29C12.6149 7.19896 12.5028 7.12759 12.38 7.08ZM12 2C10.0222 2 8.08879 2.58649 6.4443 3.6853C4.79981 4.78412 3.51809 6.3459 2.76121 8.17317C2.00433 10.0004 1.8063 12.0111 2.19215 13.9509C2.578 15.8907 3.53041 17.6725 4.92894 19.0711C6.32746 20.4696 8.10929 21.422 10.0491 21.8079C11.9889 22.1937 13.9996 21.9957 15.8268 21.2388C17.6541 20.4819 19.2159 19.2002 20.3147 17.5557C21.4135 15.9112 22 13.9778 22 12C22 10.6868 21.7413 9.38642 21.2388 8.17317C20.7363 6.95991 19.9997 5.85752 19.0711 4.92893C18.1425 4.00035 17.0401 3.26375 15.8268 2.7612C14.6136 2.25866 13.3132 2 12 2ZM12 20C10.4178 20 8.87104 19.5308 7.55544 18.6518C6.23985 17.7727 5.21447 16.5233 4.60897 15.0615C4.00347 13.5997 3.84504 11.9911 4.15372 10.4393C4.4624 8.88743 5.22433 7.46197 6.34315 6.34315C7.46197 5.22433 8.88743 4.4624 10.4393 4.15372C11.9911 3.84504 13.5997 4.00346 15.0615 4.60896C16.5233 5.21447 17.7727 6.23984 18.6518 7.55544C19.5308 8.87103 20 10.4177 20 12C20 14.1217 19.1572 16.1566 17.6569 17.6569C16.1566 19.1571 14.1217 20 12 20Z"></path></svg>Note</p>
<div class="starlight-aside__content"><p>Cache hints only provide values that can be used in other parts of your project and do not automatically cause the response to be cached by Astro. You can use them to create your own caching strategy, such as setting HTTP headers or using a CDN.</p></div></aside> <div class="sl-heading-wrapper level-h2">
<h2 id="live-collection-limitations">Live collection limitations</h2>
<a class="sl-anchor-link" href="#live-collection-limitations"><span aria-hidden="true" class="sl-anchor-icon"><svg width="16" height="16" viewbox="0 0 24 24"><path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path></svg></span><span class="sr-only">Section titled “Live collection limitations”</span></a>
</div> <p>Live content collections have some limitations compared to build-time collections:</p> <ul> <li>
<strong>No MDX support</strong>: MDX cannot be rendered at runtime</li> <li>
<strong>No image optimization</strong>: Images cannot be processed at runtime</li> <li>
<strong>Performance considerations</strong>: Data is fetched on each request (unless cached)</li> <li>
<strong>No data store persistence</strong>: Data is not saved to the content layer data store</li> </ul> <div class="sl-heading-wrapper level-h2">
<h2 id="differences-from-build-time-collections">Differences from build-time collections</h2>
<a class="sl-anchor-link" href="#differences-from-build-time-collections"><span aria-hidden="true" class="sl-anchor-icon"><svg width="16" height="16" viewbox="0 0 24 24"><path fill="currentcolor" d="m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z"></path></svg></span><span class="sr-only">Section titled “Differences from build-time collections”</span></a>
</div> <p>Live collections use a different API than current preloaded content collections. Key differences include:</p> <ol> <li>
<strong>Execution time</strong>: Run at request time instead of build time</li> <li>
<strong>Configuration file</strong>: Use <code dir="auto">src/live.config.ts</code> instead of <code dir="auto">src/content.config.ts</code>
</li> <li>
<strong>Collection definition</strong>: Use <code dir="auto">defineLiveCollection()</code> instead of <code dir="auto">defineCollection()</code>
</li> <li>
<strong>Loader API</strong>: Implement <code dir="auto">loadCollection</code> and <code dir="auto">loadEntry</code> methods instead of the <code dir="auto">load</code> method</li> <li>
<strong>Data return</strong>: Return data directly instead of storing in the data store</li> <li>
<strong>User-facing functions</strong>: Use <code dir="auto">getLiveCollection</code>/<code dir="auto">getLiveEntry</code> instead of <code dir="auto">getCollection</code>/<code dir="auto">getEntry</code>
</li> </ol> <p>For a complete overview and to give feedback on this experimental API, see the <a href="https://github.com/withastro/roadmap/blob/feat/live-loaders/proposals/0055-live-content-loaders.md">Live Content collections RFC</a>.</p> <span id="docsearch-lvl0" hidden>Reference</span> </div> <div class="hide-when-toc-is-visible astro-o5o7wsh2"> <div class="container astro-zwxhm4ix" lang="en" dir="ltr" data-algolia-exclude> <aside aria-labelledby="learn-astro-course-1" class="astro-zwxhm4ix"> <div class="graphics astro-zwxhm4ix"> <img src="data:image/webp;base64,UklGRuQBAABXRUJQVlA4WAoAAAAQAAAARwAARwAAQUxQSBIAAAABD9D/iAgICRKm+z+aIvqfLgxWUDggrAEAANANAJ0BKkgASAA+bSyQRiQvI6EwtOwB4A2JYwDG7ApEmQTzrdjsTkQzIBD+xzUh0lK3EX6+lo0SCwRPGsgIGouWHJ2/nnSC9HGXEl2gpNNAYWRIW6VJ/K32YOrQKSEuKouno9R49M0eHE5iXb3aonSnft3gbtsAAP7w1R/RCOMR3YSO8dX6PK4mdXb+xC9xMW1jRYuDmnAY9270+m9BomJwqQ3dS4e/wb3PBG6f3XR0+vwd1aCpD6/39Q3FfzrpzNkiA3GXnChlpsJimbR9u+t3F/W1NvSBwbqU3GLXZQFNLWH1SKzuq+KfhFypeOnfRiBH6+kzyNj+Sr84yQmVvisMqHD24nmzW7XfBHlC2NvstZ+VChFGkasDLlfX5EEomwykq/uSu9zggr/z8g984C2ffX5fZWkhLaquVhVD5XOLiMnVhGhSt/hiuogfyH0+d8eN1XWUESYvySWIQRk4O3AgPqjYBgx/FfSWMMt/q8FCgeKPiFzuTksEY6gSwOPtQlvtY8Hzpb30kv5b6/8GtspkOOxWaYugHtREhWXRs0GNMszhFvbgbNIQ3gAA" alt="Scrimba" loading="lazy" decoding="async" fetchpriority="auto" width="72" height="72" class="scrimba-bubble astro-zwxhm4ix"> <img src="data:image/webp;base64,UklGRvoDAABXRUJQVlA4IO4DAAAwEwCdASpIAEgAPmkskkWkIqGY/AV0QAaEoAw21BVt60ZuePWKZ7zbq872zZ/BpVOcprJG6rUF6VCYw1xb+cknsA2zq7LlFTOPhOQtATm7HQCmwZKYCP2/dKDnOQt7NjOTAyXsaLlh+zawtCgXbADYXiJ78rCNCSRmA0/LsXRb2sQPi+1njYrG+r/+veKiFtqbnBkd8NcaO7yBLmepdcRhtsAA/vI7s9UG/cHtR7mErbfZieOcsg2DNyNpmynibwMFtVQef5zaA7TMoJGeF8ZOcgdG8Er7tclM1e6nPNHl69JJXCAPZvnxCxpO2uTtDJrodA26cvmxQQRG1osnWaQL8gzEfbb9AymNt0YwkidzbpO68jtwhcVB/Khj7HiXSxGx8URFmy2UtH8+xdlks6V8fP0pT6zmOMagal1b9Jf762OX75NigFcpE9SWLHPhSly+paFUghIpZd7ss4todtwb6mRTt9gLt12PZuOYcmgID8tePqFSru9ZkPVhc5jgFSDU1WaHvTxmRlqcsvuDwfCy7z357VyaavcFutcm7Nep/gdnZzsOn8I+eCrn8bvqakVt5w04DvVvqXoUkKOrw5DPMJrSR812/a6uheTmYgQMvhX7B4hIauWJp4kGPY+WS80BIeWjCAJmOgcjGATirHcyVBl5FsqjCDEUuEiPJdDgAeLvOiPdfRO4fsJd59FulhfX7OfqSz+wwD4sX6CG+7ByT5TVKoiE2jP5MNDz0yzDYuFsA7FNW8nV/U7qJAjgunKSmMMWnmN0U9/9qgYf3s1DilDDsu+FRNKwbHBXxslf6FzG3Rrc3zDAFJ+NsdudY4oHjnczojMc3supGmXFnQsfGZCHPQxn40mO9HsI1oKHH4RJ/dXss6sljuPOmx8YmrGlqBkpnmskLUM2j8p+6kMkCyYyhu+kAtDc8dCxhqbYn8yxHrGePRLyWeYzHj5qloBC+QY3fxoUYTfrSI2ZRGJ8EFp87vEPa+79jTG6fhKPVFxXq388UgLsm2KMRsa0wDXZUXSj4J7qzc7639E9TbdX8i7vu2zlw/4Innob9+Q+He4ic1y7Cw9V4TaFGAHKYJA3Ehpxob31bguhmHdlSkl0dHBTGk/LVrpMowPKfHj2cKw9XsJH7mMS0N1q1vOM4izTLT2AZtLzEfoUDe0qanVJpROTrsm/xrv9H0nzqX3eGHloUpwYGI770bMf3EnYYxl90jeYEdq8PiuFqEbpZDGDEP7j40ukUnQvULXa9UmRGSEIbov/GuSB7ne4hikpbd+KINukzOFouwlpM787dgH6+Ur8DqoBunjMA2wARrTdAi1rbnQAoKiCqw4YAAAA" alt loading="lazy" decoding="async" fetchpriority="auto" width="72" height="72" class="astro-zwxhm4ix"> </div> <h2 id="learn-astro-course-1" class="astro-zwxhm4ix"> <strong class="astro-zwxhm4ix">Learn Astro</strong> with James Q Quick </h2> <p class="astro-zwxhm4ix">Build your first site with 35 interactive Scrimba lessons</p> <a class="sl-link-button not-content primary cta astro-zwxhm4ix astro-n3qr5j5k" href="https://scrimba.com/intro-to-astro-c00ar0fi5u?via=astro" data-scrimba-cta="true"> Get 20% off </a> </aside> </div>  </div>   </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2021 Fred K. Schott<br>Licensed under the MIT License.<br>
    <a href="https://docs.astro.build/en/reference/experimental-flags/live-content-collections/" class="_attribution-link">https://docs.astro.build/en/reference/experimental-flags/live-content-collections/</a>
  </p>
</div>
