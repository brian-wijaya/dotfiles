<h1>cache<a href="#undefined" aria-label="Link for this heading" title="Link for this heading"><svg width="1em" height="1em" viewbox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a>
</h1>
<h3>React Server Components</h3>
<div><p><code dir="ltr">cache</code> is only for use with <a href="../rsc/server-components">React Server Components</a>.</p></div> <div>
<p><code dir="ltr">cache</code> lets you cache the result of a data fetch or computation.</p>
<pre data-language="jsx"><code><span>const</span> <span>cachedFn</span> = <span>cache</span><span>(</span><span>fn</span><span>)</span><span>;</span></code></pre>
</div> <ul>
<li>
<a href="#reference">Reference </a><ul><li><a href="#cache"><code dir="ltr">cache(fn)</code> </a></li></ul>
</li>
<li>
<a href="#usage">Usage </a><ul>
<li><a href="#cache-expensive-computation">Cache an expensive computation </a></li>
<li><a href="#take-and-share-snapshot-of-data">Share a snapshot of data </a></li>
<li><a href="#preload-data">Preload data </a></li>
</ul>
</li>
<li>
<a href="#troubleshooting">Troubleshooting </a><ul><li><a href="#memoized-function-still-runs">My memoized function still runs even though Iâ€™ve called it with the same arguments </a></li></ul>
</li>
</ul> <hr> <h2 id="reference">Reference <a href="#reference" aria-label="Link for Reference " title="Link for Reference "><svg width="1em" height="1em" viewbox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a>
</h2> <h3 id="cache">
<code dir="ltr">cache(fn)</code> <a href="#cache" aria-label="Link for this heading" title="Link for this heading"><svg width="1em" height="1em" viewbox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a>
</h3> <p>Call <code dir="ltr">cache</code> outside of any components to create a version of the function with caching.</p> <pre data-language="jsx"><code><span>import</span> <span>{</span><span>cache</span><span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>calculateMetrics</span> <span>from</span> <span>'lib/metrics'</span><span>;</span>

<span>const</span> <span>getMetrics</span> = <span>cache</span><span>(</span><span>calculateMetrics</span><span>)</span><span>;</span>

<span>function</span> <span>Chart</span><span>(</span><span>{</span><span>data</span><span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>report</span> = <span>getMetrics</span><span>(</span><span>data</span><span>)</span><span>;</span>
  <span>// ...</span>
<span>}</span></code></pre> <p>When <code dir="ltr">getMetrics</code> is first called with <code dir="ltr">data</code>, <code dir="ltr">getMetrics</code> will call <code dir="ltr">calculateMetrics(data)</code> and store the result in cache. If <code dir="ltr">getMetrics</code> is called again with the same <code dir="ltr">data</code>, it will return the cached result instead of calling <code dir="ltr">calculateMetrics(data)</code> again.</p> <p><a href="#usage">See more examples below.</a></p> <h4 id="parameters">Parameters <a href="#parameters" aria-label="Link for Parameters " title="Link for Parameters "><svg width="1em" height="1em" viewbox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a>
</h4> <ul> <li>
<code dir="ltr">fn</code>: The function you want to cache results for. <code dir="ltr">fn</code> can take any arguments and return any value.</li> </ul> <h4 id="returns">Returns <a href="#returns" aria-label="Link for Returns " title="Link for Returns "><svg width="1em" height="1em" viewbox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a>
</h4> <p><code dir="ltr">cache</code> returns a cached version of <code dir="ltr">fn</code> with the same type signature. It does not call <code dir="ltr">fn</code> in the process.</p> <p>When calling <code dir="ltr">cachedFn</code> with given arguments, it first checks if a cached result exists in the cache. If a cached result exists, it returns the result. If not, it calls <code dir="ltr">fn</code> with the arguments, stores the result in the cache, and returns the result. The only time <code dir="ltr">fn</code> is called is when there is a cache miss.</p> <div class="note note-green">
<h4>Note</h4>
<div><p>The optimization of caching return values based on inputs is known as <a href="https://en.wikipedia.org/wiki/Memoization" target="_blank" rel="nofollow noopener noreferrer"><em>memoization</em></a>. We refer to the function returned from <code dir="ltr">cache</code> as a memoized function.</p></div>
</div> <h4 id="caveats">Caveats <a href="#caveats" aria-label="Link for Caveats " title="Link for Caveats "><svg width="1em" height="1em" viewbox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a>
</h4> <ul> <li>React will invalidate the cache for all memoized functions for each server request.</li> <li>Each call to <code dir="ltr">cache</code> creates a new function. This means that calling <code dir="ltr">cache</code> with the same function multiple times will return different memoized functions that do not share the same cache.</li> <li>
<code dir="ltr">cachedFn</code> will also cache errors. If <code dir="ltr">fn</code> throws an error for certain arguments, it will be cached, and the same error is re-thrown when <code dir="ltr">cachedFn</code> is called with those same arguments.</li> <li>
<code dir="ltr">cache</code> is for use in <a href="../rsc/server-components">Server Components</a> only.</li> </ul> <hr> <h2 id="usage">Usage <a href="#usage" aria-label="Link for Usage " title="Link for Usage "><svg width="1em" height="1em" viewbox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a>
</h2> <h3 id="cache-expensive-computation">Cache an expensive computation <a href="#cache-expensive-computation" aria-label="Link for Cache an expensive computation " title="Link for Cache an expensive computation "><svg width="1em" height="1em" viewbox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a>
</h3> <p>Use <code dir="ltr">cache</code> to skip duplicate work.</p> <pre data-language="jsx"><code><span>import</span> <span>{</span><span>cache</span><span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>calculateUserMetrics</span> <span>from</span> <span>'lib/user'</span><span>;</span>

<span>const</span> <span>getUserMetrics</span> = <span>cache</span><span>(</span><span>calculateUserMetrics</span><span>)</span><span>;</span>

<span>function</span> <span>Profile</span><span>(</span><span>{</span><span>user</span><span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>metrics</span> = <span>getUserMetrics(user)</span><span>;</span>
  <span>// ...</span>
<span>}</span>

<span>function</span> <span>TeamReport</span><span>(</span><span>{</span><span>users</span><span>}</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> <span>user</span> <span>in</span> <span>users</span><span>)</span> <span>{</span>
    <span>const</span> <span>metrics</span> = <span>getUserMetrics(user)</span><span>;</span>
    <span>// ...</span>
  <span>}</span>
  <span>// ...</span>
<span>}</span></code></pre> <p>If the same <code dir="ltr">user</code> object is rendered in both <code dir="ltr">Profile</code> and <code dir="ltr">TeamReport</code>, the two components can share work and only call <code dir="ltr">calculateUserMetrics</code> once for that <code dir="ltr">user</code>.</p> <p>Assume <code dir="ltr">Profile</code> is rendered first. It will call <span data-step="1"><code dir="ltr">getUserMetrics</code></span>, and check if there is a cached result. Since it is the first time <code dir="ltr">getUserMetrics</code> is called with that <code dir="ltr">user</code>, there will be a cache miss. <code dir="ltr">getUserMetrics</code> will then call <code dir="ltr">calculateUserMetrics</code> with that <code dir="ltr">user</code> and write the result to cache.</p> <p>When <code dir="ltr">TeamReport</code> renders its list of <code dir="ltr">users</code> and reaches the same <code dir="ltr">user</code> object, it will call <span data-step="2"><code dir="ltr">getUserMetrics</code></span> and read the result from cache.</p> <p>If <code dir="ltr">calculateUserMetrics</code> can be aborted by passing an <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">AbortSignal</code></a>, you can use <a href="cachesignal"><code dir="ltr">cacheSignal()</code></a> to cancel the expensive computation if React has finished rendering. <code dir="ltr">calculateUserMetrics</code> may already handle cancellation internally by using <code dir="ltr">cacheSignal</code> directly.</p> <div class="note note-orange">
<h4>Pitfall</h4>
<div>
<h5 id="pitfall-different-memoized-functions">Calling different memoized functions will read from different caches. <a href="#pitfall-different-memoized-functions" aria-label="Link for Calling different memoized functions will read from different caches. " title="Link for Calling different memoized functions will read from different caches. "><svg width="1em" height="1em" viewbox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a>
</h5>
<p>To access the same cache, components must call the same memoized function.</p>
<pre data-language="jsx"><code><span>// Temperature.js</span>
<span>import</span> <span>{</span><span>cache</span><span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span><span>calculateWeekReport</span><span>}</span> <span>from</span> <span>'./report'</span><span>;</span>

<span>export</span> <span>function</span> <span>Temperature</span><span>(</span><span>{</span><span>cityData</span><span>}</span><span>)</span> <span>{</span>
  <span>// ðŸš© Wrong: Calling `cache` in component creates new `getWeekReport` for each render</span>
  <span>const</span> <span>getWeekReport</span> = <span>cache(calculateWeekReport)</span><span>;</span>
  <span>const</span> <span>report</span> = <span>getWeekReport</span><span>(</span><span>cityData</span><span>)</span><span>;</span>
  <span>// ...</span>
<span>}</span></code></pre>
<pre data-language="jsx"><code><span>// Precipitation.js</span>
<span>import</span> <span>{</span><span>cache</span><span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span><span>calculateWeekReport</span><span>}</span> <span>from</span> <span>'./report'</span><span>;</span>

<span>// ðŸš© Wrong: `getWeekReport` is only accessible for `Precipitation` component.</span>
<span>const</span> <span>getWeekReport</span> = <span>cache(calculateWeekReport)</span><span>;</span>

<span>export</span> <span>function</span> <span>Precipitation</span><span>(</span><span>{</span><span>cityData</span><span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>report</span> = <span>getWeekReport</span><span>(</span><span>cityData</span><span>)</span><span>;</span>
  <span>// ...</span>
<span>}</span></code></pre>
<p>In the above example, <span data-step="2"><code dir="ltr">Precipitation</code></span> and <span data-step="1"><code dir="ltr">Temperature</code></span> each call <code dir="ltr">cache</code> to create a new memoized function with their own cache look-up. If both components render for the same <code dir="ltr">cityData</code>, they will do duplicate work to call <code dir="ltr">calculateWeekReport</code>.</p>
<p>In addition, <code dir="ltr">Temperature</code> creates a <span data-step="1">new memoized function</span> each time the component is rendered which doesnâ€™t allow for any cache sharing.</p>
<p>To maximize cache hits and reduce work, the two components should call the same memoized function to access the same cache. Instead, define the memoized function in a dedicated module that can be <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">import</code>-ed</a> across components.</p>
<pre data-language="jsx"><code><span>// getWeekReport.js</span>
<span>import</span> <span>{</span><span>cache</span><span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span><span>calculateWeekReport</span><span>}</span> <span>from</span> <span>'./report'</span><span>;</span>

<span>export default cache(calculateWeekReport)</span><span>;</span></code></pre>
<pre data-language="jsx"><code><span>// Temperature.js</span>
<span>import</span> <span>getWeekReport</span> <span>from</span> <span>'./getWeekReport'</span><span>;</span>

<span>export</span> <span>default</span> <span>function</span> <span>Temperature</span><span>(</span><span>{</span><span>cityData</span><span>}</span><span>)</span> <span>{</span>
	<span>const</span> <span>report</span> = <span>getWeekReport</span><span>(</span><span>cityData</span><span>)</span><span>;</span>
  <span>// ...</span>
<span>}</span></code></pre>
<pre data-language="jsx"><code><span>// Precipitation.js</span>
<span>import</span> <span>getWeekReport</span> <span>from</span> <span>'./getWeekReport'</span><span>;</span>

<span>export</span> <span>default</span> <span>function</span> <span>Precipitation</span><span>(</span><span>{</span><span>cityData</span><span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>report</span> = <span>getWeekReport</span><span>(</span><span>cityData</span><span>)</span><span>;</span>
  <span>// ...</span>
<span>}</span></code></pre>
<p>Here, both components call the <span data-step="3">same memoized function</span> exported from <code dir="ltr">./getWeekReport.js</code> to read and write to the same cache.</p>
</div>
</div> <h3 id="take-and-share-snapshot-of-data">Share a snapshot of data <a href="#take-and-share-snapshot-of-data" aria-label="Link for Share a snapshot of data " title="Link for Share a snapshot of data "><svg width="1em" height="1em" viewbox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a>
</h3> <p>To share a snapshot of data between components, call <code dir="ltr">cache</code> with a data-fetching function like <code dir="ltr">fetch</code>. When multiple components make the same data fetch, only one request is made and the data returned is cached and shared across components. All components refer to the same snapshot of data across the server render.</p> <pre data-language="jsx"><code><span>import</span> <span>{</span><span>cache</span><span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> <span>{</span><span>fetchTemperature</span><span>}</span> <span>from</span> <span>'./api.js'</span><span>;</span>

<span>const</span> <span>getTemperature</span> = <span>cache</span><span>(</span><span>async</span> <span>(</span><span>city</span><span>)</span> <span>=&gt;</span> <span>{</span>
	<span>return</span> <span>await</span> <span>fetchTemperature(city)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>async</span> <span>function</span> <span>AnimatedWeatherCard</span><span>(</span><span>{</span><span>city</span><span>}</span><span>)</span> <span>{</span>
	<span>const</span> <span>temperature</span> = <span>await</span> <span>getTemperature</span><span>(</span><span>city</span><span>)</span><span>;</span>
	<span>// ...</span>
<span>}</span>

<span>async</span> <span>function</span> <span>MinimalWeatherCard</span><span>(</span><span>{</span><span>city</span><span>}</span><span>)</span> <span>{</span>
	<span>const</span> <span>temperature</span> = <span>await</span> <span>getTemperature</span><span>(</span><span>city</span><span>)</span><span>;</span>
	<span>// ...</span>
<span>}</span></code></pre> <p>If <code dir="ltr">AnimatedWeatherCard</code> and <code dir="ltr">MinimalWeatherCard</code> both render for the same <span data-step="1">city</span>, they will receive the same snapshot of data from the <span data-step="2">memoized function</span>.</p> <p>If <code dir="ltr">AnimatedWeatherCard</code> and <code dir="ltr">MinimalWeatherCard</code> supply different <span data-step="1">city</span> arguments to <span data-step="2"><code dir="ltr">getTemperature</code></span>, then <code dir="ltr">fetchTemperature</code> will be called twice and each call site will receive different data.</p> <p>The <span data-step="1">city</span> acts as a cache key.</p> <div class="note note-green">
<h4>Note</h4>
<div>
<p><span data-step="3">Asynchronous rendering</span> is only supported for Server Components.</p>
<pre data-language="jsx"><code><span>async</span> <span>function</span> <span>AnimatedWeatherCard</span><span>(</span><span>{</span><span>city</span><span>}</span><span>)</span> <span>{</span>
	<span>const</span> <span>temperature</span> = <span>await</span> <span>getTemperature</span><span>(</span><span>city</span><span>)</span><span>;</span>
	<span>// ...</span>
<span>}</span></code></pre>
<p>To render components that use asynchronous data in Client Components, see <a href="use"><code dir="ltr">use()</code> documentation</a>.</p>
</div>
</div> <h3 id="preload-data">Preload data <a href="#preload-data" aria-label="Link for Preload data " title="Link for Preload data "><svg width="1em" height="1em" viewbox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a>
</h3> <p>By caching a long-running data fetch, you can kick off asynchronous work prior to rendering the component.</p> <pre data-language="jsx"><code><span>const</span> <span>getUser</span> = <span>cache</span><span>(</span><span>async</span> <span>(</span><span>id</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>return</span> <span>await</span> <span>db</span>.<span>user</span>.<span>query</span><span>(</span><span>id</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>async</span> <span>function</span> <span>Profile</span><span>(</span><span>{</span><span>id</span><span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>user</span> = <span>await getUser(id)</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>section</span><span>&gt;</span>
      <span>&lt;</span><span>img</span> <span>src</span>=<span>{</span><span>user</span>.<span>profilePic</span><span>}</span> <span>/&gt;</span>
      <span>&lt;</span><span>h2</span><span>&gt;</span><span>{</span><span>user</span>.<span>name</span><span>}</span><span>&lt;/</span><span>h2</span><span>&gt;</span>
    <span>&lt;/</span><span>section</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>Page</span><span>(</span><span>{</span><span>id</span><span>}</span><span>)</span> <span>{</span>
  <span>// âœ… Good: start fetching the user data</span>
  <span>getUser(id)</span><span>;</span>
  <span>// ... some computational work</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>Profile</span> <span>id</span>=<span>{</span><span>id</span><span>}</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span></code></pre> <p>When rendering <code dir="ltr">Page</code>, the component calls <span data-step="1"><code dir="ltr">getUser</code></span> but note that it doesnâ€™t use the returned data. This early <span data-step="1"><code dir="ltr">getUser</code></span> call kicks off the asynchronous database query that occurs while <code dir="ltr">Page</code> is doing other computational work and rendering children.</p> <p>When rendering <code dir="ltr">Profile</code>, we call <span data-step="2"><code dir="ltr">getUser</code></span> again. If the initial <span data-step="1"><code dir="ltr">getUser</code></span> call has already returned and cached the user data, when <code dir="ltr">Profile</code> <span data-step="2">asks and waits for this data</span>, it can simply read from the cache without requiring another remote procedure call. If the <span data-step="1"> initial data request</span> hasnâ€™t been completed, preloading data in this pattern reduces delay in data-fetching.</p> <details class="note note-blue"><summary tabindex="-1"><h5>
<svg width="1.5em" height="1.5em" viewbox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M34.7409 59.7228L32.9567 58.9094C27.2672 56.3157 20.7328 56.3157 15.0433 58.9094C12.6018 60.0224 9.39163 59.0275 8.44602 56.0621C7.45647 52.9589 5.99975 46.5898 6 35.9997C6.00029 23.5648 8.00803 18.3599 9.11099 16.4196C9.67795 15.4222 10.5255 14.8455 11.2254 14.5264L12.0179 14.1651C19.6351 10.6926 28.4011 10.6738 36 14.1733C43.5989 10.6738 52.3649 10.6926 59.9821 14.1651L60.7746 14.5264C61.4745 14.8455 62.3221 15.4222 62.889 16.4196C63.992 18.3599 65.9997 23.5648 66 35.9997C66.0002 46.5898 64.5435 52.9589 63.554 56.0621C62.6084 59.0275 59.3982 60.0224 56.9567 58.9094C51.2672 56.3157 44.7328 56.3157 39.0433 58.9094L37.2591 59.7228C37.1986 59.7508 37.1373 59.7767 37.0753 59.8004C36.4484 60.0411 35.7556 60.0653 35.1102 59.8648C34.9847 59.8258 34.8613 59.7784 34.7409 59.7228ZM14.5068 19.6246C20.3733 16.9501 27.0874 16.8775 33 19.4067V52.473C26.7613 50.32 19.9378 50.471 13.7811 52.9261C13.0005 49.9843 11.9998 44.547 12 35.9998C12.0002 25.5786 13.4879 21.1893 14.1179 19.8018L14.5068 19.6246ZM39 52.473C45.2387 50.32 52.0622 50.471 58.2189 52.9261C58.9995 49.9843 60.0002 44.547 60 35.9998C59.9998 25.5786 58.5121 21.1893 57.8821 19.8018L57.4932 19.6246C51.6267 16.9501 44.9126 16.8775 39 19.4067V52.473Z" fill="currentColor"></path></svg>Deep Dive</h5>
<h4 id="caching-asynchronous-work">Caching asynchronous work <a href="#caching-asynchronous-work" aria-label="Link for Caching asynchronous work " title="Link for Caching asynchronous work "><svg width="1em" height="1em" viewbox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a>
</h4></summary><div>
<p>When evaluating an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="nofollow noopener noreferrer">asynchronous function</a>, you will receive a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="nofollow noopener noreferrer">Promise</a> for that work. The promise holds the state of that work (<em>pending</em>, <em>fulfilled</em>, <em>failed</em>) and its eventual settled result.</p>
<p>In this example, the asynchronous function <span data-step="1"><code dir="ltr">fetchData</code></span> returns a promise that is awaiting the <code dir="ltr">fetch</code>.</p>
<pre data-language="jsx"><code><span>async</span> <span>function</span> <span>fetchData()</span> <span>{</span>
  <span>return</span> <span>await</span> <span>fetch</span><span>(</span><span>`https://...`</span><span>)</span><span>;</span>
<span>}</span>

<span>const</span> <span>getData</span> = <span>cache</span><span>(</span><span>fetchData</span><span>)</span><span>;</span>

<span>async</span> <span>function</span> <span>MyComponent</span><span>(</span><span>)</span> <span>{</span>
  <span>getData()</span><span>;</span>
  <span>// ... some computational work</span>
  <span>await</span> <span>getData()</span><span>;</span>
  <span>// ...</span>
<span>}</span></code></pre>
<p>In calling <span data-step="2"><code dir="ltr">getData</code></span> the first time, the promise returned from <span data-step="1"><code dir="ltr">fetchData</code></span> is cached. Subsequent look-ups will then return the same promise.</p>
<p>Notice that the first <span data-step="2"><code dir="ltr">getData</code></span> call does not <code dir="ltr">await</code> whereas the <span data-step="3">second</span> does. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">await</code></a> is a JavaScript operator that will wait and return the settled result of the promise. The first <span data-step="2"><code dir="ltr">getData</code></span> call simply initiates the <code dir="ltr">fetch</code> to cache the promise for the second <span data-step="3"><code dir="ltr">getData</code></span> to look-up.</p>
<p>If by the <span data-step="3">second call</span> the promise is still <em>pending</em>, then <code dir="ltr">await</code> will pause for the result. The optimization is that while we wait on the <code dir="ltr">fetch</code>, React can continue with computational work, thus reducing the wait time for the <span data-step="3">second call</span>.</p>
<p>If the promise is already settled, either to an error or the <em>fulfilled</em> result, <code dir="ltr">await</code> will return that value immediately. In both outcomes, there is a performance benefit.</p>
</div></details> <div class="note note-orange">
<h4>Pitfall</h4>
<div>
<h5 id="pitfall-memoized-call-outside-component">Calling a memoized function outside of a component will not use the cache. <a href="#pitfall-memoized-call-outside-component" aria-label="Link for Calling a memoized function outside of a component will not use the cache. " title="Link for Calling a memoized function outside of a component will not use the cache. "><svg width="1em" height="1em" viewbox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a>
</h5>
<pre data-language="jsx"><code><span>import</span> <span>{</span><span>cache</span><span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>const</span> <span>getUser</span> = <span>cache</span><span>(</span><span>async</span> <span>(</span><span>userId</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>return</span> <span>await</span> <span>db</span>.<span>user</span>.<span>query</span><span>(</span><span>userId</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>// ðŸš© Wrong: Calling memoized function outside of component will not memoize.</span>
<span>getUser</span><span>(</span><span>'demo-id'</span><span>)</span><span>;</span>

<span>async</span> <span>function</span> <span>DemoProfile</span><span>(</span><span>)</span> <span>{</span>
  <span>// âœ… Good: `getUser` will memoize.</span>
  <span>const</span> <span>user</span> = <span>await</span> <span>getUser</span><span>(</span><span>'demo-id'</span><span>)</span><span>;</span>
  <span>return</span> <span>&lt;</span><span>Profile</span> <span>user</span>=<span>{</span><span>user</span><span>}</span> <span>/&gt;</span><span>;</span>
<span>}</span></code></pre>
<p>React only provides cache access to the memoized function in a component. When calling <span data-step="1"><code dir="ltr">getUser</code></span> outside of a component, it will still evaluate the function but not read or update the cache.</p>
<p>This is because cache access is provided through a <a href="../../learn/passing-data-deeply-with-context">context</a> which is only accessible from a component.</p>
</div>
</div> <details class="note note-blue"><summary tabindex="-1"><h5>
<svg width="1.5em" height="1.5em" viewbox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M34.7409 59.7228L32.9567 58.9094C27.2672 56.3157 20.7328 56.3157 15.0433 58.9094C12.6018 60.0224 9.39163 59.0275 8.44602 56.0621C7.45647 52.9589 5.99975 46.5898 6 35.9997C6.00029 23.5648 8.00803 18.3599 9.11099 16.4196C9.67795 15.4222 10.5255 14.8455 11.2254 14.5264L12.0179 14.1651C19.6351 10.6926 28.4011 10.6738 36 14.1733C43.5989 10.6738 52.3649 10.6926 59.9821 14.1651L60.7746 14.5264C61.4745 14.8455 62.3221 15.4222 62.889 16.4196C63.992 18.3599 65.9997 23.5648 66 35.9997C66.0002 46.5898 64.5435 52.9589 63.554 56.0621C62.6084 59.0275 59.3982 60.0224 56.9567 58.9094C51.2672 56.3157 44.7328 56.3157 39.0433 58.9094L37.2591 59.7228C37.1986 59.7508 37.1373 59.7767 37.0753 59.8004C36.4484 60.0411 35.7556 60.0653 35.1102 59.8648C34.9847 59.8258 34.8613 59.7784 34.7409 59.7228ZM14.5068 19.6246C20.3733 16.9501 27.0874 16.8775 33 19.4067V52.473C26.7613 50.32 19.9378 50.471 13.7811 52.9261C13.0005 49.9843 11.9998 44.547 12 35.9998C12.0002 25.5786 13.4879 21.1893 14.1179 19.8018L14.5068 19.6246ZM39 52.473C45.2387 50.32 52.0622 50.471 58.2189 52.9261C58.9995 49.9843 60.0002 44.547 60 35.9998C59.9998 25.5786 58.5121 21.1893 57.8821 19.8018L57.4932 19.6246C51.6267 16.9501 44.9126 16.8775 39 19.4067V52.473Z" fill="currentColor"></path></svg>Deep Dive</h5>
<h4 id="cache-memo-usememo">When should I use <code dir="ltr">cache</code>, <a href="memo"><code dir="ltr">memo</code></a>, or <a href="usememo"><code dir="ltr">useMemo</code></a>? <a href="#cache-memo-usememo" aria-label="Link for this heading" title="Link for this heading"><svg width="1em" height="1em" viewbox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a>
</h4></summary><div>
<p>All mentioned APIs offer memoization but the difference is what theyâ€™re intended to memoize, who can access the cache, and when their cache is invalidated.</p>
<h4 id="deep-dive-use-memo">
<code dir="ltr">useMemo</code> <a href="#deep-dive-use-memo" aria-label="Link for this heading" title="Link for this heading"><svg width="1em" height="1em" viewbox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a>
</h4>
<p>In general, you should use <a href="usememo"><code dir="ltr">useMemo</code></a> for caching an expensive computation in a Client Component across renders. As an example, to memoize a transformation of data within a component.</p>
<pre data-language="jsx"><code><span>'use client'</span><span>;</span>

<span>function</span> <span>WeatherReport</span><span>(</span><span>{</span><span>record</span><span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>avgTemp</span> = <span>useMemo</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>calculateAvg</span><span>(</span><span>record</span><span>)</span><span>,</span> <span>record</span><span>)</span><span>;</span>
  <span>// ...</span>
<span>}</span>

<span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>record</span> = <span>getRecord</span><span>(</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>WeatherReport</span> <span>record</span>=<span>{</span><span>record</span><span>}</span> <span>/&gt;</span>
      <span>&lt;</span><span>WeatherReport</span> <span>record</span>=<span>{</span><span>record</span><span>}</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span></code></pre>
<p>In this example, <code dir="ltr">App</code> renders two <code dir="ltr">WeatherReport</code>s with the same record. Even though both components do the same work, they cannot share work. <code dir="ltr">useMemo</code>â€™s cache is only local to the component.</p>
<p>However, <code dir="ltr">useMemo</code> does ensure that if <code dir="ltr">App</code> re-renders and the <code dir="ltr">record</code> object doesnâ€™t change, each component instance would skip work and use the memoized value of <code dir="ltr">avgTemp</code>. <code dir="ltr">useMemo</code> will only cache the last computation of <code dir="ltr">avgTemp</code> with the given dependencies.</p>
<h4 id="deep-dive-cache">
<code dir="ltr">cache</code> <a href="#deep-dive-cache" aria-label="Link for this heading" title="Link for this heading"><svg width="1em" height="1em" viewbox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a>
</h4>
<p>In general, you should use <code dir="ltr">cache</code> in Server Components to memoize work that can be shared across components.</p>
<pre data-language="jsx"><code><span>const</span> <span>cachedFetchReport</span> = <span>cache(fetchReport)</span><span>;</span>

<span>function</span> <span>WeatherReport</span><span>(</span><span>{</span><span>city</span><span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>report</span> = <span>cachedFetchReport</span><span>(</span><span>city</span><span>)</span><span>;</span>
  <span>// ...</span>
<span>}</span>

<span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>city</span> = <span>"Los Angeles"</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;WeatherReport city={city} /&gt;</span>
      <span>&lt;WeatherReport city={city} /&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span></code></pre>
<p>Re-writing the previous example to use <code dir="ltr">cache</code>, in this case the <span data-step="3">second instance of <code dir="ltr">WeatherReport</code></span> will be able to skip duplicate work and read from the same cache as the <span data-step="1">first <code dir="ltr">WeatherReport</code></span>. Another difference from the previous example is that <code dir="ltr">cache</code> is also recommended for <span data-step="2">memoizing data fetches</span>, unlike <code dir="ltr">useMemo</code> which should only be used for computations.</p>
<p>At this time, <code dir="ltr">cache</code> should only be used in Server Components and the cache will be invalidated across server requests.</p>
<h4 id="deep-dive-memo">
<code dir="ltr">memo</code> <a href="#deep-dive-memo" aria-label="Link for this heading" title="Link for this heading"><svg width="1em" height="1em" viewbox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a>
</h4>
<p>You should use <a href="memo"><code dir="ltr">memo</code></a> to prevent a component re-rendering if its props are unchanged.</p>
<pre data-language="jsx"><code><span>'use client'</span><span>;</span>

<span>function</span> <span>WeatherReport</span><span>(</span><span>{</span><span>record</span><span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>avgTemp</span> = <span>calculateAvg</span><span>(</span><span>record</span><span>)</span><span>;</span>
  <span>// ...</span>
<span>}</span>

<span>const</span> <span>MemoWeatherReport</span> = <span>memo</span><span>(</span><span>WeatherReport</span><span>)</span><span>;</span>

<span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>record</span> = <span>getRecord</span><span>(</span><span>)</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>MemoWeatherReport</span> <span>record</span>=<span>{</span><span>record</span><span>}</span> <span>/&gt;</span>
      <span>&lt;</span><span>MemoWeatherReport</span> <span>record</span>=<span>{</span><span>record</span><span>}</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span></code></pre>
<p>In this example, both <code dir="ltr">MemoWeatherReport</code> components will call <code dir="ltr">calculateAvg</code> when first rendered. However, if <code dir="ltr">App</code> re-renders, with no changes to <code dir="ltr">record</code>, none of the props have changed and <code dir="ltr">MemoWeatherReport</code> will not re-render.</p>
<p>Compared to <code dir="ltr">useMemo</code>, <code dir="ltr">memo</code> memoizes the component render based on props vs. specific computations. Similar to <code dir="ltr">useMemo</code>, the memoized component only caches the last render with the last prop values. Once the props change, the cache invalidates and the component re-renders.</p>
</div></details> <hr> <h2 id="troubleshooting">Troubleshooting <a href="#troubleshooting" aria-label="Link for Troubleshooting " title="Link for Troubleshooting "><svg width="1em" height="1em" viewbox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a>
</h2> <h3 id="memoized-function-still-runs">My memoized function still runs even though Iâ€™ve called it with the same arguments <a href="#memoized-function-still-runs" aria-label="Link for My memoized function still runs even though Iâ€™ve called it with the same arguments " title="Link for My memoized function still runs even though Iâ€™ve called it with the same arguments "><svg width="1em" height="1em" viewbox="0 0 13 13" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor" fill-rule="evenodd"><path d="M7.778 7.975a2.5 2.5 0 0 0 .347-3.837L6.017 2.03a2.498 2.498 0 0 0-3.542-.007 2.5 2.5 0 0 0 .006 3.543l1.153 1.15c.07-.29.154-.563.25-.773.036-.077.084-.16.14-.25L3.18 4.85a1.496 1.496 0 0 1 .002-2.12 1.496 1.496 0 0 1 2.12 0l2.124 2.123a1.496 1.496 0 0 1-.333 2.37c.16.246.42.504.685.752z"></path><path d="M5.657 4.557a2.5 2.5 0 0 0-.347 3.837l2.108 2.108a2.498 2.498 0 0 0 3.542.007 2.5 2.5 0 0 0-.006-3.543L9.802 5.815c-.07.29-.154.565-.25.774-.036.076-.084.16-.14.25l.842.84c.585.587.59 1.532 0 2.122-.587.585-1.532.59-2.12 0L6.008 7.68a1.496 1.496 0 0 1 .332-2.372c-.16-.245-.42-.503-.685-.75z"></path></g></svg></a>
</h3> <p>See prior mentioned pitfalls</p> <ul> <li><a href="#pitfall-different-memoized-functions">Calling different memoized functions will read from different caches.</a></li> <li><a href="#pitfall-memoized-call-outside-component">Calling a memoized function outside of a component will not use the cache.</a></li> </ul> <p>If none of the above apply, it may be a problem with how React checks if something exists in cache.</p> <p>If your arguments are not <a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" target="_blank" rel="nofollow noopener noreferrer">primitives</a> (ex. objects, functions, arrays), ensure youâ€™re passing the same object reference.</p> <p>When calling a memoized function, React will look up the input arguments to see if a result is already cached. React will use shallow equality of the arguments to determine if there is a cache hit.</p> <pre data-language="jsx"><code><span>import</span> <span>{</span><span>cache</span><span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>const</span> <span>calculateNorm</span> = <span>cache</span><span>(</span><span>(</span><span>vector</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>// ...</span>
<span>}</span><span>)</span><span>;</span>

<span>function</span> <span>MapMarker</span><span>(</span><span>props</span><span>)</span> <span>{</span>
  <span>// ðŸš© Wrong: props is an object that changes every render.</span>
  <span>const</span> <span>length</span> = <span>calculateNorm</span><span>(</span><span>props</span><span>)</span><span>;</span>
  <span>// ...</span>
<span>}</span>

<span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>MapMarker</span> <span>x</span>=<span>{</span><span>10</span><span>}</span> <span>y</span>=<span>{</span><span>10</span><span>}</span> <span>z</span>=<span>{</span><span>10</span><span>}</span> <span>/&gt;</span>
      <span>&lt;</span><span>MapMarker</span> <span>x</span>=<span>{</span><span>10</span><span>}</span> <span>y</span>=<span>{</span><span>10</span><span>}</span> <span>z</span>=<span>{</span><span>10</span><span>}</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span></code></pre> <p>In this case the two <code dir="ltr">MapMarker</code>s look like theyâ€™re doing the same work and calling <code dir="ltr">calculateNorm</code> with the same value of <code dir="ltr">{x: 10, y: 10, z:10}</code>. Even though the objects contain the same values, they are not the same object reference as each component creates its own <code dir="ltr">props</code> object.</p> <p>React will call <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is" target="_blank" rel="nofollow noopener noreferrer"><code dir="ltr">Object.is</code></a> on the input to verify if there is a cache hit.</p> <pre data-language="jsx"><code><span>import</span> <span>{</span><span>cache</span><span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>const</span> <span>calculateNorm</span> = <span>cache</span><span>(</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>z</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>// ...</span>
<span>}</span><span>)</span><span>;</span>

<span>function</span> <span>MapMarker</span><span>(</span><span>props</span><span>)</span> <span>{</span>
  <span>// âœ… Good: Pass primitives to memoized function</span>
  <span>const</span> <span>length</span> = <span>calculateNorm</span><span>(</span><span>props</span>.<span>x</span><span>,</span> <span>props</span>.<span>y</span><span>,</span> <span>props</span>.<span>z</span><span>)</span><span>;</span>
  <span>// ...</span>
<span>}</span>

<span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>MapMarker</span> <span>x</span>=<span>{</span><span>10</span><span>}</span> <span>y</span>=<span>{</span><span>10</span><span>}</span> <span>z</span>=<span>{</span><span>10</span><span>}</span> <span>/&gt;</span>
      <span>&lt;</span><span>MapMarker</span> <span>x</span>=<span>{</span><span>10</span><span>}</span> <span>y</span>=<span>{</span><span>10</span><span>}</span> <span>z</span>=<span>{</span><span>10</span><span>}</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span></code></pre> <p>One way to address this could be to pass the vector dimensions to <code dir="ltr">calculateNorm</code>. This works because the dimensions themselves are primitives.</p> <p>Another solution may be to pass the vector object itself as a prop to the component. Weâ€™ll need to pass the same object to both component instances.</p> <pre data-language="jsx"><code><span>import</span> <span>{</span><span>cache</span><span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>const</span> <span>calculateNorm</span> = <span>cache</span><span>(</span><span>(</span><span>vector</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>// ...</span>
<span>}</span><span>)</span><span>;</span>

<span>function</span> <span>MapMarker</span><span>(</span><span>props</span><span>)</span> <span>{</span>
  <span>// âœ… Good: Pass the same `vector` object</span>
  <span>const</span> <span>length</span> = <span>calculateNorm</span><span>(</span><span>props</span>.<span>vector</span><span>)</span><span>;</span>
  <span>// ...</span>
<span>}</span>

<span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>vector</span> = <span>[</span><span>10</span><span>,</span> <span>10</span><span>,</span> <span>10</span><span>]</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span><span>MapMarker</span> <span>vector</span>=<span>{</span><span>vector</span><span>}</span> <span>/&gt;</span>
      <span>&lt;</span><span>MapMarker</span> <span>vector</span>=<span>{</span><span>vector</span><span>}</span> <span>/&gt;</span>
    <span>&lt;/</span><span>&gt;</span>
  <span>)</span><span>;</span>
<span>}</span></code></pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2013&ndash;present Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>
    <a href="https://react.dev/reference/react/cache" class="_attribution-link">https://react.dev/reference/react/cache</a>
  </p>
</div>
