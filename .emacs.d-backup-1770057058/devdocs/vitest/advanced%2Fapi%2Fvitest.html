<h1 id="vitest" tabindex="-1">Vitest </h1>
<p>Vitest instance requires the current test mode. It can be either:</p>
<ul>
<li>
<code>test</code> when running runtime tests</li>
<li>
<code>benchmark</code> when running benchmarks <span class="VPBadge warning">experimental</span>
</li>
</ul>
<div class="details custom-block">
<summary>New in Vitest 3</summary><p>Vitest 3 is one step closer to stabilising the public API. To achieve that, we deprecated and removed some of the previously public methods on the <code>Vitest</code> class. These APIs were made private:</p>
<ul>
<li>
<code>configOverride</code> (use <a href="#setglobaltestnamepattern"><code>setGlobalTestNamePattern</code></a> or <a href="#enablesnapshotupdate"><code>enableSnapshotUpdate</code></a>)</li>
<li><code>coverageProvider</code></li>
<li><code>filenamePattern</code></li>
<li><code>runningPromise</code></li>
<li><code>closingPromise</code></li>
<li><code>isCancelling</code></li>
<li><code>coreWorkspaceProject</code></li>
<li><code>resolvedProjects</code></li>
<li><code>_browserLastPort</code></li>
<li><code>_options</code></li>
<li><code>reporters</code></li>
<li><code>vitenode</code></li>
<li><code>runner</code></li>
<li><code>pool</code></li>
<li><code>setServer</code></li>
<li><code>_initBrowserServers</code></li>
<li><code>rerunTask</code></li>
<li><code>changeProjectName</code></li>
<li><code>changeNamePattern</code></li>
<li><code>changeFilenamePattern</code></li>
<li><code>rerunFailed</code></li>
<li>
<code>_createRootProject</code> (renamed to <code>_ensureRootProject</code>, but still private)</li>
<li>
<code>filterTestsBySource</code> (this was moved to the new internal <code>vitest.specifications</code> instance)</li>
<li>
<code>runFiles</code> (use <a href="#runtestspecifications"><code>runTestSpecifications</code></a> instead)</li>
<li><code>onAfterSetServer</code></li>
</ul>
<p>These APIs were deprecated:</p>
<ul>
<li><code>invalidates</code></li>
<li>
<code>changedTests</code> (use <a href="#onfilterwatchedspecification"><code>onFilterWatchedSpecification</code></a> instead)</li>
<li>
<code>server</code> (use <a href="#vite"><code>vite</code></a> instead)</li>
<li>
<code>getProjectsByTestFile</code> (use <a href="#getmodulespecifications"><code>getModuleSpecifications</code></a> instead)</li>
<li>
<code>getFileWorkspaceSpecs</code> (use <a href="#getmodulespecifications"><code>getModuleSpecifications</code></a> instead)</li>
<li>
<code>getModuleProjects</code> (filter by <a href="#projects"><code>this.projects</code></a> yourself)</li>
<li>
<code>updateLastChanged</code> (renamed to <a href="#invalidatefile"><code>invalidateFile</code></a>)</li>
<li>
<code>globTestSpecs</code> (use <a href="#globtestspecifications"><code>globTestSpecifications</code></a> instead)</li>
<li>
<code>globTestFiles</code> (use <a href="#globtestspecifications"><code>globTestSpecifications</code></a> instead)</li>
<li>
<code>listFile</code> (use <a href="#getrelevanttestspecifications"><code>getRelevantTestSpecifications</code></a> instead)</li>
</ul>
</div>
<h2 id="mode" tabindex="-1">mode </h2>
<h3 id="test" tabindex="-1">test </h3>
<p>Test mode will only call functions inside <code>test</code> or <code>it</code>, and throws an error when <code>bench</code> is encountered. This mode uses <code>include</code> and <code>exclude</code> options in the config to find test files.</p>
<h3 id="benchmark-experimental" tabindex="-1">benchmark <span class="VPBadge warning">experimental</span> </h3>
<p>Benchmark mode calls <code>bench</code> functions and throws an error, when it encounters <code>test</code> or <code>it</code>. This mode uses <code>benchmark.include</code> and <code>benchmark.exclude</code> options in the config to find benchmark files.</p>
<h2 id="config" tabindex="-1">config </h2>
<p>The root (or global) config. If workspace feature is enabled, projects will reference this as <code>globalConfig</code>.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>This is Vitest config, it doesn't extend <em>Vite</em> config. It only has resolved values from the <code>test</code> property.</p>
</div>
<h2 id="vite" tabindex="-1">vite </h2>
<p>This is a global <a href="https://vite.dev/guide/api-javascript#vitedevserver" target="_blank" rel="noreferrer"><code>ViteDevServer</code></a>.</p>
<h2 id="state-experimental" tabindex="-1">state <span class="VPBadge warning">experimental</span> </h2>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>Public <code>state</code> is an experimental API (except <code>vitest.state.getReportedEntity</code>). Breaking changes might not follow SemVer, please pin Vitest's version when using it.</p>
</div>
<p>Global state stores information about the current tests. It uses the same API from <code>@vitest/runner</code> by default, but we recommend using the <a href="../reporters#reported-tasks">Reported Tasks API</a> instead by calling <code>state.getReportedEntity()</code> on the <code>@vitest/runner</code> API:</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">const task = vitest.state.idMap.get(taskId) // old API
const testCase = vitest.state.getReportedEntity(task) // new API</pre>
</div>
<p>In the future, the old API won't be exposed anymore.</p>
<h2 id="snapshot" tabindex="-1">snapshot </h2>
<p>The global snapshot manager. Vitest keeps track of all snapshots using the <code>snapshot.add</code> method.</p>
<p>You can get the latest summary of snapshots via the <code>vitest.snapshot.summay</code> property.</p>
<h2 id="cache" tabindex="-1">cache </h2>
<p>Cache manager that stores information about latest test results and test file stats. In Vitest itself this is only used by the default sequencer to sort tests.</p>
<h2 id="projects" tabindex="-1">projects </h2>
<p>An array of <a href="test-project">test projects</a> that belong to the user's workspace. If the user did not specify a custom workspace, the workspace will only have a <a href="#getrootproject">root project</a>.</p>
<p>Vitest will ensure that there is always at least one project in the workspace. If the user specifies a non-existent <code>--project</code> name, Vitest will throw an error.</p>
<h2 id="getrootproject" tabindex="-1">getRootProject </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function getRootProject(): TestProject</pre>
</div>
<p>This returns the root test project. The root project generally doesn't run any tests and is not included in <code>vitest.projects</code> unless the user explicitly includes the root config in their workspace, or the workspace is not defined at all.</p>
<p>The primary goal of the root project is to setup the global config. In fact, <code>rootProject.config</code> references <code>rootProject.globalConfig</code> and <code>vitest.config</code> directly:</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">rootProject.config === rootProject.globalConfig === rootProject.vitest.config</pre>
</div>
<h2 id="provide" tabindex="-1">provide </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function provide&lt;T extends keyof ProvidedContext &amp; string&gt;(
  key: T,
  value: ProvidedContext[T],
): void</pre>
</div>
<p>Vitest exposes <code>provide</code> method which is a shorthand for <code>vitest.getRootProject().provide</code>. With this method you can pass down values from the main thread to tests. All values are checked with <code>structuredClone</code> before they are stored, but the values themselves are not cloned.</p>
<p>To recieve the values in the test, you need to import <code>inject</code> method from <code>vitest</code> entrypont:</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { inject } from 'vitest'
const port = inject('wsPort') // 3000</pre>
</div>
<p>For better type safety, we encourage you to augment the type of <code>ProvidedContext</code>:</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { createVitest } from 'vitest/node'

const vitest = await createVitest('test', {
  watch: false,
})
vitest.provide('wsPort', 3000)

declare module 'vitest' {
  export interface ProvidedContext {
    wsPort: number
  }
}</pre>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>Technically, <code>provide</code> is a method of <a href="test-project"><code>TestProject</code></a>, so it is limited to the specific project. However, all projects inherit the values from the core project which makes <code>vitest.provide</code> universal way of passing down values to tests.</p>
</div>
<h2 id="getprovidedcontext" tabindex="-1">getProvidedContext </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function getProvidedContext(): ProvidedContext</pre>
</div>
<p>This returns the root context object. This is a shorthand for <code>vitest.getRootProject().getProvidedContext</code>.</p>
<h2 id="getprojectbyname" tabindex="-1">getProjectByName </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function getProjectByName(name: string): TestProject</pre>
</div>
<p>This method returns the project by its name. Simillar to calling <code>vitest.projects.find</code>.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>In case the project doesn't exist, this method will return the root project - make sure to check the names again if the project you are looking for is the one returned.</p>
<p>If user didn't customize a name, the Vitest will assign an empty string as a name.</p>
</div>
<h2 id="globtestspecifications" tabindex="-1">globTestSpecifications </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function globTestSpecifications(
  filters?: string[],
): Promise&lt;TestSpecification[]&gt;</pre>
</div>
<p>This method constructs new <a href="test-specification">test specifications</a> by collecting every test in all projects with <a href="test-project#globtestfiles"><code>project.globTestFiles</code></a>. It accepts string filters to match the test files - these are the same filters that <a href="../../guide/filtering#cli">CLI supports</a>.</p>
<p>This method automatically caches all test specifications. When you call <a href="#getmodulespecifications"><code>getModuleSpecifications</code></a> next time, it will return the same specifications unless <a href="#clearspecificationscache"><code>clearSpecificationsCache</code></a> was called before that.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>As of Vitest 3, it's possible to have multiple test specifications with the same module ID (file path) if <code>poolMatchGlob</code> has several pools or if <code>typecheck</code> is enabled. This possibility will be removed in Vitest 4.</p>
</div>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">const specifications = await vitest.globTestSpecifications(['my-filter'])
// [TestSpecification{ moduleId: '/tests/my-filter.test.ts' }]
console.log(specifications)</pre>
</div>
<h2 id="getrelevanttestspecifications" tabindex="-1">getRelevantTestSpecifications </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function getRelevantTestSpecifications(
  filters?: string[]
): Promise&lt;TestSpecification[]&gt;</pre>
</div>
<p>This method resolves every test specification by calling <a href="test-project#globtestfiles"><code>project.globTestFiles</code></a>. It accepts string filters to match the test files - these are the same filters that <a href="../../guide/filtering#cli">CLI supports</a>. If <code>--changed</code> flag was specified, the list will be filtered to include only files that changed. <code>getRelevantTestSpecifications</code> doesn't run any test files.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>This method can be slow because it needs to filter <code>--changed</code> flags. Do not use it if you just need a list of test files.</p>
<ul>
<li>If you need to get the list of specifications for known test files, use <a href="#getmodulespecifications"><code>getModuleSpecifications</code></a> instead.</li>
<li>If you need to get the list of all possible test files, use <a href="#globtestspecifications"><code>globTestSpecifications</code></a>.</li>
</ul>
</div>
<h2 id="mergereports" tabindex="-1">mergeReports </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function mergeReports(directory?: string): Promise&lt;TestRunResult&gt;</pre>
</div>
<p>Merge reports from multiple runs located in the specified directory (value from <code>--merge-reports</code> if not specified). This value can also be set on <code>config.mergeReports</code> (by default, it will read <code>.vitest-reports</code> folder).</p>
<p>Note that the <code>directory</code> will always be resolved relative to the working directory.</p>
<p>This method is called automatically by <a href="../guide/tests"><code>startVitest</code></a> if <code>config.mergeReports</code> is set.</p>
<h2 id="collect" tabindex="-1">collect </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function collect(filters?: string[]): Promise&lt;TestRunResult&gt;</pre>
</div>
<p>Execute test files without running test callbacks. <code>collect</code> returns unhandled errors and an array of <a href="test-module">test modules</a>. It accepts string filters to match the test files - these are the same filters that <a href="../../guide/filtering#cli">CLI supports</a>.</p>
<p>This method resolves tests specifications based on the config <code>include</code>, <code>exclude</code>, and <code>includeSource</code> values. Read more at <a href="test-project#globtestfiles"><code>project.globTestFiles</code></a>. If <code>--changed</code> flag was specified, the list will be filtered to include only files that changed.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>Note that Vitest doesn't use static analysis to collect tests. Vitest will run every test file in isolation, just like it runs regular tests.</p>
<p>This makes this method very slow, unless you disable isolation before collecting tests.</p>
</div>
<h2 id="start" tabindex="-1">start </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function start(filters?: string[]): Promise&lt;TestRunResult&gt;</pre>
</div>
<p>Initialize reporters, the coverage provider, and run tests. This method accepts string filters to match the test files - these are the same filters that <a href="../../guide/filtering#cli">CLI supports</a>.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>This method should not be called if <a href="#init"><code>vitest.init()</code></a> is also invoked. Use <a href="#runtestspecifications"><code>runTestSpecifications</code></a> or <a href="#reruntestspecifications"><code>rerunTestSpecifications</code></a> instead if you need to run tests after Vitest was inititalised.</p>
</div>
<p>This method is called automatically by <a href="../guide/tests"><code>startVitest</code></a> if <code>config.mergeReports</code> and <code>config.standalone</code> are not set.</p>
<h2 id="init" tabindex="-1">init </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function init(): Promise&lt;void&gt;</pre>
</div>
<p>Initialize reporters and the coverage provider. This method doesn't run any tests. If the <code>--watch</code> flag is provided, Vitest will still run changed tests even if this method was not called.</p>
<p>Internally, this method is called only if <a href="../../guide/cli#standalone"><code>--standalone</code></a> flag is enabled.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>This method should not be called if <a href="#start"><code>vitest.start()</code></a> is also invoked.</p>
</div>
<p>This method is called automatically by <a href="../guide/tests"><code>startVitest</code></a> if <code>config.standalone</code> is set.</p>
<h2 id="getmodulespecifications" tabindex="-1">getModuleSpecifications </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function getModuleSpecifications(moduleId: string): TestSpecification[]</pre>
</div>
<p>Returns a list of test specifications related to the module ID. The ID should already be resolved to an absolute file path. If ID doesn't match <code>include</code> or <code>includeSource</code> patterns, the returned array will be empty.</p>
<p>This method can return already cached specifications based on the <code>moduleId</code> and <code>pool</code>. But note that <a href="test-project#createspecification"><code>project.createSpecification</code></a> always returns a new instance and it's not cached automatically. However, specifications are automatically cached when <a href="#runtestspecifications"><code>runTestSpecifications</code></a> is called.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>As of Vitest 3, this method uses a cache to check if the file is a test. To make sure that the cache is not empty, call <a href="#globtestspecifications"><code>globTestSpecifications</code></a> at least once.</p>
</div>
<h2 id="clearspecificationscache" tabindex="-1">clearSpecificationsCache </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function clearSpecificationsCache(moduleId?: string): void</pre>
</div>
<p>Vitest automatically caches test specifications for each file when <a href="#globtestspecifications"><code>globTestSpecifications</code></a> or <a href="#runtestspecifications"><code>runTestSpecifications</code></a> is called. This method clears the cache for the given file or the whole cache alltogether depending on the first argument.</p>
<h2 id="runtestspecifications" tabindex="-1">runTestSpecifications </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function runTestSpecifications(
  specifications: TestSpecification[],
  allTestsRun = false
): Promise&lt;TestRunResult&gt;</pre>
</div>
<p>This method runs every test based on the received <a href="test-specification">specifications</a>. The second argument, <code>allTestsRun</code>, is used by the coverage provider to determine if it needs to instrument coverage on <em>every</em> file in the root (this only matters if coverage is enabled and <code>coverage.all</code> is set to <code>true</code>).</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>This method doesn't trigger <code>onWatcherRerun</code>, <code>onWatcherStart</code> and <code>onTestsRerun</code> callbacks. If you are rerunning tests based on the file change, consider using <a href="#reruntestspecifications"><code>rerunTestSpecifications</code></a> instead.</p>
</div>
<h2 id="reruntestspecifications" tabindex="-1">rerunTestSpecifications </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function rerunTestSpecifications(
  specifications: TestSpecification[],
  allTestsRun = false
): Promise&lt;TestRunResult&gt;</pre>
</div>
<p>This method emits <code>reporter.onWatcherRerun</code> and <code>onTestsRerun</code> events, then it runs tests with <a href="#runtestspecifications"><code>runTestSpecifications</code></a>. If there were no errors in the main process, it will emit <code>reporter.onWatcherStart</code> event.</p>
<h2 id="updatesnapshot" tabindex="-1">updateSnapshot </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function updateSnapshot(files?: string[]): Promise&lt;TestRunResult&gt;</pre>
</div>
<p>Update snapshots in specified files. If no files are provided, it will update files with failed tests and obsolete snapshots.</p>
<h2 id="collecttests" tabindex="-1">collectTests </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function collectTests(
  specifications: TestSpecification[]
): Promise&lt;TestRunResult&gt;</pre>
</div>
<p>Execute test files without running test callbacks. <code>collectTests</code> returns unhandled errors and an array of <a href="test-module">test modules</a>.</p>
<p>This method works exactly the same as <a href="#collect"><code>collect</code></a>, but you need to provide test specifications yourself.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>Note that Vitest doesn't use static analysis to collect tests. Vitest will run every test file in isolation, just like it runs regular tests.</p>
<p>This makes this method very slow, unless you disable isolation before collecting tests.</p>
</div>
<h2 id="cancelcurrentrun" tabindex="-1">cancelCurrentRun </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function cancelCurrentRun(reason: CancelReason): Promise&lt;void&gt;</pre>
</div>
<p>This method will gracefully cancel all ongoing tests. It will wait for started tests to finish running and will not run tests that were scheduled to run but haven't started yet.</p>
<h2 id="setglobaltestnamepattern" tabindex="-1">setGlobalTestNamePattern </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function setGlobalTestNamePattern(pattern: string | RegExp): void</pre>
</div>
<p>This methods overrides the global <a href="../../config/index#testnamepattern">test name pattern</a>.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>This method doesn't start running any tests. To run tests with updated pattern, call <a href="#runtestspecifications"><code>runTestSpecifications</code></a>.</p>
</div>
<h2 id="resetglobaltestnamepattern" tabindex="-1">resetGlobalTestNamePattern </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function resetGlobalTestNamePattern(): void</pre>
</div>
<p>This methods resets the <a href="../../config/index#testnamepattern">test name pattern</a>. It means Vitest won't skip any tests now.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>This method doesn't start running any tests. To run tests without a pattern, call <a href="#runtestspecifications"><code>runTestSpecifications</code></a>.</p>
</div>
<h2 id="enablesnapshotupdate" tabindex="-1">enableSnapshotUpdate </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function enableSnapshotUpdate(): void</pre>
</div>
<p>Enable the mode that allows updating snapshots when running tests. Every test that runs after this method is called will update snapshots. To disable the mode, call <a href="#resetsnapshotupdate"><code>resetSnapshotUpdate</code></a>.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>This method doesn't start running any tests. To update snapshots, run tests with <a href="#runtestspecifications"><code>runTestSpecifications</code></a>.</p>
</div>
<h2 id="resetsnapshotupdate" tabindex="-1">resetSnapshotUpdate </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function resetSnapshotUpdate(): void</pre>
</div>
<p>Disable the mode that allows updating snapshots when running tests. This method doesn't start running any tests.</p>
<h2 id="invalidatefile" tabindex="-1">invalidateFile </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function invalidateFile(filepath: string): void</pre>
</div>
<p>This method invalidates the file in the cache of every project. It is mostly useful if you rely on your own watcher because Vite's cache persist in memory.</p>
<div class="danger custom-block">
<strong class="custom-block-title">DANGER</strong><p>If you disable Vitest's watcher but keep Vitest running, it is important to manually clear the cache with this method because there is no way to disable the cache. This method will also invalidate file's importers.</p>
</div>
<h2 id="import" tabindex="-1">import </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function import&lt;T&gt;(moduleId: string): Promise&lt;T&gt;</pre>
</div>
<p>Import a file using Vite module runner. The file will be transformed by Vite with the global config and executed in a separate context. Note that <code>moduleId</code> will be relative to the <code>config.root</code>.</p>
<div class="danger custom-block">
<strong class="custom-block-title">DANGER</strong><p><code>project.import</code> reuses Vite's module graph, so importing the same module using a regular import will return a different module:</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import * as staticExample from './example.js'
const dynamicExample = await vitest.import('./example.js')

dynamicExample !== staticExample // âœ…</pre>
</div>
</div>
<div class="info custom-block">
<strong class="custom-block-title">INFO</strong><p>Internally, Vitest uses this method to import global setups, custom coverage providers, workspace file, and custom reporters, meaning all of them share the same module graph as long as they belong to the same Vite server.</p>
</div>
<h2 id="close" tabindex="-1">close </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function close(): Promise&lt;void&gt;</pre>
</div>
<p>Closes all projects and their associated resources. This can only be called once; the closing promise is cached until the server restarts.</p>
<h2 id="exit" tabindex="-1">exit </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function exit(force = false): Promise&lt;void&gt;</pre>
</div>
<p>Closes all projects and exit the process. If <code>force</code> is set to <code>true</code>, the process will exit immediately after closing the projects.</p>
<p>This method will also forcefuly call <code>process.exit()</code> if the process is still active after <a href="../../config/index#teardowntimeout"><code>config.teardownTimeout</code></a> milliseconds.</p>
<h2 id="shouldkeepserver" tabindex="-1">shouldKeepServer </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function shouldKeepServer(): boolean</pre>
</div>
<p>This method will return <code>true</code> if the server should be kept running after the tests are done. This usually means that the <code>watch</code> mode was enabled.</p>
<h2 id="onserverrestart" tabindex="-1">onServerRestart </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function onServerRestart(fn: OnServerRestartHandler): void</pre>
</div>
<p>Register a handler that will be called when the server is restarted due to a config change.</p>
<h2 id="oncancel" tabindex="-1">onCancel </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function onCancel(fn: (reason: CancelReason) =&gt; Awaitable&lt;void&gt;): void</pre>
</div>
<p>Register a handler that will be called when the test run is cancelled with <a href="#cancelcurrentrun"><code>vitest.cancelCurrentRun</code></a>.</p>
<h2 id="onclose" tabindex="-1">onClose </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function onClose(fn: () =&gt; Awaitable&lt;void&gt;): void</pre>
</div>
<p>Register a handler that will be called when the server is closed.</p>
<h2 id="ontestsrerun" tabindex="-1">onTestsRerun </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function onTestsRerun(fn: OnTestsRerunHandler): void</pre>
</div>
<p>Register a handler that will be called when the tests are rerunning. The tests can rerun when <a href="#reruntestspecifications"><code>rerunTestSpecifications</code></a> is called manually or when a file is changed and the built-in watcher schedules a rerun.</p>
<h2 id="onfilterwatchedspecification" tabindex="-1">onFilterWatchedSpecification </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function onFilterWatchedSpecification(
  fn: (specification: TestSpecification) =&gt; boolean
): void</pre>
</div>
<p>Register a handler that will be called when a file is changed. This callback should return <code>true</code> or <code>false</code>, indicating whether the test file needs to be rerun.</p>
<p>With this method, you can hook into the default watcher logic to delay or discard tests that the user doesn't want to keep track of at the moment:</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">const continuesTests: string[] = []

myCustomWrapper.onContinuesRunEnabled(testItem =&gt;
  continuesTests.push(item.fsPath)
)

vitest.onFilterWatchedSpecification(specification =&gt;
  continuesTests.includes(specification.moduleId)
)</pre>
</div>
<p>Vitest can create different specifications for the same file depending on the <code>pool</code> or <code>locations</code> options, so do not rely on the reference. Vitest can also return cached specification from <a href="#getmodulespecifications"><code>vitest.getModuleSpecifications</code></a> - the cache is based on the <code>moduleId</code> and <code>pool</code>. Note that <a href="test-project#createspecification"><code>project.createSpecification</code></a> always returns a new instance.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2021-Present Anthony Fu<br>&copy; 2021-Present Matias Capeletto<br>Licensed under the MIT License.<br>
    <a href="https://vitest.dev/advanced/api/vitest" class="_attribution-link">https://vitest.dev/advanced/api/vitest</a>
  </p>
</div>
