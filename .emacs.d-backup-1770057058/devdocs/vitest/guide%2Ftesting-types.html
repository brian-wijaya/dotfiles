<h1 id="testing-types" tabindex="-1">Testing Types </h1>
<div class="tip custom-block">
<strong class="custom-block-title">Sample Project</strong><p><a href="https://github.com/vitest-dev/vitest/tree/main/examples/typecheck" target="_blank" rel="noreferrer">GitHub</a> - <a href="https://stackblitz.com/fork/github/vitest-dev/vitest/tree/main/examples/typecheck?initialPath=__vitest__/" target="_blank" rel="noreferrer">Play Online</a></p>
</div>
<p>Vitest allows you to write tests for your types, using <code>expectTypeOf</code> or <code>assertType</code> syntaxes. By default all tests inside <code>*.test-d.ts</code> files are considered type tests, but you can change it with <a href="../config/index#typecheck-include"><code>typecheck.include</code></a> config option.</p>
<p>Under the hood Vitest calls <code>tsc</code> or <code>vue-tsc</code>, depending on your config, and parses results. Vitest will also print out type errors in your source code, if it finds any. You can disable it with <a href="../config/index#typecheck-ignoresourceerrors"><code>typecheck.ignoreSourceErrors</code></a> config option.</p>
<p>Keep in mind that Vitest doesn't run these files, they are only statically analyzed by the compiler. Meaning, that if you use a dynamic name or <code>test.each</code> or <code>test.for</code>, the test name will not be evaluated - it will be displayed as is.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>Before Vitest 2.1, your <code>typecheck.include</code> overrode the <code>include</code> pattern, so your runtime tests did not actually run; they were only type-checked.</p>
<p>Since Vitest 2.1, if your <code>include</code> and <code>typecheck.include</code> overlap, Vitest will report type tests and runtime tests as separate entries.</p>
</div>
<p>Using CLI flags, like <code>--allowOnly</code> and <code>-t</code> are also supported for type checking.</p>
<div class="vp-code-block-title">
<div class="vp-code-block-title-bar"><span class="vp-code-block-title-text" data-title="mount.test-d.ts">mount.test-d.ts</span></div>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { assertType, expectTypeOf } from 'vitest'
import { mount } from './mount.js'

test('my types work properly', () =&gt; {
  expectTypeOf(mount).toBeFunction()
  expectTypeOf(mount).parameter(0).toMatchTypeOf&lt;{ name: string }&gt;()

  // @ts-expect-error name is a string
  assertType(mount({ name: 42 }))
})</pre>
</div>
</div>
<p>Any type error triggered inside a test file will be treated as a test error, so you can use any type trick you want to test types of your project.</p>
<p>You can see a list of possible matchers in <a href="../api/expect-typeof">API section</a>.</p>
<h2 id="reading-errors" tabindex="-1">Reading Errors </h2>
<p>If you are using <code>expectTypeOf</code> API, refer to the <a href="https://github.com/mmkal/expect-type#error-messages" target="_blank" rel="noreferrer">expect-type documentation on its error messages</a>.</p>
<p>When types don't match, <code>.toEqualTypeOf</code> and <code>.toMatchTypeOf</code> use a special helper type to produce error messages that are as actionable as possible. But there's a bit of an nuance to understanding them. Since the assertions are written "fluently", the failure should be on the "expected" type, not the "actual" type (<code>expect&lt;Actual&gt;().toEqualTypeOf&lt;Expected&gt;()</code>). This means that type errors can be a little confusing - so this library produces a <code>MismatchInfo</code> type to try to make explicit what the expectation is. For example:</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">expectTypeOf({ a: 1 }).toEqualTypeOf&lt;{ a: string }&gt;()</pre>
</div>
<p>Is an assertion that will fail, since <code>{a: 1}</code> has type <code>{a: number}</code> and not <code>{a: string}</code>. The error message in this case will read something like this:</p>
<div class="language- vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">test/test.ts:999:999 - error TS2344: Type '{ a: string; }' does not satisfy the constraint '{ a: \\"Expected: string, Actual: number\\"; }'.
  Types of property 'a' are incompatible.
    Type 'string' is not assignable to type '\\"Expected: string, Actual: number\\"'.

999 expectTypeOf({a: 1}).toEqualTypeOf&lt;{a: string}&gt;()</pre>
</div>
<p>Note that the type constraint reported is a human-readable messaging specifying both the "expected" and "actual" types. Rather than taking the sentence <code>Types of property 'a' are incompatible // Type 'string' is not assignable to type "Expected: string, Actual: number"</code> literally - just look at the property name (<code>'a'</code>) and the message: <code>Expected: string, Actual: number</code>. This will tell you what's wrong, in most cases. Extremely complex types will of course be more effort to debug, and may require some experimentation. Please <a href="https://github.com/mmkal/expect-type" target="_blank" rel="noreferrer">raise an issue</a> if the error messages are actually misleading.</p>
<p>The <code>toBe...</code> methods (like <code>toBeString</code>, <code>toBeNumber</code>, <code>toBeVoid</code> etc.) fail by resolving to a non-callable type when the <code>Actual</code> type under test doesn't match up. For example, the failure for an assertion like <code>expectTypeOf(1).toBeString()</code> will look something like this:</p>
<div class="language- vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">test/test.ts:999:999 - error TS2349: This expression is not callable.
  Type 'ExpectString&lt;number&gt;' has no call signatures.

999 expectTypeOf(1).toBeString()
                    ~~~~~~~~~~</pre>
</div>
<p>The <code>This expression is not callable</code> part isn't all that helpful - the meaningful error is the next line, <code>Type 'ExpectString&lt;number&gt; has no call signatures</code>. This essentially means you passed a number but asserted it should be a string.</p>
<p>If TypeScript added support for <a href="https://github.com/microsoft/TypeScript/pull/40468" target="_blank" rel="noreferrer">"throw" types</a> these error messages could be improved significantly. Until then they will take a certain amount of squinting.</p>
<h4 id="concrete-expected-objects-vs-typeargs" tabindex="-1">Concrete "expected" objects vs typeargs </h4>
<p>Error messages for an assertion like this:</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">expectTypeOf({ a: 1 }).toEqualTypeOf({ a: '' })</pre>
</div>
<p>Will be less helpful than for an assertion like this:</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">expectTypeOf({ a: 1 }).toEqualTypeOf&lt;{ a: string }&gt;()</pre>
</div>
<p>This is because the TypeScript compiler needs to infer the typearg for the <code>.toEqualTypeOf({a: ''})</code> style, and this library can only mark it as a failure by comparing it against a generic <code>Mismatch</code> type. So, where possible, use a typearg rather than a concrete type for <code>.toEqualTypeOf</code> and <code>toMatchTypeOf</code>. If it's much more convenient to compare two concrete types, you can use <code>typeof</code>:</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">const one = valueFromFunctionOne({ some: { complex: inputs } })
const two = valueFromFunctionTwo({ some: { other: inputs } })

expectTypeOf(one).toEqualTypeof&lt;typeof two&gt;()</pre>
</div>
<p>If you find it hard working with <code>expectTypeOf</code> API and figuring out errors, you can always use more simple <code>assertType</code> API:</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">const answer = 42

assertType&lt;number&gt;(answer)
// @ts-expect-error answer is not a string
assertType&lt;string&gt;(answer)</pre>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>When using <code>@ts-expect-error</code> syntax, you might want to make sure that you didn't make a typo. You can do that by including your type files in <a href="../config/index#include"><code>test.include</code></a> config option, so Vitest will also actually <em>run</em> these tests and fail with <code>ReferenceError</code>.</p>
<p>This will pass, because it expects an error, but the word “answer” has a typo, so it's a false positive error:</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">// @ts-expect-error answer is not a string
assertType&lt;string&gt;(answr)</pre>
</div>
</div>
<h2 id="run-typechecking" tabindex="-1">Run Typechecking </h2>
<p>To enable typechecking, just add <a href="../config/index#typecheck"><code>--typecheck</code></a> flag to your Vitest command in <code>package.json</code>:</p>
<div class="vp-code-block-title">
<div class="vp-code-block-title-bar"><span class="vp-code-block-title-text" data-title="package.json">package.json</span></div>
<div class="language-json vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">{
  "scripts": {
    "test": "vitest --typecheck"
  }
}</pre>
</div>
</div>
<p>Now you can run typecheck:</p>
<div class="vp-code-group vp-adaptive-theme">
<div class="tabs">
<input type="radio" name="group-k3Eew" id="tab-CYNqFSy" checked><label data-title="npm" for="tab-CYNqFSy">npm</label><input type="radio" name="group-k3Eew" id="tab-yDESrIH"><label data-title="yarn" for="tab-yDESrIH">yarn</label><input type="radio" name="group-k3Eew" id="tab-UrNxGVR"><label data-title="pnpm" for="tab-UrNxGVR">pnpm</label><input type="radio" name="group-k3Eew" id="tab-dAGxu82"><label data-title="bun" for="tab-dAGxu82">bun</label>
</div>
<div class="blocks">
<div class="language-bash vp-adaptive-theme active">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">npm run test</pre>
</div>
<div class="language-bash vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">yarn test</pre>
</div>
<div class="language-bash vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">pnpm run test</pre>
</div>
<div class="language-bash vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">bun test</pre>
</div>
</div>
</div>
<p>Vitest uses <code>tsc --noEmit</code> or <code>vue-tsc --noEmit</code>, depending on your configuration, so you can remove these scripts from your pipeline.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2021-Present Anthony Fu<br>&copy; 2021-Present Matias Capeletto<br>Licensed under the MIT License.<br>
    <a href="https://vitest.dev/guide/testing-types" class="_attribution-link">https://vitest.dev/guide/testing-types</a>
  </p>
</div>
