<h1 id="browser-mode" tabindex="-1">Browser Mode <span class="VPBadge warning">Experimental</span> </h1>
<p>This page provides information about the experimental browser mode feature in the Vitest API, which allows you to run your tests in the browser natively, providing access to browser globals like window and document. This feature is currently under development, and APIs may change in the future.</p>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>If you are looking for documentation for <code>expect</code>, <code>vi</code> or any general API like workspaces or type testing, refer to the <a href="../index">"Getting Started" guide</a>.</p>
</div>
<img alt="Vitest UI" img-light src="https://vitest.dev/ui-browser-1-light.png"><img alt="Vitest UI" img-dark src="https://vitest.dev/ui-browser-1-dark.png"><h2 id="installation" tabindex="-1">Installation </h2>
<p>For easier setup, you can use <code>vitest init browser</code> command to install required dependencies and create browser configuration.</p>
<div class="vp-code-group vp-adaptive-theme">
<div class="tabs">
<input type="radio" name="group-miQYp" id="tab-ebmyWdW" checked><label data-title="npm" for="tab-ebmyWdW">npm</label><input type="radio" name="group-miQYp" id="tab-DFNW1Hb"><label data-title="yarn" for="tab-DFNW1Hb">yarn</label><input type="radio" name="group-miQYp" id="tab-uPvDV29"><label data-title="pnpm" for="tab-uPvDV29">pnpm</label><input type="radio" name="group-miQYp" id="tab-qQvpKkX"><label data-title="bun" for="tab-qQvpKkX">bun</label>
</div>
<div class="blocks">
<div class="language-bash vp-adaptive-theme active">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">npx vitest init browser</pre>
</div>
<div class="language-bash vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">yarn exec vitest init browser</pre>
</div>
<div class="language-bash vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">pnpx vitest init browser</pre>
</div>
<div class="language-bash vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">bunx vitest init browser</pre>
</div>
</div>
</div>
<h3 id="manual-installation" tabindex="-1">Manual Installation </h3>
<p>You can also install packages manually. By default, Browser Mode doesn't require any additional E2E provider to run tests locally because it reuses your existing browser.</p>
<div class="vp-code-group vp-adaptive-theme">
<div class="tabs">
<input type="radio" name="group-yu7BH" id="tab-3fTUCEu" checked><label data-title="npm" for="tab-3fTUCEu">npm</label><input type="radio" name="group-yu7BH" id="tab-M7HP6KG"><label data-title="yarn" for="tab-M7HP6KG">yarn</label><input type="radio" name="group-yu7BH" id="tab-w6wAx9o"><label data-title="pnpm" for="tab-w6wAx9o">pnpm</label><input type="radio" name="group-yu7BH" id="tab-E2gADIX"><label data-title="bun" for="tab-E2gADIX">bun</label>
</div>
<div class="blocks">
<div class="language-bash vp-adaptive-theme active">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">npm install -D vitest @vitest/browser</pre>
</div>
<div class="language-bash vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">yarn add -D vitest @vitest/browser</pre>
</div>
<div class="language-bash vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">pnpm add -D vitest @vitest/browser</pre>
</div>
<div class="language-bash vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">bun add -D vitest @vitest/browser</pre>
</div>
</div>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>However, to run tests in CI you need to install either <a href="https://npmjs.com/package/playwright" target="_blank" rel="noreferrer"><code>playwright</code></a> or <a href="https://www.npmjs.com/package/webdriverio" target="_blank" rel="noreferrer"><code>webdriverio</code></a>. We also recommend switching to either one of them for testing locally instead of using the default <code>preview</code> provider since it relies on simulating events instead of using Chrome DevTools Protocol.</p>
<p>If you don't already use one of these tools, we recommend starting with Playwright because it supports parallel execution, which makes your tests run faster. Additionally, Playwright uses <a href="https://chromedevtools.github.io/devtools-protocol/" target="_blank" rel="noreferrer">Chrome DevTools Protocol</a> which is generally faster than WebDriver.</p>
<div class="plugin-tabs">
<div class="plugin-tabs--tab-list" role="tablist">
<button id="tab-Playwright-1" role="tab" class="plugin-tabs--tab" aria-selected="true" aria-controls="panel-Playwright-1" tabindex="0">Playwright</button><button id="tab-WebdriverIO-1" role="tab" class="plugin-tabs--tab" aria-selected="false" aria-controls="panel-WebdriverIO-1" tabindex="-1">WebdriverIO</button>
</div>
<div id="panel-Playwright-1" class="plugin-tabs--content" role="tabpanel" tabindex="0" aria-labelledby="tab-Playwright-1" data-v-c8f266f9>
<p><a href="https://npmjs.com/package/playwright" target="_blank" rel="noreferrer">Playwright</a> is a framework for Web Testing and Automation.</p>
<div class="vp-code-group vp-adaptive-theme">
<div class="tabs">
<input type="radio" name="group-tMzhB" id="tab-Et0a6j1" checked><label data-title="npm" for="tab-Et0a6j1">npm</label><input type="radio" name="group-tMzhB" id="tab-eVrr9ri"><label data-title="yarn" for="tab-eVrr9ri">yarn</label><input type="radio" name="group-tMzhB" id="tab-4G9m9ml"><label data-title="pnpm" for="tab-4G9m9ml">pnpm</label><input type="radio" name="group-tMzhB" id="tab-ISTutep"><label data-title="bun" for="tab-ISTutep">bun</label>
</div>
<div class="blocks">
<div class="language-bash vp-adaptive-theme active">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">npm install -D vitest @vitest/browser playwright</pre>
</div>
<div class="language-bash vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">yarn add -D vitest @vitest/browser playwright</pre>
</div>
<div class="language-bash vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">pnpm add -D vitest @vitest/browser playwright</pre>
</div>
<div class="language-bash vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">bun add -D vitest @vitest/browser playwright</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<h2 id="configuration" tabindex="-1">Configuration </h2>
<p>To activate browser mode in your Vitest configuration, you can use the <code>--browser=name</code> flag or set the <code>browser.enabled</code> field to <code>true</code> in your Vitest configuration file. Here is an example configuration using the browser field:</p>
<div class="vp-code-block-title">
<div class="vp-code-block-title-bar"><span class="vp-code-block-title-text" data-title="vitest.config.ts">vitest.config.ts</span></div>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { defineConfig } from 'vitest/config'
export default defineConfig({
  test: {
    browser: {
      provider: 'playwright', // or 'webdriverio'
      enabled: true,
      // at least one instance is required
      instances: [
        { browser: 'chromium' },
      ],
    },
  }
})</pre>
</div>
</div>
<div class="info custom-block">
<strong class="custom-block-title">INFO</strong><p>Vitest assigns port <code>63315</code> to avoid conflicts with the development server, allowing you to run both in parallel. You can change that with the <a href="../../config/index#browser-api"><code>browser.api</code></a> option.</p>
<p>Since Vitest 2.1.5, the CLI no longer prints the Vite URL automatically. You can press "b" to print the URL when running in watch mode.</p>
</div>
<p>If you have not used Vite before, make sure you have your framework's plugin installed and specified in the config. Some frameworks might require extra configuration to work - check their Vite related documentation to be sure.</p>
<div class="vp-code-group vp-adaptive-theme">
<div class="tabs">
<input type="radio" name="group-9BVg2" id="tab-6Y70HZy" checked><label data-title="react" for="tab-6Y70HZy">react</label><input type="radio" name="group-9BVg2" id="tab-XRjtYDv"><label data-title="vue" for="tab-XRjtYDv">vue</label><input type="radio" name="group-9BVg2" id="tab-rLS3sKl"><label data-title="svelte" for="tab-rLS3sKl">svelte</label><input type="radio" name="group-9BVg2" id="tab-5op0e3v"><label data-title="solid" for="tab-5op0e3v">solid</label><input type="radio" name="group-9BVg2" id="tab-9e-5KwJ"><label data-title="marko" for="tab-9e-5KwJ">marko</label>
</div>
<div class="blocks">
<div class="language-ts vp-adaptive-theme active">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  test: {
    browser: {
      enabled: true,
      provider: 'playwright',
      instances: [
        { browser: 'chromium' },
      ],
    }
  }
})</pre>
</div>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { defineConfig } from 'vitest/config'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  test: {
    browser: {
      enabled: true,
      provider: 'playwright',
      instances: [
        { browser: 'chromium' },
      ],
    }
  }
})</pre>
</div>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { defineConfig } from 'vitest/config'
import { svelte } from '@sveltejs/vite-plugin-svelte'

export default defineConfig({
  plugins: [svelte()],
  test: {
    browser: {
      enabled: true,
      provider: 'playwright',
      instances: [
        { browser: 'chromium' },
      ],
    }
  }
})</pre>
</div>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { defineConfig } from 'vitest/config'
import solidPlugin from 'vite-plugin-solid'

export default defineConfig({
  plugins: [solidPlugin()],
  test: {
    browser: {
      enabled: true,
      provider: 'playwright',
      instances: [
        { browser: 'chromium' },
      ],
    }
  }
})</pre>
</div>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { defineConfig } from 'vitest/config'
import marko from '@marko/vite'

export default defineConfig({
  plugins: [marko()],
  test: {
    browser: {
      enabled: true,
      provider: 'playwright',
      instances: [
        { browser: 'chromium' },
      ],
    }
  }
})</pre>
</div>
</div>
</div>
<p>If you need to run some tests using Node-based runner, you can define a <a href="../workspace">workspace</a> file with separate configurations for different testing strategies:</p>

<div class="vp-code-block-title">
<div class="vp-code-block-title-bar"><span class="vp-code-block-title-text" data-title="vitest.workspace.ts">vitest.workspace.ts</span></div>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { defineWorkspace } from 'vitest/config'

export default defineWorkspace([
  {
    test: {
      // an example of file based convention,
      // you don't have to follow it
      include: [
        'tests/unit/**/*.{test,spec}.ts',
        'tests/**/*.unit.{test,spec}.ts',
      ],
      name: 'unit',
      environment: 'node',
    },
  },
  {
    test: {
      // an example of file based convention,
      // you don't have to follow it
      include: [
        'tests/browser/**/*.{test,spec}.ts',
        'tests/**/*.browser.{test,spec}.ts',
      ],
      name: 'browser',
      browser: {
        enabled: true,
        instances: [
          { browser: 'chromium' },
        ],
      },
    },
  },
])</pre>
</div>
</div>
<h2 id="browser-option-types" tabindex="-1">Browser Option Types </h2>
<p>The browser option in Vitest depends on the provider. Vitest will fail, if you pass <code>--browser</code> and don't specify its name in the config file. Available options:</p>
<ul>
<li>
<code>webdriverio</code> supports these browsers: <ul>
<li><code>firefox</code></li>
<li><code>chrome</code></li>
<li><code>edge</code></li>
<li><code>safari</code></li>
</ul>
</li>
<li>
<code>playwright</code> supports these browsers: <ul>
<li><code>firefox</code></li>
<li><code>webkit</code></li>
<li><code>chromium</code></li>
</ul>
</li>
</ul>
<h2 id="typescript" tabindex="-1">TypeScript </h2>
<p>By default, TypeScript doesn't recognize providers options and extra <code>expect</code> properties. If you don't use any providers, make sure the <code>@vitest/browser/matchers</code> is referenced somewhere in your tests, <a href="../../config/index#setupfiles">setup file</a> or a <a href="../../config/index">config file</a> to pick up the extra <code>expect</code> definitions. If you are using custom providers, make sure to add <code>@vitest/browser/providers/playwright</code> or <code>@vitest/browser/providers/webdriverio</code> to the same file so TypeScript can pick up definitions for custom options:</p>
<div class="vp-code-group vp-adaptive-theme">
<div class="tabs">
<input type="radio" name="group-rWlQd" id="tab-U8r6FIS" checked><label data-title="default" for="tab-U8r6FIS">default</label><input type="radio" name="group-rWlQd" id="tab-cRv_W0I"><label data-title="playwright" for="tab-cRv_W0I">playwright</label><input type="radio" name="group-rWlQd" id="tab-Zdzn97E"><label data-title="webdriverio" for="tab-Zdzn97E">webdriverio</label>
</div>
<div class="blocks">
<div class="language-ts vp-adaptive-theme active">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">/// &lt;reference types="@vitest/browser/matchers" /&gt;</pre>
</div>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">/// &lt;reference types="@vitest/browser/providers/playwright" /&gt;</pre>
</div>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">/// &lt;reference types="@vitest/browser/providers/webdriverio" /&gt;</pre>
</div>
</div>
</div>
<p>Alternatively, you can also add them to <code>compilerOptions.types</code> field in your <code>tsconfig.json</code> file. Note that specifying anything in this field will disable <a href="https://www.typescriptlang.org/tsconfig/#types" target="_blank" rel="noreferrer">auto loading</a> of <code>@types/*</code> packages.</p>
<div class="vp-code-group vp-adaptive-theme">
<div class="tabs">
<input type="radio" name="group-48gcQ" id="tab-EHxttS8" checked><label data-title="default" for="tab-EHxttS8">default</label><input type="radio" name="group-48gcQ" id="tab-sCVtdfC"><label data-title="playwright" for="tab-sCVtdfC">playwright</label><input type="radio" name="group-48gcQ" id="tab-skZmbby"><label data-title="webdriverio" for="tab-skZmbby">webdriverio</label>
</div>
<div class="blocks">
<div class="language-json vp-adaptive-theme active">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">{
  "compilerOptions": {
    "types": ["@vitest/browser/matchers"]
  }
}</pre>
</div>
<div class="language-json vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">{
  "compilerOptions": {
    "types": ["@vitest/browser/providers/playwright"]
  }
}</pre>
</div>
<div class="language-json vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">{
  "compilerOptions": {
    "types": ["@vitest/browser/providers/webdriverio"]
  }
}</pre>
</div>
</div>
</div>
<h2 id="browser-compatibility" tabindex="-1">Browser Compatibility </h2>
<p>Vitest uses <a href="https://vitejs.dev/guide/#browser-support" target="_blank" rel="noreferrer">Vite dev server</a> to run your tests, so we only support features specified in the <a href="https://vitejs.dev/config/shared-options.html#esbuild" target="_blank" rel="noreferrer"><code>esbuild.target</code></a> option (<code>esnext</code> by default).</p>
<p>By default, Vite targets browsers which support the native <a href="https://caniuse.com/es6-module" target="_blank" rel="noreferrer">ES Modules</a>, native <a href="https://caniuse.com/es6-module-dynamic-import" target="_blank" rel="noreferrer">ESM dynamic import</a>, and <a href="https://caniuse.com/mdn-javascript_operators_import_meta" target="_blank" rel="noreferrer"><code>import.meta</code></a>. On top of that, we utilize <a href="https://caniuse.com/?search=BroadcastChannel" target="_blank" rel="noreferrer"><code>BroadcastChannel</code></a> to communicate between iframes:</p>
<ul>
<li>Chrome &gt;=87</li>
<li>Firefox &gt;=78</li>
<li>Safari &gt;=15.4</li>
<li>Edge &gt;=88</li>
</ul>
<h2 id="running-tests" tabindex="-1">Running Tests </h2>
<p>When you specify a browser name in the browser option, Vitest will try to run the specified browser using <code>preview</code> by default, and then run the tests there. If you don't want to use <code>preview</code>, you can configure the custom browser provider by using <code>browser.provider</code> option.</p>
<p>To specify a browser using the CLI, use the <code>--browser</code> flag followed by the browser name, like this:</p>
<div class="language-sh vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">npx vitest --browser=chrome</pre>
</div>
<p>Or you can provide browser options to CLI with dot notation:</p>
<div class="language-sh vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">npx vitest --browser.headless</pre>
</div>
<p>By default, Vitest will automatically open the browser UI for development. Your tests will run inside an iframe in the center. You can configure the viewport by selecting the preferred dimensions, calling <code>page.viewport</code> inside the test, or setting default values in <a href="../../config/index#browser-viewport">the config</a>.</p>
<h2 id="headless" tabindex="-1">Headless </h2>
<p>Headless mode is another option available in the browser mode. In headless mode, the browser runs in the background without a user interface, which makes it useful for running automated tests. The headless option in Vitest can be set to a boolean value to enable or disable headless mode.</p>
<p>When using headless mode, Vitest won't open the UI automatically. If you want to continue using the UI but have tests run headlessly, you can install the <a href="../ui"><code>@vitest/ui</code></a> package and pass the <code>--ui</code> flag when running Vitest.</p>
<p>Here's an example configuration enabling headless mode:</p>
<div class="vp-code-block-title">
<div class="vp-code-block-title-bar"><span class="vp-code-block-title-text" data-title="vitest.config.ts">vitest.config.ts</span></div>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { defineConfig } from 'vitest/config'
export default defineConfig({
  test: {
    browser: {
      provider: 'playwright',
      enabled: true,
      headless: true,
    },
  }
})</pre>
</div>
</div>
<p>You can also set headless mode using the <code>--browser.headless</code> flag in the CLI, like this:</p>
<div class="language-sh vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">npx vitest --browser.headless</pre>
</div>
<p>In this case, Vitest will run in headless mode using the Chrome browser.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>Headless mode is not available by default. You need to use either <a href="https://npmjs.com/package/playwright" target="_blank" rel="noreferrer"><code>playwright</code></a> or <a href="https://www.npmjs.com/package/webdriverio" target="_blank" rel="noreferrer"><code>webdriverio</code></a> providers to enable this feature.</p>
</div>
<h2 id="examples" tabindex="-1">Examples </h2>
<p>By default, you don't need any external packages to work with the Browser Mode:</p>
<div class="vp-code-block-title">
<div class="vp-code-block-title-bar"><span class="vp-code-block-title-text" data-title="example.test.js">example.test.js</span></div>
<div class="language-js vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { expect, test } from 'vitest'
import { page } from '@vitest/browser/context'
import { render } from './my-render-function.js'

test('properly handles form inputs', async () =&gt; {
  render() // mount DOM elements

  // Asserts initial state.
  await expect.element(page.getByText('Hi, my name is Alice')).toBeInTheDocument()

  // Get the input DOM node by querying the associated label.
  const usernameInput = page.getByLabelText(/username/i)

  // Type the name into the input. This already validates that the input
  // is filled correctly, no need to check the value manually.
  await usernameInput.fill('Bob')

  await expect.element(page.getByText('Hi, my name is Bob')).toBeInTheDocument()
})</pre>
</div>
</div>
<p>However, Vitest also provides packages to render components for several popular frameworks out of the box:</p>
<ul>
<li>
<a href="https://github.com/vitest-dev/vitest-browser-vue" target="_blank" rel="noreferrer"><code>vitest-browser-vue</code></a> to render <a href="https://vuejs.org" target="_blank" rel="noreferrer">vue</a> components</li>
<li>
<a href="https://github.com/vitest-dev/vitest-browser-svelte" target="_blank" rel="noreferrer"><code>vitest-browser-svelte</code></a> to render <a href="https://svelte.dev" target="_blank" rel="noreferrer">svelte</a> components</li>
<li>
<a href="https://github.com/vitest-dev/vitest-browser-react" target="_blank" rel="noreferrer"><code>vitest-browser-react</code></a> to render <a href="https://react.dev" target="_blank" rel="noreferrer">react</a> components</li>
</ul>
<p>If your framework is not represented, feel free to create your own package - it is a simple wrapper around the framework renderer and <code>page.elementLocator</code> API. We will add a link to it on this page. Make sure it has a name starting with <code>vitest-browser-</code>.</p>
<p>Besides rendering components and locating elements, you will also need to make assertions. Vitest bundles the <a href="https://github.com/testing-library/jest-dom" target="_blank" rel="noreferrer"><code>@testing-library/jest-dom</code></a> library to provide a wide range of DOM assertions out of the box. Read more at the <a href="assertion-api">Assertions API</a>.</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { expect } from 'vitest'
import { page } from '@vitest/browser/context'
// element is rendered correctly
await expect.element(page.getByText('Hello World')).toBeInTheDocument()</pre>
</div>
<p>Vitest exposes a <a href="context">Context API</a> with a small set of utilities that might be useful to you in tests. For example, if you need to make an interaction, like clicking an element or typing text into an input, you can use <code>userEvent</code> from <code>@vitest/browser/context</code>. Read more at the <a href="interactivity-api">Interactivity API</a>.</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { page, userEvent } from '@vitest/browser/context'
await userEvent.fill(page.getByLabelText(/username/i), 'Alice')
// or just locator.fill
await page.getByLabelText(/username/i).fill('Alice')</pre>
</div>
<div class="vp-code-group vp-adaptive-theme">
<div class="tabs">
<input type="radio" name="group-hWQ63" id="tab-kxl8TJk" checked><label data-title="vue" for="tab-kxl8TJk">vue</label><input type="radio" name="group-hWQ63" id="tab-Iicer0y"><label data-title="svelte" for="tab-Iicer0y">svelte</label><input type="radio" name="group-hWQ63" id="tab-sMmtYpD"><label data-title="react" for="tab-sMmtYpD">react</label>
</div>
<div class="blocks">
<div class="language-ts vp-adaptive-theme active">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { render } from 'vitest-browser-vue'
import Component from './Component.vue'

test('properly handles v-model', async () =&gt; {
  const screen = render(Component)

  // Asserts initial state.
  await expect.element(screen.getByText('Hi, my name is Alice')).toBeInTheDocument()

  // Get the input DOM node by querying the associated label.
  const usernameInput = screen.getByLabelText(/username/i)

  // Type the name into the input. This already validates that the input
  // is filled correctly, no need to check the value manually.
  await usernameInput.fill('Bob')

  await expect.element(screen.getByText('Hi, my name is Bob')).toBeInTheDocument()
})</pre>
</div>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { render } from 'vitest-browser-svelte'
import { expect, test } from 'vitest'

import Greeter from './greeter.svelte'

test('greeting appears on click', async () =&gt; {
  const screen = render(Greeter, { name: 'World' })

  const button = screen.getByRole('button')
  await button.click()
  const greeting = screen.getByText(/hello world/iu)

  await expect.element(greeting).toBeInTheDocument()
})</pre>
</div>
<div class="language-tsx vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { render } from 'vitest-browser-react'
import Fetch from './fetch'

test('loads and displays greeting', async () =&gt; {
  // Render a React element into the DOM
  const screen = render(&lt;Fetch url="/greeting" /&gt;)

  await screen.getByText('Load Greeting').click()
  // wait before throwing an error if it cannot find an element
  const heading = screen.getByRole('heading')

  // assert that the alert message is correct
  await expect.element(heading).toHaveTextContent('hello there')
  await expect.element(screen.getByRole('button')).toBeDisabled()
})</pre>
</div>
</div>
</div>
<p>Vitest doesn't support all frameworks out of the box, but you can use external tools to run tests with these frameworks. We also encourage the community to create their own <code>vitest-browser</code> wrappers - if you have one, feel free to add it to the examples above.</p>
<p>For unsupported frameworks, we recommend using <code>testing-library</code> packages:</p>
<ul>
<li>
<a href="https://testing-library.com/docs/preact-testing-library/intro" target="_blank" rel="noreferrer"><code>@testing-library/preact</code></a> to render <a href="https://preactjs.com" target="_blank" rel="noreferrer">preact</a> components</li>
<li>
<a href="https://testing-library.com/docs/solid-testing-library/intro" target="_blank" rel="noreferrer"><code>@solidjs/testing-library</code></a> to render <a href="https://www.solidjs.com" target="_blank" rel="noreferrer">solid</a> components</li>
<li>
<a href="https://testing-library.com/docs/marko-testing-library/intro" target="_blank" rel="noreferrer"><code>@marko/testing-library</code></a> to render <a href="https://markojs.com" target="_blank" rel="noreferrer">marko</a> components</li>
</ul>
<p>You can also see more examples in <a href="https://github.com/vitest-tests/browser-examples" target="_blank" rel="noreferrer"><code>browser-examples</code></a> repository.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p><code>testing-library</code> provides a package <code>@testing-library/user-event</code>. We do not recommend using it directly because it simulates events instead of actually triggering them - instead, use <a href="interactivity-api"><code>userEvent</code></a> imported from <code>@vitest/browser/context</code> that uses Chrome DevTools Protocol or Webdriver (depending on the provider) under the hood.</p>
</div>
<div class="vp-code-group vp-adaptive-theme">
<div class="tabs">
<input type="radio" name="group-ee1nA" id="tab-9QSYrw6" checked><label data-title="preact" for="tab-9QSYrw6">preact</label><input type="radio" name="group-ee1nA" id="tab-0w2a4f5"><label data-title="solid" for="tab-0w2a4f5">solid</label><input type="radio" name="group-ee1nA" id="tab-af4fMHy"><label data-title="marko" for="tab-af4fMHy">marko</label>
</div>
<div class="blocks">
<div class="language-tsx vp-adaptive-theme active">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">// based on @testing-library/preact example
// https://testing-library.com/docs/preact-testing-library/example

import { h } from 'preact'
import { page } from '@vitest/browser/context'
import { render } from '@testing-library/preact'

import HiddenMessage from '../hidden-message'

test('shows the children when the checkbox is checked', async () =&gt; {
  const testMessage = 'Test Message'

  const { baseElement } = render(
    &lt;HiddenMessage&gt;{testMessage}&lt;/HiddenMessage&gt;,
  )

  const screen = page.elementLocator(baseElement)

  // .query() will return the element or null if it cannot be found.
  // .element() will return the element or throw an error if it cannot be found.
  expect(screen.getByText(testMessage).query()).not.toBeInTheDocument()

  // The queries can accept a regex to make your selectors more
  // resilient to content tweaks and changes.
  await screen.getByLabelText(/show/i).click()

  await expect.element(screen.getByText(testMessage)).toBeInTheDocument()
})</pre>
</div>
<div class="language-tsx vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">// baed on @testing-library/solid API
// https://testing-library.com/docs/solid-testing-library/api

import { render } from '@testing-library/solid'

it('uses params', async () =&gt; {
  const App = () =&gt; (
    &lt;&gt;
      &lt;Route
        path="/ids/:id"
        component={() =&gt; (
          &lt;p&gt;
            Id:
            {useParams()?.id}
          &lt;/p&gt;
        )}
      /&gt;
      &lt;Route path="/" component={() =&gt; &lt;p&gt;Start&lt;/p&gt;} /&gt;
    &lt;/&gt;
  )
  const { baseElement } = render(() =&gt; &lt;App /&gt;, { location: 'ids/1234' })
  const screen = page.elementLocator(baseElement)

  await expect.screen(screen.getByText('Id: 1234')).toBeInTheDocument()
})</pre>
</div>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">// baed on @testing-library/marko API
// https://testing-library.com/docs/marko-testing-library/api

import { render, screen } from '@marko/testing-library'
import Greeting from './greeting.marko'

test('renders a message', async () =&gt; {
  const { baseElement } = await render(Greeting, { name: 'Marko' })
  const screen = page.elementLocator(baseElement)
  await expect.element(screen.getByText(/Marko/)).toBeInTheDocument()
  expect(container.firstChild).toMatchInlineSnapshot(`
    &lt;h1&gt;Hello, Marko!&lt;/h1&gt;
  `)
})</pre>
</div>
</div>
</div>
<h2 id="limitations" tabindex="-1">Limitations </h2>
<h3 id="thread-blocking-dialogs" tabindex="-1">Thread Blocking Dialogs </h3>
<p>When using Vitest Browser, it's important to note that thread blocking dialogs like <code>alert</code> or <code>confirm</code> cannot be used natively. This is because they block the web page, which means Vitest cannot continue communicating with the page, causing the execution to hang.</p>
<p>In such situations, Vitest provides default mocks with default returned values for these APIs. This ensures that if the user accidentally uses synchronous popup web APIs, the execution would not hang. However, it's still recommended for the user to mock these web APIs for better experience. Read more in <a href="../mocking">Mocking</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2021-Present Anthony Fu<br>&copy; 2021-Present Matias Capeletto<br>Licensed under the MIT License.<br>
    <a href="https://vitest.dev/guide/browser/" class="_attribution-link">https://vitest.dev/guide/browser/</a>
  </p>
</div>
