<h1 id="reporters" tabindex="-1">Reporters </h1>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>This is an advanced API. If you just want to configure built-in reporters, read the <a href="../../guide/reporters">"Reporters"</a> guide.</p>
</div>
<p>Vitest has its own test run lifecycle. These are represented by reporter's methods:</p>
<ul>
<li><a href="#oninit"><code>onInit</code></a></li>
<li>
<a href="#ontestrunstart"><code>onTestRunStart</code></a><ul>
<li><a href="#ontestmodulequeued"><code>onTestModuleQueued</code></a></li>
<li><a href="#ontestmodulecollected"><code>onTestModuleCollected</code></a></li>
<li>
<a href="#ontestmodulestart"><code>onTestModuleStart</code></a><ul>
<li>
<a href="#ontestsuiteready"><code>onTestSuiteReady</code></a><ul>
<li><a href="#onhookstart"><code>onHookStart(beforeAll)</code></a></li>
<li>
<a href="#onhookend"><code>onHookEnd(beforeAll)</code></a><ul>
<li>
<a href="#ontestcaseready"><code>onTestCaseReady</code></a><ul>
<li><a href="#onhookstart"><code>onHookStart(beforeEach)</code></a></li>
<li><a href="#onhookend"><code>onHookEnd(beforeEach)</code></a></li>
<li><a href="#onhookstart"><code>onHookStart(afterEach)</code></a></li>
<li><a href="#onhookend"><code>onHookEnd(afterEach)</code></a></li>
</ul>
</li>
<li><a href="#ontestcaseresult"><code>onTestCaseResult</code></a></li>
</ul>
</li>
<li><a href="#onhookstart"><code>onHookStart(afterAll)</code></a></li>
<li><a href="#onhookend"><code>onHookEnd(afterAll)</code></a></li>
</ul>
</li>
<li><a href="#ontestsuiteresult"><code>onTestSuiteResult</code></a></li>
</ul>
</li>
<li><a href="#ontestmoduleend"><code>onTestModuleEnd</code></a></li>
</ul>
</li>
<li><a href="#ontestrunend"><code>onTestRunEnd</code></a></li>
</ul>
<p>Tests and suites within a single module will be reported in order unless they were skipped. All skipped tests are reported at the end of suite/module.</p>
<p>Note that since test modules can run in parallel, Vitest will report them in parallel.</p>
<p>This guide lists all supported reporter methods. However, don't forget that instead of creating your own reporter, you can <a href="../reporters">extend existing one</a> instead:</p>
<div class="vp-code-block-title">
<div class="vp-code-block-title-bar"><span class="vp-code-block-title-text" data-title="custom-reporter.js">custom-reporter.js</span></div>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { BaseReporter } from 'vitest/reporters'

export default class CustomReporter extends BaseReporter {
  onTestRunEnd(testModules, errors) {
    console.log(testModule.length, 'tests finished running')
    super.onTestRunEnd(testModules, errors)
  }
}</pre>
</div>
</div>
<h2 id="oninit" tabindex="-1">onInit </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function onInit(vitest: Vitest): Awaitable&lt;void&gt;</pre>
</div>
<p>This method is called when <a href="vitest">Vitest</a> was initiated or started, but before the tests were filtered.</p>
<div class="info custom-block">
<strong class="custom-block-title">INFO</strong><p>Internally this method is called inside <a href="vitest#start"><code>vitest.start</code></a>, <a href="vitest#init"><code>vitest.init</code></a> or <a href="vitest#mergereports"><code>vitest.mergeReports</code></a>. If you are using programmatic API, make sure to call either one dependning on your needs before calling <a href="vitest#runtestspecifications"><code>vitest.runTestSpecifications</code></a>, for example. Built-in CLI will always run methods in correct order.</p>
</div>
<p>Note that you can also get access to <code>vitest</code> instance from test cases, suites and test modules via a <a href="test-project"><code>project</code></a> property, but it might also be useful to store a reference to <code>vitest</code> in this method.</p>
<div class="details custom-block">
<summary>Example</summary><div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import type { Reporter, TestSpecification, Vitest } from 'vitest/node'

class MyReporter implements Reporter {
  private vitest!: Vitest

  onInit(vitest: Vitest) {
    this.vitest = vitest
  }

  onTestRunStart(specifications: TestSpecification[]) {
    console.log(
      specifications.length,
      'test files will run in',
      this.vitest.config.root,
    )
  }
}

export default new MyReporter()</pre>
</div>
</div>
<h2 id="onbrowserinit" tabindex="-1">onBrowserInit <span class="VPBadge warning">experimental</span> </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function onBrowserInit(project: TestProject): Awaitable&lt;void&gt;</pre>
</div>
<p>This method is called when the browser instance is initiated. It receives an instance of the project for which the browser is initiated. <code>project.browser</code> will always be defined when this method is called.</p>
<h2 id="ontestrunstart" tabindex="-1">onTestRunStart </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function onTestRunStart(
  specifications: TestSpecification[]
): Awaitable&lt;void&gt;</pre>
</div>
<p>This method is called when a new test run has started. It receives an array of <a href="test-specification">test specifications</a> scheduled to run. This array is readonly and available only for information purposes.</p>
<p>If Vitest didn't find any test files to run, this event will be invoked with an empty array, and then <a href="#ontestrunend"><code>onTestRunEnd</code></a> will be called immediately after.</p>
<div class="details custom-block">
<summary>Example</summary><div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import type { Reporter, TestSpecification } from 'vitest/node'

class MyReporter implements Reporter {
  onTestRunStart(specifications: TestSpecification[]) {
    console.log(specifications.length, 'test files will run')
  }
}

export default new MyReporter()</pre>
</div>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">DEPRECATION NOTICE</strong><p>This method was added in Vitest 3, replacing <code>onPathsCollected</code> and <code>onSpecsCollected</code>, both of which are now deprecated.</p>
</div>
<h2 id="ontestrunend" tabindex="-1">onTestRunEnd </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function onTestRunEnd(
  testModules: ReadonlyArray&lt;TestModule&gt;,
  unhandledErrors: ReadonlyArray&lt;SerializedError&gt;,
  reason: TestRunEndReason
): Awaitable&lt;void&gt;</pre>
</div>
<p>This method is called after all tests have finished running and the coverage merged all reports, if it's enabled. Note that you can get the coverage information in <a href="#oncoverage"><code>onCoverage</code></a> hook.</p>
<p>It receives a readonly list of test modules. You can iterate over it via a <a href="test-collection"><code>testModule.children</code></a> property to report the state and errors, if any.</p>
<p>The second argument is a readonly list of unhandled errors that Vitest wasn't able to attribute to any test. These can happen outside of the test run because of an error in a plugin, or inside the test run as a side-effect of a non-awaited function (for example, a timeout that threw an error after the test has finished running).</p>
<p>The third argument indicated why the test run was finished:</p>
<ul>
<li>
<code>passed</code>: test run was finished normally and there are no errors</li>
<li>
<code>failed</code>: test run has at least one error (due to a syntax error during collection or an actual error during test execution)</li>
<li>
<code>interrupted</code>: test was interruped by <a href="vitest#cancelcurrentrun"><code>vitest.cancelCurrentRun</code></a> call or <code>Ctrl+C</code> was pressed in the terminal (note that it's still possible to have failed tests in this case)</li>
</ul>
<p>If Vitest didn't find any test files to run, this event will be invoked with empty arrays of modules and errors, and the state will depend on the value of <a href="../../config/index#passwithnotests"><code>config.passWithNoTests</code></a>.</p>
<div class="details custom-block">
<summary>Example</summary><div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import type {
  Reporter,
  SerializedError,
  TestModule,
  TestRunEndReason,
  TestSpecification
} from 'vitest/node'

class MyReporter implements Reporter {
  onTestRunEnd(
    testModules: ReadonlyArray&lt;TestModule&gt;,
    unhandledErrors: ReadonlyArray&lt;SerializedError&gt;,
    reason: TestRunEndReason,
  ) {
    if (reason === 'passed') {
      testModules.forEach(module =&gt; console.log(module.moduleId, 'succeeded'))
    }
    else if (reason === 'failed') {
      // note that this will skip possible errors in suites
      // you can get them from testSuite.errors()
      for (const testCase of testModules.children.allTests()) {
        if (testCase.result().state === 'failed') {
          console.log(testCase.fullName, 'in', testCase.module.moduleId, 'failed')
          console.log(testCase.result().errors)
        }
      }
    }
    else {
      console.log('test run was interrupted, skipping report')
    }
  }
}

export default new MyReporter()</pre>
</div>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">DEPRECATION NOTICE</strong><p>This method was added in Vitest 3, replacing <code>onFinished</code>, which is now deprecated.</p>
</div>
<h2 id="oncoverage" tabindex="-1">onCoverage </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function onCoverage(coverage: unknown): Awaitable&lt;void&gt;</pre>
</div>
<p>This hook is called after coverage results have been processed. Coverage provider's reporters are called after this hook. The typings of <code>coverage</code> depends on the <code>coverage.provider</code>. For Vitest's default built-in providers you can import the types from <code>istanbul-lib-coverage</code> package:</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import type { CoverageMap } from 'istanbul-lib-coverage'

declare function onCoverage(coverage: CoverageMap): Awaitable&lt;void&gt;</pre>
</div>
<p>If Vitest didn't perform any coverage, this hook is not called.</p>
<h2 id="ontestmodulequeued" tabindex="-1">onTestModuleQueued </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function onTestModuleQueued(testModule: TestModule): Awaitable&lt;void&gt;</pre>
</div>
<p>This method is called right before Vitest imports the setup file and the test module itself. This means that <code>testModule</code> will have no <a href="test-suite#children"><code>children</code></a> yet, but you can start reporting it as the next test to run.</p>
<h2 id="ontestmodulecollected" tabindex="-1">onTestModuleCollected </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function onTestModuleCollected(testModule: TestModule): Awaitable&lt;void&gt;</pre>
</div>
<p>This method is called when all tests inside the file were collected, meaning <a href="test-suite#children"><code>testModule.children</code></a> collection is populated, but tests don't have any results yet.</p>
<h2 id="ontestmodulestart" tabindex="-1">onTestModuleStart </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function onTestModuleStart(testModule: TestModule): Awaitable&lt;void&gt;</pre>
</div>
<p>This method is called right after <a href="#ontestmodulecollected"><code>onTestModuleCollected</code></a> unless Vitest runs in collection mode (<a href="vitest#collect"><code>vitest.collect()</code></a> or <code>vitest collect</code> in the CLI), in this case it will not be called at all because there are no tests to run.</p>
<h2 id="ontestmoduleend" tabindex="-1">onTestModuleEnd </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function onTestModuleEnd(testModule: TestModule): Awaitable&lt;void&gt;</pre>
</div>
<p>This method is called when every test in the module finished running. This means, every test inside <a href="test-suite#children"><code>testModule.children</code></a> will have a <code>test.result()</code> that is not equal to <code>pending</code>.</p>
<h2 id="onhookstart" tabindex="-1">onHookStart </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function onHookStart(context: ReportedHookContext): Awaitable&lt;void&gt;</pre>
</div>
<p>This method is called when any of these hooks have started running:</p>
<ul>
<li><code>beforeAll</code></li>
<li><code>afterAll</code></li>
<li><code>beforeEach</code></li>
<li><code>afterEach</code></li>
</ul>
<p>If <code>beforeAll</code> or <code>afterAll</code> are started, the <code>entity</code> will be either <a href="test-suite"><code>TestSuite</code></a> or <a href="test-module"><code>TestModule</code></a>.</p>
<p>If <code>beforeEach</code> or <code>afterEach</code> are started, the <code>entity</code> will always be <a href="test-case"><code>TestCase</code></a>.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p><code>onHookStart</code> method will not be called if the hook did not run during the test run.</p>
</div>
<h2 id="onhookend" tabindex="-1">onHookEnd </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function onHookEnd(context: ReportedHookContext): Awaitable&lt;void&gt;</pre>
</div>
<p>This method is called when any of these hooks have finished running:</p>
<ul>
<li><code>beforeAll</code></li>
<li><code>afterAll</code></li>
<li><code>beforeEach</code></li>
<li><code>afterEach</code></li>
</ul>
<p>If <code>beforeAll</code> or <code>afterAll</code> have finished, the <code>entity</code> will be either <a href="test-suite"><code>TestSuite</code></a> or <a href="test-module"><code>TestModule</code></a>.</p>
<p>If <code>beforeEach</code> or <code>afterEach</code> have finished, the <code>entity</code> will always be <a href="test-case"><code>TestCase</code></a>.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p><code>onHookEnd</code> method will not be called if the hook did not run during the test run.</p>
</div>
<h2 id="ontestsuiteready" tabindex="-1">onTestSuiteReady </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function onTestSuiteReady(testSuite: TestSuite): Awaitable&lt;void&gt;</pre>
</div>
<p>This method is called before the suite starts to run its tests. This method is also called if the suite was skipped.</p>
<p>If the file doesn't have any suites, this method will not be called. Consider using <code>onTestModuleStart</code> to cover this use case.</p>
<h2 id="ontestsuiteresult" tabindex="-1">onTestSuiteResult </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function onTestSuiteResult(testSuite: TestSuite): Awaitable&lt;void&gt;</pre>
</div>
<p>This method is called after the suite has finished running tests. This method is also called if the suite was skipped.</p>
<p>If the file doesn't have any suites, this method will not be called. Consider using <code>onTestModuleEnd</code> to cover this use case.</p>
<h2 id="ontestcaseready" tabindex="-1">onTestCaseReady </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function onTestCaseReady(testCase: TestCase): Awaitable&lt;void&gt;</pre>
</div>
<p>This method is called before the test starts to run or it was skipped. Note that <code>beforeEach</code> and <code>afterEach</code> hooks are considered part of the test because they can influence the result.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>Notice that it's possible to have <a href="test-case#result"><code>testCase.result()</code></a> with <code>passed</code> or <code>failed</code> state already when <code>onTestCaseReady</code> is called. This can happen if test was running too fast and both <code>onTestCaseReady</code> and <code>onTestCaseResult</code> were scheduled to run in the same microtask.</p>
</div>
<h2 id="ontestcaseresult" tabindex="-1">onTestCaseResult </h2>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">function onTestCaseResult(testCase: TestCase): Awaitable&lt;void&gt;</pre>
</div>
<p>This method is called when the test has finished running or was just skipped. Note that this will be called after the <code>afterEach</code> hook is finished, if there are any.</p>
<p>At this point, <a href="test-case#result"><code>testCase.result()</code></a> will have non-pending state.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2021-Present Anthony Fu<br>&copy; 2021-Present Matias Capeletto<br>Licensed under the MIT License.<br>
    <a href="https://vitest.dev/advanced/api/reporters" class="_attribution-link">https://vitest.dev/advanced/api/reporters</a>
  </p>
</div>
