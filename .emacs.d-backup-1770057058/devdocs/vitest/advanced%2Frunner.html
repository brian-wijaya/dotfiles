<h1 id="runner-api" tabindex="-1">Runner API </h1>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>This is advanced API. If you just want to <a href="../guide/index">run tests</a>, you probably don't need this. It is primarily used by library authors.</p>
</div>
<p>You can specify a path to your test runner with the <code>runner</code> option in your configuration file. This file should have a default export with a class constructor implementing these methods:</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">export interface VitestRunner {
  /**
   * First thing that's getting called before actually collecting and running tests.
   */
  onBeforeCollect?: (paths: string[]) =&gt; unknown
  /**
   * Called after collecting tests and before "onBeforeRun".
   */
  onCollected?: (files: File[]) =&gt; unknown

  /**
   * Called when test runner should cancel next test runs.
   * Runner should listen for this method and mark tests and suites as skipped in
   * "onBeforeRunSuite" and "onBeforeRunTask" when called.
   */
  onCancel?: (reason: CancelReason) =&gt; unknown

  /**
   * Called before running a single test. Doesn't have "result" yet.
   */
  onBeforeRunTask?: (test: TaskPopulated) =&gt; unknown
  /**
   * Called before actually running the test function. Already has "result" with "state" and "startTime".
   */
  onBeforeTryTask?: (test: TaskPopulated, options: { retry: number; repeats: number }) =&gt; unknown
  /**
   * Called after result and state are set.
   */
  onAfterRunTask?: (test: TaskPopulated) =&gt; unknown
  /**
   * Called right after running the test function. Doesn't have new state yet. Will not be called, if the test function throws.
   */
  onAfterTryTask?: (test: TaskPopulated, options: { retry: number; repeats: number }) =&gt; unknown

  /**
   * Called before running a single suite. Doesn't have "result" yet.
   */
  onBeforeRunSuite?: (suite: Suite) =&gt; unknown
  /**
   * Called after running a single suite. Has state and result.
   */
  onAfterRunSuite?: (suite: Suite) =&gt; unknown

  /**
   * If defined, will be called instead of usual Vitest suite partition and handling.
   * "before" and "after" hooks will not be ignored.
   */
  runSuite?: (suite: Suite) =&gt; Promise&lt;void&gt;
  /**
   * If defined, will be called instead of usual Vitest handling. Useful, if you have your custom test function.
   * "before" and "after" hooks will not be ignored.
   */
  runTask?: (test: TaskPopulated) =&gt; Promise&lt;void&gt;

  /**
   * Called, when a task is updated. The same as "onTaskUpdate" in a reporter, but this is running in the same thread as tests.
   */
  onTaskUpdate?: (task: [string, TaskResult | undefined, TaskMeta | undefined][]) =&gt; Promise&lt;void&gt;

  /**
   * Called before running all tests in collected paths.
   */
  onBeforeRunFiles?: (files: File[]) =&gt; unknown
  /**
   * Called right after running all tests in collected paths.
   */
  onAfterRunFiles?: (files: File[]) =&gt; unknown
  /**
   * Called when new context for a test is defined. Useful, if you want to add custom properties to the context.
   * If you only want to define custom context with a runner, consider using "beforeAll" in "setupFiles" instead.
   */
  extendTaskContext?: (context: TestContext) =&gt; TestContext
  /**
   * Called when certain files are imported. Can be called in two situations: to collect tests and to import setup files.
   */
  importFile: (filepath: string, source: VitestRunnerImportSource) =&gt; unknown
  /**
   * Function that is called when the runner attempts to get the value when `test.extend` is used with `{ injected: true }`
   */
  injectValue?: (key: string) =&gt; unknown
  /**
   * Publicly available configuration.
   */
  config: VitestRunnerConfig
  /**
   * The name of the current pool. Can affect how stack trace is inferred on the server side.
   */
  pool?: string
}</pre>
</div>
<p>When initiating this class, Vitest passes down Vitest config, - you should expose it as a <code>config</code> property:</p>
<div class="vp-code-block-title">
<div class="vp-code-block-title-bar"><span class="vp-code-block-title-text" data-title="runner.ts">runner.ts</span></div>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import type { RunnerTestFile } from 'vitest'
import type { VitestRunner, VitestRunnerConfig } from 'vitest/suite'
import { VitestTestRunner } from 'vitest/runners'

class CustomRunner extends VitestTestRunner implements VitestRunner {
  public config: VitestRunnerConfig

  constructor(config: VitestRunnerConfig) {
    this.config = config
  }

  onAfterRunFiles(files: RunnerTestFile[]) {
    console.log('finished running', files)
  }
}

export default CustomRunner</pre>
</div>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>Vitest also injects an instance of <code>ViteNodeRunner</code> as <code>__vitest_executor</code> property. You can use it to process files in <code>importFile</code> method (this is default behavior of <code>TestRunner</code> and <code>BenchmarkRunner</code>).</p>
<p><code>ViteNodeRunner</code> exposes <code>executeId</code> method, which is used to import test files in a Vite-friendly environment. Meaning, it will resolve imports and transform file content at runtime so that Node can understand it:</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">export default class Runner {
  async importFile(filepath: string) {
    await this.__vitest_executor.executeId(filepath)
  }
}</pre>
</div>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>If you don't have a custom runner or didn't define <code>runTest</code> method, Vitest will try to retrieve a task automatically. If you didn't add a function with <code>setFn</code>, it will fail.</p>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>Snapshot support and some other features depend on the runner. If you don't want to lose it, you can extend your runner from <code>VitestTestRunner</code> imported from <code>vitest/runners</code>. It also exposes <code>BenchmarkNodeRunner</code>, if you want to extend benchmark functionality.</p>
</div>
<h2 id="tasks" tabindex="-1">Tasks </h2>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>The "Runner Tasks API" is experimental and should primarily be used only in the test runtime. Vitest also exposes the <a href="api/test-module">"Reported Tasks API"</a>, which should be preferred when working in the main thread (inside the reporter, for example).</p>
<p>The team is currently discussing if "Runner Tasks" should be replaced by "Reported Tasks" in the future.</p>
</div>
<p>Suites and tests are called <code>tasks</code> internally. Vitest runner initiates a <code>File</code> task before collecting any tests - this is a superset of <code>Suite</code> with a few additional properties. It is available on every task (including <code>File</code>) as a <code>file</code> property.</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">interface File extends Suite {
  /**
   * The name of the pool that the file belongs to.
   * @default 'forks'
   */
  pool?: string
  /**
   * The path to the file in UNIX format.
   */
  filepath: string
  /**
   * The name of the workspace project the file belongs to.
   */
  projectName: string | undefined
  /**
   * The time it took to collect all tests in the file.
   * This time also includes importing all the file dependencies.
   */
  collectDuration?: number
  /**
   * The time it took to import the setup file.
   */
  setupDuration?: number
}</pre>
</div>
<p>Every suite has a <code>tasks</code> property that is populated during collection phase. It is useful to traverse the task tree from the top down.</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">interface Suite extends TaskBase {
  type: 'suite'
  /**
   * File task. It's the root task of the file.
   */
  file: File
  /**
   * An array of tasks that are part of the suite.
   */
  tasks: Task[]
}</pre>
</div>
<p>Every task has a <code>suite</code> property that references a suite it is located in. If <code>test</code> or <code>describe</code> are initiated at the top level, they will not have a <code>suite</code> property (it will <strong>not</strong> be equal to <code>file</code>!). <code>File</code> also never has a <code>suite</code> property. It is useful to travers the tasks from the bottom up.</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">interface Test&lt;ExtraContext = object&gt; extends TaskBase {
  type: 'test'
  /**
   * Test context that will be passed to the test function.
   */
  context: TestContext &amp; ExtraContext
  /**
   * File task. It's the root task of the file.
   */
  file: File
  /**
   * Whether the task was skipped by calling `t.skip()`.
   */
  pending?: boolean
  /**
   * Whether the task should succeed if it fails. If the task fails, it will be marked as passed.
   */
  fails?: boolean
  /**
   * Store promises (from async expects) to wait for them before finishing the test
   */
  promises?: Promise&lt;any&gt;[]
}</pre>
</div>
<p>Every task can have a <code>result</code> field. Suites can only have this field if an error thrown within a suite callback or <code>beforeAll</code>/<code>afterAll</code> callbacks prevents them from collecting tests. Tests always have this field after their callbacks are called - the <code>state</code> and <code>errors</code> fields are present depending on the outcome. If an error was thrown in <code>beforeEach</code> or <code>afterEach</code> callbacks, the thrown error will be present in <code>task.result.errors</code>.</p>
<div class="language-ts vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">export interface TaskResult {
  /**
   * State of the task. Inherits the `task.mode` during collection.
   * When the task has finished, it will be changed to `pass` or `fail`.
   * - **pass**: task ran successfully
   * - **fail**: task failed
   */
  state: TaskState
  /**
   * Errors that occurred during the task execution. It is possible to have several errors
   * if `expect.soft()` failed multiple times.
   */
  errors?: ErrorWithDiff[]
  /**
   * How long in milliseconds the task took to run.
   */
  duration?: number
  /**
   * Time in milliseconds when the task started running.
   */
  startTime?: number
  /**
   * Heap size in bytes after the task finished.
   * Only available if `logHeapUsage` option is set and `process.memoryUsage` is defined.
   */
  heap?: number
  /**
   * State of related to this task hooks. Useful during reporting.
   */
  hooks?: Partial&lt;Record&lt;'afterAll' | 'beforeAll' | 'beforeEach' | 'afterEach', TaskState&gt;&gt;
  /**
   * The amount of times the task was retried. The task is retried only if it
   * failed and `retry` option is set.
   */
  retryCount?: number
  /**
   * The amount of times the task was repeated. The task is repeated only if
   * `repeats` option is set. This number also contains `retryCount`.
   */
  repeatCount?: number
}</pre>
</div>
<h2 id="your-task-function" tabindex="-1">Your Task Function </h2>
<p>Vitest exposes <code>createTaskCollector</code> utility to create your own <code>test</code> method. It behaves the same way as a test, but calls a custom method during collection.</p>
<p>A task is an object that is part of a suite. It is automatically added to the current suite with a <code>suite.task</code> method:</p>
<div class="vp-code-block-title">
<div class="vp-code-block-title-bar"><span class="vp-code-block-title-text" data-title="custom.js">custom.js</span></div>
<div class="language-js vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { createTaskCollector, getCurrentSuite } from 'vitest/suite'

export { afterAll, beforeAll, describe } from 'vitest'

// this function will be called during collection phase:
// don't call function handler here, add it to suite tasks
// with "getCurrentSuite().task()" method
// note: createTaskCollector provides support for "todo"/"each"/...
export const myCustomTask = createTaskCollector(
  function (name, fn, timeout) {
    getCurrentSuite().task(name, {
      ...this, // so "todo"/"skip"/... is tracked correctly
      meta: {
        customPropertyToDifferentiateTask: true
      },
      handler: fn,
      timeout,
    })
  }
)</pre>
</div>
</div>
<div class="vp-code-block-title">
<div class="vp-code-block-title-bar"><span class="vp-code-block-title-text" data-title="tasks.test.js">tasks.test.js</span></div>
<div class="language-js vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import {
  afterAll,
  beforeAll,
  describe,
  myCustomTask
} from './custom.js'
import { gardener } from './gardener.js'

describe('take care of the garden', () =&gt; {
  beforeAll(() =&gt; {
    gardener.putWorkingClothes()
  })

  myCustomTask('weed the grass', () =&gt; {
    gardener.weedTheGrass()
  })
  myCustomTask.todo('mow the lawn', () =&gt; {
    gardener.mowerTheLawn()
  })
  myCustomTask('water flowers', () =&gt; {
    gardener.waterFlowers()
  })

  afterAll(() =&gt; {
    gardener.goHome()
  })
})</pre>
</div>
</div>
<div class="language-bash vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">vitest ./garden/tasks.test.js</pre>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2021-Present Anthony Fu<br>&copy; 2021-Present Matias Capeletto<br>Licensed under the MIT License.<br>
    <a href="https://vitest.dev/advanced/runner" class="_attribution-link">https://vitest.dev/advanced/runner</a>
  </p>
</div>
