   <h1 class="chapter">Shell Grammar</h1>        <h2 class="section">Simple Commands &amp; Pipelines</h2>   <p id="index-commands_002c-simple">A <em>simple command</em> is a sequence of optional parameter assignments followed by blank-separated words, with optional redirections interspersed. For a description of assignment, see the beginning of <a href="parameters#Parameters">Parameters</a>. </p> <p>The first word is the command to be executed, and the remaining words, if any, are arguments to the command. If a command name is given, the parameter assignments modify the environment of the command when it is executed. The value of a simple command is its exit status, or 128 plus the signal number if terminated by a signal. For example, </p> <div class="example"> <pre class="example">echo foo
</pre>
</div> <p>is a simple command with arguments. </p>  <p id="index-pipeline">A <em>pipeline</em> is either a simple command, or a sequence of two or more simple commands where each command is separated from the next by ‘<tt>|</tt>’ or ‘<tt>|&amp;</tt>’. Where commands are separated by ‘<tt>|</tt>’, the standard output of the first command is connected to the standard input of the next. ‘<tt>|&amp;</tt>’ is shorthand for ‘<tt>2&gt;&amp;1 |</tt>’, which connects both the standard output and the standard error of the command to the standard input of the next. The value of a pipeline is the value of the last command, unless the pipeline is preceded by ‘<tt>!</tt>’ in which case the value is the logical inverse of the value of the last command. For example, </p> <div class="example"> <pre class="example">echo foo | sed 's/foo/bar/'
</pre>
</div> <p>is a pipeline, where the output (‘<tt>foo</tt>’ plus a newline) of the first command will be passed to the input of the second. </p>   <p id="index-coprocess">If a pipeline is preceded by ‘<tt>coproc</tt>’, it is executed as a coprocess; a two-way pipe is established between it and the parent shell. The shell can read from or write to the coprocess by means of the ‘<tt>&gt;&amp;p</tt>’ and ‘<tt>&lt;&amp;p</tt>’ redirection operators or with ‘<tt>print -p</tt>’ and ‘<tt>read -p</tt>’. A pipeline cannot be preceded by both ‘<tt>coproc</tt>’ and ‘<tt>!</tt>’. If job control is active, the coprocess can be treated in other than input and output as an ordinary background job. </p>  <p id="index-sublist">A <em>sublist</em> is either a single pipeline, or a sequence of two or more pipelines separated by ‘<tt>&amp;&amp;</tt>’ or ‘<tt>||</tt>’. If two pipelines are separated by ‘<tt>&amp;&amp;</tt>’, the second pipeline is executed only if the first succeeds (returns a zero status). If two pipelines are separated by ‘<tt>||</tt>’, the second is executed only if the first fails (returns a nonzero status). Both operators have equal precedence and are left associative. The value of the sublist is the value of the last pipeline executed. For example, </p> <div class="example"> <pre class="example">dmesg | grep panic &amp;&amp; print yes
</pre>
</div> <p>is a sublist consisting of two pipelines, the second just a simple command which will be executed if and only if the <tt>grep</tt> command returns a zero status. If it does not, the value of the sublist is that return status, else it is the status returned by the <tt>print</tt> (almost certainly zero). </p>  <p id="index-list">A <em>list</em> is a sequence of zero or more sublists, in which each sublist is terminated by ‘<tt>;</tt>’, ‘<tt>&amp;</tt>’, ‘<tt>&amp;|</tt>’, ‘<tt>&amp;!</tt>’, or a newline. This terminator may optionally be omitted from the last sublist in the list when the list appears as a complex command inside ‘<tt>(</tt>...<tt>)</tt>’ or ‘<tt>{</tt>...<tt>}</tt>’. When a sublist is terminated by ‘<tt>;</tt>’ or newline, the shell waits for it to finish before executing the next sublist. If a sublist is terminated by a ‘<tt>&amp;</tt>’, ‘<tt>&amp;|</tt>’, or ‘<tt>&amp;!</tt>’, the shell executes the last pipeline in it in the background, and does not wait for it to finish (note the difference from other shells which execute the whole sublist in the background). A backgrounded pipeline returns a status of zero. </p> <p>More generally, a list can be seen as a set of any shell commands whatsoever, including the complex commands below; this is implied wherever the word ‘list’ appears in later descriptions. For example, the commands in a shell function form a special sort of list. </p>    <h2 class="section" id="Precommand-Modifiers-1">Precommand Modifiers</h2>   <p id="index-modifiers_002c-precommand">A simple command may be preceded by a <em>precommand modifier</em>, which will alter how the command is interpreted. These modifiers are shell builtin commands with the exception of <tt>nocorrect</tt> which is a reserved word. </p> <dl compact>  <dt id="index-_002d"><tt>-</tt></dt> <dd>
<p>The command is executed with a ‘<tt>-</tt>’ prepended to its <tt>argv[0]</tt> string. </p>  </dd> <dt id="index-builtin"><tt>builtin</tt></dt> <dd>
<p>The command word is taken to be the name of a builtin command, rather than a shell function or external command. </p>  </dd> <dt id="index-command">
<tt>command</tt> [ <tt>-pvV</tt> ]</dt> <dd>
<p>The command word is taken to be the name of an external command, rather than a shell function or builtin. If the <tt>POSIX_BUILTINS</tt> option is set, builtins will also be executed but certain special properties of them are suppressed. The <tt>-p</tt> flag causes a default path to be searched instead of that in <tt>$path</tt>. With the <tt>-v</tt> flag, <tt>command</tt> is similar to <tt>whence</tt> and with <tt>-V</tt>, it is equivalent to <tt>whence -v</tt>. </p>  </dd> <dt id="index-exec">
<tt>exec</tt> [ <tt>-cl</tt> ] [ <tt>-a</tt> <var>argv0</var> ]</dt> <dd>
<p>The following command together with any arguments is run in place of the current process, rather than as a sub-process. The shell does not fork and is replaced. The shell does not invoke <tt>TRAPEXIT</tt>, nor does it source <tt>zlogout</tt> files. The options are provided for compatibility with other shells. </p> <p>The <tt>-c</tt> option clears the environment. </p> <p>The <tt>-l</tt> option is equivalent to the <tt>-</tt> precommand modifier, to treat the replacement command as a login shell; the command is executed with a <tt>-</tt> prepended to its <tt>argv[0]</tt> string. This flag has no effect if used together with the <tt>-a</tt> option. </p> <p>The <tt>-a</tt> option is used to specify explicitly the <tt>argv[0]</tt> string (the name of the command as seen by the process itself) to be used by the replacement command and is directly equivalent to setting a value for the <tt>ARGV0</tt> environment variable. </p>  </dd> <dt id="index-nocorrect"><tt>nocorrect</tt></dt> <dd>
<p>Spelling correction is not done on any of the words. This must appear before any other precommand modifier, as it is interpreted immediately, before any parsing is done. It has no effect in non-interactive shells. </p>  </dd> <dt id="index-noglob"><tt>noglob</tt></dt> <dd>
<p>Filename generation (globbing) is not performed on any of the words. </p> </dd> </dl>     <h2 class="section" id="Complex-Commands-1">Complex Commands</h2>   <p id="index-commands_002c-complex">A <em>complex command</em> in zsh is one of the following: </p> <dl compact>  <dt id="index-if">
<tt>if</tt> <var>list</var> <tt>then</tt> <var>list</var> [ <tt>elif</tt> <var>list</var> <tt>then</tt> <var>list</var> ] ... [ <tt>else</tt> <var>list</var> ] <tt>fi</tt>
</dt> <dd>
<p>The <tt>if</tt> <var>list</var> is executed, and if it returns a zero exit status, the <tt>then</tt> <var>list</var> is executed. Otherwise, the <tt>elif</tt> <var>list</var> is executed and if its status is zero, the <tt>then</tt> <var>list</var> is executed. If each <tt>elif</tt> <var>list</var> returns nonzero status, the <tt>else</tt> <var>list</var> is executed. </p>    </dd> <dt id="index-if-construct">
<tt>for</tt> <var>name</var> ... [ <tt>in</tt> <var>word</var> ... ] <var>term</var> <tt>do</tt> <var>list</var> <tt>done</tt>
</dt> <dd>
<p>Expand the list of <var>word</var>s, and set the parameter <var>name</var> to each of them in turn, executing <var>list</var> each time. If the ‘<tt>in</tt> <var>word</var>’ is omitted, use the positional parameters instead of the <var>word</var>s. </p> <p>The <var>term</var> consists of one or more newline or <tt>;</tt> which terminate the <var>word</var>s, and are optional when the ‘<tt>in</tt> <var>word</var>’ is omitted. </p> <p>More than one parameter <var>name</var> can appear before the list of <var>word</var>s. If <var>N</var> <var>name</var>s are given, then on each execution of the loop the next <var>N</var> <var>word</var>s are assigned to the corresponding parameters. If there are more <var>name</var>s than remaining <var>word</var>s, the remaining parameters are each set to the empty string. Execution of the loop ends when there is no remaining <var>word</var> to assign to the first <var>name</var>. It is only possible for <tt>in</tt> to appear as the first <var>name</var> in the list, else it will be treated as marking the end of the list. </p> </dd> <dt id="index-for">
<tt>for ((</tt> [<var>expr1</var>] <tt>;</tt> [<var>expr2</var>] <tt>;</tt> [<var>expr3</var>] <tt>)) do</tt> <var>list</var> <tt>done</tt>
</dt> <dd>
<p>The arithmetic expression <var>expr1</var> is evaluated first (see <a href="arithmetic-evaluation#Arithmetic-Evaluation">Arithmetic Evaluation</a>). The arithmetic expression <var>expr2</var> is repeatedly evaluated until it evaluates to zero and when non-zero, <var>list</var> is executed and the arithmetic expression <var>expr3</var> evaluated. If any expression is omitted, then it behaves as if it evaluated to 1. </p>    </dd> <dt id="index-for-loops">
<tt>while</tt> <var>list</var> <tt>do</tt> <var>list</var> <tt>done</tt>
</dt> <dd>
<p>Execute the <tt>do</tt> <var>list</var> as long as the <tt>while</tt> <var>list</var> returns a zero exit status. </p>    </dd> <dt id="index-loops_002c-for">
<tt>until</tt> <var>list</var> <tt>do</tt> <var>list</var> <tt>done</tt>
</dt> <dd>
<p>Execute the <tt>do</tt> <var>list</var> as long as <tt>until</tt> <var>list</var> returns a nonzero exit status. </p>    </dd> <dt id="index-while">
<tt>repeat</tt> <var>word</var> <tt>do</tt> <var>list</var> <tt>done</tt>
</dt> <dd>
<p><var>word</var> is expanded and treated as an arithmetic expression, which must evaluate to a number <var>n</var>. <var>list</var> is then executed <var>n</var> times. </p> <p>The <tt>repeat</tt> syntax is disabled by default when the shell starts in a mode emulating another shell. It can be enabled with the command ‘<tt>enable -r repeat</tt>’ </p>    </dd> <dt id="index-while-loops">
<tt>case</tt> <var>word</var> <tt>in</tt> [ [<tt>(</tt>] <var>pattern</var> [ <tt>|</tt> <var>pattern</var> ] ... <tt>)</tt> <var>list</var> (<tt>;;</tt>|<tt>;&amp;</tt>|<tt>;|</tt>) ] ... <tt>esac</tt>
</dt> <dd>
<p>Execute the <var>list</var> associated with the first <var>pattern</var> that matches <var>word</var>, if any. The form of the patterns is the same as that used for filename generation. See <a href="expansion#Filename-Generation">Filename Generation</a>. </p> <p>Note further that, unless the <tt>SH_GLOB</tt> option is set, the whole pattern with alternatives is treated by the shell as equivalent to a group of patterns within parentheses, although white space may appear about the parentheses and the vertical bar and will be stripped from the pattern at those points. White space may appear elsewhere in the pattern; this is not stripped. If the <tt>SH_GLOB</tt> option is set, so that an opening parenthesis can be unambiguously treated as part of the case syntax, the expression is parsed into separate words and these are treated as strict alternatives (as in other shells). </p> <p>If the <var>list</var> that is executed is terminated with <tt>;&amp;</tt> rather than <tt>;;</tt>, the following list is also executed. The rule for the terminator of the following list <tt>;;</tt>, <tt>;&amp;</tt> or <tt>;|</tt> is applied unless the <tt>esac</tt> is reached. </p> <p>If the <var>list</var> that is executed is terminated with <tt>;|</tt> the shell continues to scan the <var>pattern</var>s looking for the next match, executing the corresponding <var>list</var>, and applying the rule for the corresponding terminator <tt>;;</tt>, <tt>;&amp;</tt> or <tt>;|</tt>. Note that <var>word</var> is not re-expanded; all applicable <var>pattern</var>s are tested with the same <var>word</var>. </p>    </dd> <dt id="index-loops_002c-while">
<tt>select</tt> <var>name</var> [ <tt>in</tt> <var>word</var> ... <var>term</var> ] <tt>do</tt> <var>list</var> <tt>done</tt>
</dt> <dd>
<p>where <var>term</var> is one or more newline or <tt>;</tt> to terminate the <var>word</var>s.  Print the set of <var>word</var>s, each preceded by a number. If the <tt>in</tt> <var>word</var> is omitted, use the positional parameters. The <tt>PROMPT3</tt> prompt is printed and a line is read from the line editor if the shell is interactive and that is active, or else standard input. If this line consists of the number of one of the listed <var>word</var>s, then the parameter <var>name</var> is set to the <var>word</var> corresponding to this number. If this line is empty, the selection list is printed again. Otherwise, the value of the parameter <var>name</var> is set to null. The contents of the line read from standard input is saved in the parameter <tt>REPLY</tt>. <var>list</var> is executed for each selection until a break or end-of-file is encountered. </p>  </dd> <dt id="index-until">
<tt>(</tt> <var>list</var> <tt>)</tt>
</dt> <dd>
<p>Execute <var>list</var> in a subshell. Traps set by the <tt>trap</tt> builtin are reset to their default values while executing <var>list</var>; an exception is that ignored signals will continue to be ignored if the option <tt>POSIXTRAPS</tt> is set. </p> </dd> <dt id="index-until-loops">
<tt>{</tt> <var>list</var> <tt>}</tt>
</dt> <dd>
<p>Execute <var>list</var>. </p>    </dd> <dt id="index-loops_002c-until">
<tt>{</tt> <var>try-list</var> <tt>} always {</tt> <var>always-list</var> <tt>}</tt>
</dt> <dd>
<p>First execute <var>try-list</var>. Regardless of errors, or <tt>break</tt> or <tt>continue</tt> commands encountered within <var>try-list</var>, execute <var>always-list</var>. Execution then continues from the result of the execution of <var>try-list</var>; in other words, any error, or <tt>break</tt> or <tt>continue</tt> command is treated in the normal way, as if <var>always-list</var> were not present. The two chunks of code are referred to as the ‘try block’ and the ‘always block’. </p> <p>Optional newlines or semicolons may appear after the <tt>always</tt>; note, however, that they may <em>not</em> appear between the preceding closing brace and the <tt>always</tt>. </p> <p>An ‘error’ in this context is a condition such as a syntax error which causes the shell to abort execution of the current function, script, or list. Syntax errors encountered while the shell is parsing the code do not cause the <var>always-list</var> to be executed. For example, an erroneously constructed <tt>if</tt> block in <var>try-list</var> would cause the shell to abort during parsing, so that <var>always-list</var> would not be executed, while an erroneous substitution such as <tt>${*foo*}</tt> would cause a run-time error, after which <var>always-list</var> would be executed. </p> <p>An error condition can be tested and reset with the special integer variable <tt>TRY_BLOCK_ERROR</tt>. Outside an <var>always-list</var> the value is irrelevant, but it is initialised to <tt>-1</tt>. Inside <var>always-list</var>, the value is 1 if an error occurred in the <var>try-list</var>, else 0. If <tt>TRY_BLOCK_ERROR</tt> is set to 0 during the <var>always-list</var>, the error condition caused by the <var>try-list</var> is reset, and shell execution continues normally after the end of <var>always-list</var>. Altering the value during the <var>try-list</var> is not useful (unless this forms part of an enclosing <tt>always</tt> block). </p> <p>Regardless of <tt>TRY_BLOCK_ERROR</tt>, after the end of <var>always-list</var> the normal shell status <tt>$?</tt> is the value returned from <var>try-list</var>. This will be non-zero if there was an error, even if <tt>TRY_BLOCK_ERROR</tt> was set to zero. </p> <p>The following executes the given code, ignoring any errors it causes. This is an alternative to the usual convention of protecting code by executing it in a subshell. </p> <div class="example"> <pre class="example">{
    # code which may cause an error
  } always {
    # This code is executed regardless of the error.
    (( TRY_BLOCK_ERROR = 0 ))
}
# The error condition has been reset.
</pre>
</div> <p>When a <tt>try</tt> block occurs outside of any function, a <tt>return</tt> or a <tt>exit</tt> encountered in <var>try-list</var> does <em>not</em> cause the execution of <var>always-list</var>. Instead, the shell exits immediately after any <tt>EXIT</tt> trap has been executed. Otherwise, a <tt>return</tt> command encountered in <var>try-list</var> will cause the execution of <var>always-list</var>, just like <tt>break</tt> and <tt>continue</tt>. </p>  </dd> <dt id="index-repeat">
<tt>function</tt> [ <tt>-T</tt> ] <var>word</var> ... [ <tt>()</tt> ] [ <var>term</var> ] <tt>{</tt> <var>list</var> <tt>}</tt>
</dt> <dt id="index-repeat-loops">
<var>word</var> ... <tt>()</tt> [ <var>term</var> ] <tt>{</tt> <var>list</var> <tt>}</tt>
</dt> <dt id="index-loops_002c-repeat">
<var>word</var> ... <tt>()</tt> [ <var>term</var> ] <var>command</var>
</dt> <dd>
<p>where <var>term</var> is one or more newline or <tt>;</tt>. Define a function which is referenced by any one of <var>word</var>. Normally, only one <var>word</var> is provided; multiple <var>word</var>s are usually only useful for setting traps. The body of the function is the <var>list</var> between the <tt>{</tt> and <tt>}</tt>. See <a href="functions#Functions">Functions</a>. </p> <p>The options of <tt>function</tt> have the following meanings: </p> <dl compact> <dt>-T</dt> <dd>
<p>Enable tracing for this function, as though with <tt>functions -T</tt>. See the documentation of the <tt>-f</tt> option to the <tt>typeset</tt> builtin, in <a href="shell-builtin-commands#Shell-Builtin-Commands">Shell Builtin Commands</a>. </p> </dd> </dl> <p>If the option <tt>SH_GLOB</tt> is set for compatibility with other shells, then whitespace may appear between the left and right parentheses when there is a single <var>word</var>; otherwise, the parentheses will be treated as forming a globbing pattern in that case. </p> <p>In any of the forms above, a redirection may appear outside the function body, for example </p> <div class="example"> <pre class="example">func() { ... } 2&gt;&amp;1
</pre>
</div> <p>The redirection is stored with the function and applied whenever the function is executed. Any variables in the redirection are expanded at the point the function is executed, but outside the function scope. </p>   </dd> <dt id="index-case">
<tt>time</tt> [ <var>pipeline</var> ]</dt> <dd>
<p>The <var>pipeline</var> is executed, and timing statistics are reported on the standard error in the form specified by the <tt>TIMEFMT</tt> parameter. If <var>pipeline</var> is omitted, print statistics about the shell process and its children. </p>   </dd> <dt id="index-case-selection">
<tt>[[</tt> <var>exp</var> <tt>]]</tt>
</dt> <dd>
<p>Evaluates the conditional expression <var>exp</var> and return a zero exit status if it is true. See <a href="conditional-expressions#Conditional-Expressions">Conditional Expressions</a> for a description of <var>exp</var>. </p> </dd> </dl>     <h2 class="section" id="Alternate-Forms-For-Complex-Commands-1">Alternate Forms For Complex Commands</h2>   <p id="index-commands_002c-alternate-forms-for-complex">Many of zsh’s complex commands have alternate forms. These are non-standard and are likely not to be obvious even to seasoned shell programmers; they should not be used anywhere that portability of shell code is a concern. </p> <p>The short versions below only work if <var>sublist</var> is of the form ‘<tt>{</tt> <var>list</var> <tt>}</tt>’ or if the <tt>SHORT_LOOPS</tt> option is set. For the <tt>if</tt>, <tt>while</tt> and <tt>until</tt> commands, in both these cases the test part of the loop must also be suitably delimited, such as by ‘<tt>[[</tt> <var>...</var> <tt>]]</tt>’ or ‘<tt>((</tt> <var>...</var> <tt>))</tt>’, else the end of the test will not be recognized. For the <tt>for</tt>, <tt>repeat</tt>, <tt>case</tt> and <tt>select</tt> commands no such special form for the arguments is necessary, but the other condition (the special form of <var>sublist</var> or use of the <tt>SHORT_LOOPS</tt> option) still applies. The <tt>SHORT_REPEAT</tt> option is available to enable the short version only for the <tt>repeat</tt> command. </p> <dl compact> <dt id="index-foreach">
<tt>if</tt> <var>list</var> <tt>{</tt> <var>list</var> <tt>}</tt> [ <tt>elif</tt> <var>list</var> <tt>{</tt> <var>list</var> <tt>}</tt> ] ... [ <tt>else {</tt> <var>list</var> <tt>}</tt> ]</dt> <dd>
<p>An alternate form of <tt>if</tt>. The rules mean that </p> <div class="example"> <pre class="example">if [[ -o ignorebraces ]] {
  print yes
}
</pre>
</div> <p>works, but </p> <div class="example"> <pre class="example">if true {  # Does not work!
  print yes
}
</pre>
</div> <p>does <em>not</em>, since the test is not suitably delimited. </p> </dd> <dt>
<tt>if</tt> <var>list</var> <var>sublist</var>
</dt> <dd>
<p>A short form of the alternate <tt>if</tt>. The same limitations on the form of <var>list</var> apply as for the previous form. </p> </dd> <dt>
<tt>for</tt> <var>name</var> ... <tt>(</tt> <var>word</var> ... <tt>)</tt> <var>sublist</var>
</dt> <dd>
<p>A short form of <tt>for</tt>. </p> </dd> <dt>
<tt>for</tt> <var>name</var> ... [ <tt>in</tt> <var>word</var> ... ] <var>term</var> <var>sublist</var>
</dt> <dd>
<p>where <var>term</var> is at least one newline or <tt>;</tt>. Another short form of <tt>for</tt>. </p> </dd> <dt>
<tt>for ((</tt> [<var>expr1</var>] <tt>;</tt> [<var>expr2</var>] <tt>;</tt> [<var>expr3</var>] <tt>))</tt> <var>sublist</var>
</dt> <dd>
<p>A short form of the arithmetic <tt>for</tt> command. </p>  </dd> <dt>
<tt>foreach</tt> <var>name</var> ... <tt>(</tt> <var>word</var> ... <tt>)</tt> <var>list</var> <tt>end</tt>
</dt> <dd>
<p>Another form of <tt>for</tt>. </p> </dd> <dt>
<tt>while</tt> <var>list</var> <tt>{</tt> <var>list</var> <tt>}</tt>
</dt> <dd>
<p>An alternative form of <tt>while</tt>. Note the limitations on the form of <var>list</var> mentioned above. </p> </dd> <dt>
<tt>until</tt> <var>list</var> <tt>{</tt> <var>list</var> <tt>}</tt>
</dt> <dd>
<p>An alternative form of <tt>until</tt>. Note the limitations on the form of <var>list</var> mentioned above. </p> </dd> <dt>
<tt>repeat</tt> <var>word</var> <var>sublist</var>
</dt> <dd>
<p>This is a short form of <tt>repeat</tt>. </p> </dd> <dt>
<tt>case</tt> <var>word</var> <tt>{</tt> [ [<tt>(</tt>] <var>pattern</var> [ <tt>|</tt> <var>pattern</var> ] ... <tt>)</tt> <var>list</var> (<tt>;;</tt>|<tt>;&amp;</tt>|<tt>;|</tt>) ] ... <tt>}</tt>
</dt> <dd>
<p>An alternative form of <tt>case</tt>. </p> </dd> <dt>
<tt>select</tt> <var>name</var> [ <tt>in</tt> <var>word</var> ... <var>term</var> ] <var>sublist</var>
</dt> <dd>
<p>where <var>term</var> is at least one newline or <tt>;</tt>. A short form of <tt>select</tt>. </p> </dd> <dt>
<tt>function</tt> <var>word</var> ... [ <tt>()</tt> ] [ <var>term</var> ] <var>sublist</var>
</dt> <dd>
<p>This is a short form of <tt>function</tt>. </p> </dd> </dl>     <h2 class="section" id="Reserved-Words-1">Reserved Words</h2>   <p id="index-disable_002c-use-of">The following words are recognized as reserved words when used as the first word of a command unless quoted or disabled using <tt>disable -r</tt>: </p> <p><tt>do done esac then elif else fi for case if while function repeat time until select coproc nocorrect foreach end ! [[ { } declare export float integer local readonly typeset</tt> </p> <p>Additionally, ‘<tt>}</tt>’ is recognized in any position if neither the <tt>IGNORE_BRACES</tt> option nor the <tt>IGNORE_CLOSE_BRACES</tt> option is set. </p>    <h2 class="section" id="Errors-1">Errors</h2>  <p id="index-errors_002c-handling-of">Certain errors are treated as fatal by the shell: in an interactive shell, they cause control to return to the command line, and in a non-interactive shell they cause the shell to be aborted. In older versions of zsh, a non-interactive shell running a script would not abort completely, but would resume execution at the next command to be read from the script, skipping the remainder of any functions or shell constructs such as loops or conditions; this somewhat illogical behaviour can be recovered by setting the option <tt>CONTINUE_ON_ERROR</tt>. </p> <p>Fatal errors found in non-interactive shells include: </p> <ul> <li> Failure to parse shell options passed when invoking the shell </li>
<li> Failure to change options with the <tt>set</tt> builtin </li>
<li> Parse errors of all sorts, including failures to parse mathematical expressions </li>
<li> Failures to set or modify variable behaviour with <tt>typeset</tt>, <tt>local</tt>, <tt>declare</tt>, <tt>export</tt>, <tt>integer</tt>, <tt>float</tt> </li>
<li> Execution of incorrectly positioned loop control structures (<tt>continue</tt>, <tt>break</tt>) </li>
<li> Attempts to use regular expression with no regular expression module available </li>
<li> Disallowed operations when the <tt>RESTRICTED</tt> options is set </li>
<li> Failure to create a pipe needed for a pipeline </li>
<li> Failure to create a multio </li>
<li> Failure to autoload a module needed for a declared shell feature </li>
<li> Errors creating command or process substitutions </li>
<li> Syntax errors in glob qualifiers </li>
<li> File generation errors where not caught by the option <tt>BAD_PATTERN</tt> </li>
<li> All bad patterns used for matching within case statements </li>
<li> File generation failures where not caused by <tt>NO_MATCH</tt> or similar options </li>
<li> All file generation errors where the pattern was used to create a multio </li>
<li> Memory errors where detected by the shell </li>
<li> Invalid subscripts to shell variables </li>
<li> Attempts to assign read-only variables </li>
<li> Logical errors with variables such as assignment to the wrong type </li>
<li> Use of invalid variable names </li>
<li> Errors in variable substitution syntax </li>
<li> Failure to convert characters in <tt>$’</tt>...<tt>’</tt> expressions </li>
</ul> <p>If the <tt>POSIX_BUILTINS</tt> option is set, more errors associated with shell builtin commands are treated as fatal, as specified by the POSIX standard. </p>     <h2 class="section" id="Comments-1">Comments</h2>    <p id="index-histchars_002c-use-of">In non-interactive shells, or in interactive shells with the <tt>INTERACTIVE_COMMENTS</tt> option set, a word beginning with the third character of the <tt>histchars</tt> parameter (‘<tt>#</tt>’ by default) causes that word and all the following characters up to a newline to be ignored. </p>    <h2 class="section" id="Aliasing-1">Aliasing</h2>  <p id="index-aliasing">Every eligible <em>word</em> in the shell input is checked to see if there is an alias defined for it. If so, it is replaced by the text of the alias if it is in command position (if it could be the first word of a simple command), or if the alias is global. If the replacement text ends with a space, the next word in the shell input is always eligible for purposes of alias expansion. </p> <p>It is an error for the function name, <var>word</var>, in the sh-compatible function definition syntax ‘<var>word</var> <tt>()</tt> ...’ to be a word that resulted from alias expansion, unless the <tt>ALIAS_FUNC_DEF</tt> option is set. </p>   <p id="index-aliases_002c-global">An alias is defined using the <tt>alias</tt> builtin; global aliases may be defined using the <tt>-g</tt> option to that builtin. </p> <p>A <em>word</em> is defined as: </p> <ul> <li> Any plain string or glob pattern </li>
<li> Any quoted string, using any quoting method (note that the quotes must be part of the alias definition for this to be eligible) </li>
<li> Any parameter reference or command substitution </li>
<li> Any series of the foregoing, concatenated without whitespace or other tokens between them </li>
<li> Any reserved word (<tt>case</tt>, <tt>do</tt>, <tt>else</tt>, etc.) </li>
<li> With global aliasing, any command separator, any redirection operator, and ‘<tt>(</tt>’ or ‘<tt>)</tt>’ when not part of a glob pattern </li>
</ul> <p>Alias expansion is done on the shell input before any other expansion except history expansion. Therefore, if an alias is defined for the word <tt>foo</tt>, alias expansion may be avoided by quoting part of the word, e.g. <tt>\foo</tt>. Any form of quoting works, although there is nothing to prevent an alias being defined for the quoted form such as <tt>\foo</tt> as well. </p> <p>In particular, note that quoting must be used when using <tt>unalias</tt> to remove global aliases: </p> <div class="example"> <pre class="example">% alias -g foo=bar
% unalias foo
unalias: no such hash table element: bar
% unalias \foo
% 
</pre>
</div> <p>When <tt>POSIX_ALIASES</tt> is set, only plain unquoted strings are eligible for aliasing. The <tt>alias</tt> builtin does not reject ineligible aliases, but they are not expanded. </p> <p>For use with completion, which would remove an initial backslash followed by a character that isn’t special, it may be more convenient to quote the word by starting with a single quote, i.e. <tt>’foo</tt>; completion will automatically add the trailing single quote. </p>    <h3 class="subsection" id="Alias-difficulties">Alias difficulties</h3> <p>Although aliases can be used in ways that bend normal shell syntax, not every string of non-white-space characters can be used as an alias. </p> <p>Any set of characters not listed as a word above is not a word, hence no attempt is made to expand it as an alias, no matter how it is defined (i.e. via the builtin or the special parameter <tt>aliases</tt> described in <a href="zsh-modules#The-zsh_002fparameter-Module">The zsh/parameter Module</a>). However, as noted in the case of <tt>POSIX_ALIASES</tt> above, the shell does not attempt to deduce whether the string corresponds to a word at the time the alias is created. </p> <p>For example, an expression containing an <tt>=</tt> at the start of a command line is an assignment and cannot be expanded as an alias; a lone <tt>=</tt> is not an assignment but can only be set as an alias using the parameter, as otherwise the <tt>=</tt> is taken part of the syntax of the builtin command. </p> <p>It is not presently possible to alias the ‘<tt>((</tt>’ token that introduces arithmetic expressions, because until a full statement has been parsed, it cannot be distinguished from two consecutive ‘<tt>(</tt>’ tokens introducing nested subshells. Also, if a separator such as <tt>&amp;&amp;</tt> is aliased, <tt>\&amp;&amp;</tt> turns into the two tokens <tt>\&amp;</tt> and <tt>&amp;</tt>, each of which may have been aliased separately. Similarly for <tt>\&lt;&lt;</tt>, <tt>\&gt;|</tt>, etc. </p> <p>There is a commonly encountered problem with aliases illustrated by the following code: </p> <div class="example"> <pre class="example">alias echobar='echo bar'; echobar
</pre>
</div> <p>This prints a message that the command <tt>echobar</tt> could not be found. This happens because aliases are expanded when the code is read in; the entire line is read in one go, so that when <tt>echobar</tt> is executed it is too late to expand the newly defined alias. This is often a problem in shell scripts, functions, and code executed with ‘<tt>source</tt>’ or ‘<tt>.</tt>’. Consequently, use of functions rather than aliases is recommended in non-interactive code. </p>     <h2 class="section" id="Quoting-1">Quoting</h2>  <p id="index-quoting">A character may be <em>quoted</em> (that is, made to stand for itself) by preceding it with a ‘<tt>\</tt>’. ‘<tt>\</tt>’ followed by a newline is ignored. </p> <p>A string enclosed between ‘<tt>$’</tt>’ and ‘<tt>’</tt>’ is processed the same way as the string arguments of the <tt>print</tt> builtin, and the resulting string is considered to be entirely quoted. A literal ‘<tt>’</tt>’ character can be included in the string by using the ‘<tt>\’</tt>’ escape. </p>  <p id="index-RC_005fQUOTES_002c-use-of">All characters enclosed between a pair of single quotes (<tt>’’</tt>) that is not preceded by a ‘<tt>$</tt>’ are quoted. A single quote cannot appear within single quotes unless the option <tt>RC_QUOTES</tt> is set, in which case a pair of single quotes are turned into a single quote. For example, </p> <div class="example"> <pre class="example">print ''''
</pre>
</div> <p>outputs nothing apart from a newline if <tt>RC_QUOTES</tt> is not set, but one single quote if it is set. </p> <p>Inside double quotes (<tt>""</tt>), parameter and command substitution occur, and ‘<tt>\</tt>’ quotes the characters ‘<tt>\</tt>’, ‘<tt>‘</tt>’, ‘<tt>"</tt>’, ‘<tt>$</tt>’, and the first character of <tt>$histchars</tt> (default ‘<tt>!</tt>’). </p>  <p> <font size="-1"> This document was generated on <i>May 14, 2022</i> using <a href="http://www.nongnu.org/texi2html/"><i>texi2html 5.0</i></a>. </font> <br> <font size="-1">Zsh version 5.9, released on May 14, 2022.</font> </p><div class="_attribution">
  <p class="_attribution-p">
         The Z Shell is copyright &copy; 1992&ndash;2017 Paul Falstad, Richard Coleman,Zoltán Hidvégi, Andrew Main, Peter Stephenson, Sven Wischnowsky, and others.<br />     Licensed under the MIT License.<br>
    <a href="https://zsh.sourceforge.io/Doc/Release/Shell-Grammar.html" class="_attribution-link">https://zsh.sourceforge.io/Doc/Release/Shell-Grammar.html</a>
  </p>
</div>
