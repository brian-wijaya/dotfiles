   <h1 class="chapter">Conditional Expressions</h1>   <p>A <em>conditional expression</em> is used with the <tt>[[</tt> compound command to test attributes of files and to compare strings. Each expression can be constructed from one or more of the following unary or binary expressions: </p> <dl compact> <dt>
<tt>-a</tt> <var>file</var>
</dt> <dd>
<p>true if <var>file</var> exists. </p> </dd> <dt>
<tt>-b</tt> <var>file</var>
</dt> <dd>
<p>true if <var>file</var> exists and is a block special file. </p> </dd> <dt>
<tt>-c</tt> <var>file</var>
</dt> <dd>
<p>true if <var>file</var> exists and is a character special file. </p> </dd> <dt>
<tt>-d</tt> <var>file</var>
</dt> <dd>
<p>true if <var>file</var> exists and is a directory. </p> </dd> <dt>
<tt>-e</tt> <var>file</var>
</dt> <dd>
<p>true if <var>file</var> exists. </p> </dd> <dt>
<tt>-f</tt> <var>file</var>
</dt> <dd>
<p>true if <var>file</var> exists and is a regular file. </p> </dd> <dt>
<tt>-g</tt> <var>file</var>
</dt> <dd>
<p>true if <var>file</var> exists and has its setgid bit set. </p> </dd> <dt>
<tt>-h</tt> <var>file</var>
</dt> <dd>
<p>true if <var>file</var> exists and is a symbolic link. </p> </dd> <dt>
<tt>-k</tt> <var>file</var>
</dt> <dd>
<p>true if <var>file</var> exists and has its sticky bit set. </p> </dd> <dt>
<tt>-n</tt> <var>string</var>
</dt> <dd>
<p>true if length of <var>string</var> is non-zero. </p> </dd> <dt>
<tt>-o</tt> <var>option</var>
</dt> <dd>
<p>true if option named <var>option</var> is on. <var>option</var> may be a single character, in which case it is a single letter option name. (See <a href="options#Specifying-Options">Specifying Options</a>.) </p> <p>When no option named <var>option</var> exists, and the <tt>POSIX_BUILTINS</tt> option hasn’t been set, return 3 with a warning. If that option is set, return 1 with no warning. </p> </dd> <dt>
<tt>-p</tt> <var>file</var>
</dt> <dd>
<p>true if <var>file</var> exists and is a FIFO special file (named pipe). </p> </dd> <dt>
<tt>-r</tt> <var>file</var>
</dt> <dd>
<p>true if <var>file</var> exists and is readable by current process. </p> </dd> <dt>
<tt>-s</tt> <var>file</var>
</dt> <dd>
<p>true if <var>file</var> exists and has size greater than zero. </p> </dd> <dt>
<tt>-t</tt> <var>fd</var>
</dt> <dd>
<p>true if file descriptor number <var>fd</var> is open and associated with a terminal device. (note: <var>fd</var> is not optional) </p> </dd> <dt>
<tt>-u</tt> <var>file</var>
</dt> <dd>
<p>true if <var>file</var> exists and has its setuid bit set. </p> </dd> <dt>
<tt>-v</tt> <var>varname</var>
</dt> <dd>
<p>true if shell variable <var>varname</var> is set. </p> </dd> <dt>
<tt>-w</tt> <var>file</var>
</dt> <dd>
<p>true if <var>file</var> exists and is writable by current process. </p> </dd> <dt>
<tt>-x</tt> <var>file</var>
</dt> <dd>
<p>true if <var>file</var> exists and is executable by current process. If <var>file</var> exists and is a directory, then the current process has permission to search in the directory. </p> </dd> <dt>
<tt>-z</tt> <var>string</var>
</dt> <dd>
<p>true if length of <var>string</var> is zero. </p> </dd> <dt>
<tt>-L</tt> <var>file</var>
</dt> <dd>
<p>true if <var>file</var> exists and is a symbolic link. </p> </dd> <dt>
<tt>-O</tt> <var>file</var>
</dt> <dd>
<p>true if <var>file</var> exists and is owned by the effective user ID of this process. </p> </dd> <dt>
<tt>-G</tt> <var>file</var>
</dt> <dd>
<p>true if <var>file</var> exists and its group matches the effective group ID of this process. </p> </dd> <dt>
<tt>-S</tt> <var>file</var>
</dt> <dd>
<p>true if <var>file</var> exists and is a socket. </p> </dd> <dt>
<tt>-N</tt> <var>file</var>
</dt> <dd>
<p>true if <var>file</var> exists and its access time is not newer than its modification time. </p> </dd> <dt>
<var>file1</var> <tt>-nt</tt> <var>file2</var>
</dt> <dd>
<p>true if <var>file1</var> exists and is newer than <var>file2</var>. </p> </dd> <dt>
<var>file1</var> <tt>-ot</tt> <var>file2</var>
</dt> <dd>
<p>true if <var>file1</var> exists and is older than <var>file2</var>. </p> </dd> <dt>
<var>file1</var> <tt>-ef</tt> <var>file2</var>
</dt> <dd>
<p>true if <var>file1</var> and <var>file2</var> exist and refer to the same file. </p> </dd> <dt>
<var>string</var> <tt>=</tt> <var>pattern</var>
</dt> <dt>
<var>string</var> <tt>==</tt> <var>pattern</var>
</dt> <dd>
<p>true if <var>string</var> matches <var>pattern</var>. The two forms are exactly equivalent. The ‘<tt>=</tt>’ form is the traditional shell syntax (and hence the only one generally used with the <tt>test</tt> and <tt>[</tt> builtins); the ‘<tt>==</tt>’ form provides compatibility with other sorts of computer language. </p> </dd> <dt>
<var>string</var> <tt>!=</tt> <var>pattern</var>
</dt> <dd>
<p>true if <var>string</var> does not match <var>pattern</var>. </p> </dd> <dt>
<var>string</var> <tt>=~</tt> <var>regexp</var>
</dt> <dd>
<p>true if <var>string</var> matches the regular expression <var>regexp</var>. If the option <tt>RE_MATCH_PCRE</tt> is set <var>regexp</var> is tested as a PCRE regular expression using the <tt>zsh/pcre</tt> module, else it is tested as a POSIX extended regular expression using the <tt>zsh/regex</tt> module. Upon successful match, some variables will be updated; no variables are changed if the matching fails. </p> <p>If the option <tt>BASH_REMATCH</tt> is not set the scalar parameter <tt>MATCH</tt> is set to the substring that matched the pattern and the integer parameters <tt>MBEGIN</tt> and <tt>MEND</tt> to the index of the start and end, respectively, of the match in <var>string</var>, such that if <var>string</var> is contained in variable <tt>var</tt> the expression ‘<tt>${var[$MBEGIN,$MEND]}</tt>’ is identical to ‘<tt>$MATCH</tt>’. The setting of the option <tt>KSH_ARRAYS</tt> is respected. Likewise, the array <tt>match</tt> is set to the substrings that matched parenthesised subexpressions and the arrays <tt>mbegin</tt> and <tt>mend</tt> to the indices of the start and end positions, respectively, of the substrings within <var>string</var>. The arrays are not set if there were no parenthesised subexpressions. For example, if the string ‘<tt>a short string</tt>’ is matched against the regular expression ‘<tt>s(...)t</tt>’, then (assuming the option <tt>KSH_ARRAYS</tt> is not set) <tt>MATCH</tt>, <tt>MBEGIN</tt> and <tt>MEND</tt> are ‘<tt>short</tt>’, <tt>3</tt> and <tt>7</tt>, respectively, while <tt>match</tt>, <tt>mbegin</tt> and <tt>mend</tt> are single entry arrays containing the strings ‘<tt>hor</tt>’, ‘<tt>4</tt>’ and ‘<tt>6</tt>’, respectively. </p> <p>If the option <tt>BASH_REMATCH</tt> is set the array <tt>BASH_REMATCH</tt> is set to the substring that matched the pattern followed by the substrings that matched parenthesised subexpressions within the pattern. </p> </dd> <dt>
<var>string1</var> <tt>&lt;</tt> <var>string2</var>
</dt> <dd>
<p>true if <var>string1</var> comes before <var>string2</var> based on ASCII value of their characters. </p> </dd> <dt>
<var>string1</var> <tt>&gt;</tt> <var>string2</var>
</dt> <dd>
<p>true if <var>string1</var> comes after <var>string2</var> based on ASCII value of their characters. </p> </dd> <dt>
<var>exp1</var> <tt>-eq</tt> <var>exp2</var>
</dt> <dd>
<p>true if <var>exp1</var> is numerically equal to <var>exp2</var>. Note that for purely numeric comparisons use of the <tt>((</tt><var>...</var><tt>))</tt> builtin described in <a href="arithmetic-evaluation#Arithmetic-Evaluation">Arithmetic Evaluation</a> is more convenient than conditional expressions. </p> </dd> <dt>
<var>exp1</var> <tt>-ne</tt> <var>exp2</var>
</dt> <dd>
<p>true if <var>exp1</var> is numerically not equal to <var>exp2</var>. </p> </dd> <dt>
<var>exp1</var> <tt>-lt</tt> <var>exp2</var>
</dt> <dd>
<p>true if <var>exp1</var> is numerically less than <var>exp2</var>. </p> </dd> <dt>
<var>exp1</var> <tt>-gt</tt> <var>exp2</var>
</dt> <dd>
<p>true if <var>exp1</var> is numerically greater than <var>exp2</var>. </p> </dd> <dt>
<var>exp1</var> <tt>-le</tt> <var>exp2</var>
</dt> <dd>
<p>true if <var>exp1</var> is numerically less than or equal to <var>exp2</var>. </p> </dd> <dt>
<var>exp1</var> <tt>-ge</tt> <var>exp2</var>
</dt> <dd>
<p>true if <var>exp1</var> is numerically greater than or equal to <var>exp2</var>. </p> </dd> <dt>
<tt>(</tt> <var>exp</var> <tt>)</tt>
</dt> <dd>
<p>true if <var>exp</var> is true. </p> </dd> <dt>
<tt>!</tt> <var>exp</var>
</dt> <dd>
<p>true if <var>exp</var> is false. </p> </dd> <dt>
<var>exp1</var> <tt>&amp;&amp;</tt> <var>exp2</var>
</dt> <dd>
<p>true if <var>exp1</var> and <var>exp2</var> are both true. </p> </dd> <dt>
<var>exp1</var> <tt>||</tt> <var>exp2</var>
</dt> <dd>
<p>true if either <var>exp1</var> or <var>exp2</var> is true. </p> </dd> </dl> <p>For compatibility, if there is a single argument that is not syntactically significant, typically a variable, the condition is treated as a test for whether the expression expands as a string of non-zero length. In other words, <tt>[[ $var ]]</tt> is the same as <tt>[[ -n $var ]]</tt>. It is recommended that the second, explicit, form be used where possible. </p> <p>Normal shell expansion is performed on the <var>file</var>, <var>string</var> and <var>pattern</var> arguments, but the result of each expansion is constrained to be a single word, similar to the effect of double quotes. </p> <p>Filename generation is not performed on any form of argument to conditions. However, it can be forced in any case where normal shell expansion is valid and when the option <tt>EXTENDED_GLOB</tt> is in effect by using an explicit glob qualifier of the form <tt>(#q)</tt> at the end of the string. A normal glob qualifier expression may appear between the ‘<tt>q</tt>’ and the closing parenthesis; if none appears the expression has no effect beyond causing filename generation. The results of filename generation are joined together to form a single word, as with the results of other forms of expansion. </p> <p>This special use of filename generation is only available with the <tt>[[</tt> syntax. If the condition occurs within the <tt>[</tt> or <tt>test</tt> builtin commands then globbing occurs instead as part of normal command line expansion before the condition is evaluated. In this case it may generate multiple words which are likely to confuse the syntax of the test command. </p> <p>For example, </p> <div class="example"> <pre class="example">[[ -n file*(#qN) ]]
</pre>
</div> <p>produces status zero if and only if there is at least one file in the current directory beginning with the string ‘<tt>file</tt>’. The globbing qualifier <tt>N</tt> ensures that the expression is empty if there is no matching file. </p> <p>Pattern metacharacters are active for the <var>pattern</var> arguments; the patterns are the same as those used for filename generation, see <a href="expansion#Filename-Generation">Filename Generation</a>, but there is no special behaviour of ‘<tt>/</tt>’ nor initial dots, and no glob qualifiers are allowed. </p> <p>In each of the above expressions, if <var>file</var> is of the form ‘<tt>/dev/fd/</tt><var>n</var>’, where <var>n</var> is an integer, then the test applied to the open file whose descriptor number is <var>n</var>, even if the underlying system does not support the <tt>/dev/fd</tt> directory. </p> <p>In the forms which do numeric comparison, the expressions <var>exp</var> undergo arithmetic expansion as if they were enclosed in <tt>$((</tt><var>...</var><tt>))</tt>. </p> <p>For example, the following: </p> <div class="example"> <pre class="example">[[ ( -f foo || -f bar ) &amp;&amp; $report = y* ]] &amp;&amp; print File exists.
</pre>
</div> <p>tests if either file <tt>foo</tt> or file <tt>bar</tt> exists, and if so, if the value of the parameter <tt>report</tt> begins with ‘<tt>y</tt>’; if the complete condition is true, the message ‘<tt>File exists.</tt>’ is printed. </p>  <p> <font size="-1"> This document was generated on <i>May 14, 2022</i> using <a href="http://www.nongnu.org/texi2html/"><i>texi2html 5.0</i></a>. </font> <br> <font size="-1">Zsh version 5.9, released on May 14, 2022.</font> </p><div class="_attribution">
  <p class="_attribution-p">
         The Z Shell is copyright &copy; 1992&ndash;2017 Paul Falstad, Richard Coleman,Zoltán Hidvégi, Andrew Main, Peter Stephenson, Sven Wischnowsky, and others.<br />     Licensed under the MIT License.<br>
    <a href="https://zsh.sourceforge.io/Doc/Release/Conditional-Expressions.html" class="_attribution-link">https://zsh.sourceforge.io/Doc/Release/Conditional-Expressions.html</a>
  </p>
</div>
