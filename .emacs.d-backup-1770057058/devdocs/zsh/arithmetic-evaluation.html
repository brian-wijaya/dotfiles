   <h1 class="chapter">Arithmetic Evaluation</h1>    <p>The shell can perform integer and floating point arithmetic, either using the builtin <tt>let</tt>, or via a substitution of the form <tt>$((</tt><var>...</var><tt>))</tt>. For integers, the shell is usually compiled to use 8-byte precision where this is available, otherwise precision is 4 bytes. This can be tested, for example, by giving the command ‘<tt>print - $(( 12345678901 ))</tt>’; if the number appears unchanged, the precision is at least 8 bytes. Floating point arithmetic always uses the ‘double’ type with whatever corresponding precision is provided by the compiler and the library. </p> <p>The <tt>let</tt> builtin command takes arithmetic expressions as arguments; each is evaluated separately. Since many of the arithmetic operators, as well as spaces, require quoting, an alternative form is provided: for any command which begins with a ‘<tt>((</tt>’, all the characters until a matching ‘<tt>))</tt>’ are treated as a double-quoted expression and arithmetic expansion performed as for an argument of <tt>let</tt>. More precisely, ‘<tt>((</tt><var>...</var><tt>))</tt>’ is equivalent to ‘<tt>let "</tt><var>...</var><tt>"</tt>’. The return status is 0 if the arithmetic value of the expression is non-zero, 1 if it is zero, and 2 if an error occurred. </p> <p>For example, the following statement </p> <div class="example"> <pre class="example">(( val = 2 + 1 ))
</pre>
</div> <p>is equivalent to </p> <div class="example"> <pre class="example">let "val = 2 + 1"
</pre>
</div> <p>both assigning the value 3 to the shell variable <tt>val</tt> and returning a zero status. </p>   <p>Integers can be in bases other than 10. A leading ‘<tt>0x</tt>’ or ‘<tt>0X</tt>’ denotes hexadecimal and a leading ‘<tt>0b</tt>’ or ‘<tt>0B</tt>’ binary. Integers may also be of the form ‘<var>base</var><tt>#</tt><var>n</var>’, where <var>base</var> is a decimal number between two and thirty-six representing the arithmetic base and <var>n</var> is a number in that base (for example, ‘<tt>16#ff</tt>’ is 255 in hexadecimal). The <var>base</var><tt>#</tt> may also be omitted, in which case base 10 is used. For backwards compatibility the form ‘<tt>[</tt><var>base</var><tt>]</tt><var>n</var>’ is also accepted. </p> <p>An integer expression or a base given in the form ‘<var>base</var><tt>#</tt><var>n</var>’ may contain underscores (‘<tt>_</tt>’) after the leading digit for visual guidance; these are ignored in computation. Examples are <tt>1_000_000</tt> or <tt>0xffff_ffff</tt> which are equivalent to <tt>1000000</tt> and <tt>0xffffffff</tt> respectively. </p> <p>It is also possible to specify a base to be used for output in the form ‘<tt>[#</tt><var>base</var><tt>]</tt>’, for example ‘<tt>[#16]</tt>’. This is used when outputting arithmetical substitutions or when assigning to scalar parameters, but an explicitly defined integer or floating point parameter will not be affected. If an integer variable is implicitly defined by an arithmetic expression, any base specified in this way will be set as the variable’s output arithmetic base as if the option ‘<tt>-i</tt> <var>base</var>’ to the <tt>typeset</tt> builtin had been used. The expression has no precedence and if it occurs more than once in a mathematical expression, the last encountered is used. For clarity it is recommended that it appear at the beginning of an expression. As an example: </p> <div class="example"> <pre class="example">typeset -i 16 y
print $(( [#8] x = 32, y = 32 ))
print $x $y
</pre>
</div> <p>outputs first ‘<tt>8#40</tt>’, the rightmost value in the given output base, and then ‘<tt>8#40 16#20</tt>’, because <tt>y</tt> has been explicitly declared to have output base 16, while <tt>x</tt> (assuming it does not already exist) is implicitly typed by the arithmetic evaluation, where it acquires the output base 8. </p> <p>The <var>base</var> may be replaced or followed by an underscore, which may itself be followed by a positive integer (if it is missing the value 3 is used). This indicates that underscores should be inserted into the output string, grouping the number for visual clarity. The following integer specifies the number of digits to group together. For example: </p> <div class="example"> <pre class="example">setopt cbases
print $(( [#16_4] 65536 ** 2 ))
</pre>
</div> <p>outputs ‘<tt>0x1_0000_0000</tt>’. </p> <p>The feature can be used with floating point numbers, in which case the base must be omitted; grouping is away from the decimal point. For example, </p> <div class="example"> <pre class="example">zmodload zsh/mathfunc
print $(( [#_] sqrt(1e7) ))
</pre>
</div> <p>outputs ‘<tt>3_162.277_660_168_379_5</tt>’ (the number of decimal places shown may vary). </p>   <p>If the <tt>C_BASES</tt> option is set, hexadecimal numbers are output in the standard C format, for example ‘<tt>0xFF</tt>’ instead of the usual ‘<tt>16#FF</tt>’. If the option <tt>OCTAL_ZEROES</tt> is also set (it is not by default), octal numbers will be treated similarly and hence appear as ‘<tt>077</tt>’ instead of ‘<tt>8#77</tt>’. This option has no effect on the output of bases other than hexadecimal and octal, and these formats are always understood on input. </p> <p>When an output base is specified using the ‘<tt>[#</tt><var>base</var><tt>]</tt>’ syntax, an appropriate base prefix will be output if necessary, so that the value output is valid syntax for input. If the <tt>#</tt> is doubled, for example ‘<tt>[##16]</tt>’, then no base prefix is output. </p> <p>Floating point constants are recognized by the presence of a decimal point or an exponent. The decimal point may be the first character of the constant, but the exponent character <tt>e</tt> or <tt>E</tt> may not, as it will be taken for a parameter name. All numeric parts (before and after the decimal point and in the exponent) may contain underscores after the leading digit for visual guidance; these are ignored in computation. </p>   <p>An arithmetic expression uses nearly the same syntax and associativity of expressions as in C. </p> <p>In the native mode of operation, the following operators are supported (listed in decreasing order of precedence): </p> <dl compact> <dt><tt>+ - ! ~ ++ –</tt></dt> <dd><p>unary plus/minus, logical NOT, complement, {pre,post}{in,de}crement </p></dd> <dt><tt>&lt;&lt; &gt;&gt;</tt></dt> <dd><p>bitwise shift left, right </p></dd> <dt><tt>&amp;</tt></dt> <dd><p>bitwise AND </p></dd> <dt><tt>^</tt></dt> <dd><p>bitwise XOR </p></dd> <dt><tt>|</tt></dt> <dd><p>bitwise OR </p></dd> <dt><tt>**</tt></dt> <dd><p>exponentiation </p></dd> <dt><tt>* / %</tt></dt> <dd><p>multiplication, division, modulus (remainder) </p></dd> <dt><tt>+ -</tt></dt> <dd><p>addition, subtraction </p></dd> <dt><tt>&lt; &gt; &lt;= &gt;=</tt></dt> <dd><p>comparison </p></dd> <dt><tt>== !=</tt></dt> <dd><p>equality and inequality </p></dd> <dt><tt>&amp;&amp;</tt></dt> <dd><p>logical AND </p></dd> <dt><tt>|| ^^</tt></dt> <dd><p>logical OR, XOR </p></dd> <dt><tt>? :</tt></dt> <dd><p>ternary operator </p></dd> <dt><tt>= += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= &amp;&amp;= ||= ^^= **=</tt></dt> <dd><p>assignment </p></dd> <dt><tt>,</tt></dt> <dd><p>comma operator </p></dd> </dl> <p>The operators ‘<tt>&amp;&amp;</tt>’, ‘<tt>||</tt>’, ‘<tt>&amp;&amp;=</tt>’, and ‘<tt>||=</tt>’ are short-circuiting, and only one of the latter two expressions in a ternary operator is evaluated. Note the precedence of the bitwise AND, OR, and XOR operators. </p> <p>With the option <tt>C_PRECEDENCES</tt> the precedences (but no other properties) of the operators are altered to be the same as those in most other languages that support the relevant operators: </p> <dl compact> <dt><tt>+ - ! ~ ++ –</tt></dt> <dd><p>unary plus/minus, logical NOT, complement, {pre,post}{in,de}crement </p></dd> <dt><tt>**</tt></dt> <dd><p>exponentiation </p></dd> <dt><tt>* / %</tt></dt> <dd><p>multiplication, division, modulus (remainder) </p></dd> <dt><tt>+ -</tt></dt> <dd><p>addition, subtraction </p></dd> <dt><tt>&lt;&lt; &gt;&gt;</tt></dt> <dd><p>bitwise shift left, right </p></dd> <dt><tt>&lt; &gt; &lt;= &gt;=</tt></dt> <dd><p>comparison </p></dd> <dt><tt>== !=</tt></dt> <dd><p>equality and inequality </p></dd> <dt><tt>&amp;</tt></dt> <dd><p>bitwise AND </p></dd> <dt><tt>^</tt></dt> <dd><p>bitwise XOR </p></dd> <dt><tt>|</tt></dt> <dd><p>bitwise OR </p></dd> <dt><tt>&amp;&amp;</tt></dt> <dd><p>logical AND </p></dd> <dt><tt>^^</tt></dt> <dd><p>logical XOR </p></dd> <dt><tt>||</tt></dt> <dd><p>logical OR </p></dd> <dt><tt>? :</tt></dt> <dd><p>ternary operator </p></dd> <dt><tt>= += -= *= /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= &amp;&amp;= ||= ^^= **=</tt></dt> <dd><p>assignment </p></dd> <dt><tt>,</tt></dt> <dd><p>comma operator </p></dd> </dl> <p>Note the precedence of exponentiation in both cases is below that of unary operators, hence ‘<tt>-3**2</tt>’ evaluates as ‘<tt>9</tt>’, not ‘<tt>-9</tt>’. Use parentheses where necessary: ‘<tt>-(3**2)</tt>’. This is for compatibility with other shells. </p>   <p>Mathematical functions can be called with the syntax ‘<var>func</var><tt>(</tt><var>args</var><tt>)</tt>’, where the function decides if the <var>args</var> is used as a string or a comma-separated list of arithmetic expressions. The shell currently defines no mathematical functions by default, but the module <tt>zsh/mathfunc</tt> may be loaded with the <tt>zmodload</tt> builtin to provide standard floating point mathematical functions. </p> <p>An expression of the form ‘<tt>##</tt><var>x</var>’ where <var>x</var> is any character sequence such as ‘<tt>a</tt>’, ‘<tt>^A</tt>’, or ‘<tt>\M-\C-x</tt>’ gives the value of this character and an expression of the form ‘<tt>#</tt><var>name</var>’ gives the value of the first character of the contents of the parameter <var>name</var>. Character values are according to the character set used in the current locale; for multibyte character handling the option <tt>MULTIBYTE</tt> must be set. Note that this form is different from ‘<tt>$#</tt><var>name</var>’, a standard parameter substitution which gives the length of the parameter <var>name</var>. ‘<tt>#\</tt>’ is accepted instead of ‘<tt>##</tt>’, but its use is deprecated. </p> <p>Named parameters and subscripted arrays can be referenced by name within an arithmetic expression without using the parameter expansion syntax. For example, </p> <div class="example"> <pre class="example">((val2 = val1 * 2))
</pre>
</div> <p>assigns twice the value of <tt>$val1</tt> to the parameter named <tt>val2</tt>. </p> <p>An internal integer representation of a named parameter can be specified with the <tt>integer</tt> builtin.    Arithmetic evaluation is performed on the value of each assignment to a named parameter declared integer in this manner. Assigning a floating point number to an integer results in rounding towards zero. </p>    <p>Likewise, floating point numbers can be declared with the <tt>float</tt> builtin; there are two types, differing only in their output format, as described for the <tt>typeset</tt> builtin. The output format can be bypassed by using arithmetic substitution instead of the parameter substitution, i.e. ‘<tt>${</tt><var>float</var><tt>}</tt>’ uses the defined format, but ‘<tt>$((</tt><var>float</var><tt>))</tt>’ uses a generic floating point format. </p> <p>Promotion of integer to floating point values is performed where necessary. In addition, if any operator which requires an integer (‘<tt>&amp;</tt>’, ‘<tt>|</tt>’, ‘<tt>^</tt>’, ‘<tt>&lt;&lt;</tt>’, ‘<tt>&gt;&gt;</tt>’ and their equivalents with assignment) is given a floating point argument, it will be silently rounded towards zero except for ‘<tt>~</tt>’ which rounds down. </p> <p>Users should beware that, in common with many other programming languages but not software designed for calculation, the evaluation of an expression in zsh is taken a term at a time and promotion of integers to floating point does not occur in terms only containing integers. A typical result of this is that a division such as <tt>6/8</tt> is truncated, in this being rounded towards 0. The <tt>FORCE_FLOAT</tt> shell option can be used in scripts or functions where floating point evaluation is required throughout. </p> <p>Scalar variables can hold integer or floating point values at different times; there is no memory of the numeric type in this case. </p> <p>If a variable is first assigned in a numeric context without previously being declared, it will be implicitly typed as <tt>integer</tt> or <tt>float</tt> and retain that type either until the type is explicitly changed or until the end of the scope. This can have unforeseen consequences. For example, in the loop </p> <div class="example"> <pre class="example">for (( f = 0; f &lt; 1; f += 0.1 )); do
# use $f
done
</pre>
</div> <p>if <tt>f</tt> has not already been declared, the first assignment will cause it to be created as an integer, and consequently the operation ‘<tt>f += 0.1</tt>’ will always cause the result to be truncated to zero, so that the loop will fail. A simple fix would be to turn the initialization into ‘<tt>f = 0.0</tt>’. It is therefore best to declare numeric variables with explicit types. </p>  <p> <font size="-1"> This document was generated on <i>May 14, 2022</i> using <a href="http://www.nongnu.org/texi2html/"><i>texi2html 5.0</i></a>. </font> <br> <font size="-1">Zsh version 5.9, released on May 14, 2022.</font> </p><div class="_attribution">
  <p class="_attribution-p">
         The Z Shell is copyright &copy; 1992&ndash;2017 Paul Falstad, Richard Coleman,Zoltán Hidvégi, Andrew Main, Peter Stephenson, Sven Wischnowsky, and others.<br />     Licensed under the MIT License.<br>
    <a href="https://zsh.sourceforge.io/Doc/Release/Arithmetic-Evaluation.html" class="_attribution-link">https://zsh.sourceforge.io/Doc/Release/Arithmetic-Evaluation.html</a>
  </p>
</div>
