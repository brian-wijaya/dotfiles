<h2 id="worker-threads">Worker threads
</h2> 
<div class="api_stability api_stability_2">
<a href="https://nodejs.org/api/documentation.html#stability-index">Stability: 2</a> - Stable</div>
 <p><strong>Source Code:</strong> <a href="https://github.com/nodejs/node/blob/v25.0.0/lib/worker_threads.js">lib/worker_threads.js</a></p> <p>The <code>node:worker_threads</code> module enables the use of threads that execute JavaScript in parallel. To access it:</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import worker_threads from 'node:worker_threads';</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const worker_threads = require('node:worker_threads');</pre></details> <p>Workers (threads) are useful for performing CPU-intensive JavaScript operations. They do not help much with I/O-intensive work. The Node.js built-in asynchronous I/O operations are more efficient than Workers can be.</p> <p>Unlike <code>child_process</code> or <code>cluster</code>, <code>worker_threads</code> can share memory. They do so by transferring <code>ArrayBuffer</code> instances or sharing <code>SharedArrayBuffer</code> instances.</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import {
  Worker,
  isMainThread,
  parentPort,
  workerData,
} from 'node:worker_threads';

if (!isMainThread) {
  const { parse } = await import('some-js-parsing-library');
  const script = workerData;
  parentPort.postMessage(parse(script));
}

export default function parseJSAsync(script) {
  return new Promise((resolve, reject) =&gt; {
    const worker = new Worker(new URL(import.meta.url), {
      workerData: script,
    });
    worker.on('message', resolve);
    worker.on('error', reject);
    worker.on('exit', (code) =&gt; {
      if (code !== 0)
        reject(new Error(`Worker stopped with exit code ${code}`));
    });
  });
};</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const {
  Worker,
  isMainThread,
  parentPort,
  workerData,
} = require('node:worker_threads');

if (isMainThread) {
  module.exports = function parseJSAsync(script) {
    return new Promise((resolve, reject) =&gt; {
      const worker = new Worker(__filename, {
        workerData: script,
      });
      worker.on('message', resolve);
      worker.on('error', reject);
      worker.on('exit', (code) =&gt; {
        if (code !== 0)
          reject(new Error(`Worker stopped with exit code ${code}`));
      });
    });
  };
} else {
  const { parse } = require('some-js-parsing-library');
  const script = workerData;
  parentPort.postMessage(parse(script));
}</pre></details> <p>The above example spawns a Worker thread for each <code>parseJSAsync()</code> call. In practice, use a pool of Workers for these kinds of tasks. Otherwise, the overhead of creating Workers would likely exceed their benefit.</p> <p>When implementing a worker pool, use the <a href="async_hooks#class-asyncresource"><code>AsyncResource</code></a> API to inform diagnostic tools (e.g. to provide asynchronous stack traces) about the correlation between tasks and their outcomes. See <a href="async_context#using-asyncresource-for-a-worker-thread-pool">"Using <code>AsyncResource</code> for a <code>Worker</code> thread pool"</a> in the <code>async_hooks</code> documentation for an example implementation.</p> <p>Worker threads inherit non-process-specific options by default. Refer to <a href="#new-workerfilename-options"><code>Worker constructor options</code></a> to know how to customize worker thread options, specifically <code>argv</code> and <code>execArgv</code> options.</p> <section><h3 id="worker_threadsgetenvironmentdatakey">
<code>worker_threads.getEnvironmentData(key)</code>
</h3> <div class="api_metadata"> <details class="changelog"><summary>History</summary> <table> <tbody>
<tr>
<th>Version</th>
<th>Changes</th>
</tr> <tr>
<td>v17.5.0, v16.15.0</td> <td><p>No longer experimental.</p></td>
</tr> <tr>
<td>v15.12.0, v14.18.0</td> <td><p><span>Added in: v15.12.0, v14.18.0</span></p></td>
</tr> </tbody>
</table> </details> </div> <ul> <li>
<code>key</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" class="type">&lt;any&gt;</a> Any arbitrary, cloneable JavaScript value that can be used as a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" class="type">&lt;Map&gt;</a> key.</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" class="type">&lt;any&gt;</a>
</li> </ul> <p>Within a worker thread, <code>worker.getEnvironmentData()</code> returns a clone of data passed to the spawning thread's <code>worker.setEnvironmentData()</code>. Every new <code>Worker</code> receives its own copy of the environment data automatically.</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import {
  Worker,
  isMainThread,
  setEnvironmentData,
  getEnvironmentData,
} from 'node:worker_threads';

if (isMainThread) {
  setEnvironmentData('Hello', 'World!');
  const worker = new Worker(new URL(import.meta.url));
} else {
  console.log(getEnvironmentData('Hello'));  // Prints 'World!'.
}</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const {
  Worker,
  isMainThread,
  setEnvironmentData,
  getEnvironmentData,
} = require('node:worker_threads');

if (isMainThread) {
  setEnvironmentData('Hello', 'World!');
  const worker = new Worker(__filename);
} else {
  console.log(getEnvironmentData('Hello'));  // Prints 'World!'.
}</pre></details> </section><section><h3 id="worker_threadsisinternalthread">
<code>worker_threads.isInternalThread</code>
</h3> <div class="api_metadata"> <span>Added in: v23.7.0, v22.14.0</span> </div> <ul> <li>Type: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;boolean&gt;</a>
</li> </ul> <p>Is <code>true</code> if this code is running inside of an internal <a href="#class-worker"><code>Worker</code></a> thread (e.g the loader thread).</p> <pre data-language="js">node --experimental-loader ./loader.js main.js copy</pre> <details open><summary>JavaScript modules</summary><pre data-language="js">// loader.js
import { isInternalThread } from 'node:worker_threads';
console.log(isInternalThread);  // true</pre></details><details><summary>CommonJS</summary><pre data-language="js">// loader.js
'use strict';

const { isInternalThread } = require('node:worker_threads');
console.log(isInternalThread);  // true</pre></details> <details open><summary>JavaScript modules</summary><pre data-language="js">// main.js
import { isInternalThread } from 'node:worker_threads';
console.log(isInternalThread);  // false</pre></details><details><summary>CommonJS</summary><pre data-language="js">// main.js
'use strict';

const { isInternalThread } = require('node:worker_threads');
console.log(isInternalThread);  // false</pre></details> </section><section><h3 id="worker_threadsismainthread">
<code>worker_threads.isMainThread</code>
</h3> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <ul> <li>Type: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;boolean&gt;</a>
</li> </ul> <p>Is <code>true</code> if this code is not running inside of a <a href="#class-worker"><code>Worker</code></a> thread.</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import { Worker, isMainThread } from 'node:worker_threads';

if (isMainThread) {
  // This re-loads the current file inside a Worker instance.
  new Worker(new URL(import.meta.url));
} else {
  console.log('Inside Worker!');
  console.log(isMainThread);  // Prints 'false'.
}</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const { Worker, isMainThread } = require('node:worker_threads');

if (isMainThread) {
  // This re-loads the current file inside a Worker instance.
  new Worker(__filename);
} else {
  console.log('Inside Worker!');
  console.log(isMainThread);  // Prints 'false'.
}</pre></details> </section><section><h3 id="worker_threadsmarkasuntransferableobject">
<code>worker_threads.markAsUntransferable(object)</code>
</h3> <div class="api_metadata"> <span>Added in: v14.5.0, v12.19.0</span> </div> <ul> <li>
<code>object</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" class="type">&lt;any&gt;</a> Any arbitrary JavaScript value.</li> </ul> <p>Mark an object as not transferable. If <code>object</code> occurs in the transfer list of a <a href="#portpostmessagevalue-transferlist"><code>port.postMessage()</code></a> call, an error is thrown. This is a no-op if <code>object</code> is a primitive value.</p> <p>In particular, this makes sense for objects that can be cloned, rather than transferred, and which are used by other objects on the sending side. For example, Node.js marks the <code>ArrayBuffer</code>s it uses for its <a href="buffer#static-method-bufferallocunsafesize"><code>Buffer</code> pool</a> with this.</p> <p>This operation cannot be undone.</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import { MessageChannel, markAsUntransferable } from 'node:worker_threads';

const pooledBuffer = new ArrayBuffer(8);
const typedArray1 = new Uint8Array(pooledBuffer);
const typedArray2 = new Float64Array(pooledBuffer);

markAsUntransferable(pooledBuffer);

const { port1 } = new MessageChannel();
try {
  // This will throw an error, because pooledBuffer is not transferable.
  port1.postMessage(typedArray1, [ typedArray1.buffer ]);
} catch (error) {
  // error.name === 'DataCloneError'
}

// The following line prints the contents of typedArray1 -- it still owns
// its memory and has not been transferred. Without
// `markAsUntransferable()`, this would print an empty Uint8Array and the
// postMessage call would have succeeded.
// typedArray2 is intact as well.
console.log(typedArray1);
console.log(typedArray2);</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const { MessageChannel, markAsUntransferable } = require('node:worker_threads');

const pooledBuffer = new ArrayBuffer(8);
const typedArray1 = new Uint8Array(pooledBuffer);
const typedArray2 = new Float64Array(pooledBuffer);

markAsUntransferable(pooledBuffer);

const { port1 } = new MessageChannel();
try {
  // This will throw an error, because pooledBuffer is not transferable.
  port1.postMessage(typedArray1, [ typedArray1.buffer ]);
} catch (error) {
  // error.name === 'DataCloneError'
}

// The following line prints the contents of typedArray1 -- it still owns
// its memory and has not been transferred. Without
// `markAsUntransferable()`, this would print an empty Uint8Array and the
// postMessage call would have succeeded.
// typedArray2 is intact as well.
console.log(typedArray1);
console.log(typedArray2);</pre></details> <p>There is no equivalent to this API in browsers.</p> </section><section><h3 id="worker_threadsismarkedasuntransferableobject">
<code>worker_threads.isMarkedAsUntransferable(object)</code>
</h3> <div class="api_metadata"> <span>Added in: v21.0.0</span> </div> <ul> <li>
<code>object</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" class="type">&lt;any&gt;</a> Any JavaScript value.</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;boolean&gt;</a>
</li> </ul> <p>Check if an object is marked as not transferable with <a href="#worker_threadsmarkasuntransferableobject"><code>markAsUntransferable()</code></a>.</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import { markAsUntransferable, isMarkedAsUntransferable } from 'node:worker_threads';

const pooledBuffer = new ArrayBuffer(8);
markAsUntransferable(pooledBuffer);

isMarkedAsUntransferable(pooledBuffer);  // Returns true.</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const { markAsUntransferable, isMarkedAsUntransferable } = require('node:worker_threads');

const pooledBuffer = new ArrayBuffer(8);
markAsUntransferable(pooledBuffer);

isMarkedAsUntransferable(pooledBuffer);  // Returns true.</pre></details> <p>There is no equivalent to this API in browsers.</p> </section><section><h3 id="worker_threadsmarkasuncloneableobject">
<code>worker_threads.markAsUncloneable(object)</code>
</h3> <div class="api_metadata"> <span>Added in: v23.0.0, v22.10.0</span> </div> <ul> <li>
<code>object</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" class="type">&lt;any&gt;</a> Any arbitrary JavaScript value.</li> </ul> <p>Mark an object as not cloneable. If <code>object</code> is used as <a href="#event-message"><code>message</code></a> in a <a href="#portpostmessagevalue-transferlist"><code>port.postMessage()</code></a> call, an error is thrown. This is a no-op if <code>object</code> is a primitive value.</p> <p>This has no effect on <code>ArrayBuffer</code>, or any <code>Buffer</code> like objects.</p> <p>This operation cannot be undone.</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import { markAsUncloneable } from 'node:worker_threads';

const anyObject = { foo: 'bar' };
markAsUncloneable(anyObject);
const { port1 } = new MessageChannel();
try {
  // This will throw an error, because anyObject is not cloneable.
  port1.postMessage(anyObject);
} catch (error) {
  // error.name === 'DataCloneError'
}</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const { markAsUncloneable } = require('node:worker_threads');

const anyObject = { foo: 'bar' };
markAsUncloneable(anyObject);
const { port1 } = new MessageChannel();
try {
  // This will throw an error, because anyObject is not cloneable.
  port1.postMessage(anyObject);
} catch (error) {
  // error.name === 'DataCloneError'
}</pre></details> <p>There is no equivalent to this API in browsers.</p> </section><section><h3 id="worker_threadsmovemessageporttocontextport-contextifiedsandbox">
<code>worker_threads.moveMessagePortToContext(port, contextifiedSandbox)</code>
</h3> <div class="api_metadata"> <span>Added in: v11.13.0</span> </div> <ul> <li> <p><code>port</code> <a href="worker_threads#class-messageport" class="type">&lt;MessagePort&gt;</a> The message port to transfer.</p> </li> <li> <p><code>contextifiedSandbox</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a> A <a href="vm#what-does-it-mean-to-contextify-an-object">contextified</a> object as returned by the <code>vm.createContext()</code> method.</p> </li> <li> <p>Returns: <a href="worker_threads#class-messageport" class="type">&lt;MessagePort&gt;</a></p> </li> </ul> <p>Transfer a <code>MessagePort</code> to a different <a href="vm"><code>vm</code></a> Context. The original <code>port</code> object is rendered unusable, and the returned <code>MessagePort</code> instance takes its place.</p> <p>The returned <code>MessagePort</code> is an object in the target context and inherits from its global <code>Object</code> class. Objects passed to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/MessagePort/onmessage"><code>port.onmessage()</code></a> listener are also created in the target context and inherit from its global <code>Object</code> class.</p> <p>However, the created <code>MessagePort</code> no longer inherits from <a href="events#class-eventtarget" class="type">&lt;EventTarget&gt;</a>, and only <a href="https://developer.mozilla.org/en-US/docs/Web/API/MessagePort/onmessage"><code>port.onmessage()</code></a> can be used to receive events using it.</p> </section><section><h3 id="worker_threadsparentport">
<code>worker_threads.parentPort</code>
</h3> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <ul> <li>Type: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type" class="type">&lt;null&gt;</a> | <a href="worker_threads#class-messageport" class="type">&lt;MessagePort&gt;</a>
</li> </ul> <p>If this thread is a <a href="#class-worker"><code>Worker</code></a>, this is a <a href="#class-messageport"><code>MessagePort</code></a> allowing communication with the parent thread. Messages sent using <code>parentPort.postMessage()</code> are available in the parent thread using <code>worker.on('message')</code>, and messages sent from the parent thread using <code>worker.postMessage()</code> are available in this thread using <code>parentPort.on('message')</code>.</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import { Worker, isMainThread, parentPort } from 'node:worker_threads';

if (isMainThread) {
  const worker = new Worker(new URL(import.meta.url));
  worker.once('message', (message) =&gt; {
    console.log(message);  // Prints 'Hello, world!'.
  });
  worker.postMessage('Hello, world!');
} else {
  // When a message from the parent thread is received, send it back:
  parentPort.once('message', (message) =&gt; {
    parentPort.postMessage(message);
  });
}</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const { Worker, isMainThread, parentPort } = require('node:worker_threads');

if (isMainThread) {
  const worker = new Worker(__filename);
  worker.once('message', (message) =&gt; {
    console.log(message);  // Prints 'Hello, world!'.
  });
  worker.postMessage('Hello, world!');
} else {
  // When a message from the parent thread is received, send it back:
  parentPort.once('message', (message) =&gt; {
    parentPort.postMessage(message);
  });
}</pre></details> </section><section><h3 id="worker_threadspostmessagetothreadthreadid-value-transferlist-timeout">
<code>worker_threads.postMessageToThread(threadId, value[, transferList][, timeout])</code>
</h3> <div class="api_metadata"> <span>Added in: v22.5.0, v20.19.0</span> </div> 
<div class="api_stability api_stability_1">
<a href="https://nodejs.org/api/documentation.html#stability-index">Stability: 1.1</a> - Active development</div>
 <ul> <li>
<code>threadId</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;number&gt;</a> The target thread ID. If the thread ID is invalid, a <a href="errors#err_worker_messaging_failed"><code>ERR_WORKER_MESSAGING_FAILED</code></a> error will be thrown. If the target thread ID is the current thread ID, a <a href="errors#err_worker_messaging_same_thread"><code>ERR_WORKER_MESSAGING_SAME_THREAD</code></a> error will be thrown.</li> <li>
<code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" class="type">&lt;any&gt;</a> The value to send.</li> <li>
<code>transferList</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object[]&gt;</a> If one or more <code>MessagePort</code>-like objects are passed in <code>value</code>, a <code>transferList</code> is required for those items or <a href="errors#err_missing_message_port_in_transfer_list"><code>ERR_MISSING_MESSAGE_PORT_IN_TRANSFER_LIST</code></a> is thrown. See <a href="#portpostmessagevalue-transferlist"><code>port.postMessage()</code></a> for more information.</li> <li>
<code>timeout</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;number&gt;</a> Time to wait for the message to be delivered in milliseconds. By default it's <code>undefined</code>, which means wait forever. If the operation times out, a <a href="errors#err_worker_messaging_timeout"><code>ERR_WORKER_MESSAGING_TIMEOUT</code></a> error is thrown.</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" class="type">&lt;Promise&gt;</a> A promise which is fulfilled if the message was successfully processed by destination thread.</li> </ul> <p>Sends a value to another worker, identified by its thread ID.</p> <p>If the target thread has no listener for the <code>workerMessage</code> event, then the operation will throw a <a href="errors#err_worker_messaging_failed"><code>ERR_WORKER_MESSAGING_FAILED</code></a> error.</p> <p>If the target thread threw an error while processing the <code>workerMessage</code> event, then the operation will throw a <a href="errors#err_worker_messaging_errored"><code>ERR_WORKER_MESSAGING_ERRORED</code></a> error.</p> <p>This method should be used when the target thread is not the direct parent or child of the current thread. If the two threads are parent-children, use the <a href="#workerpostmessagevalue-transferlist"><code>require('node:worker_threads').parentPort.postMessage()</code></a> and the <a href="#workerpostmessagevalue-transferlist"><code>worker.postMessage()</code></a> to let the threads communicate.</p> <p>The example below shows the use of of <code>postMessageToThread</code>: it creates 10 nested threads, the last one will try to communicate with the main thread.</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import process from 'node:process';
import {
  postMessageToThread,
  threadId,
  workerData,
  Worker,
} from 'node:worker_threads';

const channel = new BroadcastChannel('sync');
const level = workerData?.level ?? 0;

if (level &lt; 10) {
  const worker = new Worker(new URL(import.meta.url), {
    workerData: { level: level + 1 },
  });
}

if (level === 0) {
  process.on('workerMessage', (value, source) =&gt; {
    console.log(`${source} -&gt; ${threadId}:`, value);
    postMessageToThread(source, { message: 'pong' });
  });
} else if (level === 10) {
  process.on('workerMessage', (value, source) =&gt; {
    console.log(`${source} -&gt; ${threadId}:`, value);
    channel.postMessage('done');
    channel.close();
  });

  await postMessageToThread(0, { message: 'ping' });
}

channel.onmessage = channel.close;</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const process = require('node:process');
const {
  postMessageToThread,
  threadId,
  workerData,
  Worker,
} = require('node:worker_threads');

const channel = new BroadcastChannel('sync');
const level = workerData?.level ?? 0;

if (level &lt; 10) {
  const worker = new Worker(__filename, {
    workerData: { level: level + 1 },
  });
}

if (level === 0) {
  process.on('workerMessage', (value, source) =&gt; {
    console.log(`${source} -&gt; ${threadId}:`, value);
    postMessageToThread(source, { message: 'pong' });
  });
} else if (level === 10) {
  process.on('workerMessage', (value, source) =&gt; {
    console.log(`${source} -&gt; ${threadId}:`, value);
    channel.postMessage('done');
    channel.close();
  });

  postMessageToThread(0, { message: 'ping' });
}

channel.onmessage = channel.close;</pre></details> </section><section><h3 id="worker_threadsreceivemessageonportport">
<code>worker_threads.receiveMessageOnPort(port)</code>
</h3> <div class="api_metadata"> <details class="changelog"><summary>History</summary> <table> <tbody>
<tr>
<th>Version</th>
<th>Changes</th>
</tr> <tr>
<td>v15.12.0</td> <td><p>The port argument can also refer to a <code>BroadcastChannel</code> now.</p></td>
</tr> <tr>
<td>v12.3.0</td> <td><p><span>Added in: v12.3.0</span></p></td>
</tr> </tbody>
</table> </details> </div> <ul> <li> <p><code>port</code> <a href="worker_threads#class-messageport" class="type">&lt;MessagePort&gt;</a> | <a href="worker_threads#class-broadcastchannel-extends-eventtarget" class="type">&lt;BroadcastChannel&gt;</a></p> </li> <li> <p>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type" class="type">&lt;undefined&gt;</a></p> </li> </ul> <p>Receive a single message from a given <code>MessagePort</code>. If no message is available, <code>undefined</code> is returned, otherwise an object with a single <code>message</code> property that contains the message payload, corresponding to the oldest message in the <code>MessagePort</code>'s queue.</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import { MessageChannel, receiveMessageOnPort } from 'node:worker_threads';
const { port1, port2 } = new MessageChannel();
port1.postMessage({ hello: 'world' });

console.log(receiveMessageOnPort(port2));
// Prints: { message: { hello: 'world' } }
console.log(receiveMessageOnPort(port2));
// Prints: undefined</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const { MessageChannel, receiveMessageOnPort } = require('node:worker_threads');
const { port1, port2 } = new MessageChannel();
port1.postMessage({ hello: 'world' });

console.log(receiveMessageOnPort(port2));
// Prints: { message: { hello: 'world' } }
console.log(receiveMessageOnPort(port2));
// Prints: undefined</pre></details> <p>When this function is used, no <code>'message'</code> event is emitted and the <code>onmessage</code> listener is not invoked.</p> </section><section><h3 id="worker_threadsresourcelimits">
<code>worker_threads.resourceLimits</code>
</h3> <div class="api_metadata"> <span>Added in: v13.2.0, v12.16.0</span> </div> <ul> <li>Type: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a> <ul> <li>
<code>maxYoungGenerationSizeMb</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;number&gt;</a>
</li> <li>
<code>maxOldGenerationSizeMb</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;number&gt;</a>
</li> <li>
<code>codeRangeSizeMb</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;number&gt;</a>
</li> <li>
<code>stackSizeMb</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;number&gt;</a>
</li> </ul> </li> </ul> <p>Provides the set of JS engine resource constraints inside this Worker thread. If the <code>resourceLimits</code> option was passed to the <a href="#class-worker"><code>Worker</code></a> constructor, this matches its values.</p> <p>If this is used in the main thread, its value is an empty object.</p> </section><section><h3 id="worker_threadsshare_env">
<code>worker_threads.SHARE_ENV</code>
</h3> <div class="api_metadata"> <span>Added in: v11.14.0</span> </div> <ul> <li>Type: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type" class="type">&lt;symbol&gt;</a>
</li> </ul> <p>A special value that can be passed as the <code>env</code> option of the <a href="#class-worker"><code>Worker</code></a> constructor, to indicate that the current thread and the Worker thread should share read and write access to the same set of environment variables.</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import process from 'node:process';
import { Worker, SHARE_ENV } from 'node:worker_threads';
new Worker('process.env.SET_IN_WORKER = "foo"', { eval: true, env: SHARE_ENV })
  .on('exit', () =&gt; {
    console.log(process.env.SET_IN_WORKER);  // Prints 'foo'.
  });</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const { Worker, SHARE_ENV } = require('node:worker_threads');
new Worker('process.env.SET_IN_WORKER = "foo"', { eval: true, env: SHARE_ENV })
  .on('exit', () =&gt; {
    console.log(process.env.SET_IN_WORKER);  // Prints 'foo'.
  });</pre></details> </section><section><h3 id="worker_threadssetenvironmentdatakey-value">
<code>worker_threads.setEnvironmentData(key[, value])</code>
</h3> <div class="api_metadata"> <details class="changelog"><summary>History</summary> <table> <tbody>
<tr>
<th>Version</th>
<th>Changes</th>
</tr> <tr>
<td>v17.5.0, v16.15.0</td> <td><p>No longer experimental.</p></td>
</tr> <tr>
<td>v15.12.0, v14.18.0</td> <td><p><span>Added in: v15.12.0, v14.18.0</span></p></td>
</tr> </tbody>
</table> </details> </div> <ul> <li>
<code>key</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" class="type">&lt;any&gt;</a> Any arbitrary, cloneable JavaScript value that can be used as a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" class="type">&lt;Map&gt;</a> key.</li> <li>
<code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" class="type">&lt;any&gt;</a> Any arbitrary, cloneable JavaScript value that will be cloned and passed automatically to all new <code>Worker</code> instances. If <code>value</code> is passed as <code>undefined</code>, any previously set value for the <code>key</code> will be deleted.</li> </ul> <p>The <code>worker.setEnvironmentData()</code> API sets the content of <code>worker.getEnvironmentData()</code> in the current thread and all new <code>Worker</code> instances spawned from the current context.</p> </section><section><h3 id="worker_threadsthreadid">
<code>worker_threads.threadId</code>
</h3> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <ul> <li>Type: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;integer&gt;</a>
</li> </ul> <p>An integer identifier for the current thread. On the corresponding worker object (if there is any), it is available as <a href="#workerthreadid"><code>worker.threadId</code></a>. This value is unique for each <a href="#class-worker"><code>Worker</code></a> instance inside a single process.</p> </section><section><h3 id="worker_threadsthreadname">
<code>worker_threads.threadName</code>
</h3> <div class="api_metadata"> <span>Added in: v24.6.0, v22.20.0</span> </div> <ul> <li>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type" class="type">&lt;null&gt;</a>
</li> </ul> <p>A string identifier for the current thread or null if the thread is not running. On the corresponding worker object (if there is any), it is available as <a href="#workerthreadname"><code>worker.threadName</code></a>.</p> </section><section><h3 id="worker_threadsworkerdata">
<code>worker_threads.workerData</code>
</h3> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <p>An arbitrary JavaScript value that contains a clone of the data passed to this thread's <code>Worker</code> constructor.</p> <p>The data is cloned as if using <a href="#portpostmessagevalue-transferlist"><code>postMessage()</code></a>, according to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm">HTML structured clone algorithm</a>.</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import { Worker, isMainThread, workerData } from 'node:worker_threads';

if (isMainThread) {
  const worker = new Worker(new URL(import.meta.url), { workerData: 'Hello, world!' });
} else {
  console.log(workerData);  // Prints 'Hello, world!'.
}</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const { Worker, isMainThread, workerData } = require('node:worker_threads');

if (isMainThread) {
  const worker = new Worker(__filename, { workerData: 'Hello, world!' });
} else {
  console.log(workerData);  // Prints 'Hello, world!'.
}</pre></details> </section><section><h3 id="worker_threadslocks">
<code>worker_threads.locks</code>
</h3> <div class="api_metadata"> <span>Added in: v24.5.0</span> </div> 
<div class="api_stability api_stability_1">
<a href="https://nodejs.org/api/documentation.html#stability-index">Stability: 1</a> - Experimental</div>
 <ul> <li><a href="worker_threads#class-lockmanager" class="type">&lt;LockManager&gt;</a></li> </ul> <p>An instance of a <a href="#class-lockmanager"><code>LockManager</code></a> that can be used to coordinate access to resources that may be shared across multiple threads within the same process. The API mirrors the semantics of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/LockManager">browser <code>LockManager</code></a></p> <div> <h4 id="class-lock">Class: <code>Lock</code>
</h4> <div class="api_metadata"> <span>Added in: v24.5.0</span> </div> <p>The <code>Lock</code> interface provides information about a lock that has been granted via <a href="#locksrequestname-options-callback"><code>locks.request()</code></a></p> <div> <h5 id="lockname">
<code>lock.name</code>
</h5> <div class="api_metadata"> <span>Added in: v24.5.0</span> </div> <ul> <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;string&gt;</a></li> </ul> <p>The name of the lock.</p> </div>
<div> <h5 id="lockmode">
<code>lock.mode</code>
</h5> <div class="api_metadata"> <span>Added in: v24.5.0</span> </div> <ul> <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;string&gt;</a></li> </ul> <p>The mode of the lock. Either <code>shared</code> or <code>exclusive</code>.</p> </div>
</div>
<div> <h4 id="class-lockmanager">Class: <code>LockManager</code>
</h4> <div class="api_metadata"> <span>Added in: v24.5.0</span> </div> <p>The <code>LockManager</code> interface provides methods for requesting and introspecting locks. To obtain a <code>LockManager</code> instance use</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import { locks } from 'node:worker_threads';</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const { locks } = require('node:worker_threads');</pre></details> <p>This implementation matches the <a href="https://developer.mozilla.org/en-US/docs/Web/API/LockManager">browser <code>LockManager</code></a> API.</p> <div> <h5 id="locksrequestname-options-callback">
<code>locks.request(name[, options], callback)</code>
</h5> <div class="api_metadata"> <span>Added in: v24.5.0</span> </div> <ul> <li>
<code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;string&gt;</a>
</li> <li>
<code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a> <ul> <li>
<code>mode</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;string&gt;</a> Either <code>'exclusive'</code> or <code>'shared'</code>. <strong>Default:</strong> <code>'exclusive'</code>.</li> <li>
<code>ifAvailable</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;boolean&gt;</a> If <code>true</code>, the request will only be granted if the lock is not already held. If it cannot be granted, <code>callback</code> will be invoked with <code>null</code> instead of a <code>Lock</code> instance. <strong>Default:</strong> <code>false</code>.</li> <li>
<code>steal</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;boolean&gt;</a> If <code>true</code>, any existing locks with the same name are released and the request is granted immediately, pre-empting any queued requests. <strong>Default:</strong> <code>false</code>.</li> <li>
<code>signal</code> <a href="globals#class-abortsignal" class="type">&lt;AbortSignal&gt;</a> that can be used to abort a pending (but not yet granted) lock request.</li> </ul> </li> <li>
<code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a> Invoked once the lock is granted (or immediately with <code>null</code> if <code>ifAvailable</code> is <code>true</code> and the lock is unavailable). The lock is released automatically when the function returns, or—if the function returns a promise—when that promise settles.</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" class="type">&lt;Promise&gt;</a> Resolves once the lock has been released.</li> </ul> <details open><summary>JavaScript modules</summary><pre data-language="js">import { locks } from 'node:worker_threads';

await locks.request('my_resource', async (lock) =&gt; {
  // The lock has been acquired.
});
// The lock has been released here.</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const { locks } = require('node:worker_threads');

locks.request('my_resource', async (lock) =&gt; {
  // The lock has been acquired.
}).then(() =&gt; {
  // The lock has been released here.
});</pre></details> </div>
<div> <h5 id="locksquery">
<code>locks.query()</code>
</h5> <div class="api_metadata"> <span>Added in: v24.5.0</span> </div> <ul> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" class="type">&lt;Promise&gt;</a>
</li> </ul> <p>Resolves with a <code>LockManagerSnapshot</code> describing the currently held and pending locks for the current process.</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import { locks } from 'node:worker_threads';

const snapshot = await locks.query();
for (const lock of snapshot.held) {
  console.log(`held lock: name ${lock.name}, mode ${lock.mode}`);
}
for (const pending of snapshot.pending) {
  console.log(`pending lock: name ${pending.name}, mode ${pending.mode}`);
}</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const { locks } = require('node:worker_threads');

locks.query().then((snapshot) =&gt; {
  for (const lock of snapshot.held) {
    console.log(`held lock: name ${lock.name}, mode ${lock.mode}`);
  }
  for (const pending of snapshot.pending) {
    console.log(`pending lock: name ${pending.name}, mode ${pending.mode}`);
  }
});</pre></details> </div>
</div> </section><section><h3 id="class-broadcastchannel-extends-eventtarget">Class: <code>BroadcastChannel extends EventTarget</code>
</h3> <div class="api_metadata"> <details class="changelog"><summary>History</summary> <table> <tbody>
<tr>
<th>Version</th>
<th>Changes</th>
</tr> <tr>
<td>v18.0.0</td> <td><p>No longer experimental.</p></td>
</tr> <tr>
<td>v15.4.0</td> <td><p><span>Added in: v15.4.0</span></p></td>
</tr> </tbody>
</table> </details> </div> <p>Instances of <code>BroadcastChannel</code> allow asynchronous one-to-many communication with all other <code>BroadcastChannel</code> instances bound to the same channel name.</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import {
  isMainThread,
  BroadcastChannel,
  Worker,
} from 'node:worker_threads';

const bc = new BroadcastChannel('hello');

if (isMainThread) {
  let c = 0;
  bc.onmessage = (event) =&gt; {
    console.log(event.data);
    if (++c === 10) bc.close();
  };
  for (let n = 0; n &lt; 10; n++)
    new Worker(new URL(import.meta.url));
} else {
  bc.postMessage('hello from every worker');
  bc.close();
}</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const {
  isMainThread,
  BroadcastChannel,
  Worker,
} = require('node:worker_threads');

const bc = new BroadcastChannel('hello');

if (isMainThread) {
  let c = 0;
  bc.onmessage = (event) =&gt; {
    console.log(event.data);
    if (++c === 10) bc.close();
  };
  for (let n = 0; n &lt; 10; n++)
    new Worker(__filename);
} else {
  bc.postMessage('hello from every worker');
  bc.close();
}</pre></details> <div> <h4 id="new-broadcastchannelname">
<code>new BroadcastChannel(name)</code>
</h4> <div class="api_metadata"> <span>Added in: v15.4.0</span> </div> <ul> <li>
<code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" class="type">&lt;any&gt;</a> The name of the channel to connect to. Any JavaScript value that can be converted to a string using <code>`${name}`</code> is permitted.</li> </ul> </div>
<div> <h4 id="broadcastchannelclose">
<code>broadcastChannel.close()</code>
</h4> <div class="api_metadata"> <span>Added in: v15.4.0</span> </div> <p>Closes the <code>BroadcastChannel</code> connection.</p> </div>
<div> <h4 id="broadcastchannelonmessage">
<code>broadcastChannel.onmessage</code>
</h4> <div class="api_metadata"> <span>Added in: v15.4.0</span> </div> <ul> <li>Type: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a> Invoked with a single <code>MessageEvent</code> argument when a message is received.</li> </ul> </div>
<div> <h4 id="broadcastchannelonmessageerror">
<code>broadcastChannel.onmessageerror</code>
</h4> <div class="api_metadata"> <span>Added in: v15.4.0</span> </div> <ul> <li>Type: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a> Invoked with a received message cannot be deserialized.</li> </ul> </div>
<div> <h4 id="broadcastchannelpostmessagemessage">
<code>broadcastChannel.postMessage(message)</code>
</h4> <div class="api_metadata"> <span>Added in: v15.4.0</span> </div> <ul> <li>
<code>message</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" class="type">&lt;any&gt;</a> Any cloneable JavaScript value.</li> </ul> </div>
<div> <h4 id="broadcastchannelref">
<code>broadcastChannel.ref()</code>
</h4> <div class="api_metadata"> <span>Added in: v15.4.0</span> </div> <p>Opposite of <code>unref()</code>. Calling <code>ref()</code> on a previously <code>unref()</code>ed BroadcastChannel does <em>not</em> let the program exit if it's the only active handle left (the default behavior). If the port is <code>ref()</code>ed, calling <code>ref()</code> again has no effect.</p> </div>
<div> <h4 id="broadcastchannelunref">
<code>broadcastChannel.unref()</code>
</h4> <div class="api_metadata"> <span>Added in: v15.4.0</span> </div> <p>Calling <code>unref()</code> on a BroadcastChannel allows the thread to exit if this is the only active handle in the event system. If the BroadcastChannel is already <code>unref()</code>ed calling <code>unref()</code> again has no effect.</p> </div> </section><section><h3 id="class-messagechannel">Class: <code>MessageChannel</code>
</h3> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <p>Instances of the <code>worker.MessageChannel</code> class represent an asynchronous, two-way communications channel. The <code>MessageChannel</code> has no methods of its own. <code>new MessageChannel()</code> yields an object with <code>port1</code> and <code>port2</code> properties, which refer to linked <a href="#class-messageport"><code>MessagePort</code></a> instances.</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import { MessageChannel } from 'node:worker_threads';

const { port1, port2 } = new MessageChannel();
port1.on('message', (message) =&gt; console.log('received', message));
port2.postMessage({ foo: 'bar' });
// Prints: received { foo: 'bar' } from the `port1.on('message')` listener</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const { MessageChannel } = require('node:worker_threads');

const { port1, port2 } = new MessageChannel();
port1.on('message', (message) =&gt; console.log('received', message));
port2.postMessage({ foo: 'bar' });
// Prints: received { foo: 'bar' } from the `port1.on('message')` listener</pre></details> </section><section><h3 id="class-messageport">Class: <code>MessagePort</code>
</h3> <div class="api_metadata"> <details class="changelog"><summary>History</summary> <table> <tbody>
<tr>
<th>Version</th>
<th>Changes</th>
</tr> <tr>
<td>v14.7.0</td> <td><p>This class now inherits from <code>EventTarget</code> rather than from <code>EventEmitter</code>.</p></td>
</tr> <tr>
<td>v10.5.0</td> <td><p><span>Added in: v10.5.0</span></p></td>
</tr> </tbody>
</table> </details> </div> <ul> <li>Extends: <a href="events#class-eventtarget" class="type">&lt;EventTarget&gt;</a>
</li> </ul> <p>Instances of the <code>worker.MessagePort</code> class represent one end of an asynchronous, two-way communications channel. It can be used to transfer structured data, memory regions and other <code>MessagePort</code>s between different <a href="#class-worker"><code>Worker</code></a>s.</p> <p>This implementation matches <a href="https://developer.mozilla.org/en-US/docs/Web/API/MessagePort">browser <code>MessagePort</code></a>s.</p> <div> <h4 id="event-close">Event: <code>'close'</code>
</h4> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <p>The <code>'close'</code> event is emitted once either side of the channel has been disconnected.</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import { MessageChannel } from 'node:worker_threads';
const { port1, port2 } = new MessageChannel();

// Prints:
//   foobar
//   closed!
port2.on('message', (message) =&gt; console.log(message));
port2.on('close', () =&gt; console.log('closed!'));

port1.postMessage('foobar');
port1.close();</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const { MessageChannel } = require('node:worker_threads');
const { port1, port2 } = new MessageChannel();

// Prints:
//   foobar
//   closed!
port2.on('message', (message) =&gt; console.log(message));
port2.on('close', () =&gt; console.log('closed!'));

port1.postMessage('foobar');
port1.close();</pre></details> </div>
<div> <h4 id="event-message">Event: <code>'message'</code>
</h4> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <ul> <li>
<code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" class="type">&lt;any&gt;</a> The transmitted value</li> </ul> <p>The <code>'message'</code> event is emitted for any incoming message, containing the cloned input of <a href="#portpostmessagevalue-transferlist"><code>port.postMessage()</code></a>.</p> <p>Listeners on this event receive a clone of the <code>value</code> parameter as passed to <code>postMessage()</code> and no further arguments.</p> </div>
<div> <h4 id="event-messageerror">Event: <code>'messageerror'</code>
</h4> <div class="api_metadata"> <span>Added in: v14.5.0, v12.19.0</span> </div> <ul> <li>
<code>error</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" class="type">&lt;Error&gt;</a> An Error object</li> </ul> <p>The <code>'messageerror'</code> event is emitted when deserializing a message failed.</p> <p>Currently, this event is emitted when there is an error occurring while instantiating the posted JS object on the receiving end. Such situations are rare, but can happen, for instance, when certain Node.js API objects are received in a <code>vm.Context</code> (where Node.js APIs are currently unavailable).</p> </div>
<div> <h4 id="portclose">
<code>port.close()</code>
</h4> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <p>Disables further sending of messages on either side of the connection. This method can be called when no further communication will happen over this <code>MessagePort</code>.</p> <p>The <a href="#event-close"><code>'close'</code> event</a> is emitted on both <code>MessagePort</code> instances that are part of the channel.</p> </div>
<div> <h4 id="portpostmessagevalue-transferlist">
<code>port.postMessage(value[, transferList])</code>
</h4> <div class="api_metadata"> <details class="changelog"><summary>History</summary> <table> <tbody>
<tr>
<th>Version</th>
<th>Changes</th>
</tr> <tr>
<td>v21.0.0</td> <td><p>An error is thrown when an untransferable object is in the transfer list.</p></td>
</tr> <tr>
<td>v15.6.0</td> <td><p>Added <code>X509Certificate</code> to the list of cloneable types.</p></td>
</tr> <tr>
<td>v15.0.0</td> <td><p>Added <code>CryptoKey</code> to the list of cloneable types.</p></td>
</tr> <tr>
<td>v15.14.0, v14.18.0</td> <td><p>Add 'BlockList' to the list of cloneable types.</p></td>
</tr> <tr>
<td>v15.9.0, v14.18.0</td> <td><p>Add 'Histogram' types to the list of cloneable types.</p></td>
</tr> <tr>
<td>v14.5.0, v12.19.0</td> <td><p>Added <code>KeyObject</code> to the list of cloneable types.</p></td>
</tr> <tr>
<td>v14.5.0, v12.19.0</td> <td><p>Added <code>FileHandle</code> to the list of transferable types.</p></td>
</tr> <tr>
<td>v10.5.0</td> <td><p><span>Added in: v10.5.0</span></p></td>
</tr> </tbody>
</table> </details> </div> <ul> <li>
<code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" class="type">&lt;any&gt;</a>
</li> <li>
<code>transferList</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object[]&gt;</a>
</li> </ul> <p>Sends a JavaScript value to the receiving side of this channel. <code>value</code> is transferred in a way which is compatible with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm">HTML structured clone algorithm</a>.</p> <p>In particular, the significant differences to <code>JSON</code> are:</p> <ul> <li>
<code>value</code> may contain circular references.</li> <li>
<code>value</code> may contain instances of builtin JS types such as <code>RegExp</code>s, <code>BigInt</code>s, <code>Map</code>s, <code>Set</code>s, etc.</li> <li>
<code>value</code> may contain typed arrays, both using <code>ArrayBuffer</code>s and <code>SharedArrayBuffer</code>s.</li> <li>
<code>value</code> may contain <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module"><code>WebAssembly.Module</code></a> instances.</li> <li>
<code>value</code> may not contain native (C++-backed) objects other than: <ul> <li>
<a href="webcrypto#class-cryptokey" class="type">&lt;CryptoKey&gt;</a>s,</li> <li>
<a href="fs#class-filehandle" class="type">&lt;FileHandle&gt;</a>s,</li> <li>
<a href="perf_hooks#class-histogram" class="type">&lt;Histogram&gt;</a>s,</li> <li>
<a href="crypto#class-keyobject" class="type">&lt;KeyObject&gt;</a>s,</li> <li>
<a href="worker_threads#class-messageport" class="type">&lt;MessagePort&gt;</a>s,</li> <li>
<a href="net#class-netblocklist" class="type">&lt;net.BlockList&gt;</a>s,</li> <li>
<a href="net#class-netsocketaddress" class="type">&lt;net.SocketAddress&gt;</a>es,</li> <li>
<a href="crypto#class-x509certificate" class="type">&lt;X509Certificate&gt;</a>s.</li> </ul> </li> </ul> <details open><summary>JavaScript modules</summary><pre data-language="js">import { MessageChannel } from 'node:worker_threads';
const { port1, port2 } = new MessageChannel();

port1.on('message', (message) =&gt; console.log(message));

const circularData = {};
circularData.foo = circularData;
// Prints: { foo: [Circular] }
port2.postMessage(circularData);</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const { MessageChannel } = require('node:worker_threads');
const { port1, port2 } = new MessageChannel();

port1.on('message', (message) =&gt; console.log(message));

const circularData = {};
circularData.foo = circularData;
// Prints: { foo: [Circular] }
port2.postMessage(circularData);</pre></details> <p><code>transferList</code> may be a list of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" class="type">&lt;ArrayBuffer&gt;</a>, <a href="#class-messageport"><code>MessagePort</code></a>, and <a href="fs#class-filehandle"><code>FileHandle</code></a> objects. After transferring, they are not usable on the sending side of the channel anymore (even if they are not contained in <code>value</code>). Unlike with <a href="child_process">child processes</a>, transferring handles such as network sockets is currently not supported.</p> <p>If <code>value</code> contains <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer" class="type">&lt;SharedArrayBuffer&gt;</a> instances, those are accessible from either thread. They cannot be listed in <code>transferList</code>.</p> <p><code>value</code> may still contain <code>ArrayBuffer</code> instances that are not in <code>transferList</code>; in that case, the underlying memory is copied rather than moved.</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import { MessageChannel } from 'node:worker_threads';
const { port1, port2 } = new MessageChannel();

port1.on('message', (message) =&gt; console.log(message));

const uint8Array = new Uint8Array([ 1, 2, 3, 4 ]);
// This posts a copy of `uint8Array`:
port2.postMessage(uint8Array);
// This does not copy data, but renders `uint8Array` unusable:
port2.postMessage(uint8Array, [ uint8Array.buffer ]);

// The memory for the `sharedUint8Array` is accessible from both the
// original and the copy received by `.on('message')`:
const sharedUint8Array = new Uint8Array(new SharedArrayBuffer(4));
port2.postMessage(sharedUint8Array);

// This transfers a freshly created message port to the receiver.
// This can be used, for example, to create communication channels between
// multiple `Worker` threads that are children of the same parent thread.
const otherChannel = new MessageChannel();
port2.postMessage({ port: otherChannel.port1 }, [ otherChannel.port1 ]);</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const { MessageChannel } = require('node:worker_threads');
const { port1, port2 } = new MessageChannel();

port1.on('message', (message) =&gt; console.log(message));

const uint8Array = new Uint8Array([ 1, 2, 3, 4 ]);
// This posts a copy of `uint8Array`:
port2.postMessage(uint8Array);
// This does not copy data, but renders `uint8Array` unusable:
port2.postMessage(uint8Array, [ uint8Array.buffer ]);

// The memory for the `sharedUint8Array` is accessible from both the
// original and the copy received by `.on('message')`:
const sharedUint8Array = new Uint8Array(new SharedArrayBuffer(4));
port2.postMessage(sharedUint8Array);

// This transfers a freshly created message port to the receiver.
// This can be used, for example, to create communication channels between
// multiple `Worker` threads that are children of the same parent thread.
const otherChannel = new MessageChannel();
port2.postMessage({ port: otherChannel.port1 }, [ otherChannel.port1 ]);</pre></details> <p>The message object is cloned immediately, and can be modified after posting without having side effects.</p> <p>For more information on the serialization and deserialization mechanisms behind this API, see the <a href="v8#serialization-api">serialization API of the <code>node:v8</code> module</a>.</p> <div> <h5 id="considerations-when-transferring-typedarrays-and-buffers">Considerations when transferring TypedArrays and Buffers
</h5> <p>All <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" class="type">&lt;TypedArray&gt;</a> | <a href="buffer#class-buffer" class="type">&lt;Buffer&gt;</a> instances are views over an underlying <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" class="type">&lt;ArrayBuffer&gt;</a>. That is, it is the <code>ArrayBuffer</code> that actually stores the raw data while the <code>TypedArray</code> and <code>Buffer</code> objects provide a way of viewing and manipulating the data. It is possible and common for multiple views to be created over the same <code>ArrayBuffer</code> instance. Great care must be taken when using a transfer list to transfer an <code>ArrayBuffer</code> as doing so causes all <code>TypedArray</code> and <code>Buffer</code> instances that share that same <code>ArrayBuffer</code> to become unusable.</p> <pre data-language="js">const ab = new ArrayBuffer(10);

const u1 = new Uint8Array(ab);
const u2 = new Uint16Array(ab);

console.log(u2.length);  // prints 5

port.postMessage(u1, [u1.buffer]);

console.log(u2.length);  // prints 0 copy</pre> <p>For <code>Buffer</code> instances, specifically, whether the underlying <code>ArrayBuffer</code> can be transferred or cloned depends entirely on how instances were created, which often cannot be reliably determined.</p> <p>An <code>ArrayBuffer</code> can be marked with <a href="#worker_threadsmarkasuntransferableobject"><code>markAsUntransferable()</code></a> to indicate that it should always be cloned and never transferred.</p> <p>Depending on how a <code>Buffer</code> instance was created, it may or may not own its underlying <code>ArrayBuffer</code>. An <code>ArrayBuffer</code> must not be transferred unless it is known that the <code>Buffer</code> instance owns it. In particular, for <code>Buffer</code>s created from the internal <code>Buffer</code> pool (using, for instance <code>Buffer.from()</code> or <code>Buffer.allocUnsafe()</code>), transferring them is not possible and they are always cloned, which sends a copy of the entire <code>Buffer</code> pool. This behavior may come with unintended higher memory usage and possible security concerns.</p> <p>See <a href="buffer#static-method-bufferallocunsafesize"><code>Buffer.allocUnsafe()</code></a> for more details on <code>Buffer</code> pooling.</p> <p>The <code>ArrayBuffer</code>s for <code>Buffer</code> instances created using <code>Buffer.alloc()</code> or <code>Buffer.allocUnsafeSlow()</code> can always be transferred but doing so renders all other existing views of those <code>ArrayBuffer</code>s unusable.</p> </div>
<div> <h5 id="considerations-when-cloning-objects-with-prototypes-classes-and-accessors">Considerations when cloning objects with prototypes, classes, and accessors
</h5> <p>Because object cloning uses the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm">HTML structured clone algorithm</a>, non-enumerable properties, property accessors, and object prototypes are not preserved. In particular, <a href="buffer#class-buffer" class="type">&lt;Buffer&gt;</a> objects will be read as plain <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" class="type">&lt;Uint8Array&gt;</a>s on the receiving side, and instances of JavaScript classes will be cloned as plain JavaScript objects.</p>  <pre data-language="js">const b = Symbol('b');

class Foo {
  #a = 1;
  constructor() {
    this[b] = 2;
    this.c = 3;
  }

  get d() { return 4; }
}

const { port1, port2 } = new MessageChannel();

port1.onmessage = ({ data }) =&gt; console.log(data);

port2.postMessage(new Foo());

// Prints: { c: 3 } copy</pre> <p>This limitation extends to many built-in objects, such as the global <code>URL</code> object:</p> <pre data-language="js">const { port1, port2 } = new MessageChannel();

port1.onmessage = ({ data }) =&gt; console.log(data);

port2.postMessage(new URL('https://example.org'));

// Prints: { } copy</pre> </div>
</div>
<div> <h4 id="porthasref">
<code>port.hasRef()</code>
</h4> <div class="api_metadata"> <details class="changelog"><summary>History</summary> <table> <tbody>
<tr>
<th>Version</th>
<th>Changes</th>
</tr> <tr>
<td>v24.0.0, v22.17.0</td> <td><p>Marking the API stable.</p></td>
</tr> <tr>
<td>v18.1.0, v16.17.0</td> <td><p><span>Added in: v18.1.0, v16.17.0</span></p></td>
</tr> </tbody>
</table> </details> </div> <ul> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;boolean&gt;</a>
</li> </ul> <p>If true, the <code>MessagePort</code> object will keep the Node.js event loop active.</p> </div>
<div> <h4 id="portref">
<code>port.ref()</code>
</h4> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <p>Opposite of <code>unref()</code>. Calling <code>ref()</code> on a previously <code>unref()</code>ed port does <em>not</em> let the program exit if it's the only active handle left (the default behavior). If the port is <code>ref()</code>ed, calling <code>ref()</code> again has no effect.</p> <p>If listeners are attached or removed using <code>.on('message')</code>, the port is <code>ref()</code>ed and <code>unref()</code>ed automatically depending on whether listeners for the event exist.</p> </div>
<div> <h4 id="portstart">
<code>port.start()</code>
</h4> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <p>Starts receiving messages on this <code>MessagePort</code>. When using this port as an event emitter, this is called automatically once <code>'message'</code> listeners are attached.</p> <p>This method exists for parity with the Web <code>MessagePort</code> API. In Node.js, it is only useful for ignoring messages when no event listener is present. Node.js also diverges in its handling of <code>.onmessage</code>. Setting it automatically calls <code>.start()</code>, but unsetting it lets messages queue up until a new handler is set or the port is discarded.</p> </div>
<div> <h4 id="portunref">
<code>port.unref()</code>
</h4> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <p>Calling <code>unref()</code> on a port allows the thread to exit if this is the only active handle in the event system. If the port is already <code>unref()</code>ed calling <code>unref()</code> again has no effect.</p> <p>If listeners are attached or removed using <code>.on('message')</code>, the port is <code>ref()</code>ed and <code>unref()</code>ed automatically depending on whether listeners for the event exist.</p> </div> </section><section><h3 id="class-worker">Class: <code>Worker</code>
</h3> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <ul> <li>Extends: <a href="events#class-eventemitter" class="type">&lt;EventEmitter&gt;</a>
</li> </ul> <p>The <code>Worker</code> class represents an independent JavaScript execution thread. Most Node.js APIs are available inside of it.</p> <p>Notable differences inside a Worker environment are:</p> <ul> <li>The <a href="process#processstdin"><code>process.stdin</code></a>, <a href="process#processstdout"><code>process.stdout</code></a>, and <a href="process#processstderr"><code>process.stderr</code></a> streams may be redirected by the parent thread.</li> <li>The <a href="#worker_threadsismainthread"><code>require('node:worker_threads').isMainThread</code></a> property is set to <code>false</code>.</li> <li>The <a href="#worker_threadsparentport"><code>require('node:worker_threads').parentPort</code></a> message port is available.</li> <li>
<a href="process#processexitcode"><code>process.exit()</code></a> does not stop the whole program, just the single thread, and <a href="process#processabort"><code>process.abort()</code></a> is not available.</li> <li>
<a href="process#processchdirdirectory"><code>process.chdir()</code></a> and <code>process</code> methods that set group or user ids are not available.</li> <li>
<a href="process#processenv"><code>process.env</code></a> is a copy of the parent thread's environment variables, unless otherwise specified. Changes to one copy are not visible in other threads, and are not visible to native add-ons (unless <a href="#worker_threadsshare_env"><code>worker.SHARE_ENV</code></a> is passed as the <code>env</code> option to the <a href="#class-worker"><code>Worker</code></a> constructor). On Windows, unlike the main thread, a copy of the environment variables operates in a case-sensitive manner.</li> <li>
<a href="process#processtitle"><code>process.title</code></a> cannot be modified.</li> <li>Signals are not delivered through <a href="process#signal-events"><code>process.on('...')</code></a>.</li> <li>Execution may stop at any point as a result of <a href="#workerterminate"><code>worker.terminate()</code></a> being invoked.</li> <li>IPC channels from parent processes are not accessible.</li> <li>The <a href="tracing"><code>trace_events</code></a> module is not supported.</li> <li>Native add-ons can only be loaded from multiple threads if they fulfill <a href="addons#worker-support">certain conditions</a>.</li> </ul> <p>Creating <code>Worker</code> instances inside of other <code>Worker</code>s is possible.</p> <p>Like <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">Web Workers</a> and the <a href="cluster"><code>node:cluster</code> module</a>, two-way communication can be achieved through inter-thread message passing. Internally, a <code>Worker</code> has a built-in pair of <a href="#class-messageport"><code>MessagePort</code></a>s that are already associated with each other when the <code>Worker</code> is created. While the <code>MessagePort</code> object on the parent side is not directly exposed, its functionalities are exposed through <a href="#workerpostmessagevalue-transferlist"><code>worker.postMessage()</code></a> and the <a href="#event-message_1"><code>worker.on('message')</code></a> event on the <code>Worker</code> object for the parent thread.</p> <p>To create custom messaging channels (which is encouraged over using the default global channel because it facilitates separation of concerns), users can create a <code>MessageChannel</code> object on either thread and pass one of the <code>MessagePort</code>s on that <code>MessageChannel</code> to the other thread through a pre-existing channel, such as the global one.</p> <p>See <a href="#portpostmessagevalue-transferlist"><code>port.postMessage()</code></a> for more information on how messages are passed, and what kind of JavaScript values can be successfully transported through the thread barrier.</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import assert from 'node:assert';
import {
  Worker, MessageChannel, MessagePort, isMainThread, parentPort,
} from 'node:worker_threads';
if (isMainThread) {
  const worker = new Worker(new URL(import.meta.url));
  const subChannel = new MessageChannel();
  worker.postMessage({ hereIsYourPort: subChannel.port1 }, [subChannel.port1]);
  subChannel.port2.on('message', (value) =&gt; {
    console.log('received:', value);
  });
} else {
  parentPort.once('message', (value) =&gt; {
    assert(value.hereIsYourPort instanceof MessagePort);
    value.hereIsYourPort.postMessage('the worker is sending this');
    value.hereIsYourPort.close();
  });
}</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const assert = require('node:assert');
const {
  Worker, MessageChannel, MessagePort, isMainThread, parentPort,
} = require('node:worker_threads');
if (isMainThread) {
  const worker = new Worker(__filename);
  const subChannel = new MessageChannel();
  worker.postMessage({ hereIsYourPort: subChannel.port1 }, [subChannel.port1]);
  subChannel.port2.on('message', (value) =&gt; {
    console.log('received:', value);
  });
} else {
  parentPort.once('message', (value) =&gt; {
    assert(value.hereIsYourPort instanceof MessagePort);
    value.hereIsYourPort.postMessage('the worker is sending this');
    value.hereIsYourPort.close();
  });
}</pre></details> <div> <h4 id="new-workerfilename-options">
<code>new Worker(filename[, options])</code>
</h4> <div class="api_metadata"> <details class="changelog"><summary>History</summary> <table> <tbody>
<tr>
<th>Version</th>
<th>Changes</th>
</tr> <tr>
<td>v19.8.0, v18.16.0</td> <td><p>Added support for a <code>name</code> option, which allows adding a name to worker title for debugging.</p></td>
</tr> <tr>
<td>v14.9.0</td> <td><p>The <code>filename</code> parameter can be a WHATWG <code>URL</code> object using <code>data:</code> protocol.</p></td>
</tr> <tr>
<td>v14.9.0</td> <td><p>The <code>trackUnmanagedFds</code> option was set to <code>true</code> by default.</p></td>
</tr> <tr>
<td>v14.6.0, v12.19.0</td> <td><p>The <code>trackUnmanagedFds</code> option was introduced.</p></td>
</tr> <tr>
<td>v13.13.0, v12.17.0</td> <td><p>The <code>transferList</code> option was introduced.</p></td>
</tr> <tr>
<td>v13.12.0, v12.17.0</td> <td><p>The <code>filename</code> parameter can be a WHATWG <code>URL</code> object using <code>file:</code> protocol.</p></td>
</tr> <tr>
<td>v13.4.0, v12.16.0</td> <td><p>The <code>argv</code> option was introduced.</p></td>
</tr> <tr>
<td>v13.2.0, v12.16.0</td> <td><p>The <code>resourceLimits</code> option was introduced.</p></td>
</tr> <tr>
<td>v10.5.0</td> <td><p><span>Added in: v10.5.0</span></p></td>
</tr> </tbody>
</table> </details> </div> <ul> <li>
<code>filename</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;string&gt;</a> | <a href="url#the-whatwg-url-api" class="type">&lt;URL&gt;</a> The path to the Worker's main script or module. Must be either an absolute path or a relative path (i.e. relative to the current working directory) starting with <code>./</code> or <code>../</code>, or a WHATWG <code>URL</code> object using <code>file:</code> or <code>data:</code> protocol. When using a <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs"><code>data:</code> URL</a>, the data is interpreted based on MIME type using the <a href="esm#data-imports">ECMAScript module loader</a>. If <code>options.eval</code> is <code>true</code>, this is a string containing JavaScript code rather than a path.</li> <li>
<code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a> <ul> <li>
<code>argv</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" class="type">&lt;any[]&gt;</a> List of arguments which would be stringified and appended to <code>process.argv</code> in the worker. This is mostly similar to the <code>workerData</code> but the values are available on the global <code>process.argv</code> as if they were passed as CLI options to the script.</li> <li>
<code>env</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a> If set, specifies the initial value of <code>process.env</code> inside the Worker thread. As a special value, <a href="#worker_threadsshare_env"><code>worker.SHARE_ENV</code></a> may be used to specify that the parent thread and the child thread should share their environment variables; in that case, changes to one thread's <code>process.env</code> object affect the other thread as well. <strong>Default:</strong> <code>process.env</code>.</li> <li>
<code>eval</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;boolean&gt;</a> If <code>true</code> and the first argument is a <code>string</code>, interpret the first argument to the constructor as a script that is executed once the worker is online.</li> <li>
<code>execArgv</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;string[]&gt;</a> List of node CLI options passed to the worker. V8 options (such as <code>--max-old-space-size</code>) and options that affect the process (such as <code>--title</code>) are not supported. If set, this is provided as <a href="process#processexecargv"><code>process.execArgv</code></a> inside the worker. By default, options are inherited from the parent thread.</li> <li>
<code>stdin</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;boolean&gt;</a> If this is set to <code>true</code>, then <code>worker.stdin</code> provides a writable stream whose contents appear as <code>process.stdin</code> inside the Worker. By default, no data is provided.</li> <li>
<code>stdout</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;boolean&gt;</a> If this is set to <code>true</code>, then <code>worker.stdout</code> is not automatically piped through to <code>process.stdout</code> in the parent.</li> <li>
<code>stderr</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;boolean&gt;</a> If this is set to <code>true</code>, then <code>worker.stderr</code> is not automatically piped through to <code>process.stderr</code> in the parent.</li> <li>
<code>workerData</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" class="type">&lt;any&gt;</a> Any JavaScript value that is cloned and made available as <a href="#worker_threadsworkerdata"><code>require('node:worker_threads').workerData</code></a>. The cloning occurs as described in the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm">HTML structured clone algorithm</a>, and an error is thrown if the object cannot be cloned (e.g. because it contains <code>function</code>s).</li> <li>
<code>trackUnmanagedFds</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;boolean&gt;</a> If this is set to <code>true</code>, then the Worker tracks raw file descriptors managed through <a href="fs#fsopenpath-flags-mode-callback"><code>fs.open()</code></a> and <a href="fs#fsclosefd-callback"><code>fs.close()</code></a>, and closes them when the Worker exits, similar to other resources like network sockets or file descriptors managed through the <a href="fs#class-filehandle"><code>FileHandle</code></a> API. This option is automatically inherited by all nested <code>Worker</code>s. <strong>Default:</strong> <code>true</code>.</li> <li>
<code>transferList</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object[]&gt;</a> If one or more <code>MessagePort</code>-like objects are passed in <code>workerData</code>, a <code>transferList</code> is required for those items or <a href="errors#err_missing_message_port_in_transfer_list"><code>ERR_MISSING_MESSAGE_PORT_IN_TRANSFER_LIST</code></a> is thrown. See <a href="#portpostmessagevalue-transferlist"><code>port.postMessage()</code></a> for more information.</li> <li>
<code>resourceLimits</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a> An optional set of resource limits for the new JS engine instance. Reaching these limits leads to termination of the <code>Worker</code> instance. These limits only affect the JS engine, and no external data, including no <code>ArrayBuffer</code>s. Even if these limits are set, the process may still abort if it encounters a global out-of-memory situation. <ul> <li>
<code>maxOldGenerationSizeMb</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;number&gt;</a> The maximum size of the main heap in MB. If the command-line argument <a href="cli#--max-old-space-sizesize-in-mib"><code>--max-old-space-size</code></a> is set, it overrides this setting.</li> <li>
<code>maxYoungGenerationSizeMb</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;number&gt;</a> The maximum size of a heap space for recently created objects. If the command-line argument <a href="cli#--max-semi-space-sizesize-in-mib"><code>--max-semi-space-size</code></a> is set, it overrides this setting.</li> <li>
<code>codeRangeSizeMb</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;number&gt;</a> The size of a pre-allocated memory range used for generated code.</li> <li>
<code>stackSizeMb</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;number&gt;</a> The default maximum stack size for the thread. Small values may lead to unusable Worker instances. <strong>Default:</strong> <code>4</code>.</li> </ul> </li> <li>
<code>name</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;string&gt;</a> An optional <code>name</code> to be replaced in the thread name and to the worker title for debugging/identification purposes, making the final title as <code>[worker ${id}] ${name}</code>. This parameter has a maximum allowed size, depending on the operating system. If the provided name exceeds the limit, it will be truncated <ul> <li>Maximum sizes: <ul> <li>Windows: 32,767 characters</li> <li>macOS: 64 characters</li> <li>Linux: 16 characters</li> <li>NetBSD: limited to <code>PTHREAD_MAX_NAMELEN_NP</code>
</li> <li>FreeBSD and OpenBSD: limited to <code>MAXCOMLEN</code> <strong>Default:</strong> <code>'WorkerThread'</code>.</li> </ul> </li> </ul> </li> </ul> </li> </ul> </div>
<div> <h4 id="event-error">Event: <code>'error'</code>
</h4> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <ul> <li>
<code>err</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" class="type">&lt;Error&gt;</a>
</li> </ul> <p>The <code>'error'</code> event is emitted if the worker thread throws an uncaught exception. In that case, the worker is terminated.</p> </div>
<div> <h4 id="event-exit">Event: <code>'exit'</code>
</h4> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <ul> <li>
<code>exitCode</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;integer&gt;</a>
</li> </ul> <p>The <code>'exit'</code> event is emitted once the worker has stopped. If the worker exited by calling <a href="process#processexitcode"><code>process.exit()</code></a>, the <code>exitCode</code> parameter is the passed exit code. If the worker was terminated, the <code>exitCode</code> parameter is <code>1</code>.</p> <p>This is the final event emitted by any <code>Worker</code> instance.</p> </div>
<div> <h4 id="event-message_1">Event: <code>'message'</code>
</h4> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <ul> <li>
<code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" class="type">&lt;any&gt;</a> The transmitted value</li> </ul> <p>The <code>'message'</code> event is emitted when the worker thread has invoked <a href="#workerpostmessagevalue-transferlist"><code>require('node:worker_threads').parentPort.postMessage()</code></a>. See the <a href="#event-message"><code>port.on('message')</code></a> event for more details.</p> <p>All messages sent from the worker thread are emitted before the <a href="#event-exit"><code>'exit'</code> event</a> is emitted on the <code>Worker</code> object.</p> </div>
<div> <h4 id="event-messageerror_1">Event: <code>'messageerror'</code>
</h4> <div class="api_metadata"> <span>Added in: v14.5.0, v12.19.0</span> </div> <ul> <li>
<code>error</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" class="type">&lt;Error&gt;</a> An Error object</li> </ul> <p>The <code>'messageerror'</code> event is emitted when deserializing a message failed.</p> </div>
<div> <h4 id="event-online">Event: <code>'online'</code>
</h4> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <p>The <code>'online'</code> event is emitted when the worker thread has started executing JavaScript code.</p> </div>
<div> <h4 id="workercpuusageprev">
<code>worker.cpuUsage([prev])</code>
</h4> <div class="api_metadata"> <span>Added in: v24.6.0, v22.19.0</span> </div> <ul> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" class="type">&lt;Promise&gt;</a>
</li> </ul> <p>This method returns a <code>Promise</code> that will resolve to an object identical to <a href="process#processthreadcpuusagepreviousvalue"><code>process.threadCpuUsage()</code></a>, or reject with an <a href="errors#err_worker_not_running"><code>ERR_WORKER_NOT_RUNNING</code></a> error if the worker is no longer running. This methods allows the statistics to be observed from outside the actual thread.</p> </div>
<div> <h4 id="workergetheapsnapshotoptions">
<code>worker.getHeapSnapshot([options])</code>
</h4> <div class="api_metadata"> <details class="changelog"><summary>History</summary> <table> <tbody>
<tr>
<th>Version</th>
<th>Changes</th>
</tr> <tr>
<td>v19.1.0</td> <td><p>Support options to configure the heap snapshot.</p></td>
</tr> <tr>
<td>v13.9.0, v12.17.0</td> <td><p><span>Added in: v13.9.0, v12.17.0</span></p></td>
</tr> </tbody>
</table> </details> </div> <ul> <li>
<code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a> <ul> <li>
<code>exposeInternals</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;boolean&gt;</a> If true, expose internals in the heap snapshot. <strong>Default:</strong> <code>false</code>.</li> <li>
<code>exposeNumericValues</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;boolean&gt;</a> If true, expose numeric values in artificial fields. <strong>Default:</strong> <code>false</code>.</li> </ul> </li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" class="type">&lt;Promise&gt;</a> A promise for a Readable Stream containing a V8 heap snapshot</li> </ul> <p>Returns a readable stream for a V8 snapshot of the current state of the Worker. See <a href="v8#v8getheapsnapshotoptions"><code>v8.getHeapSnapshot()</code></a> for more details.</p> <p>If the Worker thread is no longer running, which may occur before the <a href="#event-exit"><code>'exit'</code> event</a> is emitted, the returned <code>Promise</code> is rejected immediately with an <a href="errors#err_worker_not_running"><code>ERR_WORKER_NOT_RUNNING</code></a> error.</p> </div>
<div> <h4 id="workergetheapstatistics">
<code>worker.getHeapStatistics()</code>
</h4> <div class="api_metadata"> <span>Added in: v24.0.0, v22.16.0</span> </div> <ul> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" class="type">&lt;Promise&gt;</a>
</li> </ul> <p>This method returns a <code>Promise</code> that will resolve to an object identical to <a href="v8#v8getheapstatistics"><code>v8.getHeapStatistics()</code></a>, or reject with an <a href="errors#err_worker_not_running"><code>ERR_WORKER_NOT_RUNNING</code></a> error if the worker is no longer running. This methods allows the statistics to be observed from outside the actual thread.</p> </div>
<div> <h4 id="workerperformance">
<code>worker.performance</code>
</h4> <div class="api_metadata"> <span>Added in: v15.1.0, v14.17.0, v12.22.0</span> </div> <p>An object that can be used to query performance information from a worker instance. Similar to <a href="perf_hooks#perf_hooksperformance"><code>perf_hooks.performance</code></a>.</p> <div> <h5 id="performanceeventlooputilizationutilization1-utilization2">
<code>performance.eventLoopUtilization([utilization1[, utilization2]])</code>
</h5> <div class="api_metadata"> <span>Added in: v15.1.0, v14.17.0, v12.22.0</span> </div> <ul> <li>
<code>utilization1</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a> The result of a previous call to <code>eventLoopUtilization()</code>.</li> <li>
<code>utilization2</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a> The result of a previous call to <code>eventLoopUtilization()</code> prior to <code>utilization1</code>.</li> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a> <ul> <li>
<code>idle</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;number&gt;</a>
</li> <li>
<code>active</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;number&gt;</a>
</li> <li>
<code>utilization</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;number&gt;</a>
</li> </ul> </li> </ul> <p>The same call as <a href="perf_hooks#performanceeventlooputilizationutilization1-utilization2"><code>perf_hooks</code> <code>eventLoopUtilization()</code></a>, except the values of the worker instance are returned.</p> <p>One difference is that, unlike the main thread, bootstrapping within a worker is done within the event loop. So the event loop utilization is immediately available once the worker's script begins execution.</p> <p>An <code>idle</code> time that does not increase does not indicate that the worker is stuck in bootstrap. The following examples shows how the worker's entire lifetime never accumulates any <code>idle</code> time, but is still be able to process messages.</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import { Worker, isMainThread, parentPort } from 'node:worker_threads';

if (isMainThread) {
  const worker = new Worker(new URL(import.meta.url));
  setInterval(() =&gt; {
    worker.postMessage('hi');
    console.log(worker.performance.eventLoopUtilization());
  }, 100).unref();
} else {
  parentPort.on('message', () =&gt; console.log('msg')).unref();
  (function r(n) {
    if (--n &lt; 0) return;
    const t = Date.now();
    while (Date.now() - t &lt; 300);
    setImmediate(r, n);
  })(10);
}</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const { Worker, isMainThread, parentPort } = require('node:worker_threads');

if (isMainThread) {
  const worker = new Worker(__filename);
  setInterval(() =&gt; {
    worker.postMessage('hi');
    console.log(worker.performance.eventLoopUtilization());
  }, 100).unref();
} else {
  parentPort.on('message', () =&gt; console.log('msg')).unref();
  (function r(n) {
    if (--n &lt; 0) return;
    const t = Date.now();
    while (Date.now() - t &lt; 300);
    setImmediate(r, n);
  })(10);
}</pre></details> <p>The event loop utilization of a worker is available only after the <a href="#event-online"><code>'online'</code> event</a> emitted, and if called before this, or after the <a href="#event-exit"><code>'exit'</code> event</a>, then all properties have the value of <code>0</code>.</p> </div>
</div>
<div> <h4 id="workerpostmessagevalue-transferlist">
<code>worker.postMessage(value[, transferList])</code>
</h4> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <ul> <li>
<code>value</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types" class="type">&lt;any&gt;</a>
</li> <li>
<code>transferList</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object[]&gt;</a>
</li> </ul> <p>Send a message to the worker that is received via <a href="#event-message"><code>require('node:worker_threads').parentPort.on('message')</code></a>. See <a href="#portpostmessagevalue-transferlist"><code>port.postMessage()</code></a> for more details.</p> </div>
<div> <h4 id="workerref">
<code>worker.ref()</code>
</h4> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <p>Opposite of <code>unref()</code>, calling <code>ref()</code> on a previously <code>unref()</code>ed worker does <em>not</em> let the program exit if it's the only active handle left (the default behavior). If the worker is <code>ref()</code>ed, calling <code>ref()</code> again has no effect.</p> </div>
<div> <h4 id="workerresourcelimits">
<code>worker.resourceLimits</code>
</h4> <div class="api_metadata"> <span>Added in: v13.2.0, v12.16.0</span> </div> <ul> <li>Type: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a> <ul> <li>
<code>maxYoungGenerationSizeMb</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;number&gt;</a>
</li> <li>
<code>maxOldGenerationSizeMb</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;number&gt;</a>
</li> <li>
<code>codeRangeSizeMb</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;number&gt;</a>
</li> <li>
<code>stackSizeMb</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;number&gt;</a>
</li> </ul> </li> </ul> <p>Provides the set of JS engine resource constraints for this Worker thread. If the <code>resourceLimits</code> option was passed to the <a href="#class-worker"><code>Worker</code></a> constructor, this matches its values.</p> <p>If the worker has stopped, the return value is an empty object.</p> </div>
<div> <h4 id="workerstartcpuprofile">
<code>worker.startCpuProfile()</code>
</h4> <div class="api_metadata"> <span>Added in: v24.8.0</span> </div> <ul> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" class="type">&lt;Promise&gt;</a>
</li> </ul> <p>Starting a CPU profile then return a Promise that fulfills with an error or an <code>CPUProfileHandle</code> object. This API supports <code>await using</code> syntax.</p> <pre data-language="js">const { Worker } = require('node:worker_threads');

const worker = new Worker(`
  const { parentPort } = require('worker_threads');
  parentPort.on('message', () =&gt; {});
  `, { eval: true });

worker.on('online', async () =&gt; {
  const handle = await worker.startCpuProfile();
  const profile = await handle.stop();
  console.log(profile);
  worker.terminate();
}); copy</pre> <p><code>await using</code> example.</p> <pre data-language="js">const { Worker } = require('node:worker_threads');

const w = new Worker(`
  const { parentPort } = require('node:worker_threads');
  parentPort.on('message', () =&gt; {});
  `, { eval: true });

w.on('online', async () =&gt; {
  // Stop profile automatically when return and profile will be discarded
  await using handle = await w.startCpuProfile();
}); copy</pre> </div>
<div> <h4 id="workerstartheapprofile">
<code>worker.startHeapProfile()</code>
</h4> <div class="api_metadata"> <span>Added in: v24.9.0, v22.20.0</span> </div> <ul> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" class="type">&lt;Promise&gt;</a>
</li> </ul> <p>Starting a Heap profile then return a Promise that fulfills with an error or an <code>HeapProfileHandle</code> object. This API supports <code>await using</code> syntax.</p> <pre data-language="js">const { Worker } = require('node:worker_threads');

const worker = new Worker(`
  const { parentPort } = require('worker_threads');
  parentPort.on('message', () =&gt; {});
  `, { eval: true });

worker.on('online', async () =&gt; {
  const handle = await worker.startHeapProfile();
  const profile = await handle.stop();
  console.log(profile);
  worker.terminate();
}); copy</pre> <p><code>await using</code> example.</p> <pre data-language="js">const { Worker } = require('node:worker_threads');

const w = new Worker(`
  const { parentPort } = require('node:worker_threads');
  parentPort.on('message', () =&gt; {});
  `, { eval: true });

w.on('online', async () =&gt; {
  // Stop profile automatically when return and profile will be discarded
  await using handle = await w.startHeapProfile();
}); copy</pre> </div>
<div> <h4 id="workerstderr">
<code>worker.stderr</code>
</h4> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <ul> <li>Type: <a href="stream#class-streamreadable" class="type">&lt;stream.Readable&gt;</a>
</li> </ul> <p>This is a readable stream which contains data written to <a href="process#processstderr"><code>process.stderr</code></a> inside the worker thread. If <code>stderr: true</code> was not passed to the <a href="#class-worker"><code>Worker</code></a> constructor, then data is piped to the parent thread's <a href="process#processstderr"><code>process.stderr</code></a> stream.</p> </div>
<div> <h4 id="workerstdin">
<code>worker.stdin</code>
</h4> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <ul> <li>Type: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type" class="type">&lt;null&gt;</a> | <a href="stream#class-streamwritable" class="type">&lt;stream.Writable&gt;</a>
</li> </ul> <p>If <code>stdin: true</code> was passed to the <a href="#class-worker"><code>Worker</code></a> constructor, this is a writable stream. The data written to this stream will be made available in the worker thread as <a href="process#processstdin"><code>process.stdin</code></a>.</p> </div>
<div> <h4 id="workerstdout">
<code>worker.stdout</code>
</h4> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <ul> <li>Type: <a href="stream#class-streamreadable" class="type">&lt;stream.Readable&gt;</a>
</li> </ul> <p>This is a readable stream which contains data written to <a href="process#processstdout"><code>process.stdout</code></a> inside the worker thread. If <code>stdout: true</code> was not passed to the <a href="#class-worker"><code>Worker</code></a> constructor, then data is piped to the parent thread's <a href="process#processstdout"><code>process.stdout</code></a> stream.</p> </div>
<div> <h4 id="workerterminate">
<code>worker.terminate()</code>
</h4> <div class="api_metadata"> <details class="changelog"><summary>History</summary> <table> <tbody>
<tr>
<th>Version</th>
<th>Changes</th>
</tr> <tr>
<td>v12.5.0</td> <td><p>This function now returns a Promise. Passing a callback is deprecated, and was useless up to this version, as the Worker was actually terminated synchronously. Terminating is now a fully asynchronous operation.</p></td>
</tr> <tr>
<td>v10.5.0</td> <td><p><span>Added in: v10.5.0</span></p></td>
</tr> </tbody>
</table> </details> </div> <ul> <li>Returns: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" class="type">&lt;Promise&gt;</a>
</li> </ul> <p>Stop all JavaScript execution in the worker thread as soon as possible. Returns a Promise for the exit code that is fulfilled when the <a href="#event-exit"><code>'exit'</code> event</a> is emitted.</p> </div>
<div> <h4 id="workerthreadid">
<code>worker.threadId</code>
</h4> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <ul> <li>Type: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;integer&gt;</a>
</li> </ul> <p>An integer identifier for the referenced thread. Inside the worker thread, it is available as <a href="#worker_threadsthreadid"><code>require('node:worker_threads').threadId</code></a>. This value is unique for each <code>Worker</code> instance inside a single process.</p> </div>
<div> <h4 id="workerthreadname">
<code>worker.threadName</code>
</h4> <div class="api_metadata"> <span>Added in: v24.6.0, v22.20.0</span> </div> <ul> <li>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type" class="type">&lt;string&gt;</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type" class="type">&lt;null&gt;</a>
</li> </ul> <p>A string identifier for the referenced thread or null if the thread is not running. Inside the worker thread, it is available as <a href="#worker_threadsthreadname"><code>require('node:worker_threads').threadName</code></a>.</p> </div>
<div> <h4 id="workerunref">
<code>worker.unref()</code>
</h4> <div class="api_metadata"> <span>Added in: v10.5.0</span> </div> <p>Calling <code>unref()</code> on a worker allows the thread to exit if this is the only active handle in the event system. If the worker is already <code>unref()</code>ed calling <code>unref()</code> again has no effect.</p> </div>
<div> <h4 id="workersymbolasyncdispose">
<code>worker[Symbol.asyncDispose]()</code>
</h4> <div class="api_metadata"> <span>Added in: v24.2.0, v22.18.0</span> </div> <p>Calls <a href="#workerterminate"><code>worker.terminate()</code></a> when the dispose scope is exited.</p> <pre data-language="js">async function example() {
  await using worker = new Worker('for (;;) {}', { eval: true });
  // Worker is automatically terminate when the scope is exited.
} copy</pre> </div> </section><section><h3 id="notes">Notes
</h3> <div> <h4 id="synchronous-blocking-of-stdio">Synchronous blocking of stdio
</h4> <p><code>Worker</code>s utilize message passing via <a href="worker_threads#class-messageport" class="type">&lt;MessagePort&gt;</a> to implement interactions with <code>stdio</code>. This means that <code>stdio</code> output originating from a <code>Worker</code> can get blocked by synchronous code on the receiving end that is blocking the Node.js event loop.</p> <details open><summary>JavaScript modules</summary><pre data-language="js">import {
  Worker,
  isMainThread,
} from 'node:worker_threads';

if (isMainThread) {
  new Worker(new URL(import.meta.url));
  for (let n = 0; n &lt; 1e10; n++) {
    // Looping to simulate work.
  }
} else {
  // This output will be blocked by the for loop in the main thread.
  console.log('foo');
}</pre></details><details><summary>CommonJS</summary><pre data-language="js">'use strict';

const {
  Worker,
  isMainThread,
} = require('node:worker_threads');

if (isMainThread) {
  new Worker(__filename);
  for (let n = 0; n &lt; 1e10; n++) {
    // Looping to simulate work.
  }
} else {
  // This output will be blocked by the for loop in the main thread.
  console.log('foo');
}</pre></details> </div>
<div> <h4 id="launching-worker-threads-from-preload-scripts">Launching worker threads from preload scripts
</h4> <p>Take care when launching worker threads from preload scripts (scripts loaded and run using the <code>-r</code> command line flag). Unless the <code>execArgv</code> option is explicitly set, new Worker threads automatically inherit the command line flags from the running process and will preload the same preload scripts as the main thread. If the preload script unconditionally launches a worker thread, every thread spawned will spawn another until the application crashes.</p>
</div></section><div class="_attribution">
  <p class="_attribution-p">
    &copy; Joyent, Inc. and other Node contributors<br>Licensed under the MIT License.<br>Node.js is a trademark of Joyent, Inc. and is used with its permission.<br>We are not endorsed by or affiliated with Joyent.<br>
    <a href="https://nodejs.org/api/worker_threads.html" class="_attribution-link">https://nodejs.org/api/worker_threads.html</a>
  </p>
</div>
