<section id="kerberos-authentication"> <h1 id="windows-winrm-kerberos">Kerberos Authentication</h1> <p>Kerberos authentication is a modern method used in Windows environments for authentication. It allows both the client and server to verify each others identities and supports modern encryption methods like AES.</p>  <ul class="simple"> <li><a class="reference internal" href="#installing-kerberos" id="id1">Installing Kerberos</a></li> <li><a class="reference internal" href="#configuring-host-kerberos" id="id2">Configuring Host Kerberos</a></li> <li><a class="reference internal" href="#verifying-kerberos-configuration" id="id3">Verifying Kerberos Configuration</a></li> <li><a class="reference internal" href="#ticket-management" id="id4">Ticket Management</a></li> <li><a class="reference internal" href="#delegation" id="id5">Delegation</a></li> <li><a class="reference internal" href="#troubleshooting-kerberos" id="id6">Troubleshooting Kerberos</a></li> </ul>  <section id="installing-kerberos"> <h2>Installing Kerberos</h2> <p>Kerberos is provided through a GSSAPI library which is part of a system package. Some distributions install the Kerberos packages by default but others may require manual installation.</p> <p>To install the Kerberos libraries on a RHEL/Fedora based system:</p> <pre data-language="bash">$ sudo dnf install krb5-devel krb5-libs krb5-workstation python3-devel
</pre> <p>For a Debian/Ubuntu based system:</p> <pre data-language="bash">$ sudo apt-get install krb5-user libkrb5-dev python3-dev
</pre> <p>For an Arch Linux based system:</p> <pre data-language="bash">$ sudo pacman -S krb5
</pre> <p>For a FreeBSD based system:</p> <pre data-language="bash">$ sudo pkg install heimdal
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <code>python3-devel</code> / <code>python3-dev</code> packages can be ignored if using Kerberos with the <code>ssh</code> connection plugin. They are only needed if using a WinRM based connection with Kerberos authentication.</p> </div> <p>Once installed the <code>kinit</code>, <code>klist</code>, and <code>krb5-config</code> packages will be available. You can test them out with the following command:</p> <pre data-language="bash">$ krb5-config --version

Kerberos 5 release 1.21.3
</pre> <p>The <code>psrp</code> and <code>winrm</code> connection plugins require extra Python libraries for Kerberos authentication. The following step can be skipped if using Kerberos with the <code>ssh</code> connection.</p> <p>If you chose the <code>pipx</code> install instructions for Ansible, you can install those requirements by running the following:</p> <pre data-language="shell">pipx inject "pypsrp[kerberos]&lt;=1.0.0"  # for psrp
pipx inject "pywinrm[kerberos]&gt;=0.4.0"  # for winrm
</pre> <p>Or, if you chose the <code>pip</code> install instructions:</p> <pre data-language="shell">pip3 install "pypsrp[kerberos]&lt;=1.0.0"  # for psrp
pip3 install "pywinrm[kerberos]&gt;=0.4.0"  # for winrm
</pre> </section> <section id="configuring-host-kerberos"> <h2>Configuring Host Kerberos</h2> <p>Once the dependencies have been installed, Kerberos needs to be configured so that it can communicate with a domain. Most Kerberos implementations can either find a domain using DNS or through manual configuration in the <code>/etc/krb5.conf</code> file. For details on what can be set in the <code>/etc/krb5.conf</code> file see <a class="reference external" href="https://web.mit.edu/kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html">krb5.conf</a> for more details. A simple <code>krb5.conf</code> file that uses DNS to lookup the KDC would be:</p> <pre data-language="ini">[libdefaults]
    # Not required but helpful if the realm cannot be determined from
    # the hostname
    default_realm = MY.DOMAIN.COM

    # Enabled KDC lookups from DNS SRV records
    dns_lookup_kdc = true
</pre> <p>With the above configuration when a Kerberos ticket is requested for the server <code>server.my.domain.com</code> the Kerberos library will do an SRV lookup for <code>_kerberos._udp.my.domain.com</code> and <code>_kerberos._tcp.my.domain.com</code> to find the KDC. If you wish to manually set the KDC realms you can use the following configuration:</p> <pre data-language="ini">[libdefaults]
    default_realm = MY.DOMAIN.COM
    dns_lookup_kdc = false

[realms]
    MY.DOMAIN.COM = {
        kdc = domain-controller1.my.domain.com
        kdc = domain-controller2.my.domain.com
    }

[domain_realm]
    .my.domain.com = MY.DOMAIN.COM
    my.domain.com = MY.DOMAIN.COM
</pre> <p>With this configuration any request for a ticket with the DNS suffix <code>.my.domain.com</code> and <code>my.domain.com</code> itself will be sent to the KDC <code>domain-controller1.my.domain.com</code> with a fallback to <code>domain-controller2.my.domain.com</code>.</p> <p>More information on how the Kerberos library attempts to find the KDC can be found in the <a class="reference external" href="https://web.mit.edu/kerberos/krb5-latest/doc/admin/realm_config.html">MIT Kerberos Documentation</a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The information in this section assumes you are using the MIT Kerberos implementation which is typically the default on most Linux distributions. Some platforms like FreeBSD or macOS use a different GSSAPI implementation called Heimdal which acts in a similar way to MIT Kerberos but some behaviors may be different.</p> </div> </section> <section id="verifying-kerberos-configuration"> <h2 id="winrm-kerberos-verify-config">Verifying Kerberos Configuration</h2> <p>To verify that Kerberos is working correctly, you can use the <code>kinit</code> command to obtain a ticket for a user in the domain. The following command will request a ticket for the user <code>username</code> in the domain <code>MY.DOMAIN.COM</code>:</p> <pre data-language="bash">$ kinit username@MY.DOMAIN.COM
Password for username@REALM.COM
</pre> <p>If the password is correct, the command will return without any output. To verify that the ticket has been obtained, you can use the <code>klist</code> command:</p> <pre data-language="bash">&gt; klist
Ticket cache: KCM:1000
Default principal: username@MY.DOMAIN.COM

Valid starting     Expires            Service principal
29/08/24 13:54:51  29/08/24 23:54:51  krbtgt/MY.DOMAIN.COM@MY.DOMAIN.COM
        renew until 05/09/24 13:54:48
</pre> <p>If successful, this validates that the Kerberos configuration is correct and that the user can obtain a Ticket Granting Ticket (<code>TGT</code>) from the KDC. If <code>kinit</code> is unable to find the KDC for the requested realm, verify your Kerberos configuration by ensuring DNS can locate the KDC using the SRV records or that the KDC is manually mapped in the <code>krb5.conf</code>.</p> <p>On MIT Kerberos based systems, you can use the <code>kvno</code> command to verify that you are able to retrieve a service ticket for a particular service. For example, if you are using a WinRM based connection to authenticate with <code>server.my.domain.com</code> you can use the following command to verify that your TGT is able to get a service ticket for the target server:</p> <pre data-language="bash">$ kvno http/server.my.domain.com
http/server2025.domain.test@DOMAIN.TEST: kvno = 2
</pre> <p>The <code>klist</code> command can also be used to verify the ticket was stored in the Kerberos cache:</p> <pre data-language="bash">$ klist
Ticket cache: KCM:1000
Default principal: username@MY.DOMAIN.COM

Valid starting     Expires            Service principal
29/08/24 13:54:51  29/08/24 23:54:51  krbtgt/MY.DOMAIN.COM@MY.DOMAIN.COM
        renew until 05/09/24 13:54:48
29/08/24 13:55:30  29/08/24 23:55:30  http/server.my.domain.com@MY.DOMAIN.COM
        renew until 05/09/24 13:55:30
</pre> <p>In the above example we have the TGT stored under the <code>krbtgt</code> service principal and our <code>http/server.my.domain.com</code> under its own service principal.</p> <p>The <code>kdestroy</code> command can be used to remove the ticket cache.</p> </section> <section id="ticket-management"> <h2>Ticket Management</h2> <p>For Kerberos authentication to work with Ansible, a Kerberos TGT for a user must be present so that Ansible can request a service ticket for the target server. Some connection plugins like <code>ssh</code> require the TGT to already be present and accessible to the Ansible control process. Other connection plugins, like <code>psrp</code> and <code>winrm</code>, can automatically obtain a TGT for the user if the user’s password is provided in the inventory.</p> <p>To retrieve a TGT manually for a user, run the <code>kinit</code> command with the user’s username and domain as shown in <a class="reference internal" href="#winrm-kerberos-verify-config"><span class="std std-ref">Verifying Kerberos Configuration</span></a>. This TGT will be used automatically when Kerberos authentication is requested by the connection plugin in Ansible.</p> <p>If you are using the <code>psrp</code> or <code>winrm</code> connection plugin and the user’s password is provided in the inventory, the connection plugin will automatically obtain a TGT for the user. This is done by running the <code>kinit</code> command with the user’s username and password. The TGT will be stored in a temporary credential cache and will be used for the task.</p> </section> <section id="delegation"> <h2>Delegation</h2> <p>Kerberos delegation allows the credentials to traverse multiple hops. This is useful when you need to authenticate to a server and then have that server authenticate to another server on your behalf. To enable delegation, you must:</p> <ul class="simple"> <li>request a forwardable TGT when obtaining a ticket with <code>kinit</code>
</li> <li>request the connection plugin to allow delegation to the server</li> <li>the AD user is not marked as sensitive and cannot be delegated and is not a member of the <code>Protected Users</code> group</li> <li>depending on the <code>krb5.conf</code> configuration, the target server may need to allow unconstrained delegation through its AD object delegation settings</li> <li>the target resource to delegate to must be accessible with Kerberos authentication</li> </ul> <p>To request a forwardable TGT, either add the <code>-f</code> flag to the <code>kinit</code> command or set the <code>forwardable = true</code> option in the <code>[libdefaults]</code> section of the <code>krb5.conf</code> file. If you are using the <code>psrp</code> or <code>winrm</code> connection plugin to retrieve the TGT from the user’s password in the inventory, it will automatically request a forwardable TGT if the connection plugin is configured to use delegation.</p> <p>To have the connection plugin delegate the credentials it will need to set the following hostvar in the inventory:</p> <pre data-language="yaml+jinja"># psrp
ansible_psrp_negotiate_delegate: true

# winrm
ansible_winrm_kerberos_delegation: true

# ssh
ansible_ssh_common_args: -o GSSAPIDelegateCredentials=yes
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>It is also possible to set <code>GSSAPIDelegateCredentials yes</code> in the <code>~/.ssh/config</code> file to allow delegation for all SSH connections.</p> </div> <p>To verify if a user is allowed to delegate their credentials, you can run the following PowerShell script on a Windows host in the same domain:</p> <pre data-language="powershell">Function Test-IsDelegatable {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        [string]
        $UserName
    )

    $NOT_DELEGATED = 0x00100000

    $searcher = [ADSISearcher]"(&amp;(objectClass=user)(objectCategory=person)(sAMAccountName=$UserName))"
    $res = $searcher.FindOne()
    if (-not $res) {
        Write-Error -Message "Failed to find user '$UserName'"
    }
    else {
        $uac = $res.Properties.useraccountcontrol[0]
        $memberOf = @($res.Properties.memberof)

        $isSensitive = [bool]($uac -band $NOT_DELEGATED)
        $isProtectedUser = [bool]($memberOf -like 'CN=Protected Users,*').Count

        -not ($isSensitive -or $isProtectedUser)
    }
}

Test-IsDelegatable -UserName username
</pre> <p>Newer versions of MIT Kerberos have added a configuration option <code>enforce_ok_as_delegate</code> in the <code>[libdefaults]</code> section of the <code>krb5.conf</code> file. If this option is set to <code>true</code> delegation will only work if the target server account allows unconstrained delegation. To check or set unconstrained delegation on a Windows computer host, you can use the following PowerShell script:</p> <pre data-language="powershell"># Check if the server allows unconstrained delegation
(Get-ADComputer -Identity WINHOST -Properties TrustedForDelegation).TrustedForDelegation

# Enable unconstrained delegation
Set-ADComputer -Identity WINHOST -TrustedForDelegation $true
</pre> <p>To verify that delegation is working, you can use the <code>klist.exe</code> command on the Windows node to verify that the ticket has been forwarded. The output should show the ticket server is for <code>krbtgt/MY.DOMAIN.COM @ MY.CDOMAIN.COM</code> and the ticket flags contained <code>forwarded</code>.</p> <pre data-language="shell">$ ansible WINHOST -m ansible.windows.win_command -a C:/Windows/System32/klist.exe

WINHOST | CHANGED | rc=0 &gt;&gt;

Current LogonId is 0:0x82b6977

Cached Tickets: (1)

#0&gt;     Client: username @ MY.DOMAIN.COM
        Server: krbtgt/MY.DOMAIN.COM @ MY.DOMAIN.COM
        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96
        Ticket Flags 0x60a10000 -&gt; forwardable forwarded renewable pre_authent name_canonicalize
        Start Time: 8/30/2024 14:15:18 (local)
        End Time:   8/31/2024 0:12:49 (local)
        Renew Time: 9/6/2024 14:12:49 (local)
        Session Key Type: AES-256-CTS-HMAC-SHA1-96
        Cache Flags: 0x1 -&gt; PRIMARY
        Kdc Called:
</pre> <p>If anything goes wrong, the output for <code>klist.exe</code> will not have the <code>forwarded</code> flag and the server will be for the target server principal and not <code>krbtgt</code>.</p> <pre data-language="shell">$ ansible WINHOST -m ansible.windows.win_command -a C:/Windows/System32/klist.exe

WINHOST | CHANGED | rc=0 &gt;&gt;

Current LogonId is 0:0x82c312c

Cached Tickets: (1)

#0&gt;     Client: username @ MY.DOMAIN.COM
        Server: http/winhost.my.domain.com @ MY.DOMAIN.COM
        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96
        Ticket Flags 0x40a10000 -&gt; forwardable renewable pre_authent name_canonicalize
        Start Time: 8/30/2024 14:16:24 (local)
        End Time:   8/31/2024 0:16:12 (local)
        Renew Time: 0
        Session Key Type: AES-256-CTS-HMAC-SHA1-96
        Cache Flags: 0x8 -&gt; ASC
        Kdc Called:
</pre> <p>It is also important to ensure that the target resource to delegate to will work with Kerberos authentication. This means that the target server must have a Service Principal Name (<code>SPN</code>) registered in Active Directory (<code>AD</code>) and that the outbound authentication attempt on Windows uses the hostname and not an IP address/alias. For example, you should access a fileshare using the path <code>\\server.fqdn.com\share</code> and not <code>\\192.168.1.2\share</code>. To verify that an SPN is registered and the session Ansible runs under can delegate using Kerberos, you can use the following <code>klist.exe</code> command to request a service ticket for the target server.</p> <pre data-language="shell">$ ansible WINHOST -m ansible.windows.win_command -a 'C:/Windows/System32/klist.exe get cifs/fs.my.domain.com'

WINHOST | CHANGED | rc=0 &gt;&gt;

Current LogonId is 0:0x225639b
A ticket to cifs/fs.my.domain.com has been retrieved successfully.

Cached Tickets: (2)

...

#2&gt;     Client: username @ MY.DOMAIN.COM
        Server: cifs/fs.my.domain.com @ MY.DOMAIN.COM
        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96
        Ticket Flags 0x60a50000 -&gt; forwardable forwarded renewable pre_authent ok_as_delegate name_canonicalize
        Start Time: 8/30/2024 14:16:24 (local)
        End Time:   8/31/2024 0:16:12 (local)
        Renew Time: 0
        Session Key Type: AES-256-CTS-HMAC-SHA1-96
        Cache Flags: 0x8 -&gt; ASC
        Kdc Called: dc01.my.domain.com
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The SPN prefix for the target server depends on the service you are trying to access. The <code>cifs</code> service if used for file shares, <code>http</code> for web services, and so on. Make sure to use the correct prefix for testing our Kerberos delegation.</p> </div> </section> <section id="troubleshooting-kerberos"> <h2>Troubleshooting Kerberos</h2> <p>Kerberos is reliant on a properly configured environment to work. Some common issues that can cause Kerberos authentication to fail are:</p> <ul class="simple"> <li>The hostname set for the Windows host is an alias or an IP address</li> <li>The time on the Ansible control node is not synchronized with the AD domain controller</li> <li>The KDC realm is not set correctly in the <code>krb5.conf</code> file or cannot be resolved through DNS</li> </ul> <p>If using the MIT Kerberos implementation, you can set the environment variable <code>KRB5_TRACE=/dev/stdout</code> to get more detailed information on what the Kerberos library is doing. This can be useful for debugging issues with the Kerberos library such as the KDC lookup behavior, time sync issues, and server name lookup failures.</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2018 Michael DeHaan<br>&copy; 2018&ndash;2025 Red Hat, Inc.<br>Licensed under the GNU General Public License version 3.<br>
    <a href="https://docs.ansible.com/ansible/latest/os_guide/windows_winrm_kerberos.html" class="_attribution-link">https://docs.ansible.com/ansible/latest/os_guide/windows_winrm_kerberos.html</a>
  </p>
</div>
