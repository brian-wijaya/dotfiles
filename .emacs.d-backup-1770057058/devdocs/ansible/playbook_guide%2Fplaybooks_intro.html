<section id="ansible-playbooks"> <h1 id="about-playbooks">Ansible playbooks</h1> <p>Ansible Playbooks provide a repeatable, reusable, simple configuration management and multimachine deployment system that is well suited to deploying complex applications. If you need to execute a task with Ansible more than once, you can write a playbook and put the playbook under source control. You can then use the playbook to push new configurations or confirm the configuration of remote systems.</p> <p>Playbooks allow you to perform the following actions:</p> <ul class="simple"> <li>Declare configurations.</li> <li>Orchestrate steps of any manual ordered process on multiple sets of machines in a defined order.</li> <li>Launch tasks synchronously or <a class="reference internal" href="playbooks_async#playbooks-async"><span class="std std-ref">asynchronously</span></a>.</li> </ul>  <ul class="simple"> <li><a class="reference internal" href="#playbook-syntax" id="id3">Playbook syntax</a></li> <li>
<p><a class="reference internal" href="#playbook-execution" id="id4">Playbook execution</a></p> <ul> <li><a class="reference internal" href="#task-execution" id="id5">Task execution</a></li> <li><a class="reference internal" href="#desired-state-and-idempotency" id="id6">Desired state and idempotency</a></li> <li><a class="reference internal" href="#running-playbooks" id="id7">Running playbooks</a></li> <li><a class="reference internal" href="#running-playbooks-in-check-mode" id="id8">Running playbooks in check mode</a></li> </ul> </li> <li><a class="reference internal" href="#ansible-pull" id="id9">Ansible-Pull</a></li> <li>
<p><a class="reference internal" href="#verifying-playbooks" id="id10">Verifying playbooks</a></p> <ul> <li><a class="reference internal" href="#ansible-lint" id="id11">ansible-lint</a></li> </ul> </li> </ul>  <section id="playbook-syntax"> <h2 id="playbook-language-example">Playbook syntax</h2> <p>You express playbooks in YAML format with a minimum of syntax. If you are not familiar with YAML, review the <a class="reference internal" href="../reference_appendices/yamlsyntax#yaml-syntax"><span class="std std-ref">YAML Syntax</span></a> overview and consider installing an add-on for your text editor (see <a class="reference internal" href="https://docs.ansible.com/ansible/latest/community/other_tools_and_programs.html#other-tools-and-programs"><span class="std std-ref">Other Tools and Programs</span></a>) to help you write clean YAML syntax in your playbooks.</p> <p>A playbook consists of one or more ‘plays’ in an ordered list. The terms ‘playbook’ and ‘play’ are sports analogies. Each play executes part of the overall goal of the playbook, running one or more tasks. Each task calls an Ansible module.</p> </section> <section id="playbook-execution"> <h2>Playbook execution</h2> <p>A playbook runs in order from top to bottom. Within each play, tasks also run in order from top to bottom. Playbooks with multiple plays can orchestrate multimachine deployments, running one play on your webservers, another play on your database servers, and a third play on your network infrastructure. At a minimum, each play defines two things:</p> <ul class="simple"> <li>The managed nodes to target, using a <a class="reference internal" href="../inventory_guide/intro_patterns#intro-patterns"><span class="std std-ref">pattern</span></a>.</li> <li>At least one task to execute.</li> </ul> <p>For Ansible 2.10 and later, you should use the fully-qualified collection name (FQCN) in your playbooks. Using the FQCN ensures that you have selected the correct module, because multiple collections can contain modules with the same name. For example, <code>user</code>. See <a class="reference internal" href="../collections_guide/collections_using_playbooks#collections-using-playbook"><span class="std std-ref">Using collections in a playbook</span></a>.</p> <p>In the following example, the first play targets the web servers and the second play targets the database servers.</p> <pre data-language="yaml">---
- name: Update web servers
  hosts: webservers
  remote_user: root

  tasks:
  - name: Ensure apache is at the latest version
    ansible.builtin.yum:
      name: httpd
      state: latest

  - name: Write the apache config file
    ansible.builtin.template:
      src: /srv/httpd.j2
      dest: /etc/httpd.conf

- name: Update db servers
  hosts: databases
  remote_user: root

  tasks:
  - name: Ensure postgresql is at the latest version
    ansible.builtin.yum:
      name: postgresql
      state: latest

  - name: Ensure that postgresql is started
    ansible.builtin.service:
      name: postgresql
      state: started
</pre> <p>Your playbook can include more than just a hosts line and tasks. For example, the playbook above sets a <code>remote_user</code> for each play. The <code>remote_user</code> is the user account for the SSH connection. You can add other <a class="reference internal" href="../reference_appendices/playbooks_keywords#playbook-keywords"><span class="std std-ref">Playbook Keywords</span></a> at the playbook, play, or task level to influence how Ansible behaves. Playbook keywords can control the <a class="reference internal" href="../plugins/connection#connection-plugins"><span class="std std-ref">connection plugin</span></a>, whether to use <a class="reference internal" href="playbooks_privilege_escalation#become"><span class="std std-ref">privilege escalation</span></a>, how to handle errors, and more. To support a variety of environments, you can set many of these parameters as command-line flags in your Ansible configuration, or in your inventory. Learning the <a class="reference internal" href="../reference_appendices/general_precedence#general-precedence-rules"><span class="std std-ref">precedence rules</span></a> for these sources of data helps you as you expand your Ansible ecosystem.</p> <section id="task-execution"> <h3 id="tasks-list">Task execution</h3> <p>By default, Ansible executes each task in order, one at a time, against all machines matched by the host pattern. Each task executes a module with specific arguments. After a task has executed on all target machines, Ansible moves to the next task. You can use <a class="reference internal" href="playbooks_strategies#playbooks-strategies"><span class="std std-ref">strategies</span></a> to change this default behavior. Within each play, Ansible applies the same task directives to all hosts. If a task fails on a host, Ansible removes that host from the rotation for the rest of the playbook.</p> <p>When you run a playbook, Ansible returns information about connections, the <code>name</code> lines of all your plays and tasks, whether each task has succeeded or failed on each machine, and whether each task has made a change on each machine. At the bottom of the playbook execution, Ansible provides a summary of the nodes that were targeted and how they performed. General failures and fatal “unreachable” communication attempts are kept separate in the counts.</p> </section> <section id="desired-state-and-idempotency"> <h3 id="idempotency">Desired state and idempotency</h3> <p>Most Ansible modules check whether the desired final state has already been achieved and exit without performing any actions if that state has been achieved. Repeating the task does not change the final state. Modules that behave this way are ‘idempotent’. Whether you run a playbook once or multiple times, the outcome should be the same. However, not all playbooks and not all modules behave this way. If you are unsure, test your playbooks in a sandbox environment before running them multiple times in production.</p> </section> <section id="running-playbooks"> <h3 id="executing-a-playbook">Running playbooks</h3> <p>To run your playbook, use the <a class="reference internal" href="../cli/ansible-playbook#ansible-playbook"><span class="std std-ref">ansible-playbook</span></a> command.</p> <pre data-language="bash">ansible-playbook playbook.yml -f 10
</pre> <p>Use the <code>--verbose</code> flag when running your playbook to see detailed output from successful and unsuccessful tasks.</p> </section> <section id="running-playbooks-in-check-mode"> <h3>Running playbooks in check mode</h3> <p>The Ansible check mode allows you to execute a playbook without applying any alterations to your systems. You can use check mode to test playbooks before you implement them in a production environment.</p> <p>To run a playbook in check mode, pass the <code>-C</code> or <code>--check</code> flag to the <code>ansible-playbook</code> command:</p> <pre data-language="bash">ansible-playbook --check playbook.yaml
</pre> <p>Executing this command runs the playbook normally. Instead of implementing any modifications, Ansible provides a report on the changes it would have made. This report includes details such as file modifications, command execution, and module calls.</p> <p>Check mode offers a safe and practical approach to examine the functionality of your playbooks without risking unintended changes to your systems. Check mode is also a valuable tool for troubleshooting playbooks that are not functioning as expected.</p> </section> </section> <section id="ansible-pull"> <h2 id="playbook-ansible-pull">Ansible-Pull</h2> <p>You can invert the Ansible architecture so that nodes check in to a central location instead of you pushing configuration out to them.</p> <p>The <code>ansible-pull</code> command is a small script that checks out a repo of configuration instructions from git and then runs <code>ansible-playbook</code> against that content.</p> <p>If you load balance your checkout location, <code>ansible-pull</code> scales infinitely.</p> <p>Run <code>ansible-pull --help</code> for details.</p> </section> <section id="verifying-playbooks"> <h2>Verifying playbooks</h2> <p>You may want to verify your playbooks to catch syntax errors and other problems before you run them. The <a class="reference internal" href="../cli/ansible-playbook#ansible-playbook"><span class="std std-ref">ansible-playbook</span></a> command offers several options for verification, including <code>--check</code>, <code>--diff</code>, <code>--list-hosts</code>, <code>--list-tasks</code>, and <code>--syntax-check</code>. The <a class="reference internal" href="https://docs.ansible.com/ansible/latest/community/other_tools_and_programs.html#validate-playbook-tools"><span class="std std-ref">Tools for validating playbooks</span></a> topic describes other tools for validating and testing playbooks.</p> <section id="ansible-lint"> <h3 id="linting-playbooks">ansible-lint</h3> <p>You can use <a class="reference external" href="https://ansible.readthedocs.io/projects/lint/">ansible-lint</a> for detailed, Ansible-specific feedback on your playbooks before you execute them. For example, if you run <code>ansible-lint</code> on the playbook called <code>verify-apache.yml</code> near the top of this page, you should get the following results:</p> <pre data-language="bash">$ ansible-lint verify-apache.yml
[403] Package installs should not use latest
verify-apache.yml:8
Task/Handler: ensure apache is at the latest version
</pre> <p>The <a class="reference external" href="https://ansible.readthedocs.io/projects/lint/rules/">ansible-lint default rules</a> page describes each error.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference external" href="https://ansible.readthedocs.io/projects/lint/">ansible-lint</a></dt>
<dd>
<p>Learn how to test Ansible Playbooks syntax</p> </dd> <dt><a class="reference internal" href="../reference_appendices/yamlsyntax#yaml-syntax"><span class="std std-ref">YAML Syntax</span></a></dt>
<dd>
<p>Learn about YAML syntax</p> </dd> <dt><a class="reference internal" href="../tips_tricks/ansible_tips_tricks#tips-and-tricks"><span class="std std-ref">General tips</span></a></dt>
<dd>
<p>Tips for managing playbooks in the real world</p> </dd> <dt><a class="reference internal" href="../collections/index#list-of-collections"><span class="std std-ref">Collection Index</span></a></dt>
<dd>
<p>Browse existing collections, modules, and plugins</p> </dd> <dt><a class="reference internal" href="https://docs.ansible.com/ansible/latest/dev_guide/developing_modules.html#developing-modules"><span class="std std-ref">Should you develop a module?</span></a></dt>
<dd>
<p>Learn to extend Ansible by writing your own modules</p> </dd> <dt><a class="reference internal" href="../inventory_guide/intro_patterns#intro-patterns"><span class="std std-ref">Patterns: targeting hosts and groups</span></a></dt>
<dd>
<p>Learn about how to select hosts</p> </dd> <dt><a class="reference internal" href="https://docs.ansible.com/ansible/latest/community/communication.html#communication"><span class="std std-ref">Communication</span></a></dt>
<dd>
<p>Got questions? Need help? Want to share your ideas? Visit the Ansible communication guide</p> </dd> </dl> </div> </section> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2018 Michael DeHaan<br>&copy; 2018&ndash;2025 Red Hat, Inc.<br>Licensed under the GNU General Public License version 3.<br>
    <a href="https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_intro.html" class="_attribution-link">https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_intro.html</a>
  </p>
</div>
