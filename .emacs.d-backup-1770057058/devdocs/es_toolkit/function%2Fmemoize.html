<h1>memoize</h1>

<p>Caches function results so it runs faster when called again with the same arguments.</p>

<pre data-language='typescript'><code class='typescript'>const memoizedFunc = memoize(func, options);
</code></pre>

<h2>Usage</h2>

<h4><code>memoize(func, options?)</code></h4>

<p>Use <code>memoize</code> when you want to optimize performance by caching a function&#39;s execution results. When called again with the same arguments, it returns the cached result to avoid duplicate computations.</p>

<p>Use this with functions that take a single parameter. If your function takes multiple arguments, combine them into a single object or array.</p>

<p>If the argument is compared by reference, such as arrays or objects, you should provide a <code>getCacheKey</code> function to generate an appropriate cache key.</p>

<pre data-language='typescript'><code class='typescript'>import { memoize } from &#39;es-toolkit/function&#39;;

// Basic usage
const add = (x: number) =&gt; x + 10;
const memoizedAdd = memoize(add);

console.log(memoizedAdd(5)); // 15 (computed)
console.log(memoizedAdd(5)); // 15 (cached result)
console.log(memoizedAdd.cache.size); // 1

// Providing a cache key for array arguments
const sum = (arr: number[]) =&gt; arr.reduce((sum, n) =&gt; sum + n, 0);
const memoizedSum = memoize(sum, {
  getCacheKey: (arr: number[]) =&gt; arr.join(&#39;,&#39;),
});

console.log(memoizedSum([1, 2, 3])); // 6 (computed)
console.log(memoizedSum([1, 2, 3])); // 6 (cached result)
</code></pre>

<p>You can also use a custom cache.</p>

<pre data-language='typescript'><code class='typescript'>import { memoize, MemoizeCache } from &#39;es-toolkit/function&#39;;

class LRUCache&lt;K, V&gt; implements MemoizeCache&lt;K, V&gt; {
  private cache = new Map&lt;K, V&gt;();
  private maxSize = 100;

  set(key: K, value: V): void {
    if (this.cache.size &gt;= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }

  get(key: K): V | undefined {
    return this.cache.get(key);
  }

  has(key: K): boolean {
    return this.cache.has(key);
  }

  delete(key: K): boolean {
    return this.cache.delete(key);
  }

  clear(): void {
    this.cache.clear();
  }

  get size(): number {
    return this.cache.size;
  }
}

const customCache = new LRUCache&lt;string, number&gt;();
const memoizedWithCustomCache = memoize(expensiveFunction, {
  cache: customCache,
});
</code></pre>

<h4>Parameters</h4>

<ul>
<li><code>func</code> (<code>F</code>): The function to memoize. It must accept only one argument.</li>
<li><code>options</code> (object, optional): Memoization configuration options.

<ul>
<li><code>cache</code> (<code>MemoizeCache&lt;any, ReturnType&lt;F&gt;&gt;</code>, optional): The cache object to store results. Defaults to a new <code>Map</code>.</li>
<li><code>getCacheKey</code> (<code>(arg: Parameters&lt;F&gt;[0]) =&gt; unknown</code>, optional): A function to generate cache keys. Required when using non-primitive values as arguments.</li>
</ul></li>
</ul>

<h4>Returns</h4>

<p>(<code>F &amp; { cache: MemoizeCache&lt;any, ReturnType&lt;F&gt;&gt; }</code>): Returns the memoized function. It includes a <code>cache</code> property to access the internal cache.</p>
<div class="_attribution">
  <p class="_attribution-p">
          &copy; 2024-2025, Viva Republica<br>
      Licensed under the MIT License.

    <br>
    <a href="https://es-toolkit.slash.page/reference/function/memoize.html" class="_attribution-link">
      https://es-toolkit.slash.page/reference/function/memoize.html
    </a>
  </p>
</div>
