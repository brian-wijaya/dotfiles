<h1>cloneDeep</h1>

<p>Creates a deep copy of the given value.</p>

<pre data-language='typescript'><code class='typescript'>const deepCloned = cloneDeep(obj);
</code></pre>

<h2>Usage</h2>

<h4><code>cloneDeep(obj)</code></h4>

<p>Use <code>cloneDeep</code> when you want to completely copy an object or array, including all nested structures. A deep copy creates new copies of all nested objects and arrays, making the original and the copy completely independent.</p>

<pre data-language='typescript'><code class='typescript'>import { cloneDeep } from &#39;es-toolkit/object&#39;;

// Primitive values are returned as-is
const num = 29;
const clonedNum = cloneDeep(num);
console.log(clonedNum); // 29
console.log(clonedNum === num); // true

// Deep copy of nested objects
const obj = { a: { b: { c: &#39;deep&#39; } }, d: [1, 2, { e: &#39;nested&#39; }] };
const clonedObj = cloneDeep(obj);
console.log(clonedObj); // { a: { b: { c: &#39;deep&#39; } }, d: [1, 2, { e: &#39;nested&#39; }] }
console.log(clonedObj === obj); // false
console.log(clonedObj.a === obj.a); // false (nested objects are also copied)
console.log(clonedObj.d === obj.d); // false (nested arrays are also copied)
console.log(clonedObj.d[2] === obj.d[2]); // false (objects within arrays are also copied)

// Modifying the original doesn&#39;t affect the copy
const original = { a: { count: 1 } };
const copied = cloneDeep(original);
original.a.count = 2;
console.log(copied.a.count); // 1 (unchanged)
</code></pre>

<p>It supports various JavaScript types like <code>Map</code> and <code>Set</code>, and handles circular references safely.</p>

<pre data-language='typescript'><code class='typescript'>// Deep copy of Map and Set
const map = new Map([[&#39;key&#39;, { nested: &#39;value&#39; }]]);
const clonedMap = cloneDeep(map);
console.log(clonedMap !== map); // true
console.log(clonedMap.get(&#39;key&#39;) !== map.get(&#39;key&#39;)); // true (nested object is also copied)

// Handles circular references safely
const circular: any = { name: &#39;test&#39; };
circular.self = circular;
const clonedCircular = cloneDeep(circular);
console.log(clonedCircular !== circular); // true
console.log(clonedCircular.self === clonedCircular); // true (circular reference is maintained)
</code></pre>

<p>For read-only properties defined by getters, the return value of the getter is stored as a regular property in the copied object.</p>

<pre data-language='typescript'><code class='typescript'>const source = {
  get computedValue() {
    return 42;
  },
  normalValue: &#39;hello&#39;,
};

const cloned = cloneDeep(source);
console.log(cloned); // { computedValue: 42, normalValue: &#39;hello&#39; }
</code></pre>

<h4>Parameters</h4>

<ul>
<li><code>obj</code> (<code>T</code>): The value to deeply copy. It can be any type, such as objects, arrays, or primitive values.</li>
</ul>

<h4>Returns</h4>

<p>(<code>T</code>): A deep copy of the given value.</p>
<div class="_attribution">
  <p class="_attribution-p">
          &copy; 2024-2025, Viva Republica<br>
      Licensed under the MIT License.

    <br>
    <a href="https://es-toolkit.slash.page/reference/object/cloneDeep.html" class="_attribution-link">
      https://es-toolkit.slash.page/reference/object/cloneDeep.html
    </a>
  </p>
</div>
