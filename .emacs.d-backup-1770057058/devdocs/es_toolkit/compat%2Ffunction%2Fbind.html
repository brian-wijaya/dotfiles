<h1>bind (Lodash Compatibility)</h1>

<p>::: warning Use <code>Function.prototype.bind()</code></p>

<p>This <code>bind</code> function operates slowly due to complex placeholder handling, constructor function checking, and argument merging logic. If you don&#39;t need placeholders, the native <code>Function.prototype.bind()</code> is faster and simpler.</p>

<p>Use the faster and standard <code>Function.prototype.bind()</code> instead.</p>

<p>:::</p>

<p>Creates a function that fixes the <code>this</code> context and provides some arguments in advance.</p>

<pre data-language='typescript'><code class='typescript'>const boundFunction = bind(func, thisObj, ...partialArgs);
</code></pre>

<h2>Usage</h2>

<h4><code>bind(func, thisObj, ...partialArgs)</code></h4>

<p>Use <code>bind</code> when you want to fix the <code>this</code> context of a function or provide some arguments in advance. It&#39;s especially useful when you want to use placeholders to provide arguments at specific positions later.</p>

<pre data-language='typescript'><code class='typescript'>import { bind } from &#39;es-toolkit/compat&#39;;

// Basic usage
function greet(greeting, punctuation) {
  return greeting + &#39; &#39; + this.user + punctuation;
}

const object = { user: &#39;John&#39; };
const boundGreet = bind(greet, object, &#39;Hello&#39;);

console.log(boundGreet(&#39;!&#39;)); // &quot;Hello John!&quot;
console.log(boundGreet(&#39;~&#39;)); // &quot;Hello John~&quot;
</code></pre>

<p>Comparison with native bind:</p>

<pre data-language='typescript'><code class='typescript'>// Using bind
import { bind } from &#39;es-toolkit/compat&#39;;

const boundFn1 = bind(func, thisObj, &#39;arg1&#39;);

// Using native bind (faster)
const boundFn2 = func.bind(thisObj, &#39;arg1&#39;);

// Results are the same but native is faster
</code></pre>

<p>Using placeholder functionality:</p>

<pre data-language='typescript'><code class='typescript'>import { bind } from &#39;es-toolkit/compat&#39;;

function calculate(operation, a, b, suffix) {
  return `${a} ${operation} ${b} = ${operation === &#39;+&#39; ? a + b : a - b}${suffix}`;
}

// Provide arguments at specific positions later using placeholders
const calcWithSuffix = bind(
  calculate,
  null,
  bind.placeholder, // operation will be provided later
  bind.placeholder, // a will be provided later
  bind.placeholder, // b will be provided later
  &#39; points&#39; // suffix is provided in advance
);

console.log(calcWithSuffix(&#39;+&#39;, 5, 3)); // &quot;5 + 3 = 8 points&quot;
console.log(calcWithSuffix(&#39;-&#39;, 10, 4)); // &quot;10 - 4 = 6 points&quot;
</code></pre>

<p>More practical placeholder example:</p>

<pre data-language='typescript'><code class='typescript'>import { bind } from &#39;es-toolkit/compat&#39;;

function apiRequest(method, url, options, callback) {
  // API request logic
  console.log(`${method} ${url}`, options);
  callback(`${method} request complete`);
}

// Create a partially applied function for POST requests
const postRequest = bind(
  apiRequest,
  null,
  &#39;POST&#39;, // method fixed
  bind.placeholder, // url will be provided later
  { &#39;Content-Type&#39;: &#39;application/json&#39; }, // options fixed
  bind.placeholder // callback will be provided later
);

postRequest(&#39;/api/users&#39;, result =&gt; {
  console.log(result); // &quot;POST request complete&quot;
});

postRequest(&#39;/api/products&#39;, result =&gt; {
  console.log(result); // &quot;POST request complete&quot;
});
</code></pre>

<p>Method binding:</p>

<pre data-language='typescript'><code class='typescript'>import { bind } from &#39;es-toolkit/compat&#39;;

class Logger {
  constructor(prefix) {
    this.prefix = prefix;
  }

  log(level, message) {
    console.log(`[${this.prefix}] ${level}: ${message}`);
  }
}

const logger = new Logger(&#39;MyApp&#39;);

// Bind method to use in a different context
const logError = bind(logger.log, logger, &#39;ERROR&#39;);
const logInfo = bind(logger.log, logger, &#39;INFO&#39;);

// Now can be used independently
setTimeout(() =&gt; logError(&#39;Server connection failed&#39;), 1000);
setTimeout(() =&gt; logInfo(&#39;Application started&#39;), 2000);
</code></pre>

<p>Using in event handlers:</p>

<pre data-language='typescript'><code class='typescript'>import { bind } from &#39;es-toolkit/compat&#39;;

class ButtonHandler {
  constructor(name) {
    this.name = name;
    this.clickCount = 0;
  }

  handleClick(event, customData) {
    this.clickCount++;
    console.log(`${this.name} button clicked #${this.clickCount}`);
    console.log(&#39;Custom data:&#39;, customData);
    console.log(&#39;Event type:&#39;, event.type);
  }
}

const handler = new ButtonHandler(&#39;Menu&#39;);

// Provide custom data in advance, pass event later
const boundHandler = bind(
  handler.handleClick,
  handler,
  bind.placeholder, // event comes later
  &#39;Menu selected&#39; // customData provided in advance
);

// Connect to DOM event (event is automatically passed as first argument)
document.getElementById(&#39;menu-btn&#39;)?.addEventListener(&#39;click&#39;, boundHandler);
</code></pre>

<p>Constructor functions are also supported:</p>

<pre data-language='typescript'><code class='typescript'>import { bind } from &#39;es-toolkit/compat&#39;;

function Person(name, age, city) {
  this.name = name;
  this.age = age;
  this.city = city || &#39;Seoul&#39;;
}

// Constructor for creating Seoul residents
const SeoulPerson = bind(Person, null, bind.placeholder, bind.placeholder, &#39;Seoul&#39;);

const person1 = new SeoulPerson(&#39;John&#39;, 30);
const person2 = new SeoulPerson(&#39;Jane&#39;, 25);

console.log(person1); // Person { name: &#39;John&#39;, age: 30, city: &#39;Seoul&#39; }
console.log(person2); // Person { name: &#39;Jane&#39;, age: 25, city: &#39;Seoul&#39; }
</code></pre>

<p>Using in functional programming:</p>

<pre data-language='typescript'><code class='typescript'>import { bind } from &#39;es-toolkit/compat&#39;;

const numbers = [1, 2, 3, 4, 5];

// Fix parseInt radix to 10
const parseDecimal = bind(parseInt, null, bind.placeholder, 10);

// Safe to use in map
const parsed = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseDecimal);
console.log(parsed); // [1, 2, 3]

// Problem when using regular parseInt
const problematic = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt); // [1, NaN, NaN]
</code></pre>

<h4>Parameters</h4>

<ul>
<li><code>func</code> (<code>Function</code>): The function to bind.</li>
<li><code>thisObj</code> (<code>any</code>, optional): The <code>this</code> value to bind to the function.</li>
<li><code>partialArgs</code> (<code>...any[]</code>): The arguments to provide in advance. You can use <code>bind.placeholder</code> to specify positions to be provided later.</li>
</ul>

<h4>Returns</h4>

<p>(<code>Function</code>): Returns a new function with <code>this</code> fixed and some arguments applied in advance.</p>
<div class="_attribution">
  <p class="_attribution-p">
          &copy; 2024-2025, Viva Republica<br>
      Licensed under the MIT License.

    <br>
    <a href="https://es-toolkit.slash.page/reference/compat/function/bind.html" class="_attribution-link">
      https://es-toolkit.slash.page/reference/compat/function/bind.html
    </a>
  </p>
</div>
