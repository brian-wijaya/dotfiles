<h1>memoize (Lodash Compatibility)</h1>

<p>::: warning Use <code>es-toolkit</code>&#39;s <code>memoize</code>
This <code>memoize</code> function operates slowly due to <code>null</code> checks in the <code>resolver</code> function, complex type handling for the <code>MapCache</code> interface, and additional overhead for Lodash compatibility.</p>

<p>Instead, use the faster and more modern <code>es-toolkit</code>&#39;s <span>memoize</span>.
:::</p>

<p>Caches function results to improve performance when called with the same arguments.</p>

<pre data-language='typescript'><code class='typescript'>const memoizedFunc = memoize(func, resolver);
</code></pre>

<h2>Usage</h2>

<h4><code>memoize(func, resolver)</code></h4>

<p>Use <code>memoize</code> when you want to memoize function results to reuse previous results when called with the same arguments. It&#39;s useful for expensive calculations or API calls.</p>

<pre data-language='typescript'><code class='typescript'>import { memoize } from &#39;es-toolkit/compat&#39;;

// Basic usage
function expensiveCalculation(n) {
  console.log(&#39;Calculating...&#39;, n);
  return n * n;
}

const memoizedCalc = memoize(expensiveCalculation);

console.log(memoizedCalc(5)); // &#39;Calculating... 5&#39;, 25
console.log(memoizedCalc(5)); // 25 (cached result, no calculation)
console.log(memoizedCalc(10)); // &#39;Calculating... 10&#39;, 100

// Using custom resolver
function fetchUserData(userId, includeProfile) {
  console.log(&#39;Fetching user data...&#39;, userId, includeProfile);
  return { id: userId, profile: includeProfile ? &#39;Profile data&#39; : null };
}

// Generate cache key considering all arguments
const memoizedFetch = memoize(fetchUserData, (userId, includeProfile) =&gt; {
  return `${userId}_${includeProfile}`;
});

memoizedFetch(1, true); // &#39;Fetching user data... 1 true&#39;
memoizedFetch(1, true); // Uses cached result
memoizedFetch(1, false); // &#39;Fetching user data... 1 false&#39; (different cache key)

// Accessing and modifying cache
console.log(memoizedCalc.cache.get(5)); // 25
memoizedCalc.cache.set(7, 49); // Manually set cache
console.log(memoizedCalc(7)); // 49 (uses cached value without calculation)
</code></pre>

<p>In most cases, it uses a basic hash map, but you can also use custom cache implementations as needed.</p>

<h4>Parameters</h4>

<ul>
<li><code>func</code> (<code>Function</code>): The function to memoize.</li>
<li><code>resolver</code> (<code>Function</code>, optional): The function to determine the cache key. If not provided, uses the first argument as the key.</li>
</ul>

<h4>Returns</h4>

<p>(<code>Function &amp; { cache: MapCache }</code>): Returns the memoized function. The returned function has a <code>cache</code> property for direct cache access.</p>
<div class="_attribution">
  <p class="_attribution-p">
          &copy; 2024-2025, Viva Republica<br>
      Licensed under the MIT License.

    <br>
    <a href="https://es-toolkit.slash.page/reference/compat/function/memoize.html" class="_attribution-link">
      https://es-toolkit.slash.page/reference/compat/function/memoize.html
    </a>
  </p>
</div>
