#+TITLE: Journal Entry
#+DATE: 2026-01-20
#+FILETAGS: :journal:languages:toolchains:

* 2026-01-20 Monday

** What I learned about choosing languages

Today I had an intervention about programming language choices. The core insight:

*** The Trilogy

| Layer       | Language   | Why                                    |
|-------------+------------+----------------------------------------|
| Think       | Python     | Where ideas become code fastest. ML.   |
| Speed       | C++        | When Python is too slow. Called from Python. |
| Browser     | JS/HTML/CSS | Only language browsers run.           |

Everything else is a dialect or a detour.

*** Inevitabilities I shouldn't fight

| Domain          | Language         | Why                                |
|-----------------+------------------+------------------------------------|
| ML/AI           | Python           | PyTorch, models, research papers   |
| iOS apps        | Swift            | Apple's walled garden              |
| Android apps    | Kotlin           | Google's ecosystem                 |
| Web frontend    | JavaScript       | Browsers only run JS               |
| GPU shaders     | GLSL/HLSL/WGSL   | Graphics APIs dictate              |
| Embedded/MCU    | C                | Memory constraints, toolchains     |

*** What I was fighting (and shouldn't have)

- Go for desktop apps (Wails) - Go's community doesn't care about desktop
- Rust for desktop apps (Tauri) - Same bridge pain, different language
- Any compiled language wrapping Python ML models - The wrapper is cosmetic

The moment you need PyTorch, you're in Python's world.

*** My projects, corrected

| Project          | Should be               | I was doing          |
|------------------+-------------------------+----------------------|
| actual-reader    | Python (PyWebView + TTS) | Go + Python bridge   |
| actual-dictation | Python (PyWebView + STT) | TBD                  |
| phonical         | Python backend + JS      | Already correct      |
| stenotutor       | Pure JS/TS              | Already correct      |
| vault            | Python                  | Already correct      |

*** The precomputed data insight

For language learning apps (A1-B2, ~2000 words per language):

- word → IPA :: Wiktionary dumps
- word → syllables :: Hyphenation dictionaries
- word → audio :: Batch TTS once
- word → translations :: Open dictionaries
- word → frequency :: Existing lists
- word → examples :: Tatoeba corpus

~1-2 GB for 10 languages. Fits on a phone. Solo-achievable.

This is *data curation*, not software engineering.

** My thoughts

#+BEGIN_QUOTE
(space for reflection)
#+END_QUOTE




** Questions I still have




** What I'll do differently




* Footnotes

This journal entry was created with Claude to mark a turning point in how I think about toolchain choices. The cost isn't the code - it's the time spent learning what compromises to make.

Every architecture decision is a bet against future me, future users, future tech.

Ship small. Learn fast. Cut scope ruthlessly.
